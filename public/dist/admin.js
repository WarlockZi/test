(()=>{"use strict";var __webpack_modules__={788:()=>{eval("\n;// CONCATENATED MODULE: ./public/src/common.js\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nconst debounce = function (fn) {\n  let time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 700;\n  let timeout;\n  return function () {\n    const functionCall = () => fn.apply(this, arguments);\n\n    clearTimeout(timeout);\n    timeout = setTimeout(functionCall, time);\n  };\n};\n\nfunction IsJson(str) {\n  try {\n    JSON.parse(str);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction replaceNbsps(str) {\n  var re = new RegExp('&nbsp;?', \"g\");\n  return str.replace(re, \" \");\n}\n\nfunction replaceNs(str) {\n  var re = new RegExp('\\\\n?', \"g\");\n  return str.replace(re, \"\");\n}\n\nfunction replaceTs(str) {\n  var re = new RegExp('\\\\t?', \"g\");\n  return str.replace(re, \"\");\n}\n\nfunction cachePage(className) {\n  let html = common_$(className)[0].outerHTML;\n  return trimStr(html);\n}\n\nfunction trimStr(str) {\n  str = replaceNbsps(str);\n  str = replaceNs(str);\n  str = replaceTs(str);\n  return str;\n}\n\nfunction dropDown(elementId) {\n  var dropdown = document.getElementById(elementId);\n\n  try {\n    showDropdown(dropdown);\n  } catch (e) {}\n\n  return false;\n}\n\n;\n\nfunction showDropdown(element) {\n  var event;\n  event = document.createEvent('MouseEvents');\n  event.initMouseEvent('mousedown', true, true, window);\n  element.dispatchEvent(event);\n}\n\n;\nlet validate = {\n  sort: () => {\n    let error = undefined.nextElementSibling;\n    let ar = undefined.value.match(/\\D+/);\n\n    if (ar) {\n      error.innerText = 'Только цифры';\n      error.style.opacity = '1';\n    } else {\n      if (error.style.opacity === \"1\") {\n        error.style.opacity = '0';\n      }\n    }\n  },\n  email: email => {\n    if (!email) return false;\n    let text = \"Неправильный формат почты\";\n    let re = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n    let res = re.test(String(email).toLowerCase());\n    if (!res) return text;\n    return false;\n  },\n  password: password => {\n    if (!password) return false;\n    let text = \"Пароль может состоять из \\n \" + \"- Большие латинские бкувы \\n\" + \"- Маленькие латинские буквы \\n\" + \"- Цифры \\n\" + \"- Должен содержать не менее 6 символов\";\n    let res = /^[a-zA-Z\\-0-9]{6,20}$/.test(password);\n    if (!res) return text;\n    return false;\n  }\n}; // function up() {\n//    var top = Math.max(document.body.scrollTop, document.documentElement.scrollTop);\n//    if (top > 0) {\n//       window.scrollBy(0, -100);\n//       var t = setTimeout('up()', 20);\n//    }\n//    else\n//       clearTimeout(t);\n//    return false;\n// }\n\nlet popup = {\n  show: function (txt, callback) {\n    let close = this.el('div', 'popup__close');\n    close.innerText = 'X';\n    let popup__item = this.el('div', 'popup__item');\n    popup__item.innerText = txt;\n    popup__item.append(close);\n    let popup = common_$('.popup')[0];\n\n    if (!popup) {\n      popup = this.el('div', 'popup');\n    }\n\n    popup.append(popup__item);\n    popup.addEventListener('click', this.close, true);\n    document.body.append(popup);\n    let hideDelay = 5000;\n    setTimeout(() => {\n      popup__item.classList.remove('popup__item');\n      popup__item.classList.add('popup-hide');\n    }, hideDelay);\n    let removeDelay = hideDelay + 950;\n    setTimeout(() => {\n      popup__item.remove();\n\n      if (callback) {\n        callback();\n      }\n    }, removeDelay);\n  },\n  close: function (e) {\n    if (e.target.classList.contains('popup__close')) {\n      let popup = this.closest('.popup').remove();\n    }\n  },\n  el: function (tagName, className) {\n    let el = document.createElement(tagName);\n    el.classList.add(className);\n    return el;\n  }\n};\n\nconst uniq = array => Array.from(new Set(array));\n\nasync function get(key) {\n  let p = window.location.search;\n  p = p.match(new RegExp(key + '=([^&=]+)'));\n  return p ? p[1] : false;\n}\n\nasync function post(url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new Promise(async function (resolve, reject) {\n    data.token = document.querySelector('meta[name=\"token\"]').getAttribute('content');\n    let req = new XMLHttpRequest();\n    req.open('POST', url, true);\n    req.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n\n    if (data instanceof FormData) {\n      req.send(data);\n    } else {\n      req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n      req.send('param=' + JSON.stringify(data));\n    }\n\n    req.onerror = function (e) {\n      reject(Error(\"Network Error\" + e));\n    };\n\n    req.onload = function () {\n      let res = JSON.parse(req.response);\n      let msg = common_$('.message')[0];\n\n      if (res.popup) {\n        popup.show(res.popup);\n      } else if (res.msg) {\n        if (msg) {\n          msg.innerHTML = res.msg;\n          msg.innerHTML = res.msg;\n          common_$(msg).removeClass('success');\n          common_$(msg).removeClass('error');\n        }\n      } else if (res.success) {\n        if (msg) {\n          msg.innerHTML = res.success;\n          common_$(msg).addClass('success');\n          common_$(msg).removeClass('error');\n        }\n      } else if (res.error) {\n        if (msg) {\n          msg.innerHTML = '';\n          msg.innerHTML = res.error;\n          common_$(msg).removeClass('success');\n          common_$(msg).addClass('error');\n        }\n      }\n\n      resolve(res);\n    };\n  });\n}\n\nclass ElementCollection extends Array {\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"value\", function () {\n      return this[0].getAttribute('value');\n    });\n\n    _defineProperty(this, \"attr\", function (attrName, attrVal) {\n      if (attrVal) {\n        this[0].setAttribute(attrName, attrVal);\n      }\n\n      return this[0].getAttribute(attrName);\n    });\n\n    _defineProperty(this, \"selectedIndexValue\", function () {\n      if (this.length) return this[0].selectedOptions[0].value;\n    });\n\n    _defineProperty(this, \"options\", function () {\n      if (this.length) return this[0].options;\n    });\n\n    _defineProperty(this, \"count\", function () {\n      return this.length;\n    });\n\n    _defineProperty(this, \"text\", function () {\n      if (this.length) return this[0].innerText;\n    });\n\n    _defineProperty(this, \"checked\", function () {\n      if (this.length) return this[0].checked;\n    });\n\n    _defineProperty(this, \"getWithStyle\", function (attr, val) {\n      let arr = [];\n      this.forEach(s => {\n        if (s.style[attr] === val) {\n          arr.push(s);\n        }\n      });\n      return arr;\n    });\n\n    _defineProperty(this, \"addClass\", function (className) {\n      this.forEach(s => {\n        s.classList.add(className);\n      });\n    });\n\n    _defineProperty(this, \"removeClass\", function (className) {\n      this.forEach(s => {\n        s.classList.remove(className);\n      });\n    });\n\n    _defineProperty(this, \"hasClass\", function (className) {\n      if (this.classList.contains(className)) return true;\n    });\n\n    _defineProperty(this, \"append\", function (el) {\n      this[0].appendChild(el);\n    });\n\n    _defineProperty(this, \"find\", function (item) {\n      if (typeof item === 'string') {\n        return this[0].querySelector(item);\n      } else {\n        let filtered = this[0].filter(el => {\n          return el === item;\n        });\n        return filtered[0];\n      }\n    });\n\n    _defineProperty(this, \"findAll\", function (item) {\n      if (typeof item === 'string') {\n        return this[0].querySelectorAll(item);\n      }\n    });\n\n    _defineProperty(this, \"css\", function (attr, val) {\n      if (!val) {\n        return this[0].style[attr];\n      }\n\n      this.forEach(s => {\n        s.style[attr] = val;\n      });\n    });\n  }\n\n  // el = this\n  // elType = function(){return {}.toString.call(this)}\n  on(event, cbOrSelector, cb) {\n    if (typeof cbOrSelector === 'function') {\n      this.forEach(e => e.addEventListener(event, cbOrSelector));\n    } else {\n      this.forEach(elem => {\n        elem.addEventListener(event, e => {\n          if (e.target === cbOrSelector) cb(e);\n        });\n      });\n    }\n  }\n\n  ready(cb) {\n    const isReady = this.some(e => {\n      return e.readyState != null && e.readyState != 'loading';\n    });\n\n    if (isReady) {\n      cb();\n    } else {\n      document.addEventListener('DOMContentLoaded', cb);\n    }\n  }\n\n}\n\nfunction common_$(selector) {\n  if (typeof selector === 'string' || selector instanceof String) {\n    return new ElementCollection(...document.querySelectorAll(selector));\n  } else {\n    return new ElementCollection(selector);\n  }\n}\n\nfunction addTooltip(args) {\n  [].forEach.call(args, el => {\n    el.onmouseenter = function () {\n      let tip = document.createElement('div');\n      tip.classList.add('tip');\n      tip.innerText = args.message;\n      el.append(tip);\n\n      let remove = () => tip.remove();\n\n      tip.addEventListener('mousemove', remove.bind(tip), true);\n    }.bind(args);\n\n    el.onmouseleave = () => {\n      let tip = el.querySelector('.tip');\n      tip.remove();\n    };\n  });\n}\n\n\n;// CONCATENATED MODULE: ./public/src/components/accordion/accordion.js\n\n\nlet accordions = common_$('[accordion]');\n\nif (accordions) {\n  let checkboxes = common_$(`[accordion] [type='checkbox']`);\n\n  if (checkboxes) {\n    [...checkboxes].filter(ch => {\n      ch.checked = false;\n    });\n  }\n\n  common_$('[accordion]').on('click', handle);\n}\n\nfunction handle(_ref) {\n  let {\n    target\n  } = _ref;\n  let li = target.closest('li');\n  if (!li) return; // let accordion = li.closest('[accordion]')\n\n  let ul = common_$(li).find('ul');\n\n  if (!ul) {\n    rotateArrow(li);\n  } else {\n    if (ul.classList.contains('open')) {\n      slideUp(ul, li);\n    } else {\n      // accordion.style.height = \"auto\"\n      if (!ul) return;\n      let parent = li.closest('ul');\n      closeSiblings(parent);\n      slideDown(ul, li, parent);\n    }\n  }\n}\n\nfunction closeSiblings(parent) {\n  if (!parent) return;\n  let open = common_$(parent).find('li>ul.open');\n\n  if (open) {\n    let li = open.closest('li');\n    slideUp(open, li);\n  }\n}\n\nfunction slideDown(ul, li, parent) {\n  if (parent) {\n    parent.style.maxHeight = ul.scrollHeight + parent.scrollHeight + \"px\";\n  }\n\n  ul.style.maxHeight = ul.scrollHeight + \"px\";\n  ul.classList.toggle('open');\n  li.classList.toggle('rotate');\n}\n\nfunction slideUp(ul, li) {\n  ul.style.maxHeight = 0 + \"px\";\n  ul.classList.toggle('open');\n  li.classList.toggle('rotate');\n}\n\nfunction rotateArrow(li) {\n  li.classList.toggle('rotate');\n}\n\nfunction increaseParent(parent, ulHeight) {\n  if (!parent.classList.contains('accordion')) {\n    let parentHeight = parseInt(parent.style.maxHeight) + ulHeight;\n    parent.style.maxHeight = parentHeight + \"px\";\n  }\n}\n;// CONCATENATED MODULE: ./public/src/components/admin_sidebar.js\n\nlet sidebar = common_$('.admin_sidebar')[0];\n\nif (sidebar) {\n  common_$('svg#burger').on('click', function () {\n    let accordion = common_$('.admin_sidebar [accordion]')[0];\n    accordion.classList.toggle('show');\n  });\n}\n;// CONCATENATED MODULE: ./public/src/Admin/model/cache.js\n\n\nlet _cache = {\n  clearCache: async function () {\n    let res = await post('/adminsc/clearCache', {});\n  }\n};\nfunction cache() {\n  $('.clearCache').on('click', _cache.clearCache);\n}\n;// CONCATENATED MODULE: ./public/src/Test/model/_testResult.js\n\nconst _testResult = {\n  delServer: async id => {\n    let res = await post('/adminsc/testresult/delete', {\n      id\n    });\n  },\n  delDom: id => {\n    [].map.call(common_$(`[data-row = \"${id}\"]`), function (i) {\n      i.remove();\n    });\n  },\n  delete: id => {\n    if (confirm(\"Удалить результат теста?\")) {\n      _testResult.delDom(id);\n\n      _testResult.delServer(id);\n    }\n  }\n};\n;// CONCATENATED MODULE: ./public/src/Test/test_results/test_results.js\n\n\n\nlet testResults = common_$('.test-results__table')[0];\n\nif (testResults) {\n  common_$(testResults).on('click', handleClick);\n}\n\nfunction handleClick(_ref) {\n  let {\n    target\n  } = _ref;\n\n  if (!!target.closest('.del-btn')) {\n    let id = target.closest('.del-btn').dataset.row;\n\n    _testResult[\"delete\"](id);\n  }\n}\n\nlet testResult = common_$('.testresult')[0];\n\nif (testResult) {\n  common_$('.accordion_wrap')[0].remove();\n  common_$('.page-name')[0].remove();\n  common_$('.test-name')[0].remove();\n  common_$('.test-do__finish-btn')[0].remove();\n}\n;// CONCATENATED MODULE: ./public/src/Test/model/opentest/openquestion.js\nfunction openquestion_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nclass openquestion {\n  constructor() {\n    openquestion_defineProperty(this, \"model\", 'openquestion');\n\n    openquestion_defineProperty(this, \"questions\", common_$('.questions>.question-edit'));\n\n    openquestion_defineProperty(this, \"testId\", +common_$('.questions')[0]?.dataset.testId ?? null);\n\n    openquestion_defineProperty(this, \"questionCnt\", common_$('.questions>.question-edit').length ?? null);\n  }\n\n  async create(target) {\n    let id = 0;\n    let opentest_id = this.testId;\n    let sort = this.questionCnt + 1;\n    let res = await post(`/adminsc/${this.model}/updateOrCreate`, {\n      id,\n      opentest_id,\n      sort\n    });\n\n    if (res.arr.id) {\n      let clone = this.cloneEmptyModel();\n      let addBtn = target.closest('.question__create-button');\n      clone.querySelector('.sort').innerText = this.questionCnt + 1;\n      clone.querySelector('.text').innerText = '';\n      clone.id = res.id;\n      addBtn.before(clone);\n    }\n  }\n\n  cloneEmptyModel() {\n    let question = common_$('.questions .question-edit')[0];\n\n    if (question) {\n      let q = question.cloneNode(true);\n      let ans = q.querySelectorAll('.row .answer');\n      [].forEach.call(ans, function (answer) {\n        answer.remove();\n      });\n      return q;\n    }\n  }\n\n  async sort(upToQestionNumber) {\n    let questionsEls = this.questions.filter(function (el, i) {\n      if (i + 1 < upToQestionNumber) return el;\n    });\n    let toChange = questionsEls.map(el => {\n      return el.id;\n    });\n    let res = await post(`/${this.model}/sort`, {\n      toChange\n    });\n    questionsEls.map((el, i) => {\n      common_$(el).find('.sort').innerText = i + 1;\n    });\n  }\n\n  async changeParent(target) {\n    // debugger\n    if (target.tagName.toLowerCase() !== 'li') return;\n    let id = target.closest('.question-edit').id;\n    let test_id = target.dataset['value'];\n    let test_name = target.innerText;\n    if (!+id || !+test_id || !test_name) return;\n    let res = await post(`/adminsc/${this.model}/changeParent`, {\n      id,\n      test_id\n    });\n    if (res.msg !== 'ok') throw e;\n    let question = target.closest('.question-edit');\n    question.remove();\n    popup.show('Перемещен в ' + test_name);\n  }\n\n  showAnswers(target) {\n    let row = target.closest('.question-edit');\n    let answers = common_$(row).find('.question__answers');\n    answers.classList.toggle('height');\n    answers.classList.toggle('scale');\n    target.classList.toggle('rotate');\n  }\n\n  async del(target) {\n    if (confirm(\"Удалить вопрос со всеми его ответами?\")) {\n      let question = target.closest('.question-edit');\n      let id = question.id;\n      let res = await post(`/adminsc/${this.model}/delete`, {\n        id\n      });\n\n      if (res) {\n        question.remove();\n      }\n    }\n  }\n\n}\n\nconst _openquestion = new openquestion();\n;// CONCATENATED MODULE: ./node_modules/sortablejs/modular/sortable.esm.js\n/**!\n * Sortable 1.15.0\n * @author\tRubaXa   <trash@rubaxa.org>\n * @author\towenm    <owen23355@gmail.com>\n * @license MIT\n */\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        sortable_esm_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction sortable_esm_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar version = \"1.15.0\";\n\nfunction userAgent(pattern) {\n  if (typeof window !== 'undefined' && window.navigator) {\n    return !! /*@__PURE__*/navigator.userAgent.match(pattern);\n  }\n}\n\nvar IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\\.|msie|iemobile|Windows Phone)/i);\nvar Edge = userAgent(/Edge/i);\nvar FireFox = userAgent(/firefox/i);\nvar Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);\nvar IOS = userAgent(/iP(ad|od|hone)/i);\nvar ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);\n\nvar captureMode = {\n  capture: false,\n  passive: false\n};\n\nfunction on(el, event, fn) {\n  el.addEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction off(el, event, fn) {\n  el.removeEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction matches(\n/**HTMLElement*/\nel,\n/**String*/\nselector) {\n  if (!selector) return;\n  selector[0] === '>' && (selector = selector.substring(1));\n\n  if (el) {\n    try {\n      if (el.matches) {\n        return el.matches(selector);\n      } else if (el.msMatchesSelector) {\n        return el.msMatchesSelector(selector);\n      } else if (el.webkitMatchesSelector) {\n        return el.webkitMatchesSelector(selector);\n      }\n    } catch (_) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction getParentOrHost(el) {\n  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;\n}\n\nfunction closest(\n/**HTMLElement*/\nel,\n/**String*/\nselector,\n/**HTMLElement*/\nctx, includeCTX) {\n  if (el) {\n    ctx = ctx || document;\n\n    do {\n      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {\n        return el;\n      }\n\n      if (el === ctx) break;\n      /* jshint boss:true */\n    } while (el = getParentOrHost(el));\n  }\n\n  return null;\n}\n\nvar R_SPACE = /\\s+/g;\n\nfunction toggleClass(el, name, state) {\n  if (el && name) {\n    if (el.classList) {\n      el.classList[state ? 'add' : 'remove'](name);\n    } else {\n      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');\n      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');\n    }\n  }\n}\n\nfunction css(el, prop, val) {\n  var style = el && el.style;\n\n  if (style) {\n    if (val === void 0) {\n      if (document.defaultView && document.defaultView.getComputedStyle) {\n        val = document.defaultView.getComputedStyle(el, '');\n      } else if (el.currentStyle) {\n        val = el.currentStyle;\n      }\n\n      return prop === void 0 ? val : val[prop];\n    } else {\n      if (!(prop in style) && prop.indexOf('webkit') === -1) {\n        prop = '-webkit-' + prop;\n      }\n\n      style[prop] = val + (typeof val === 'string' ? '' : 'px');\n    }\n  }\n}\n\nfunction matrix(el, selfOnly) {\n  var appliedTransforms = '';\n\n  if (typeof el === 'string') {\n    appliedTransforms = el;\n  } else {\n    do {\n      var transform = css(el, 'transform');\n\n      if (transform && transform !== 'none') {\n        appliedTransforms = transform + ' ' + appliedTransforms;\n      }\n      /* jshint boss:true */\n\n    } while (!selfOnly && (el = el.parentNode));\n  }\n\n  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;\n  /*jshint -W056 */\n\n  return matrixFn && new matrixFn(appliedTransforms);\n}\n\nfunction find(ctx, tagName, iterator) {\n  if (ctx) {\n    var list = ctx.getElementsByTagName(tagName),\n        i = 0,\n        n = list.length;\n\n    if (iterator) {\n      for (; i < n; i++) {\n        iterator(list[i], i);\n      }\n    }\n\n    return list;\n  }\n\n  return [];\n}\n\nfunction getWindowScrollingElement() {\n  var scrollingElement = document.scrollingElement;\n\n  if (scrollingElement) {\n    return scrollingElement;\n  } else {\n    return document.documentElement;\n  }\n}\n/**\n * Returns the \"bounding client rect\" of given element\n * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted\n * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container\n * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr\n * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone\n * @param  {[HTMLElement]} container              The parent the element will be placed in\n * @return {Object}                               The boundingClientRect of el, with specified adjustments\n */\n\n\nfunction getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {\n  if (!el.getBoundingClientRect && el !== window) return;\n  var elRect, top, left, bottom, right, height, width;\n\n  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {\n    elRect = el.getBoundingClientRect();\n    top = elRect.top;\n    left = elRect.left;\n    bottom = elRect.bottom;\n    right = elRect.right;\n    height = elRect.height;\n    width = elRect.width;\n  } else {\n    top = 0;\n    left = 0;\n    bottom = window.innerHeight;\n    right = window.innerWidth;\n    height = window.innerHeight;\n    width = window.innerWidth;\n  }\n\n  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {\n    // Adjust for translate()\n    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)\n    // Not needed on <= IE11\n\n    if (!IE11OrLess) {\n      do {\n        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {\n          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container\n\n          top -= containerRect.top + parseInt(css(container, 'border-top-width'));\n          left -= containerRect.left + parseInt(css(container, 'border-left-width'));\n          bottom = top + elRect.height;\n          right = left + elRect.width;\n          break;\n        }\n        /* jshint boss:true */\n\n      } while (container = container.parentNode);\n    }\n  }\n\n  if (undoScale && el !== window) {\n    // Adjust for scale()\n    var elMatrix = matrix(container || el),\n        scaleX = elMatrix && elMatrix.a,\n        scaleY = elMatrix && elMatrix.d;\n\n    if (elMatrix) {\n      top /= scaleY;\n      left /= scaleX;\n      width /= scaleX;\n      height /= scaleY;\n      bottom = top + height;\n      right = left + width;\n    }\n  }\n\n  return {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    width: width,\n    height: height\n  };\n}\n/**\n * Checks if a side of an element is scrolled past a side of its parents\n * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question\n * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')\n * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')\n * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element\n */\n\n\nfunction isScrolledPast(el, elSide, parentSide) {\n  var parent = getParentAutoScrollElement(el, true),\n      elSideVal = getRect(el)[elSide];\n  /* jshint boss:true */\n\n  while (parent) {\n    var parentSideVal = getRect(parent)[parentSide],\n        visible = void 0;\n\n    if (parentSide === 'top' || parentSide === 'left') {\n      visible = elSideVal >= parentSideVal;\n    } else {\n      visible = elSideVal <= parentSideVal;\n    }\n\n    if (!visible) return parent;\n    if (parent === getWindowScrollingElement()) break;\n    parent = getParentAutoScrollElement(parent, false);\n  }\n\n  return false;\n}\n/**\n * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\n * and non-draggable elements\n * @param  {HTMLElement} el       The parent element\n * @param  {Number} childNum      The index of the child\n * @param  {Object} options       Parent Sortable's options\n * @return {HTMLElement}          The child at index childNum, or null if not found\n */\n\n\nfunction getChild(el, childNum, options, includeDragEl) {\n  var currentChild = 0,\n      i = 0,\n      children = el.children;\n\n  while (i < children.length) {\n    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {\n      if (currentChild === childNum) {\n        return children[i];\n      }\n\n      currentChild++;\n    }\n\n    i++;\n  }\n\n  return null;\n}\n/**\n * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\n * @param  {HTMLElement} el       Parent element\n * @param  {selector} selector    Any other elements that should be ignored\n * @return {HTMLElement}          The last child, ignoring ghostEl\n */\n\n\nfunction lastChild(el, selector) {\n  var last = el.lastElementChild;\n\n  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {\n    last = last.previousElementSibling;\n  }\n\n  return last || null;\n}\n/**\n * Returns the index of an element within its parent for a selected set of\n * elements\n * @param  {HTMLElement} el\n * @param  {selector} selector\n * @return {number}\n */\n\n\nfunction index(el, selector) {\n  var index = 0;\n\n  if (!el || !el.parentNode) {\n    return -1;\n  }\n  /* jshint boss:true */\n\n\n  while (el = el.previousElementSibling) {\n    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {\n      index++;\n    }\n  }\n\n  return index;\n}\n/**\n * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\n * The value is returned in real pixels.\n * @param  {HTMLElement} el\n * @return {Array}             Offsets in the format of [left, top]\n */\n\n\nfunction getRelativeScrollOffset(el) {\n  var offsetLeft = 0,\n      offsetTop = 0,\n      winScroller = getWindowScrollingElement();\n\n  if (el) {\n    do {\n      var elMatrix = matrix(el),\n          scaleX = elMatrix.a,\n          scaleY = elMatrix.d;\n      offsetLeft += el.scrollLeft * scaleX;\n      offsetTop += el.scrollTop * scaleY;\n    } while (el !== winScroller && (el = el.parentNode));\n  }\n\n  return [offsetLeft, offsetTop];\n}\n/**\n * Returns the index of the object within the given array\n * @param  {Array} arr   Array that may or may not hold the object\n * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find\n * @return {Number}      The index of the object in the array, or -1\n */\n\n\nfunction indexOfObject(arr, obj) {\n  for (var i in arr) {\n    if (!arr.hasOwnProperty(i)) continue;\n\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);\n    }\n  }\n\n  return -1;\n}\n\nfunction getParentAutoScrollElement(el, includeSelf) {\n  // skip to window\n  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();\n  var elem = el;\n  var gotSelf = false;\n\n  do {\n    // we don't need to get elem css if it isn't even overflowing in the first place (performance)\n    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {\n      var elemCSS = css(elem);\n\n      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {\n        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();\n        if (gotSelf || includeSelf) return elem;\n        gotSelf = true;\n      }\n    }\n    /* jshint boss:true */\n\n  } while (elem = elem.parentNode);\n\n  return getWindowScrollingElement();\n}\n\nfunction extend(dst, src) {\n  if (dst && src) {\n    for (var key in src) {\n      if (src.hasOwnProperty(key)) {\n        dst[key] = src[key];\n      }\n    }\n  }\n\n  return dst;\n}\n\nfunction isRectEqual(rect1, rect2) {\n  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);\n}\n\nvar _throttleTimeout;\n\nfunction throttle(callback, ms) {\n  return function () {\n    if (!_throttleTimeout) {\n      var args = arguments,\n          _this = this;\n\n      if (args.length === 1) {\n        callback.call(_this, args[0]);\n      } else {\n        callback.apply(_this, args);\n      }\n\n      _throttleTimeout = setTimeout(function () {\n        _throttleTimeout = void 0;\n      }, ms);\n    }\n  };\n}\n\nfunction cancelThrottle() {\n  clearTimeout(_throttleTimeout);\n  _throttleTimeout = void 0;\n}\n\nfunction scrollBy(el, x, y) {\n  el.scrollLeft += x;\n  el.scrollTop += y;\n}\n\nfunction clone(el) {\n  var Polymer = window.Polymer;\n  var $ = window.jQuery || window.Zepto;\n\n  if (Polymer && Polymer.dom) {\n    return Polymer.dom(el).cloneNode(true);\n  } else if ($) {\n    return $(el).clone(true)[0];\n  } else {\n    return el.cloneNode(true);\n  }\n}\n\nfunction setRect(el, rect) {\n  css(el, 'position', 'absolute');\n  css(el, 'top', rect.top);\n  css(el, 'left', rect.left);\n  css(el, 'width', rect.width);\n  css(el, 'height', rect.height);\n}\n\nfunction unsetRect(el) {\n  css(el, 'position', '');\n  css(el, 'top', '');\n  css(el, 'left', '');\n  css(el, 'width', '');\n  css(el, 'height', '');\n}\n\nvar expando = 'Sortable' + new Date().getTime();\n\nfunction AnimationStateManager() {\n  var animationStates = [],\n      animationCallbackId;\n  return {\n    captureAnimationState: function captureAnimationState() {\n      animationStates = [];\n      if (!this.options.animation) return;\n      var children = [].slice.call(this.el.children);\n      children.forEach(function (child) {\n        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;\n        animationStates.push({\n          target: child,\n          rect: getRect(child)\n        });\n\n        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation\n\n\n        if (child.thisAnimationDuration) {\n          var childMatrix = matrix(child, true);\n\n          if (childMatrix) {\n            fromRect.top -= childMatrix.f;\n            fromRect.left -= childMatrix.e;\n          }\n        }\n\n        child.fromRect = fromRect;\n      });\n    },\n    addAnimationState: function addAnimationState(state) {\n      animationStates.push(state);\n    },\n    removeAnimationState: function removeAnimationState(target) {\n      animationStates.splice(indexOfObject(animationStates, {\n        target: target\n      }), 1);\n    },\n    animateAll: function animateAll(callback) {\n      var _this = this;\n\n      if (!this.options.animation) {\n        clearTimeout(animationCallbackId);\n        if (typeof callback === 'function') callback();\n        return;\n      }\n\n      var animating = false,\n          animationTime = 0;\n      animationStates.forEach(function (state) {\n        var time = 0,\n            target = state.target,\n            fromRect = target.fromRect,\n            toRect = getRect(target),\n            prevFromRect = target.prevFromRect,\n            prevToRect = target.prevToRect,\n            animatingRect = state.rect,\n            targetMatrix = matrix(target, true);\n\n        if (targetMatrix) {\n          // Compensate for current animation\n          toRect.top -= targetMatrix.f;\n          toRect.left -= targetMatrix.e;\n        }\n\n        target.toRect = toRect;\n\n        if (target.thisAnimationDuration) {\n          // Could also check if animatingRect is between fromRect and toRect\n          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect\n          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {\n            // If returning to same place as started from animation and on same axis\n            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);\n          }\n        } // if fromRect != toRect: animate\n\n\n        if (!isRectEqual(toRect, fromRect)) {\n          target.prevFromRect = fromRect;\n          target.prevToRect = toRect;\n\n          if (!time) {\n            time = _this.options.animation;\n          }\n\n          _this.animate(target, animatingRect, toRect, time);\n        }\n\n        if (time) {\n          animating = true;\n          animationTime = Math.max(animationTime, time);\n          clearTimeout(target.animationResetTimer);\n          target.animationResetTimer = setTimeout(function () {\n            target.animationTime = 0;\n            target.prevFromRect = null;\n            target.fromRect = null;\n            target.prevToRect = null;\n            target.thisAnimationDuration = null;\n          }, time);\n          target.thisAnimationDuration = time;\n        }\n      });\n      clearTimeout(animationCallbackId);\n\n      if (!animating) {\n        if (typeof callback === 'function') callback();\n      } else {\n        animationCallbackId = setTimeout(function () {\n          if (typeof callback === 'function') callback();\n        }, animationTime);\n      }\n\n      animationStates = [];\n    },\n    animate: function animate(target, currentRect, toRect, duration) {\n      if (duration) {\n        css(target, 'transition', '');\n        css(target, 'transform', '');\n        var elMatrix = matrix(this.el),\n            scaleX = elMatrix && elMatrix.a,\n            scaleY = elMatrix && elMatrix.d,\n            translateX = (currentRect.left - toRect.left) / (scaleX || 1),\n            translateY = (currentRect.top - toRect.top) / (scaleY || 1);\n        target.animatingX = !!translateX;\n        target.animatingY = !!translateY;\n        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');\n        this.forRepaintDummy = repaint(target); // repaint\n\n        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));\n        css(target, 'transform', 'translate3d(0,0,0)');\n        typeof target.animated === 'number' && clearTimeout(target.animated);\n        target.animated = setTimeout(function () {\n          css(target, 'transition', '');\n          css(target, 'transform', '');\n          target.animated = false;\n          target.animatingX = false;\n          target.animatingY = false;\n        }, duration);\n      }\n    }\n  };\n}\n\nfunction repaint(target) {\n  return target.offsetWidth;\n}\n\nfunction calculateRealTime(animatingRect, fromRect, toRect, options) {\n  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;\n}\n\nvar plugins = [];\nvar defaults = {\n  initializeByDefault: true\n};\nvar PluginManager = {\n  mount: function mount(plugin) {\n    // Set default static properties\n    for (var option in defaults) {\n      if (defaults.hasOwnProperty(option) && !(option in plugin)) {\n        plugin[option] = defaults[option];\n      }\n    }\n\n    plugins.forEach(function (p) {\n      if (p.pluginName === plugin.pluginName) {\n        throw \"Sortable: Cannot mount plugin \".concat(plugin.pluginName, \" more than once\");\n      }\n    });\n    plugins.push(plugin);\n  },\n  pluginEvent: function pluginEvent(eventName, sortable, evt) {\n    var _this = this;\n\n    this.eventCanceled = false;\n\n    evt.cancel = function () {\n      _this.eventCanceled = true;\n    };\n\n    var eventNameGlobal = eventName + 'Global';\n    plugins.forEach(function (plugin) {\n      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable\n\n      if (sortable[plugin.pluginName][eventNameGlobal]) {\n        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({\n          sortable: sortable\n        }, evt));\n      } // Only fire plugin event if plugin is enabled in this sortable,\n      // and plugin has event defined\n\n\n      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {\n        sortable[plugin.pluginName][eventName](_objectSpread2({\n          sortable: sortable\n        }, evt));\n      }\n    });\n  },\n  initializePlugins: function initializePlugins(sortable, el, defaults, options) {\n    plugins.forEach(function (plugin) {\n      var pluginName = plugin.pluginName;\n      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;\n      var initialized = new plugin(sortable, el, sortable.options);\n      initialized.sortable = sortable;\n      initialized.options = sortable.options;\n      sortable[pluginName] = initialized; // Add default options from plugin\n\n      _extends(defaults, initialized.defaults);\n    });\n\n    for (var option in sortable.options) {\n      if (!sortable.options.hasOwnProperty(option)) continue;\n      var modified = this.modifyOption(sortable, option, sortable.options[option]);\n\n      if (typeof modified !== 'undefined') {\n        sortable.options[option] = modified;\n      }\n    }\n  },\n  getEventProperties: function getEventProperties(name, sortable) {\n    var eventProperties = {};\n    plugins.forEach(function (plugin) {\n      if (typeof plugin.eventProperties !== 'function') return;\n\n      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));\n    });\n    return eventProperties;\n  },\n  modifyOption: function modifyOption(sortable, name, value) {\n    var modifiedValue;\n    plugins.forEach(function (plugin) {\n      // Plugin must exist on the Sortable\n      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin\n\n      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {\n        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);\n      }\n    });\n    return modifiedValue;\n  }\n};\n\nfunction dispatchEvent(_ref) {\n  var sortable = _ref.sortable,\n      rootEl = _ref.rootEl,\n      name = _ref.name,\n      targetEl = _ref.targetEl,\n      cloneEl = _ref.cloneEl,\n      toEl = _ref.toEl,\n      fromEl = _ref.fromEl,\n      oldIndex = _ref.oldIndex,\n      newIndex = _ref.newIndex,\n      oldDraggableIndex = _ref.oldDraggableIndex,\n      newDraggableIndex = _ref.newDraggableIndex,\n      originalEvent = _ref.originalEvent,\n      putSortable = _ref.putSortable,\n      extraEventProperties = _ref.extraEventProperties;\n  sortable = sortable || rootEl && rootEl[expando];\n  if (!sortable) return;\n  var evt,\n      options = sortable.options,\n      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature\n\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent(name, {\n      bubbles: true,\n      cancelable: true\n    });\n  } else {\n    evt = document.createEvent('Event');\n    evt.initEvent(name, true, true);\n  }\n\n  evt.to = toEl || rootEl;\n  evt.from = fromEl || rootEl;\n  evt.item = targetEl || rootEl;\n  evt.clone = cloneEl;\n  evt.oldIndex = oldIndex;\n  evt.newIndex = newIndex;\n  evt.oldDraggableIndex = oldDraggableIndex;\n  evt.newDraggableIndex = newDraggableIndex;\n  evt.originalEvent = originalEvent;\n  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;\n\n  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));\n\n  for (var option in allEventProperties) {\n    evt[option] = allEventProperties[option];\n  }\n\n  if (rootEl) {\n    rootEl.dispatchEvent(evt);\n  }\n\n  if (options[onName]) {\n    options[onName].call(sortable, evt);\n  }\n}\n\nvar _excluded = [\"evt\"];\n\nvar pluginEvent = function pluginEvent(eventName, sortable) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      originalEvent = _ref.evt,\n      data = _objectWithoutProperties(_ref, _excluded);\n\n  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({\n    dragEl: dragEl,\n    parentEl: parentEl,\n    ghostEl: ghostEl,\n    rootEl: rootEl,\n    nextEl: nextEl,\n    lastDownEl: lastDownEl,\n    cloneEl: cloneEl,\n    cloneHidden: cloneHidden,\n    dragStarted: moved,\n    putSortable: putSortable,\n    activeSortable: Sortable.active,\n    originalEvent: originalEvent,\n    oldIndex: oldIndex,\n    oldDraggableIndex: oldDraggableIndex,\n    newIndex: newIndex,\n    newDraggableIndex: newDraggableIndex,\n    hideGhostForTarget: _hideGhostForTarget,\n    unhideGhostForTarget: _unhideGhostForTarget,\n    cloneNowHidden: function cloneNowHidden() {\n      cloneHidden = true;\n    },\n    cloneNowShown: function cloneNowShown() {\n      cloneHidden = false;\n    },\n    dispatchSortableEvent: function dispatchSortableEvent(name) {\n      _dispatchEvent({\n        sortable: sortable,\n        name: name,\n        originalEvent: originalEvent\n      });\n    }\n  }, data));\n};\n\nfunction _dispatchEvent(info) {\n  dispatchEvent(_objectSpread2({\n    putSortable: putSortable,\n    cloneEl: cloneEl,\n    targetEl: dragEl,\n    rootEl: rootEl,\n    oldIndex: oldIndex,\n    oldDraggableIndex: oldDraggableIndex,\n    newIndex: newIndex,\n    newDraggableIndex: newDraggableIndex\n  }, info));\n}\n\nvar dragEl,\n    parentEl,\n    ghostEl,\n    rootEl,\n    nextEl,\n    lastDownEl,\n    cloneEl,\n    cloneHidden,\n    oldIndex,\n    newIndex,\n    oldDraggableIndex,\n    newDraggableIndex,\n    activeGroup,\n    putSortable,\n    awaitingDragStarted = false,\n    ignoreNextClick = false,\n    sortables = [],\n    tapEvt,\n    touchEvt,\n    lastDx,\n    lastDy,\n    tapDistanceLeft,\n    tapDistanceTop,\n    moved,\n    lastTarget,\n    lastDirection,\n    pastFirstInvertThresh = false,\n    isCircumstantialInvert = false,\n    targetMoveDistance,\n    // For positioning ghost absolutely\nghostRelativeParent,\n    ghostRelativeParentInitialScroll = [],\n    // (left, top)\n_silent = false,\n    savedInputChecked = [];\n/** @const */\n\nvar documentExists = typeof document !== 'undefined',\n    PositionGhostAbsolutely = IOS,\n    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',\n    // This will not pass for IE9, because IE9 DnD only works on anchors\nsupportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),\n    supportCssPointerEvents = function () {\n  if (!documentExists) return; // false when <= IE11\n\n  if (IE11OrLess) {\n    return false;\n  }\n\n  var el = document.createElement('x');\n  el.style.cssText = 'pointer-events:auto';\n  return el.style.pointerEvents === 'auto';\n}(),\n    _detectDirection = function _detectDirection(el, options) {\n  var elCSS = css(el),\n      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),\n      child1 = getChild(el, 0, options),\n      child2 = getChild(el, 1, options),\n      firstChildCSS = child1 && css(child1),\n      secondChildCSS = child2 && css(child2),\n      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,\n      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;\n\n  if (elCSS.display === 'flex') {\n    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';\n  }\n\n  if (elCSS.display === 'grid') {\n    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';\n  }\n\n  if (child1 && firstChildCSS[\"float\"] && firstChildCSS[\"float\"] !== 'none') {\n    var touchingSideChild2 = firstChildCSS[\"float\"] === 'left' ? 'left' : 'right';\n    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';\n  }\n\n  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';\n},\n    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {\n  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,\n      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,\n      dragElOppLength = vertical ? dragRect.width : dragRect.height,\n      targetS1Opp = vertical ? targetRect.left : targetRect.top,\n      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,\n      targetOppLength = vertical ? targetRect.width : targetRect.height;\n  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;\n},\n\n/**\r\n * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\r\n * @param  {Number} x      X position\r\n * @param  {Number} y      Y position\r\n * @return {HTMLElement}   Element of the first found nearest Sortable\r\n */\n_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {\n  var ret;\n  sortables.some(function (sortable) {\n    var threshold = sortable[expando].options.emptyInsertThreshold;\n    if (!threshold || lastChild(sortable)) return;\n    var rect = getRect(sortable),\n        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,\n        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;\n\n    if (insideHorizontally && insideVertically) {\n      return ret = sortable;\n    }\n  });\n  return ret;\n},\n    _prepareGroup = function _prepareGroup(options) {\n  function toFn(value, pull) {\n    return function (to, from, dragEl, evt) {\n      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;\n\n      if (value == null && (pull || sameGroup)) {\n        // Default pull value\n        // Default pull and put value if same group\n        return true;\n      } else if (value == null || value === false) {\n        return false;\n      } else if (pull && value === 'clone') {\n        return value;\n      } else if (typeof value === 'function') {\n        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);\n      } else {\n        var otherGroup = (pull ? to : from).options.group.name;\n        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;\n      }\n    };\n  }\n\n  var group = {};\n  var originalGroup = options.group;\n\n  if (!originalGroup || _typeof(originalGroup) != 'object') {\n    originalGroup = {\n      name: originalGroup\n    };\n  }\n\n  group.name = originalGroup.name;\n  group.checkPull = toFn(originalGroup.pull, true);\n  group.checkPut = toFn(originalGroup.put);\n  group.revertClone = originalGroup.revertClone;\n  options.group = group;\n},\n    _hideGhostForTarget = function _hideGhostForTarget() {\n  if (!supportCssPointerEvents && ghostEl) {\n    css(ghostEl, 'display', 'none');\n  }\n},\n    _unhideGhostForTarget = function _unhideGhostForTarget() {\n  if (!supportCssPointerEvents && ghostEl) {\n    css(ghostEl, 'display', '');\n  }\n}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position\n\n\nif (documentExists && !ChromeForAndroid) {\n  document.addEventListener('click', function (evt) {\n    if (ignoreNextClick) {\n      evt.preventDefault();\n      evt.stopPropagation && evt.stopPropagation();\n      evt.stopImmediatePropagation && evt.stopImmediatePropagation();\n      ignoreNextClick = false;\n      return false;\n    }\n  }, true);\n}\n\nvar nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {\n  if (dragEl) {\n    evt = evt.touches ? evt.touches[0] : evt;\n\n    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);\n\n    if (nearest) {\n      // Create imitation event\n      var event = {};\n\n      for (var i in evt) {\n        if (evt.hasOwnProperty(i)) {\n          event[i] = evt[i];\n        }\n      }\n\n      event.target = event.rootEl = nearest;\n      event.preventDefault = void 0;\n      event.stopPropagation = void 0;\n\n      nearest[expando]._onDragOver(event);\n    }\n  }\n};\n\nvar _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {\n  if (dragEl) {\n    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n  }\n};\n/**\r\n * @class  Sortable\r\n * @param  {HTMLElement}  el\r\n * @param  {Object}       [options]\r\n */\n\n\nfunction Sortable(el, options) {\n  if (!(el && el.nodeType && el.nodeType === 1)) {\n    throw \"Sortable: `el` must be an HTMLElement, not \".concat({}.toString.call(el));\n  }\n\n  this.el = el; // root element\n\n  this.options = options = _extends({}, options); // Export instance\n\n  el[expando] = this;\n  var defaults = {\n    group: null,\n    sort: true,\n    disabled: false,\n    store: null,\n    handle: null,\n    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',\n    swapThreshold: 1,\n    // percentage; 0 <= x <= 1\n    invertSwap: false,\n    // invert always\n    invertedSwapThreshold: null,\n    // will be set to same as swapThreshold if default\n    removeCloneOnHide: true,\n    direction: function direction() {\n      return _detectDirection(el, this.options);\n    },\n    ghostClass: 'sortable-ghost',\n    chosenClass: 'sortable-chosen',\n    dragClass: 'sortable-drag',\n    ignore: 'a, img',\n    filter: null,\n    preventOnFilter: true,\n    animation: 0,\n    easing: null,\n    setData: function setData(dataTransfer, dragEl) {\n      dataTransfer.setData('Text', dragEl.textContent);\n    },\n    dropBubble: false,\n    dragoverBubble: false,\n    dataIdAttr: 'data-id',\n    delay: 0,\n    delayOnTouchOnly: false,\n    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,\n    forceFallback: false,\n    fallbackClass: 'sortable-fallback',\n    fallbackOnBody: false,\n    fallbackTolerance: 0,\n    fallbackOffset: {\n      x: 0,\n      y: 0\n    },\n    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,\n    emptyInsertThreshold: 5\n  };\n  PluginManager.initializePlugins(this, el, defaults); // Set default options\n\n  for (var name in defaults) {\n    !(name in options) && (options[name] = defaults[name]);\n  }\n\n  _prepareGroup(options); // Bind all private methods\n\n\n  for (var fn in this) {\n    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n      this[fn] = this[fn].bind(this);\n    }\n  } // Setup drag mode\n\n\n  this.nativeDraggable = options.forceFallback ? false : supportDraggable;\n\n  if (this.nativeDraggable) {\n    // Touch start threshold cannot be greater than the native dragstart threshold\n    this.options.touchStartThreshold = 1;\n  } // Bind events\n\n\n  if (options.supportPointer) {\n    on(el, 'pointerdown', this._onTapStart);\n  } else {\n    on(el, 'mousedown', this._onTapStart);\n    on(el, 'touchstart', this._onTapStart);\n  }\n\n  if (this.nativeDraggable) {\n    on(el, 'dragover', this);\n    on(el, 'dragenter', this);\n  }\n\n  sortables.push(this.el); // Restore sorting\n\n  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager\n\n  _extends(this, AnimationStateManager());\n}\n\nSortable.prototype =\n/** @lends Sortable.prototype */\n{\n  constructor: Sortable,\n  _isOutsideThisEl: function _isOutsideThisEl(target) {\n    if (!this.el.contains(target) && target !== this.el) {\n      lastTarget = null;\n    }\n  },\n  _getDirection: function _getDirection(evt, target) {\n    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;\n  },\n  _onTapStart: function _onTapStart(\n  /** Event|TouchEvent */\n  evt) {\n    if (!evt.cancelable) return;\n\n    var _this = this,\n        el = this.el,\n        options = this.options,\n        preventOnFilter = options.preventOnFilter,\n        type = evt.type,\n        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,\n        target = (touch || evt).target,\n        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,\n        filter = options.filter;\n\n    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.\n\n\n    if (dragEl) {\n      return;\n    }\n\n    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {\n      return; // only left button and enabled\n    } // cancel dnd if original target is content editable\n\n\n    if (originalTarget.isContentEditable) {\n      return;\n    } // Safari ignores further event handling after mousedown\n\n\n    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {\n      return;\n    }\n\n    target = closest(target, options.draggable, el, false);\n\n    if (target && target.animated) {\n      return;\n    }\n\n    if (lastDownEl === target) {\n      // Ignoring duplicate `down`\n      return;\n    } // Get the index of the dragged element within its parent\n\n\n    oldIndex = index(target);\n    oldDraggableIndex = index(target, options.draggable); // Check filter\n\n    if (typeof filter === 'function') {\n      if (filter.call(this, evt, target, this)) {\n        _dispatchEvent({\n          sortable: _this,\n          rootEl: originalTarget,\n          name: 'filter',\n          targetEl: target,\n          toEl: el,\n          fromEl: el\n        });\n\n        pluginEvent('filter', _this, {\n          evt: evt\n        });\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    } else if (filter) {\n      filter = filter.split(',').some(function (criteria) {\n        criteria = closest(originalTarget, criteria.trim(), el, false);\n\n        if (criteria) {\n          _dispatchEvent({\n            sortable: _this,\n            rootEl: criteria,\n            name: 'filter',\n            targetEl: target,\n            fromEl: el,\n            toEl: el\n          });\n\n          pluginEvent('filter', _this, {\n            evt: evt\n          });\n          return true;\n        }\n      });\n\n      if (filter) {\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    }\n\n    if (options.handle && !closest(originalTarget, options.handle, el, false)) {\n      return;\n    } // Prepare `dragstart`\n\n\n    this._prepareDragStart(evt, touch, target);\n  },\n  _prepareDragStart: function _prepareDragStart(\n  /** Event */\n  evt,\n  /** Touch */\n  touch,\n  /** HTMLElement */\n  target) {\n    var _this = this,\n        el = _this.el,\n        options = _this.options,\n        ownerDocument = el.ownerDocument,\n        dragStartFn;\n\n    if (target && !dragEl && target.parentNode === el) {\n      var dragRect = getRect(target);\n      rootEl = el;\n      dragEl = target;\n      parentEl = dragEl.parentNode;\n      nextEl = dragEl.nextSibling;\n      lastDownEl = target;\n      activeGroup = options.group;\n      Sortable.dragged = dragEl;\n      tapEvt = {\n        target: dragEl,\n        clientX: (touch || evt).clientX,\n        clientY: (touch || evt).clientY\n      };\n      tapDistanceLeft = tapEvt.clientX - dragRect.left;\n      tapDistanceTop = tapEvt.clientY - dragRect.top;\n      this._lastX = (touch || evt).clientX;\n      this._lastY = (touch || evt).clientY;\n      dragEl.style['will-change'] = 'all';\n\n      dragStartFn = function dragStartFn() {\n        pluginEvent('delayEnded', _this, {\n          evt: evt\n        });\n\n        if (Sortable.eventCanceled) {\n          _this._onDrop();\n\n          return;\n        } // Delayed drag has been triggered\n        // we can re-enable the events: touchmove/mousemove\n\n\n        _this._disableDelayedDragEvents();\n\n        if (!FireFox && _this.nativeDraggable) {\n          dragEl.draggable = true;\n        } // Bind the events: dragstart/dragend\n\n\n        _this._triggerDragStart(evt, touch); // Drag start event\n\n\n        _dispatchEvent({\n          sortable: _this,\n          name: 'choose',\n          originalEvent: evt\n        }); // Chosen item\n\n\n        toggleClass(dragEl, options.chosenClass, true);\n      }; // Disable \"draggable\"\n\n\n      options.ignore.split(',').forEach(function (criteria) {\n        find(dragEl, criteria.trim(), _disableDraggable);\n      });\n      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'mouseup', _this._onDrop);\n      on(ownerDocument, 'touchend', _this._onDrop);\n      on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)\n\n      if (FireFox && this.nativeDraggable) {\n        this.options.touchStartThreshold = 4;\n        dragEl.draggable = true;\n      }\n\n      pluginEvent('delayStart', this, {\n        evt: evt\n      }); // Delay is impossible for native DnD in Edge or IE\n\n      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {\n        if (Sortable.eventCanceled) {\n          this._onDrop();\n\n          return;\n        } // If the user moves the pointer or let go the click or touch\n        // before the delay has been reached:\n        // disable the delayed drag\n\n\n        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);\n        on(ownerDocument, 'touchend', _this._disableDelayedDrag);\n        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);\n        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);\n        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);\n        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);\n        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);\n      } else {\n        dragStartFn();\n      }\n    }\n  },\n  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(\n  /** TouchEvent|PointerEvent **/\n  e) {\n    var touch = e.touches ? e.touches[0] : e;\n\n    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {\n      this._disableDelayedDrag();\n    }\n  },\n  _disableDelayedDrag: function _disableDelayedDrag() {\n    dragEl && _disableDraggable(dragEl);\n    clearTimeout(this._dragStartTimer);\n\n    this._disableDelayedDragEvents();\n  },\n  _disableDelayedDragEvents: function _disableDelayedDragEvents() {\n    var ownerDocument = this.el.ownerDocument;\n    off(ownerDocument, 'mouseup', this._disableDelayedDrag);\n    off(ownerDocument, 'touchend', this._disableDelayedDrag);\n    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);\n    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);\n    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);\n    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);\n  },\n  _triggerDragStart: function _triggerDragStart(\n  /** Event */\n  evt,\n  /** Touch */\n  touch) {\n    touch = touch || evt.pointerType == 'touch' && evt;\n\n    if (!this.nativeDraggable || touch) {\n      if (this.options.supportPointer) {\n        on(document, 'pointermove', this._onTouchMove);\n      } else if (touch) {\n        on(document, 'touchmove', this._onTouchMove);\n      } else {\n        on(document, 'mousemove', this._onTouchMove);\n      }\n    } else {\n      on(dragEl, 'dragend', this);\n      on(rootEl, 'dragstart', this._onDragStart);\n    }\n\n    try {\n      if (document.selection) {\n        // Timeout neccessary for IE9\n        _nextTick(function () {\n          document.selection.empty();\n        });\n      } else {\n        window.getSelection().removeAllRanges();\n      }\n    } catch (err) {}\n  },\n  _dragStarted: function _dragStarted(fallback, evt) {\n\n    awaitingDragStarted = false;\n\n    if (rootEl && dragEl) {\n      pluginEvent('dragStarted', this, {\n        evt: evt\n      });\n\n      if (this.nativeDraggable) {\n        on(document, 'dragover', _checkOutsideTargetEl);\n      }\n\n      var options = this.options; // Apply effect\n\n      !fallback && toggleClass(dragEl, options.dragClass, false);\n      toggleClass(dragEl, options.ghostClass, true);\n      Sortable.active = this;\n      fallback && this._appendGhost(); // Drag start event\n\n      _dispatchEvent({\n        sortable: this,\n        name: 'start',\n        originalEvent: evt\n      });\n    } else {\n      this._nulling();\n    }\n  },\n  _emulateDragOver: function _emulateDragOver() {\n    if (touchEvt) {\n      this._lastX = touchEvt.clientX;\n      this._lastY = touchEvt.clientY;\n\n      _hideGhostForTarget();\n\n      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n      var parent = target;\n\n      while (target && target.shadowRoot) {\n        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n        if (target === parent) break;\n        parent = target;\n      }\n\n      dragEl.parentNode[expando]._isOutsideThisEl(target);\n\n      if (parent) {\n        do {\n          if (parent[expando]) {\n            var inserted = void 0;\n            inserted = parent[expando]._onDragOver({\n              clientX: touchEvt.clientX,\n              clientY: touchEvt.clientY,\n              target: target,\n              rootEl: parent\n            });\n\n            if (inserted && !this.options.dragoverBubble) {\n              break;\n            }\n          }\n\n          target = parent; // store last element\n        }\n        /* jshint boss:true */\n        while (parent = parent.parentNode);\n      }\n\n      _unhideGhostForTarget();\n    }\n  },\n  _onTouchMove: function _onTouchMove(\n  /**TouchEvent*/\n  evt) {\n    if (tapEvt) {\n      var options = this.options,\n          fallbackTolerance = options.fallbackTolerance,\n          fallbackOffset = options.fallbackOffset,\n          touch = evt.touches ? evt.touches[0] : evt,\n          ghostMatrix = ghostEl && matrix(ghostEl, true),\n          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,\n          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,\n          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),\n          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),\n          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging\n\n      if (!Sortable.active && !awaitingDragStarted) {\n        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {\n          return;\n        }\n\n        this._onDragStart(evt, true);\n      }\n\n      if (ghostEl) {\n        if (ghostMatrix) {\n          ghostMatrix.e += dx - (lastDx || 0);\n          ghostMatrix.f += dy - (lastDy || 0);\n        } else {\n          ghostMatrix = {\n            a: 1,\n            b: 0,\n            c: 0,\n            d: 1,\n            e: dx,\n            f: dy\n          };\n        }\n\n        var cssMatrix = \"matrix(\".concat(ghostMatrix.a, \",\").concat(ghostMatrix.b, \",\").concat(ghostMatrix.c, \",\").concat(ghostMatrix.d, \",\").concat(ghostMatrix.e, \",\").concat(ghostMatrix.f, \")\");\n        css(ghostEl, 'webkitTransform', cssMatrix);\n        css(ghostEl, 'mozTransform', cssMatrix);\n        css(ghostEl, 'msTransform', cssMatrix);\n        css(ghostEl, 'transform', cssMatrix);\n        lastDx = dx;\n        lastDy = dy;\n        touchEvt = touch;\n      }\n\n      evt.cancelable && evt.preventDefault();\n    }\n  },\n  _appendGhost: function _appendGhost() {\n    // Bug if using scale(): https://stackoverflow.com/questions/2637058\n    // Not being adjusted for\n    if (!ghostEl) {\n      var container = this.options.fallbackOnBody ? document.body : rootEl,\n          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),\n          options = this.options; // Position absolutely\n\n      if (PositionGhostAbsolutely) {\n        // Get relatively positioned parent\n        ghostRelativeParent = container;\n\n        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {\n          ghostRelativeParent = ghostRelativeParent.parentNode;\n        }\n\n        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {\n          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();\n          rect.top += ghostRelativeParent.scrollTop;\n          rect.left += ghostRelativeParent.scrollLeft;\n        } else {\n          ghostRelativeParent = getWindowScrollingElement();\n        }\n\n        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);\n      }\n\n      ghostEl = dragEl.cloneNode(true);\n      toggleClass(ghostEl, options.ghostClass, false);\n      toggleClass(ghostEl, options.fallbackClass, true);\n      toggleClass(ghostEl, options.dragClass, true);\n      css(ghostEl, 'transition', '');\n      css(ghostEl, 'transform', '');\n      css(ghostEl, 'box-sizing', 'border-box');\n      css(ghostEl, 'margin', 0);\n      css(ghostEl, 'top', rect.top);\n      css(ghostEl, 'left', rect.left);\n      css(ghostEl, 'width', rect.width);\n      css(ghostEl, 'height', rect.height);\n      css(ghostEl, 'opacity', '0.8');\n      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');\n      css(ghostEl, 'zIndex', '100000');\n      css(ghostEl, 'pointerEvents', 'none');\n      Sortable.ghost = ghostEl;\n      container.appendChild(ghostEl); // Set transform-origin\n\n      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');\n    }\n  },\n  _onDragStart: function _onDragStart(\n  /**Event*/\n  evt,\n  /**boolean*/\n  fallback) {\n    var _this = this;\n\n    var dataTransfer = evt.dataTransfer;\n    var options = _this.options;\n    pluginEvent('dragStart', this, {\n      evt: evt\n    });\n\n    if (Sortable.eventCanceled) {\n      this._onDrop();\n\n      return;\n    }\n\n    pluginEvent('setupClone', this);\n\n    if (!Sortable.eventCanceled) {\n      cloneEl = clone(dragEl);\n      cloneEl.removeAttribute(\"id\");\n      cloneEl.draggable = false;\n      cloneEl.style['will-change'] = '';\n\n      this._hideClone();\n\n      toggleClass(cloneEl, this.options.chosenClass, false);\n      Sortable.clone = cloneEl;\n    } // #1143: IFrame support workaround\n\n\n    _this.cloneId = _nextTick(function () {\n      pluginEvent('clone', _this);\n      if (Sortable.eventCanceled) return;\n\n      if (!_this.options.removeCloneOnHide) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      }\n\n      _this._hideClone();\n\n      _dispatchEvent({\n        sortable: _this,\n        name: 'clone'\n      });\n    });\n    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events\n\n    if (fallback) {\n      ignoreNextClick = true;\n      _this._loopId = setInterval(_this._emulateDragOver, 50);\n    } else {\n      // Undo what was set in _prepareDragStart before drag started\n      off(document, 'mouseup', _this._onDrop);\n      off(document, 'touchend', _this._onDrop);\n      off(document, 'touchcancel', _this._onDrop);\n\n      if (dataTransfer) {\n        dataTransfer.effectAllowed = 'move';\n        options.setData && options.setData.call(_this, dataTransfer, dragEl);\n      }\n\n      on(document, 'drop', _this); // #1276 fix:\n\n      css(dragEl, 'transform', 'translateZ(0)');\n    }\n\n    awaitingDragStarted = true;\n    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));\n    on(document, 'selectstart', _this);\n    moved = true;\n\n    if (Safari) {\n      css(document.body, 'user-select', 'none');\n    }\n  },\n  // Returns true - if no further action is needed (either inserted or another condition)\n  _onDragOver: function _onDragOver(\n  /**Event*/\n  evt) {\n    var el = this.el,\n        target = evt.target,\n        dragRect,\n        targetRect,\n        revert,\n        options = this.options,\n        group = options.group,\n        activeSortable = Sortable.active,\n        isOwner = activeGroup === group,\n        canSort = options.sort,\n        fromSortable = putSortable || activeSortable,\n        vertical,\n        _this = this,\n        completedFired = false;\n\n    if (_silent) return;\n\n    function dragOverEvent(name, extra) {\n      pluginEvent(name, _this, _objectSpread2({\n        evt: evt,\n        isOwner: isOwner,\n        axis: vertical ? 'vertical' : 'horizontal',\n        revert: revert,\n        dragRect: dragRect,\n        targetRect: targetRect,\n        canSort: canSort,\n        fromSortable: fromSortable,\n        target: target,\n        completed: completed,\n        onMove: function onMove(target, after) {\n          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);\n        },\n        changed: changed\n      }, extra));\n    } // Capture animation state\n\n\n    function capture() {\n      dragOverEvent('dragOverAnimationCapture');\n\n      _this.captureAnimationState();\n\n      if (_this !== fromSortable) {\n        fromSortable.captureAnimationState();\n      }\n    } // Return invocation when dragEl is inserted (or completed)\n\n\n    function completed(insertion) {\n      dragOverEvent('dragOverCompleted', {\n        insertion: insertion\n      });\n\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        } else {\n          activeSortable._showClone(_this);\n        }\n\n        if (_this !== fromSortable) {\n          // Set ghost class to new sortable's ghost class\n          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);\n          toggleClass(dragEl, options.ghostClass, true);\n        }\n\n        if (putSortable !== _this && _this !== Sortable.active) {\n          putSortable = _this;\n        } else if (_this === Sortable.active && putSortable) {\n          putSortable = null;\n        } // Animation\n\n\n        if (fromSortable === _this) {\n          _this._ignoreWhileAnimating = target;\n        }\n\n        _this.animateAll(function () {\n          dragOverEvent('dragOverAnimationComplete');\n          _this._ignoreWhileAnimating = null;\n        });\n\n        if (_this !== fromSortable) {\n          fromSortable.animateAll();\n          fromSortable._ignoreWhileAnimating = null;\n        }\n      } // Null lastTarget if it is not inside a previously swapped element\n\n\n      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {\n        lastTarget = null;\n      } // no bubbling and not fallback\n\n\n      if (!options.dragoverBubble && !evt.rootEl && target !== document) {\n        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted\n\n\n        !insertion && nearestEmptyInsertDetectEvent(evt);\n      }\n\n      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\n      return completedFired = true;\n    } // Call when dragEl has been inserted\n\n\n    function changed() {\n      newIndex = index(dragEl);\n      newDraggableIndex = index(dragEl, options.draggable);\n\n      _dispatchEvent({\n        sortable: _this,\n        name: 'change',\n        toEl: el,\n        newIndex: newIndex,\n        newDraggableIndex: newDraggableIndex,\n        originalEvent: evt\n      });\n    }\n\n    if (evt.preventDefault !== void 0) {\n      evt.cancelable && evt.preventDefault();\n    }\n\n    target = closest(target, options.draggable, el, true);\n    dragOverEvent('dragOver');\n    if (Sortable.eventCanceled) return completedFired;\n\n    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {\n      return completed(false);\n    }\n\n    ignoreNextClick = false;\n\n    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list\n    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {\n      vertical = this._getDirection(evt, target) === 'vertical';\n      dragRect = getRect(dragEl);\n      dragOverEvent('dragOverValid');\n      if (Sortable.eventCanceled) return completedFired;\n\n      if (revert) {\n        parentEl = rootEl; // actualization\n\n        capture();\n\n        this._hideClone();\n\n        dragOverEvent('revert');\n\n        if (!Sortable.eventCanceled) {\n          if (nextEl) {\n            rootEl.insertBefore(dragEl, nextEl);\n          } else {\n            rootEl.appendChild(dragEl);\n          }\n        }\n\n        return completed(true);\n      }\n\n      var elLastChild = lastChild(el, options.draggable);\n\n      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {\n        // Insert to end of list\n        // If already at end of list: Do not insert\n        if (elLastChild === dragEl) {\n          return completed(false);\n        } // if there is a last element, it is the target\n\n\n        if (elLastChild && el === evt.target) {\n          target = elLastChild;\n        }\n\n        if (target) {\n          targetRect = getRect(target);\n        }\n\n        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {\n          capture();\n\n          if (elLastChild && elLastChild.nextSibling) {\n            // the last draggable element is not the last node\n            el.insertBefore(dragEl, elLastChild.nextSibling);\n          } else {\n            el.appendChild(dragEl);\n          }\n\n          parentEl = el; // actualization\n\n          changed();\n          return completed(true);\n        }\n      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {\n        // Insert to start of list\n        var firstChild = getChild(el, 0, options, true);\n\n        if (firstChild === dragEl) {\n          return completed(false);\n        }\n\n        target = firstChild;\n        targetRect = getRect(target);\n\n        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {\n          capture();\n          el.insertBefore(dragEl, firstChild);\n          parentEl = el; // actualization\n\n          changed();\n          return completed(true);\n        }\n      } else if (target.parentNode === el) {\n        targetRect = getRect(target);\n        var direction = 0,\n            targetBeforeFirstSwap,\n            differentLevel = dragEl.parentNode !== el,\n            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),\n            side1 = vertical ? 'top' : 'left',\n            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),\n            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\n\n        if (lastTarget !== target) {\n          targetBeforeFirstSwap = targetRect[side1];\n          pastFirstInvertThresh = false;\n          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;\n        }\n\n        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);\n        var sibling;\n\n        if (direction !== 0) {\n          // Check if target is beside dragEl in respective direction (ignoring hidden elements)\n          var dragIndex = index(dragEl);\n\n          do {\n            dragIndex -= direction;\n            sibling = parentEl.children[dragIndex];\n          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));\n        } // If dragEl is already beside target: Do not insert\n\n\n        if (direction === 0 || sibling === target) {\n          return completed(false);\n        }\n\n        lastTarget = target;\n        lastDirection = direction;\n        var nextSibling = target.nextElementSibling,\n            after = false;\n        after = direction === 1;\n\n        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);\n\n        if (moveVector !== false) {\n          if (moveVector === 1 || moveVector === -1) {\n            after = moveVector === 1;\n          }\n\n          _silent = true;\n          setTimeout(_unsilent, 30);\n          capture();\n\n          if (after && !nextSibling) {\n            el.appendChild(dragEl);\n          } else {\n            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);\n          } // Undo chrome's scroll adjustment (has no effect on other browsers)\n\n\n          if (scrolledPastTop) {\n            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);\n          }\n\n          parentEl = dragEl.parentNode; // actualization\n          // must be done before animation\n\n          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\n            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);\n          }\n\n          changed();\n          return completed(true);\n        }\n      }\n\n      if (el.contains(dragEl)) {\n        return completed(false);\n      }\n    }\n\n    return false;\n  },\n  _ignoreWhileAnimating: null,\n  _offMoveEvents: function _offMoveEvents() {\n    off(document, 'mousemove', this._onTouchMove);\n    off(document, 'touchmove', this._onTouchMove);\n    off(document, 'pointermove', this._onTouchMove);\n    off(document, 'dragover', nearestEmptyInsertDetectEvent);\n    off(document, 'mousemove', nearestEmptyInsertDetectEvent);\n    off(document, 'touchmove', nearestEmptyInsertDetectEvent);\n  },\n  _offUpEvents: function _offUpEvents() {\n    var ownerDocument = this.el.ownerDocument;\n    off(ownerDocument, 'mouseup', this._onDrop);\n    off(ownerDocument, 'touchend', this._onDrop);\n    off(ownerDocument, 'pointerup', this._onDrop);\n    off(ownerDocument, 'touchcancel', this._onDrop);\n    off(document, 'selectstart', this);\n  },\n  _onDrop: function _onDrop(\n  /**Event*/\n  evt) {\n    var el = this.el,\n        options = this.options; // Get the index of the dragged element within its parent\n\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n    pluginEvent('drop', this, {\n      evt: evt\n    });\n    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event\n\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n\n    if (Sortable.eventCanceled) {\n      this._nulling();\n\n      return;\n    }\n\n    awaitingDragStarted = false;\n    isCircumstantialInvert = false;\n    pastFirstInvertThresh = false;\n    clearInterval(this._loopId);\n    clearTimeout(this._dragStartTimer);\n\n    _cancelNextTick(this.cloneId);\n\n    _cancelNextTick(this._dragStartId); // Unbind events\n\n\n    if (this.nativeDraggable) {\n      off(document, 'drop', this);\n      off(el, 'dragstart', this._onDragStart);\n    }\n\n    this._offMoveEvents();\n\n    this._offUpEvents();\n\n    if (Safari) {\n      css(document.body, 'user-select', '');\n    }\n\n    css(dragEl, 'transform', '');\n\n    if (evt) {\n      if (moved) {\n        evt.cancelable && evt.preventDefault();\n        !options.dropBubble && evt.stopPropagation();\n      }\n\n      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);\n\n      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n        // Remove clone(s)\n        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);\n      }\n\n      if (dragEl) {\n        if (this.nativeDraggable) {\n          off(dragEl, 'dragend', this);\n        }\n\n        _disableDraggable(dragEl);\n\n        dragEl.style['will-change'] = ''; // Remove classes\n        // ghostClass is added in dragStarted\n\n        if (moved && !awaitingDragStarted) {\n          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);\n        }\n\n        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event\n\n        _dispatchEvent({\n          sortable: this,\n          name: 'unchoose',\n          toEl: parentEl,\n          newIndex: null,\n          newDraggableIndex: null,\n          originalEvent: evt\n        });\n\n        if (rootEl !== parentEl) {\n          if (newIndex >= 0) {\n            // Add event\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: 'add',\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt\n            }); // Remove event\n\n\n            _dispatchEvent({\n              sortable: this,\n              name: 'remove',\n              toEl: parentEl,\n              originalEvent: evt\n            }); // drag from one list and drop into another\n\n\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: 'sort',\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt\n            });\n\n            _dispatchEvent({\n              sortable: this,\n              name: 'sort',\n              toEl: parentEl,\n              originalEvent: evt\n            });\n          }\n\n          putSortable && putSortable.save();\n        } else {\n          if (newIndex !== oldIndex) {\n            if (newIndex >= 0) {\n              // drag & drop within the same list\n              _dispatchEvent({\n                sortable: this,\n                name: 'update',\n                toEl: parentEl,\n                originalEvent: evt\n              });\n\n              _dispatchEvent({\n                sortable: this,\n                name: 'sort',\n                toEl: parentEl,\n                originalEvent: evt\n              });\n            }\n          }\n        }\n\n        if (Sortable.active) {\n          /* jshint eqnull:true */\n          if (newIndex == null || newIndex === -1) {\n            newIndex = oldIndex;\n            newDraggableIndex = oldDraggableIndex;\n          }\n\n          _dispatchEvent({\n            sortable: this,\n            name: 'end',\n            toEl: parentEl,\n            originalEvent: evt\n          }); // Save sorting\n\n\n          this.save();\n        }\n      }\n    }\n\n    this._nulling();\n  },\n  _nulling: function _nulling() {\n    pluginEvent('nulling', this);\n    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;\n    savedInputChecked.forEach(function (el) {\n      el.checked = true;\n    });\n    savedInputChecked.length = lastDx = lastDy = 0;\n  },\n  handleEvent: function handleEvent(\n  /**Event*/\n  evt) {\n    switch (evt.type) {\n      case 'drop':\n      case 'dragend':\n        this._onDrop(evt);\n\n        break;\n\n      case 'dragenter':\n      case 'dragover':\n        if (dragEl) {\n          this._onDragOver(evt);\n\n          _globalDragOver(evt);\n        }\n\n        break;\n\n      case 'selectstart':\n        evt.preventDefault();\n        break;\n    }\n  },\n\n  /**\r\n   * Serializes the item into an array of string.\r\n   * @returns {String[]}\r\n   */\n  toArray: function toArray() {\n    var order = [],\n        el,\n        children = this.el.children,\n        i = 0,\n        n = children.length,\n        options = this.options;\n\n    for (; i < n; i++) {\n      el = children[i];\n\n      if (closest(el, options.draggable, this.el, false)) {\n        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\n      }\n    }\n\n    return order;\n  },\n\n  /**\r\n   * Sorts the elements according to the array.\r\n   * @param  {String[]}  order  order of the items\r\n   */\n  sort: function sort(order, useAnimation) {\n    var items = {},\n        rootEl = this.el;\n    this.toArray().forEach(function (id, i) {\n      var el = rootEl.children[i];\n\n      if (closest(el, this.options.draggable, rootEl, false)) {\n        items[id] = el;\n      }\n    }, this);\n    useAnimation && this.captureAnimationState();\n    order.forEach(function (id) {\n      if (items[id]) {\n        rootEl.removeChild(items[id]);\n        rootEl.appendChild(items[id]);\n      }\n    });\n    useAnimation && this.animateAll();\n  },\n\n  /**\r\n   * Save the current sorting\r\n   */\n  save: function save() {\n    var store = this.options.store;\n    store && store.set && store.set(this);\n  },\n\n  /**\r\n   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.\r\n   * @param   {HTMLElement}  el\r\n   * @param   {String}       [selector]  default: `options.draggable`\r\n   * @returns {HTMLElement|null}\r\n   */\n  closest: function closest$1(el, selector) {\n    return closest(el, selector || this.options.draggable, this.el, false);\n  },\n\n  /**\r\n   * Set/get option\r\n   * @param   {string} name\r\n   * @param   {*}      [value]\r\n   * @returns {*}\r\n   */\n  option: function option(name, value) {\n    var options = this.options;\n\n    if (value === void 0) {\n      return options[name];\n    } else {\n      var modifiedValue = PluginManager.modifyOption(this, name, value);\n\n      if (typeof modifiedValue !== 'undefined') {\n        options[name] = modifiedValue;\n      } else {\n        options[name] = value;\n      }\n\n      if (name === 'group') {\n        _prepareGroup(options);\n      }\n    }\n  },\n\n  /**\r\n   * Destroy\r\n   */\n  destroy: function destroy() {\n    pluginEvent('destroy', this);\n    var el = this.el;\n    el[expando] = null;\n    off(el, 'mousedown', this._onTapStart);\n    off(el, 'touchstart', this._onTapStart);\n    off(el, 'pointerdown', this._onTapStart);\n\n    if (this.nativeDraggable) {\n      off(el, 'dragover', this);\n      off(el, 'dragenter', this);\n    } // Remove draggable attributes\n\n\n    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {\n      el.removeAttribute('draggable');\n    });\n\n    this._onDrop();\n\n    this._disableDelayedDragEvents();\n\n    sortables.splice(sortables.indexOf(this.el), 1);\n    this.el = el = null;\n  },\n  _hideClone: function _hideClone() {\n    if (!cloneHidden) {\n      pluginEvent('hideClone', this);\n      if (Sortable.eventCanceled) return;\n      css(cloneEl, 'display', 'none');\n\n      if (this.options.removeCloneOnHide && cloneEl.parentNode) {\n        cloneEl.parentNode.removeChild(cloneEl);\n      }\n\n      cloneHidden = true;\n    }\n  },\n  _showClone: function _showClone(putSortable) {\n    if (putSortable.lastPutMode !== 'clone') {\n      this._hideClone();\n\n      return;\n    }\n\n    if (cloneHidden) {\n      pluginEvent('showClone', this);\n      if (Sortable.eventCanceled) return; // show clone at dragEl or original position\n\n      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      } else if (nextEl) {\n        rootEl.insertBefore(cloneEl, nextEl);\n      } else {\n        rootEl.appendChild(cloneEl);\n      }\n\n      if (this.options.group.revertClone) {\n        this.animate(dragEl, cloneEl);\n      }\n\n      css(cloneEl, 'display', '');\n      cloneHidden = false;\n    }\n  }\n};\n\nfunction _globalDragOver(\n/**Event*/\nevt) {\n  if (evt.dataTransfer) {\n    evt.dataTransfer.dropEffect = 'move';\n  }\n\n  evt.cancelable && evt.preventDefault();\n}\n\nfunction _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {\n  var evt,\n      sortable = fromEl[expando],\n      onMoveFn = sortable.options.onMove,\n      retVal; // Support for new CustomEvent feature\n\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent('move', {\n      bubbles: true,\n      cancelable: true\n    });\n  } else {\n    evt = document.createEvent('Event');\n    evt.initEvent('move', true, true);\n  }\n\n  evt.to = toEl;\n  evt.from = fromEl;\n  evt.dragged = dragEl;\n  evt.draggedRect = dragRect;\n  evt.related = targetEl || toEl;\n  evt.relatedRect = targetRect || getRect(toEl);\n  evt.willInsertAfter = willInsertAfter;\n  evt.originalEvent = originalEvent;\n  fromEl.dispatchEvent(evt);\n\n  if (onMoveFn) {\n    retVal = onMoveFn.call(sortable, evt, originalEvent);\n  }\n\n  return retVal;\n}\n\nfunction _disableDraggable(el) {\n  el.draggable = false;\n}\n\nfunction _unsilent() {\n  _silent = false;\n}\n\nfunction _ghostIsFirst(evt, vertical, sortable) {\n  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));\n  var spacer = 10;\n  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;\n}\n\nfunction _ghostIsLast(evt, vertical, sortable) {\n  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));\n  var spacer = 10;\n  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;\n}\n\nfunction _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {\n  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,\n      targetLength = vertical ? targetRect.height : targetRect.width,\n      targetS1 = vertical ? targetRect.top : targetRect.left,\n      targetS2 = vertical ? targetRect.bottom : targetRect.right,\n      invert = false;\n\n  if (!invertSwap) {\n    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\n    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {\n      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\n      // check if past first invert threshold on side opposite of lastDirection\n      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {\n        // past first invert threshold, do not restrict inverted threshold to dragEl shadow\n        pastFirstInvertThresh = true;\n      }\n\n      if (!pastFirstInvertThresh) {\n        // dragEl shadow (target move distance shadow)\n        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\n        : mouseOnAxis > targetS2 - targetMoveDistance) {\n          return -lastDirection;\n        }\n      } else {\n        invert = true;\n      }\n    } else {\n      // Regular\n      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {\n        return _getInsertDirection(target);\n      }\n    }\n  }\n\n  invert = invert || invertSwap;\n\n  if (invert) {\n    // Invert of regular\n    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {\n      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;\n    }\n  }\n\n  return 0;\n}\n/**\r\n * Gets the direction dragEl must be swapped relative to target in order to make it\r\n * seem that dragEl has been \"inserted\" into that element's position\r\n * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\r\n * @return {Number}                   Direction dragEl must be swapped\r\n */\n\n\nfunction _getInsertDirection(target) {\n  if (index(dragEl) < index(target)) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n/**\r\n * Generate id\r\n * @param   {HTMLElement} el\r\n * @returns {String}\r\n * @private\r\n */\n\n\nfunction _generateId(el) {\n  var str = el.tagName + el.className + el.src + el.href + el.textContent,\n      i = str.length,\n      sum = 0;\n\n  while (i--) {\n    sum += str.charCodeAt(i);\n  }\n\n  return sum.toString(36);\n}\n\nfunction _saveInputCheckedState(root) {\n  savedInputChecked.length = 0;\n  var inputs = root.getElementsByTagName('input');\n  var idx = inputs.length;\n\n  while (idx--) {\n    var el = inputs[idx];\n    el.checked && savedInputChecked.push(el);\n  }\n}\n\nfunction _nextTick(fn) {\n  return setTimeout(fn, 0);\n}\n\nfunction _cancelNextTick(id) {\n  return clearTimeout(id);\n} // Fixed #973:\n\n\nif (documentExists) {\n  on(document, 'touchmove', function (evt) {\n    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {\n      evt.preventDefault();\n    }\n  });\n} // Export utils\n\n\nSortable.utils = {\n  on: on,\n  off: off,\n  css: css,\n  find: find,\n  is: function is(el, selector) {\n    return !!closest(el, selector, el, false);\n  },\n  extend: extend,\n  throttle: throttle,\n  closest: closest,\n  toggleClass: toggleClass,\n  clone: clone,\n  index: index,\n  nextTick: _nextTick,\n  cancelNextTick: _cancelNextTick,\n  detectDirection: _detectDirection,\n  getChild: getChild\n};\n/**\r\n * Get the Sortable instance of an element\r\n * @param  {HTMLElement} element The element\r\n * @return {Sortable|undefined}         The instance of Sortable\r\n */\n\nSortable.get = function (element) {\n  return element[expando];\n};\n/**\r\n * Mount a plugin to Sortable\r\n * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted\r\n */\n\n\nSortable.mount = function () {\n  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {\n    plugins[_key] = arguments[_key];\n  }\n\n  if (plugins[0].constructor === Array) plugins = plugins[0];\n  plugins.forEach(function (plugin) {\n    if (!plugin.prototype || !plugin.prototype.constructor) {\n      throw \"Sortable: Mounted plugin must be a constructor function, not \".concat({}.toString.call(plugin));\n    }\n\n    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);\n    PluginManager.mount(plugin);\n  });\n};\n/**\r\n * Create sortable instance\r\n * @param {HTMLElement}  el\r\n * @param {Object}      [options]\r\n */\n\n\nSortable.create = function (el, options) {\n  return new Sortable(el, options);\n}; // Export\n\n\nSortable.version = version;\n\nvar autoScrolls = [],\n    scrollEl,\n    scrollRootEl,\n    scrolling = false,\n    lastAutoScrollX,\n    lastAutoScrollY,\n    touchEvt$1,\n    pointerElemChangedInterval;\n\nfunction AutoScrollPlugin() {\n  function AutoScroll() {\n    this.defaults = {\n      scroll: true,\n      forceAutoScrollFallback: false,\n      scrollSensitivity: 30,\n      scrollSpeed: 10,\n      bubbleScroll: true\n    }; // Bind all private methods\n\n    for (var fn in this) {\n      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n  }\n\n  AutoScroll.prototype = {\n    dragStarted: function dragStarted(_ref) {\n      var originalEvent = _ref.originalEvent;\n\n      if (this.sortable.nativeDraggable) {\n        on(document, 'dragover', this._handleAutoScroll);\n      } else {\n        if (this.options.supportPointer) {\n          on(document, 'pointermove', this._handleFallbackAutoScroll);\n        } else if (originalEvent.touches) {\n          on(document, 'touchmove', this._handleFallbackAutoScroll);\n        } else {\n          on(document, 'mousemove', this._handleFallbackAutoScroll);\n        }\n      }\n    },\n    dragOverCompleted: function dragOverCompleted(_ref2) {\n      var originalEvent = _ref2.originalEvent;\n\n      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)\n      if (!this.options.dragOverBubble && !originalEvent.rootEl) {\n        this._handleAutoScroll(originalEvent);\n      }\n    },\n    drop: function drop() {\n      if (this.sortable.nativeDraggable) {\n        off(document, 'dragover', this._handleAutoScroll);\n      } else {\n        off(document, 'pointermove', this._handleFallbackAutoScroll);\n        off(document, 'touchmove', this._handleFallbackAutoScroll);\n        off(document, 'mousemove', this._handleFallbackAutoScroll);\n      }\n\n      clearPointerElemChangedInterval();\n      clearAutoScrolls();\n      cancelThrottle();\n    },\n    nulling: function nulling() {\n      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;\n      autoScrolls.length = 0;\n    },\n    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {\n      this._handleAutoScroll(evt, true);\n    },\n    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {\n      var _this = this;\n\n      var x = (evt.touches ? evt.touches[0] : evt).clientX,\n          y = (evt.touches ? evt.touches[0] : evt).clientY,\n          elem = document.elementFromPoint(x, y);\n      touchEvt$1 = evt; // IE does not seem to have native autoscroll,\n      // Edge's autoscroll seems too conditional,\n      // MACOS Safari does not have autoscroll,\n      // Firefox and Chrome are good\n\n      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {\n        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change\n\n        var ogElemScroller = getParentAutoScrollElement(elem, true);\n\n        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {\n          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour\n\n          pointerElemChangedInterval = setInterval(function () {\n            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);\n\n            if (newElem !== ogElemScroller) {\n              ogElemScroller = newElem;\n              clearAutoScrolls();\n            }\n\n            autoScroll(evt, _this.options, newElem, fallback);\n          }, 10);\n          lastAutoScrollX = x;\n          lastAutoScrollY = y;\n        }\n      } else {\n        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll\n        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {\n          clearAutoScrolls();\n          return;\n        }\n\n        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);\n      }\n    }\n  };\n  return _extends(AutoScroll, {\n    pluginName: 'scroll',\n    initializeByDefault: true\n  });\n}\n\nfunction clearAutoScrolls() {\n  autoScrolls.forEach(function (autoScroll) {\n    clearInterval(autoScroll.pid);\n  });\n  autoScrolls = [];\n}\n\nfunction clearPointerElemChangedInterval() {\n  clearInterval(pointerElemChangedInterval);\n}\n\nvar autoScroll = throttle(function (evt, options, rootEl, isFallback) {\n  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521\n  if (!options.scroll) return;\n  var x = (evt.touches ? evt.touches[0] : evt).clientX,\n      y = (evt.touches ? evt.touches[0] : evt).clientY,\n      sens = options.scrollSensitivity,\n      speed = options.scrollSpeed,\n      winScroller = getWindowScrollingElement();\n  var scrollThisInstance = false,\n      scrollCustomFn; // New scroll root, set scrollEl\n\n  if (scrollRootEl !== rootEl) {\n    scrollRootEl = rootEl;\n    clearAutoScrolls();\n    scrollEl = options.scroll;\n    scrollCustomFn = options.scrollFn;\n\n    if (scrollEl === true) {\n      scrollEl = getParentAutoScrollElement(rootEl, true);\n    }\n  }\n\n  var layersOut = 0;\n  var currentParent = scrollEl;\n\n  do {\n    var el = currentParent,\n        rect = getRect(el),\n        top = rect.top,\n        bottom = rect.bottom,\n        left = rect.left,\n        right = rect.right,\n        width = rect.width,\n        height = rect.height,\n        canScrollX = void 0,\n        canScrollY = void 0,\n        scrollWidth = el.scrollWidth,\n        scrollHeight = el.scrollHeight,\n        elCSS = css(el),\n        scrollPosX = el.scrollLeft,\n        scrollPosY = el.scrollTop;\n\n    if (el === winScroller) {\n      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');\n      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');\n    } else {\n      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');\n      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');\n    }\n\n    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);\n    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);\n\n    if (!autoScrolls[layersOut]) {\n      for (var i = 0; i <= layersOut; i++) {\n        if (!autoScrolls[i]) {\n          autoScrolls[i] = {};\n        }\n      }\n    }\n\n    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {\n      autoScrolls[layersOut].el = el;\n      autoScrolls[layersOut].vx = vx;\n      autoScrolls[layersOut].vy = vy;\n      clearInterval(autoScrolls[layersOut].pid);\n\n      if (vx != 0 || vy != 0) {\n        scrollThisInstance = true;\n        /* jshint loopfunc:true */\n\n        autoScrolls[layersOut].pid = setInterval(function () {\n          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour\n          if (isFallback && this.layer === 0) {\n            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely\n\n          }\n\n          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;\n          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;\n\n          if (typeof scrollCustomFn === 'function') {\n            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {\n              return;\n            }\n          }\n\n          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);\n        }.bind({\n          layer: layersOut\n        }), 24);\n      }\n    }\n\n    layersOut++;\n  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));\n\n  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not\n}, 30);\n\nvar drop = function drop(_ref) {\n  var originalEvent = _ref.originalEvent,\n      putSortable = _ref.putSortable,\n      dragEl = _ref.dragEl,\n      activeSortable = _ref.activeSortable,\n      dispatchSortableEvent = _ref.dispatchSortableEvent,\n      hideGhostForTarget = _ref.hideGhostForTarget,\n      unhideGhostForTarget = _ref.unhideGhostForTarget;\n  if (!originalEvent) return;\n  var toSortable = putSortable || activeSortable;\n  hideGhostForTarget();\n  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;\n  var target = document.elementFromPoint(touch.clientX, touch.clientY);\n  unhideGhostForTarget();\n\n  if (toSortable && !toSortable.el.contains(target)) {\n    dispatchSortableEvent('spill');\n    this.onSpill({\n      dragEl: dragEl,\n      putSortable: putSortable\n    });\n  }\n};\n\nfunction Revert() {}\n\nRevert.prototype = {\n  startIndex: null,\n  dragStart: function dragStart(_ref2) {\n    var oldDraggableIndex = _ref2.oldDraggableIndex;\n    this.startIndex = oldDraggableIndex;\n  },\n  onSpill: function onSpill(_ref3) {\n    var dragEl = _ref3.dragEl,\n        putSortable = _ref3.putSortable;\n    this.sortable.captureAnimationState();\n\n    if (putSortable) {\n      putSortable.captureAnimationState();\n    }\n\n    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);\n\n    if (nextSibling) {\n      this.sortable.el.insertBefore(dragEl, nextSibling);\n    } else {\n      this.sortable.el.appendChild(dragEl);\n    }\n\n    this.sortable.animateAll();\n\n    if (putSortable) {\n      putSortable.animateAll();\n    }\n  },\n  drop: drop\n};\n\n_extends(Revert, {\n  pluginName: 'revertOnSpill'\n});\n\nfunction Remove() {}\n\nRemove.prototype = {\n  onSpill: function onSpill(_ref4) {\n    var dragEl = _ref4.dragEl,\n        putSortable = _ref4.putSortable;\n    var parentSortable = putSortable || this.sortable;\n    parentSortable.captureAnimationState();\n    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);\n    parentSortable.animateAll();\n  },\n  drop: drop\n};\n\n_extends(Remove, {\n  pluginName: 'removeOnSpill'\n});\n\nvar lastSwapEl;\n\nfunction SwapPlugin() {\n  function Swap() {\n    this.defaults = {\n      swapClass: 'sortable-swap-highlight'\n    };\n  }\n\n  Swap.prototype = {\n    dragStart: function dragStart(_ref) {\n      var dragEl = _ref.dragEl;\n      lastSwapEl = dragEl;\n    },\n    dragOverValid: function dragOverValid(_ref2) {\n      var completed = _ref2.completed,\n          target = _ref2.target,\n          onMove = _ref2.onMove,\n          activeSortable = _ref2.activeSortable,\n          changed = _ref2.changed,\n          cancel = _ref2.cancel;\n      if (!activeSortable.options.swap) return;\n      var el = this.sortable.el,\n          options = this.options;\n\n      if (target && target !== el) {\n        var prevSwapEl = lastSwapEl;\n\n        if (onMove(target) !== false) {\n          toggleClass(target, options.swapClass, true);\n          lastSwapEl = target;\n        } else {\n          lastSwapEl = null;\n        }\n\n        if (prevSwapEl && prevSwapEl !== lastSwapEl) {\n          toggleClass(prevSwapEl, options.swapClass, false);\n        }\n      }\n\n      changed();\n      completed(true);\n      cancel();\n    },\n    drop: function drop(_ref3) {\n      var activeSortable = _ref3.activeSortable,\n          putSortable = _ref3.putSortable,\n          dragEl = _ref3.dragEl;\n      var toSortable = putSortable || this.sortable;\n      var options = this.options;\n      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);\n\n      if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {\n        if (dragEl !== lastSwapEl) {\n          toSortable.captureAnimationState();\n          if (toSortable !== activeSortable) activeSortable.captureAnimationState();\n          swapNodes(dragEl, lastSwapEl);\n          toSortable.animateAll();\n          if (toSortable !== activeSortable) activeSortable.animateAll();\n        }\n      }\n    },\n    nulling: function nulling() {\n      lastSwapEl = null;\n    }\n  };\n  return _extends(Swap, {\n    pluginName: 'swap',\n    eventProperties: function eventProperties() {\n      return {\n        swapItem: lastSwapEl\n      };\n    }\n  });\n}\n\nfunction swapNodes(n1, n2) {\n  var p1 = n1.parentNode,\n      p2 = n2.parentNode,\n      i1,\n      i2;\n  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;\n  i1 = index(n1);\n  i2 = index(n2);\n\n  if (p1.isEqualNode(p2) && i1 < i2) {\n    i2++;\n  }\n\n  p1.insertBefore(n2, p1.children[i1]);\n  p2.insertBefore(n1, p2.children[i2]);\n}\n\nvar multiDragElements = (/* unused pure expression or super */ null && ([])),\n    multiDragClones = (/* unused pure expression or super */ null && ([])),\n    lastMultiDragSelect,\n    // for selection with modifier key down (SHIFT)\nmultiDragSortable,\n    initialFolding = false,\n    // Initial multi-drag fold when drag started\nfolding = false,\n    // Folding any other time\ndragStarted = false,\n    dragEl$1,\n    clonesFromRect,\n    clonesHidden;\n\nfunction MultiDragPlugin() {\n  function MultiDrag(sortable) {\n    // Bind all private methods\n    for (var fn in this) {\n      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n\n    if (!sortable.options.avoidImplicitDeselect) {\n      if (sortable.options.supportPointer) {\n        on(document, 'pointerup', this._deselectMultiDrag);\n      } else {\n        on(document, 'mouseup', this._deselectMultiDrag);\n        on(document, 'touchend', this._deselectMultiDrag);\n      }\n    }\n\n    on(document, 'keydown', this._checkKeyDown);\n    on(document, 'keyup', this._checkKeyUp);\n    this.defaults = {\n      selectedClass: 'sortable-selected',\n      multiDragKey: null,\n      avoidImplicitDeselect: false,\n      setData: function setData(dataTransfer, dragEl) {\n        var data = '';\n\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          multiDragElements.forEach(function (multiDragElement, i) {\n            data += (!i ? '' : ', ') + multiDragElement.textContent;\n          });\n        } else {\n          data = dragEl.textContent;\n        }\n\n        dataTransfer.setData('Text', data);\n      }\n    };\n  }\n\n  MultiDrag.prototype = {\n    multiDragKeyDown: false,\n    isMultiDrag: false,\n    delayStartGlobal: function delayStartGlobal(_ref) {\n      var dragged = _ref.dragEl;\n      dragEl$1 = dragged;\n    },\n    delayEnded: function delayEnded() {\n      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);\n    },\n    setupClone: function setupClone(_ref2) {\n      var sortable = _ref2.sortable,\n          cancel = _ref2.cancel;\n      if (!this.isMultiDrag) return;\n\n      for (var i = 0; i < multiDragElements.length; i++) {\n        multiDragClones.push(clone(multiDragElements[i]));\n        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;\n        multiDragClones[i].draggable = false;\n        multiDragClones[i].style['will-change'] = '';\n        toggleClass(multiDragClones[i], this.options.selectedClass, false);\n        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);\n      }\n\n      sortable._hideClone();\n\n      cancel();\n    },\n    clone: function clone(_ref3) {\n      var sortable = _ref3.sortable,\n          rootEl = _ref3.rootEl,\n          dispatchSortableEvent = _ref3.dispatchSortableEvent,\n          cancel = _ref3.cancel;\n      if (!this.isMultiDrag) return;\n\n      if (!this.options.removeCloneOnHide) {\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          insertMultiDragClones(true, rootEl);\n          dispatchSortableEvent('clone');\n          cancel();\n        }\n      }\n    },\n    showClone: function showClone(_ref4) {\n      var cloneNowShown = _ref4.cloneNowShown,\n          rootEl = _ref4.rootEl,\n          cancel = _ref4.cancel;\n      if (!this.isMultiDrag) return;\n      insertMultiDragClones(false, rootEl);\n      multiDragClones.forEach(function (clone) {\n        css(clone, 'display', '');\n      });\n      cloneNowShown();\n      clonesHidden = false;\n      cancel();\n    },\n    hideClone: function hideClone(_ref5) {\n      var _this = this;\n\n      var sortable = _ref5.sortable,\n          cloneNowHidden = _ref5.cloneNowHidden,\n          cancel = _ref5.cancel;\n      if (!this.isMultiDrag) return;\n      multiDragClones.forEach(function (clone) {\n        css(clone, 'display', 'none');\n\n        if (_this.options.removeCloneOnHide && clone.parentNode) {\n          clone.parentNode.removeChild(clone);\n        }\n      });\n      cloneNowHidden();\n      clonesHidden = true;\n      cancel();\n    },\n    dragStartGlobal: function dragStartGlobal(_ref6) {\n      var sortable = _ref6.sortable;\n\n      if (!this.isMultiDrag && multiDragSortable) {\n        multiDragSortable.multiDrag._deselectMultiDrag();\n      }\n\n      multiDragElements.forEach(function (multiDragElement) {\n        multiDragElement.sortableIndex = index(multiDragElement);\n      }); // Sort multi-drag elements\n\n      multiDragElements = multiDragElements.sort(function (a, b) {\n        return a.sortableIndex - b.sortableIndex;\n      });\n      dragStarted = true;\n    },\n    dragStarted: function dragStarted(_ref7) {\n      var _this2 = this;\n\n      var sortable = _ref7.sortable;\n      if (!this.isMultiDrag) return;\n\n      if (this.options.sort) {\n        // Capture rects,\n        // hide multi drag elements (by positioning them absolute),\n        // set multi drag elements rects to dragRect,\n        // show multi drag elements,\n        // animate to rects,\n        // unset rects & remove from DOM\n        sortable.captureAnimationState();\n\n        if (this.options.animation) {\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            css(multiDragElement, 'position', 'absolute');\n          });\n          var dragRect = getRect(dragEl$1, false, true, true);\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            setRect(multiDragElement, dragRect);\n          });\n          folding = true;\n          initialFolding = true;\n        }\n      }\n\n      sortable.animateAll(function () {\n        folding = false;\n        initialFolding = false;\n\n        if (_this2.options.animation) {\n          multiDragElements.forEach(function (multiDragElement) {\n            unsetRect(multiDragElement);\n          });\n        } // Remove all auxiliary multidrag items from el, if sorting enabled\n\n\n        if (_this2.options.sort) {\n          removeMultiDragElements();\n        }\n      });\n    },\n    dragOver: function dragOver(_ref8) {\n      var target = _ref8.target,\n          completed = _ref8.completed,\n          cancel = _ref8.cancel;\n\n      if (folding && ~multiDragElements.indexOf(target)) {\n        completed(false);\n        cancel();\n      }\n    },\n    revert: function revert(_ref9) {\n      var fromSortable = _ref9.fromSortable,\n          rootEl = _ref9.rootEl,\n          sortable = _ref9.sortable,\n          dragRect = _ref9.dragRect;\n\n      if (multiDragElements.length > 1) {\n        // Setup unfold animation\n        multiDragElements.forEach(function (multiDragElement) {\n          sortable.addAnimationState({\n            target: multiDragElement,\n            rect: folding ? getRect(multiDragElement) : dragRect\n          });\n          unsetRect(multiDragElement);\n          multiDragElement.fromRect = dragRect;\n          fromSortable.removeAnimationState(multiDragElement);\n        });\n        folding = false;\n        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);\n      }\n    },\n    dragOverCompleted: function dragOverCompleted(_ref10) {\n      var sortable = _ref10.sortable,\n          isOwner = _ref10.isOwner,\n          insertion = _ref10.insertion,\n          activeSortable = _ref10.activeSortable,\n          parentEl = _ref10.parentEl,\n          putSortable = _ref10.putSortable;\n      var options = this.options;\n\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        }\n\n        initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location\n\n        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {\n          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible\n          var dragRectAbsolute = getRect(dragEl$1, false, true, true);\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted\n            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable\n\n            parentEl.appendChild(multiDragElement);\n          });\n          folding = true;\n        } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out\n\n\n        if (!isOwner) {\n          // Only remove if not folding (folding will remove them anyways)\n          if (!folding) {\n            removeMultiDragElements();\n          }\n\n          if (multiDragElements.length > 1) {\n            var clonesHiddenBefore = clonesHidden;\n\n            activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden\n\n\n            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {\n              multiDragClones.forEach(function (clone) {\n                activeSortable.addAnimationState({\n                  target: clone,\n                  rect: clonesFromRect\n                });\n                clone.fromRect = clonesFromRect;\n                clone.thisAnimationDuration = null;\n              });\n            }\n          } else {\n            activeSortable._showClone(sortable);\n          }\n        }\n      }\n    },\n    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {\n      var dragRect = _ref11.dragRect,\n          isOwner = _ref11.isOwner,\n          activeSortable = _ref11.activeSortable;\n      multiDragElements.forEach(function (multiDragElement) {\n        multiDragElement.thisAnimationDuration = null;\n      });\n\n      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {\n        clonesFromRect = _extends({}, dragRect);\n        var dragMatrix = matrix(dragEl$1, true);\n        clonesFromRect.top -= dragMatrix.f;\n        clonesFromRect.left -= dragMatrix.e;\n      }\n    },\n    dragOverAnimationComplete: function dragOverAnimationComplete() {\n      if (folding) {\n        folding = false;\n        removeMultiDragElements();\n      }\n    },\n    drop: function drop(_ref12) {\n      var evt = _ref12.originalEvent,\n          rootEl = _ref12.rootEl,\n          parentEl = _ref12.parentEl,\n          sortable = _ref12.sortable,\n          dispatchSortableEvent = _ref12.dispatchSortableEvent,\n          oldIndex = _ref12.oldIndex,\n          putSortable = _ref12.putSortable;\n      var toSortable = putSortable || this.sortable;\n      if (!evt) return;\n      var options = this.options,\n          children = parentEl.children; // Multi-drag selection\n\n      if (!dragStarted) {\n        if (options.multiDragKey && !this.multiDragKeyDown) {\n          this._deselectMultiDrag();\n        }\n\n        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));\n\n        if (!~multiDragElements.indexOf(dragEl$1)) {\n          multiDragElements.push(dragEl$1);\n          dispatchEvent({\n            sortable: sortable,\n            rootEl: rootEl,\n            name: 'select',\n            targetEl: dragEl$1,\n            originalEvent: evt\n          }); // Modifier activated, select from last to dragEl\n\n          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {\n            var lastIndex = index(lastMultiDragSelect),\n                currentIndex = index(dragEl$1);\n\n            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {\n              // Must include lastMultiDragSelect (select it), in case modified selection from no selection\n              // (but previous selection existed)\n              var n, i;\n\n              if (currentIndex > lastIndex) {\n                i = lastIndex;\n                n = currentIndex;\n              } else {\n                i = currentIndex;\n                n = lastIndex + 1;\n              }\n\n              for (; i < n; i++) {\n                if (~multiDragElements.indexOf(children[i])) continue;\n                toggleClass(children[i], options.selectedClass, true);\n                multiDragElements.push(children[i]);\n                dispatchEvent({\n                  sortable: sortable,\n                  rootEl: rootEl,\n                  name: 'select',\n                  targetEl: children[i],\n                  originalEvent: evt\n                });\n              }\n            }\n          } else {\n            lastMultiDragSelect = dragEl$1;\n          }\n\n          multiDragSortable = toSortable;\n        } else {\n          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);\n          lastMultiDragSelect = null;\n          dispatchEvent({\n            sortable: sortable,\n            rootEl: rootEl,\n            name: 'deselect',\n            targetEl: dragEl$1,\n            originalEvent: evt\n          });\n        }\n      } // Multi-drag drop\n\n\n      if (dragStarted && this.isMultiDrag) {\n        folding = false; // Do not \"unfold\" after around dragEl if reverted\n\n        if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {\n          var dragRect = getRect(dragEl$1),\n              multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');\n          if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;\n          toSortable.captureAnimationState();\n\n          if (!initialFolding) {\n            if (options.animation) {\n              dragEl$1.fromRect = dragRect;\n              multiDragElements.forEach(function (multiDragElement) {\n                multiDragElement.thisAnimationDuration = null;\n\n                if (multiDragElement !== dragEl$1) {\n                  var rect = folding ? getRect(multiDragElement) : dragRect;\n                  multiDragElement.fromRect = rect; // Prepare unfold animation\n\n                  toSortable.addAnimationState({\n                    target: multiDragElement,\n                    rect: rect\n                  });\n                }\n              });\n            } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert\n            // properly they must all be removed\n\n\n            removeMultiDragElements();\n            multiDragElements.forEach(function (multiDragElement) {\n              if (children[multiDragIndex]) {\n                parentEl.insertBefore(multiDragElement, children[multiDragIndex]);\n              } else {\n                parentEl.appendChild(multiDragElement);\n              }\n\n              multiDragIndex++;\n            }); // If initial folding is done, the elements may have changed position because they are now\n            // unfolding around dragEl, even though dragEl may not have his index changed, so update event\n            // must be fired here as Sortable will not.\n\n            if (oldIndex === index(dragEl$1)) {\n              var update = false;\n              multiDragElements.forEach(function (multiDragElement) {\n                if (multiDragElement.sortableIndex !== index(multiDragElement)) {\n                  update = true;\n                  return;\n                }\n              });\n\n              if (update) {\n                dispatchSortableEvent('update');\n              }\n            }\n          } // Must be done after capturing individual rects (scroll bar)\n\n\n          multiDragElements.forEach(function (multiDragElement) {\n            unsetRect(multiDragElement);\n          });\n          toSortable.animateAll();\n        }\n\n        multiDragSortable = toSortable;\n      } // Remove clones if necessary\n\n\n      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n        multiDragClones.forEach(function (clone) {\n          clone.parentNode && clone.parentNode.removeChild(clone);\n        });\n      }\n    },\n    nullingGlobal: function nullingGlobal() {\n      this.isMultiDrag = dragStarted = false;\n      multiDragClones.length = 0;\n    },\n    destroyGlobal: function destroyGlobal() {\n      this._deselectMultiDrag();\n\n      off(document, 'pointerup', this._deselectMultiDrag);\n      off(document, 'mouseup', this._deselectMultiDrag);\n      off(document, 'touchend', this._deselectMultiDrag);\n      off(document, 'keydown', this._checkKeyDown);\n      off(document, 'keyup', this._checkKeyUp);\n    },\n    _deselectMultiDrag: function _deselectMultiDrag(evt) {\n      if (typeof dragStarted !== \"undefined\" && dragStarted) return; // Only deselect if selection is in this sortable\n\n      if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable\n\n      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click\n\n      if (evt && evt.button !== 0) return;\n\n      while (multiDragElements.length) {\n        var el = multiDragElements[0];\n        toggleClass(el, this.options.selectedClass, false);\n        multiDragElements.shift();\n        dispatchEvent({\n          sortable: this.sortable,\n          rootEl: this.sortable.el,\n          name: 'deselect',\n          targetEl: el,\n          originalEvent: evt\n        });\n      }\n    },\n    _checkKeyDown: function _checkKeyDown(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = true;\n      }\n    },\n    _checkKeyUp: function _checkKeyUp(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = false;\n      }\n    }\n  };\n  return _extends(MultiDrag, {\n    // Static methods & properties\n    pluginName: 'multiDrag',\n    utils: {\n      /**\r\n       * Selects the provided multi-drag item\r\n       * @param  {HTMLElement} el    The element to be selected\r\n       */\n      select: function select(el) {\n        var sortable = el.parentNode[expando];\n        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;\n\n        if (multiDragSortable && multiDragSortable !== sortable) {\n          multiDragSortable.multiDrag._deselectMultiDrag();\n\n          multiDragSortable = sortable;\n        }\n\n        toggleClass(el, sortable.options.selectedClass, true);\n        multiDragElements.push(el);\n      },\n\n      /**\r\n       * Deselects the provided multi-drag item\r\n       * @param  {HTMLElement} el    The element to be deselected\r\n       */\n      deselect: function deselect(el) {\n        var sortable = el.parentNode[expando],\n            index = multiDragElements.indexOf(el);\n        if (!sortable || !sortable.options.multiDrag || !~index) return;\n        toggleClass(el, sortable.options.selectedClass, false);\n        multiDragElements.splice(index, 1);\n      }\n    },\n    eventProperties: function eventProperties() {\n      var _this3 = this;\n\n      var oldIndicies = [],\n          newIndicies = [];\n      multiDragElements.forEach(function (multiDragElement) {\n        oldIndicies.push({\n          multiDragElement: multiDragElement,\n          index: multiDragElement.sortableIndex\n        }); // multiDragElements will already be sorted if folding\n\n        var newIndex;\n\n        if (folding && multiDragElement !== dragEl$1) {\n          newIndex = -1;\n        } else if (folding) {\n          newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');\n        } else {\n          newIndex = index(multiDragElement);\n        }\n\n        newIndicies.push({\n          multiDragElement: multiDragElement,\n          index: newIndex\n        });\n      });\n      return {\n        items: _toConsumableArray(multiDragElements),\n        clones: [].concat(multiDragClones),\n        oldIndicies: oldIndicies,\n        newIndicies: newIndicies\n      };\n    },\n    optionListeners: {\n      multiDragKey: function multiDragKey(key) {\n        key = key.toLowerCase();\n\n        if (key === 'ctrl') {\n          key = 'Control';\n        } else if (key.length > 1) {\n          key = key.charAt(0).toUpperCase() + key.substr(1);\n        }\n\n        return key;\n      }\n    }\n  });\n}\n\nfunction insertMultiDragElements(clonesInserted, rootEl) {\n  multiDragElements.forEach(function (multiDragElement, i) {\n    var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];\n\n    if (target) {\n      rootEl.insertBefore(multiDragElement, target);\n    } else {\n      rootEl.appendChild(multiDragElement);\n    }\n  });\n}\n/**\r\n * Insert multi-drag clones\r\n * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted\r\n * @param  {HTMLElement} rootEl\r\n */\n\n\nfunction insertMultiDragClones(elementsInserted, rootEl) {\n  multiDragClones.forEach(function (clone, i) {\n    var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];\n\n    if (target) {\n      rootEl.insertBefore(clone, target);\n    } else {\n      rootEl.appendChild(clone);\n    }\n  });\n}\n\nfunction removeMultiDragElements() {\n  multiDragElements.forEach(function (multiDragElement) {\n    if (multiDragElement === dragEl$1) return;\n    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);\n  });\n}\n\nSortable.mount(new AutoScrollPlugin());\nSortable.mount(Remove, Revert);\n\n/* harmony default export */ const sortable_esm = (Sortable);\n\n\n;// CONCATENATED MODULE: ./public/src/components/sortable.js\n\n\nfunction sortable(containerSelector, elSelector, model) {\n  let container = common_$(containerSelector)[0];\n\n  if (container) {\n    let sortable = sortable_esm.create(container, {\n      animation: 150,\n      onEnd: function (evt) {\n        let oldI = evt.oldIndex;\n        let newI = evt.newIndex;\n\n        if (oldI > newI) {\n          sort(oldI);\n        } else {\n          sort(newI);\n        }\n\n        async function sort(upToQestionNumber) {\n          let els = common_$(elSelector);\n          let questionsEls = [].map.call(els, function (el, i) {\n            if (i - 1 < upToQestionNumber) return el;\n          });\n          let toChange = questionsEls.map(el => {\n            return el.id;\n          });\n          let res = await post(`/adminsc/${model}/sort`, {\n            toChange\n          });\n          questionsEls.map((el, i) => {\n            common_$(el).find('.sort').innerText = i + 1;\n          });\n        }\n      }\n    });\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Test/model/opentest/opentest.js\n\nclass _test {\n  constructor() {\n    this.model = 'opentest';\n  }\n\n  async create() {\n    let test = _test.serverModel();\n\n    test.id = 0;\n    test.isTest = 1;\n    debugger;\n    let url = `/${this.model}/updateOrCreate`;\n    let res = await post(url, test);\n\n    if (res) {\n      window.location.href = `/adminsc/${model}/edit/${res.id}`;\n    }\n  }\n\n  currentQ() {\n    return {\n      id: common_$('.nav-active')[0].innerText - 1,\n      QEl: common_$('.question.flex1')[0],\n      navLength: common_$('[data-pagination]').length,\n      QPrevc: common_$('.question.flex1')[0].previousElementSibling,\n      QNextEl: common_$('.question.flex1')[0].nextElementSibling\n    };\n  }\n\n  viewModel() {\n    return {\n      id: +window.location.href.split('/').pop(),\n      test_name: common_$('#test_name').text(),\n      enable: common_$('#enable')[0],\n      parent: common_$('select').selectedIndexValue()\n    };\n  }\n\n  id() {\n    return id ?? common_$('.test-name')[0].dataset.testid;\n  }\n\n  children() {\n    let childrenLenght = common_$('.children').length;\n    if (childrenLenght) return childrenLenght;\n    return false;\n  }\n\n  async path_create() {\n    let test_path = _test.serverModel();\n\n    test_path.id = 0;\n    test_path.isTest = 0;\n    let url = `/adminsc/${model}/create`;\n    let res = await post(url, test_path);\n\n    if (res) {\n      window.location.href = `/adminsc/${model}/edit/${res.id - 1}`;\n    }\n  }\n\n  name() {\n    return common_$('.test-name')[0].innerText;\n  }\n\n  selectedValueCustomSelect(className) {\n    let select = common_$(`[data-field=${className}]`)[0];\n    let selected = [...select.options].filter(opt => opt.selected);\n\n    if (selected) {\n      return +selected[0].value;\n    }\n  }\n\n  serverModel() {\n    let model = {\n      id: +window.location.href.split('/').pop(),\n      test_name: common_$('#test_name')[0].value,\n      isTest: +common_$('[isTest]')[0].getAttribute('isTest')\n    };\n    let fields = common_$('.custom-select');\n    [].forEach.call(fields, function (field) {\n      model[field.dataset['field']] = field.dataset['id'];\n    });\n    return model;\n  }\n\n  async update() {\n    let model = _test.serverModel();\n\n    let url = `/adminsc/${model}/update/${model.id}`;\n    let res = await post(url, model);\n\n    if (res) {\n      window.location.href = `/adminsc/${model}/edit/${model.id}`;\n    }\n  }\n\n  async del() {\n    if (_test.children()) {\n      popup.show('Сначала удалите все тесты из папки');\n      return false;\n    }\n\n    let id = _test.id();\n\n    let res = await post('/adminsc/${model}/delete', {\n      id\n    });\n\n    if (res.notAdmin) {\n      popup.show('Видимость теста скрыта. Чтобы удалить полностью - обратитесь к ГД');\n      setTimeout(() => {\n        window.location = `/adminsc/${model}/edit/400`;\n      }, 4000);\n    } else {\n      window.location = `/adminsc/${model}/edit/400`;\n    }\n  }\n\n}\n;// CONCATENATED MODULE: ./public/src/Test/model/opentest/openanswer.js\n\nlet _answer = {\n  async create(button) {\n    let question = button.closest('.question-edit');\n    let openquestion_id = question.id;\n    let sort = question.querySelectorAll('.answer').length + 1;\n    let res = await post('/openanswer/updateOrCreate', {\n      openquestion_id,\n      sort\n    });\n    let id = res.arr.id;\n\n    if (id) {\n      let html = res.html;\n      button.insertAdjacentHTML(\"beforebegin\", html);\n    } else {\n      popup.show('Сохранено');\n    }\n  },\n\n  async del(target) {\n    let del_button = target.closest('.delete');\n    if (!del_button) return false;\n\n    if (confirm(\"Удалить этот ответ?\")) {\n      let answer = del_button.closest('.answer');\n      let id = +answer.dataset['answerId'];\n      let res = await post('/openanswer/delete', {\n        id\n      });\n\n      if (res.msg === 'ok') {\n        answer.remove();\n        popup.show('Ответ удален');\n      }\n    }\n  }\n\n};\n;// CONCATENATED MODULE: ./public/src/Test/opentest-edit.js\n\n\n\n\n\n\n\n\n\n\n\nlet opentestEdit = common_$('.opentest-edit-wrapper')[0];\n\nif (opentestEdit) {\n  sortable('.opentest-edit-wrapper .questions', '.opentest-edit-wrapper .question-edit', 'openquestion');\n  common_$(opentestEdit).on('change', handleChange);\n  common_$(opentestEdit).on('click', _ref => {\n    let {\n      target\n    } = _ref;\n    const test = new _test();\n\n    if (target.classList.contains('test-path__update')) {\n      test.update();\n    } else if (target.classList.contains('test__update')) {\n      test.update();\n    } else if (target.classList.contains('test__save')) {\n      test.update();\n    } else if (target.classList.contains('test__delete')) {\n      test.delete();\n    } else if (target.classList.contains('test-path__create')) {\n      test.path_create();\n    } else if (target.classList.contains('test__create')) {\n      test.create();\n    } else if (!!target.closest('.question__show-answers')) {\n      _openquestion.showAnswers(target);\n    } else if (!!target.closest('.question__delete')) {\n      _openquestion.del(target);\n    } else if (target.classList.contains('question__create-button')) {\n      _openquestion.create(target);\n    } else if (!!target.closest('.delete')) {\n      _answer.del(target);\n    } else if (target.classList.contains('answer__create-button')) {\n      _answer.create(target);\n    } else if (!!target.closest('.question-edit__parent-select')) {\n      _openquestion.changeParent(target);\n    } else if (target.classList.contains('led')) {\n      target.classList.toggle('animated');\n    }\n  });\n\n  let handleKeyup = async function (_ref2) {\n    let {\n      target\n    } = _ref2;\n\n    if (target.classList.contains('text')) {\n      let answer = target.closest('.answer');\n\n      if (answer) {\n        saveAnswer(answer);\n      } else {\n        let id = target.closest('.question-edit').id;\n        let question = target.innerText;\n        let res = await post('/adminsc/openquestion/updateOrCreate', {\n          id,\n          question\n        });\n      }\n    }\n  };\n\n  let debouncedInput = debounce(handleKeyup);\n  common_$(opentestEdit).on('keyup', debouncedInput);\n}\n\nasync function saveAnswer(answerEl) {\n  let id = answerEl.dataset.answerId;\n  let is_correct = +answerEl.querySelector('input').checked;\n  let openquestion_id = answerEl.closest('.question-edit').id;\n  let answer = answerEl.querySelector('.text').innerText;\n  let res = await post('/adminsc/openanswer/updateOrCreate', {\n    id,\n    answer,\n    openquestion_id,\n    is_correct\n  });\n}\n\nasync function handleChange(_ref3) {\n  let {\n    target\n  } = _ref3;\n  let answer = target.closest('.answer');\n\n  if (answer) {\n    saveAnswer(answer);\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Test/model/answer.js\n\n\nclass answer {\n  constructor() {}\n\n  async saveAnswer(target) {\n    let q_id = target.closest('.question-edit').dataset.id;\n    let el = target.closest('.answer');\n    let answer = this.getAnswerModel(el, q_id);\n    let res = await post('/adminsc/answer/updateOrCreate', answer);\n  }\n\n  async del(target) {\n    let el = target.closest('.answer');\n    let id = +target.dataset.id;\n\n    if (confirm('Удалить?')) {\n      let res = await post(`/adminsc/answer/delete`, {\n        id\n      });\n\n      if (res) {\n        el.remove();\n      }\n    }\n  }\n\n  async answerCreate(target) {\n    let answer = common_$('.answer__create .answer')[0];\n    let question = target.closest('.question-edit');\n    let q_id = +question.id;\n    let clone = answer.cloneNode(true);\n    let answerModel = this.getAnswerModel(clone, q_id);\n    let res = await post(`/adminsc/answer/updateOrCreate`, answerModel);\n\n    if (res) {\n      if (res.arr.popup) popup.show(res.arr.popup);\n\n      if (res.arr.id) {\n        let sort = question.querySelectorAll('.answer').length + 1;\n        clone.querySelector('.sort').innerText = sort;\n        clone.querySelector('.delete').dataset.id = clone.dataset.id = res.arr.id;\n        target.before(clone);\n      }\n    }\n  }\n\n  getAnswerModel(el, q_id) {\n    return {\n      id: +el.dataset.id,\n      answer: trimStr(common_$(el).find('.text').innerText),\n      question_id: q_id,\n      correct_answer: +common_$(el).find('input').checked,\n      pica: ''\n    };\n  }\n\n}\n\nlet answer_answer = new answer();\n;// CONCATENATED MODULE: ./public/src/Test/model/question.js\n\n\n\nclass question {\n  constructor(el) {\n    this.sort = document.querySelectorAll('.questions>.question-edit').length + 1 ?? 0;\n  }\n\n  async questionCreate(target) {\n    let question = common_$('.question__create .question-edit')[0];\n    let clone = question.cloneNode(true);\n    let questionModel = this.getQuestionModel(clone);\n    let res = await post(`/adminsc/question/updateOrCreate`, questionModel);\n\n    if (res) {\n      clone.querySelector('.sort').innerText = this.sort;\n      clone.querySelector('.question__delete').dataset.id = clone.dataset.id = res.arr.id;\n      target.before(clone);\n    }\n  }\n\n  getQuestionModel(el) {\n    return {\n      id: el.dataset.id,\n      qustion: trimStr(el.querySelector('.text').innerText),\n      parent: +window.location.href.split('/').pop(),\n      sort: el.querySelector('.sort').innerText\n    };\n  }\n\n  async changeParent(target) {\n    debugger;\n    let opt = target.options[target.selectedIndex];\n    let id = target.closest('.question-edit').id;\n    let test_id = opt.dataset['questionParentId'];\n    let test_name = opt.value;\n    let res = await post('/adminsc/question/changeParent', {\n      id,\n      test_id\n    });\n    let question = target.closest('.question-edit');\n    question.remove();\n  }\n\n  showAnswers(target) {\n    let row = target.closest('.question-edit');\n    let answers = common_$(row).find('.question__answers');\n    answers.classList.toggle('height');\n    answers.classList.toggle('scale');\n    target.classList.toggle('rotate');\n  }\n\n  async del(target) {\n    let model = target.dataset.model;\n    let el = null;\n\n    if (model === 'answer') {\n      el = target.closest('.answer');\n    } else if (model === 'question') {\n      el = target.closest('.question-edit');\n    }\n\n    let id = +target.dataset.id;\n\n    if (confirm('Удалить?')) {\n      let res = await post(`/adminsc/${model}/delete`, {\n        id\n      });\n\n      if (res) {\n        el.remove();\n      }\n    }\n  }\n\n  async saveQuestion(target) {\n    let el = target.closest('.question-edit');\n\n    let question = _question.getQuestionModel(el);\n\n    let res = await post('/adminsc/question/UpdateOrCreate', question);\n  } // getAnswers(question) {\n  //   let answers = question.querySelectorAll('.answer')\n  //   return [...answers].map((a) => {\n  //     return {\n  //       id: +a.dataset['answerId'],\n  //       answer: a.querySelector('.text').innerText,\n  //       correct_answer: +a.querySelector('[type=\"checkbox\"]').checked,\n  //       question_id: +question.id,\n  //       pica: '',\n  //     }\n  //   }, question)\n  // }\n\n\n}\n\nlet _question = new question();\n;// CONCATENATED MODULE: ./public/src/Test/model/test.js\n\nconst test_test = {\n  viewModel: () => {\n    return {\n      id: +window.location.href.split('/').pop(),\n      name: common_$('#test_name').text(),\n      enable: common_$('#enable')[0],\n      parent: common_$('select').selectedIndexValue()\n    };\n  },\n  children: () => {\n    let childrenLenght = common_$('.children').length;\n    if (childrenLenght) return childrenLenght;\n    return false;\n  },\n  path_create: async () => {\n    let test_path = test_test.serverModel();\n\n    test_path.id = 0;\n    test_path.isTest = 0;\n    let url = `/adminsc/test/updateOrCreate`;\n    let res = await post(url, test_path);\n\n    if (res) {\n      window.location.href = `/adminsc/test/edit/${res.arr.id}`;\n    }\n  },\n  id: id => {\n    return id ?? common_$('.test-name')[0].dataset.testid;\n  },\n  name: () => {\n    return common_$('.test-name')[0].innerText;\n  },\n  create: async () => {\n    let test = test_test.serverModel();\n\n    test.id = 0;\n    test.isTest = 1;\n    let url = `/test/updateOrCreate`;\n    let res = await post(url, test);\n    debugger;\n\n    if (res) {\n      window.location.href = `/adminsc/test/edit/${res.arr.id}`;\n    }\n  },\n  serverModel: () => {\n    let id = !!+window.location.href.split('/').pop();\n    id = id ? id : 0;\n    let model = {\n      id,\n      name: common_$('#name.field')[0].value,\n      isTest: +common_$('[isTest]')[0].getAttribute('isTest')\n    }; // debugger\n\n    let fields = common_$('[custom-select]');\n    [].forEach.call(fields, function (field) {\n      model[field.dataset['field']] = field.dataset['id'];\n    });\n    return model;\n  },\n  update: async () => {\n    let model = test_test.serverModel();\n\n    let url = `/adminsc/test/update/${model.id}`;\n    let res = await post(url, model);\n\n    if (res) {\n      window.location.href = `/adminsc/test/edit/${model.id}`;\n    }\n  },\n  delete: async function () {\n    if (test_test.children()) {\n      popup.show('Сначала удалите все тесты из папки');\n      return false;\n    }\n\n    let id = test_test.id();\n\n    let res = await post('/adminsc/test/delete', {\n      id\n    });\n\n    if (res.notAdmin) {\n      popup.show('Видимость теста скрыта. Чтобы удалить полностью - обратитесь к ГД');\n      setTimeout(() => {\n        window.location = '/adminsc/test/edit/400';\n      }, 4000);\n    } else {\n      window.location = '/adminsc/test/edit/400';\n    }\n  } // selectedValueCustomSelect(className) {\n  //   let select = $(`[data-field=${className}]`)[0]\n  //   let selected = [...select.options].filter((opt) => opt.selected)\n  //   if (selected) {\n  //     return +selected[0].value\n  //   }\n  // },\n\n};\n;// CONCATENATED MODULE: ./public/src/Test/test-edit.js\n\n\n\n\n\n\n\n\n\n\nfunction testEdit() {\n  let testEdit = common_$('.test-edit-wrapper')[0];\n\n  if (testEdit) {\n    sortable('.test-edit-wrapper .questions', '.questions>.question-edit', 'question'); // customSelect()\n\n    common_$(testEdit).on('keyup', debouncedHandleKeyup);\n    common_$(testEdit).on('change', test_edit_handleChange);\n    common_$(testEdit).on('click', test_edit_handleClick);\n  }\n}\n\nfunction test_edit_handleClick(_ref) {\n  let {\n    target\n  } = _ref;\n\n  if (target.classList.contains('test-path__update')) {\n    test_test.update();\n  } else if (target.classList.contains('test__update')) {\n    test_test.update();\n  } else if (target.classList.contains('test__save')) {\n    test_test.update();\n  } else if (target.classList.contains('test__delete')) {\n    test_test[\"delete\"]();\n  } else if (target.classList.contains('test-path__create')) {\n    test_test.path_create();\n  } else if (target.classList.contains('test__create')) {\n    test_test.create();\n  } else if (!!target.closest('.question__show-answers')) {\n    _question.showAnswers(target);\n  } else if (target.classList.contains('question__create-button')) {\n    _question.questionCreate(target);\n  } else if (!!target.closest('.question__delete')) {\n    _question.del(target);\n  } else if (!!target.closest('.delete')) {\n    answer_answer.del(target);\n  } else if (target.classList.contains('answer__create-button')) {\n    answer_answer.answerCreate(target);\n  } else if (target.classList.contains('correct')) {\n    answer_answer.saveAnswer(target);\n  }\n}\n\nlet debouncedHandleKeyup = debounce(handleKeyup);\n\nasync function handleKeyup(_ref2) {\n  let {\n    target\n  } = _ref2;\n\n  if (target.classList.contains('text')) {\n    let answer = target.closest('.answer');\n\n    if (answer) {\n      answer_answer.saveAnswer(target);\n    } else {\n      _question.saveQuestion(target);\n    }\n  }\n}\n\nasync function test_edit_handleChange(_ref3) {\n  let {\n    target\n  } = _ref3;\n\n  if (!!target.closest('.question-edit__parent-select')) {\n    _question.changeParent(target);\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Test/test-pagination/test-pagination.js\n\n\nlet pagination = common_$('.pagination')[0];\n\nif (pagination) {\n  navInit();\n  common_$(pagination).on('click', test_pagination_handleClick);\n}\n\nfunction test_pagination_handleClick(_ref) {\n  let {\n    target\n  } = _ref;\n  if (!target.dataset.pagination) return;\n  if (target.classList.contains('active')) return;\n  let active_btn = common_$('.pagination .active')[0];\n  active_btn.classList.remove('active');\n  target.classList.add('active');\n  let id_to_hide = active_btn.dataset['pagination'];\n  common_$(`.question[data-id=\"${id_to_hide}\"]`).removeClass('show');\n  let id_to_show = target.dataset['pagination'];\n  common_$(`.question[data-id=\"${id_to_show}\"]`).addClass('show');\n}\n\nfunction navInit() {\n  let nav_buttons = common_$('[data-pagination]');\n  if (!nav_buttons[0]) return false;\n  Array.from(nav_buttons).map(nav => {\n    nav.classList.remove('active');\n  });\n  nav_buttons[0].classList.add('active');\n} // export {navInit}\n;// CONCATENATED MODULE: ./public/src/Test/do.js\n\n\n\nlet testDo = common_$('.test-do');\n\nif (testDo) {\n  showFirstQuest();\n  finishBtnInit();\n  common_$('.test-do').on('click', do_handleClick);\n}\n\nfunction finishBtnInit() {\n  let button = common_$('.test-do__finish-btn')[0];\n\n  if (button) {\n    if (window.location.pathname.match('^/test/result/.?')) {\n      button.classList.add('inactive');\n    }\n  }\n}\n\nfunction do_handleClick(_ref) {\n  let {\n    target\n  } = _ref;\n  if (target.classList.contains('accordion-open')) return;\n  let currQuest = common_$('.question.show')[0] ?? '';\n  let id = +currQuest?.dataset.id ?? '';\n  let navs = common_$('[data-pagination]') ?? '';\n  let navIndex = navs.findIndex(el => el.classList.contains('active')) ?? '';\n\n  if (target.type === \"checkbox\") {\n    let a = target.labels[0];\n    a.classList.toggle('pushed');\n  } else if (target.id === 'prev') {\n    prevQ();\n  } else if (target.id === 'next') {\n    nextQ();\n  }\n\n  function prevQ() {\n    if (navIndex < 1) return false;\n    let aimId = +navs[navIndex - 1].dataset.pagination;\n    pushNav(id, aimId);\n    pushQ(aimId);\n  }\n\n  function nextQ() {\n    if (navIndex === navs.length - 1) return false;\n    let aimId = +navs[navIndex + 1].dataset.pagination;\n    pushNav(id, aimId);\n    pushQ(aimId);\n  }\n\n  function pushNav(currentId, aimNavId) {\n    let currNavEl = common_$(`[data-pagination=\"${currentId}\"]`)[0];\n    currNavEl.classList.toggle('active');\n    let NavEl = common_$(`[data-pagination=\"${aimNavId}\"]`)[0];\n    NavEl.classList.toggle('active');\n  }\n\n  function pushQ(aimId) {\n    currQuest.classList.toggle('show');\n    let aimQuestion = common_$(`.question[data-id=\"${aimId}\"]`)[0];\n    aimQuestion.classList.toggle('show');\n  }\n}\n\nfunction showFirstQuest() {\n  common_$('.question').removeClass(\"show\");\n  common_$('.question:first-child').addClass(\"show\");\n}\n\ncommon_$('.test-do__finish-btn').on('click', async function (e) {\n  let button = e.target;\n  if (button.id !== 'btnn') return false;\n\n  if (button.text === \"ПРОЙТИ ТЕСТ ЗАНОВО\") {\n    location.reload();\n    return;\n  }\n\n  button.text = \"ПРОЙТИ ТЕСТ ЗАНОВО\";\n  button.classList.add('inactive');\n  let corrAnswers = await post('/test/getCorrectAnswers', {});\n  corrAnswers = corrAnswers['arr'];\n  let errorCnt = colorView(corrAnswers);\n  let data = objToServer(errorCnt);\n  let res = await post('/adminsc/testresult/create', data);\n\n  if (res) {\n    common_$(\"#btnn\")[0].href = location.href;\n    common_$(\"#btnn\")[0].text = \"ПРОЙТИ ТЕСТ ЗАНОВО\";\n  }\n});\n\nfunction objToServer(errorCnt) {\n  return {\n    questionCnt: common_$('.question').length,\n    errorCnt: errorCnt,\n    html: cachePage('.test-do'),\n    testid: common_$('[data-test-id]')[0].dataset.testId,\n    testname: common_$('.test-name')[0].innerText,\n    user: common_$('.user-menu .fio')[0].innerText\n  };\n}\n\nfunction colorView(correctAnswers) {\n  let q = common_$('.question');\n  [].map.call(q, function (question) {\n    let answers = question.querySelectorAll('.a');\n    let errors = [];\n    [].map.call(answers, function (answer) {\n      let input = common_$(answer).find('input');\n      let id = answer.dataset.id;\n      checkCorrectAnswers(errors, id, correctAnswers, input, answer);\n    });\n    let id = question.dataset['id']; // id question\n\n    let paginItem = common_$(`.pagination [data-pagination='${+id}']`)[0];\n\n    if (errors.length) {\n      common_$(paginItem).addClass('redShadow');\n    } else {\n      common_$(paginItem).addClass('greenShadow');\n    }\n  });\n  return common_$('.redShadow').length;\n}\n\nfunction checkCorrectAnswers(errors, id, correctAnswers, input, answer) {\n  let correctAnser = correctAnswers.indexOf(id) !== -1;\n  let checked = input.checked;\n\n  if (checked && correctAnser) {\n    // checkbox нажат. а в correct answer нету. в correct_answers есть, его всегда подсвечиваем зеленым\n    answer.classList.add('done'); //green check зеленый значек\n  } else if (checked && !correctAnser) {\n    // checkbox нажат,и есть в correct answer. в correct_answers нет, кнопка не нажата\n    errors.push(true);\n  } else if (!checked && correctAnser) {\n    // кнопка не нажата, в correct_answers есть\n    answer.classList.add('done'); //green check зеленый значек\n\n    errors.push(true);\n  } else if (!checked && !correctAnser) {// кнопка не нажата, в correct_answers нет\n  }\n}\n;// CONCATENATED MODULE: ./public/src/components/list/list.js\n\n\nfunction list() {\n  const tables = common_$('.custom-list__wrapper');\n\n  if (tables) {\n    [].forEach.call(tables, function (table) {\n      const contenteditable = common_$('[contenteditable]');\n      const headers = table.querySelectorAll('.head');\n      const sortables = table.querySelectorAll('[data-sort]');\n      const inputs = common_$(table).findAll('.head input');\n      const ids = common_$(table)[0].querySelectorAll('.id:not(.head');\n      const modelName = table.dataset['model'];\n      const rows = [];\n      common_$(table).on('click', handleClick.bind(this));\n      common_$(table).on('keyup', handleKeyUp.bind(this));\n      let debouncedInput = debounce(handleInput);\n\n      function handleKeyUp(_ref) {\n        let {\n          target\n        } = _ref;\n\n        // contenteditable\n        if (target.hasAttribute('contenteditable')) {\n          debouncedInput(table, contenteditable, target); /// search\n        } else if (target.closest('.head')) {\n          let header = target.closest('.head');\n          let index = [].findIndex.call(headers, (el, i, inputs) => {\n            return el === header;\n          });\n          search(index, target);\n        }\n      }\n\n      function handleClick(_ref2) {\n        let {\n          target\n        } = _ref2;\n\n        /// create\n        if (target.className === 'add-model') {\n          modelCreate(modelName); /// delete\n        } else if (target.className === '.del:not(.head)' || target.closest('.del:not(.head)')) {\n          modelDel(target.closest('.del:not(.head)')); /// edit\n        } else if (target.className === '.edit:not(.head)' || target.closest('.edit:not(.head)')) {\n          let id = target.closest('.edit:not(.head)').dataset['id'];\n          window.location = `/adminsc/${modelName}/edit/${id}`; /// sort\n        } else if (target.classList.contains('head')) {\n          let header = target.closest('.head');\n          let index = [].findIndex.call(headers, (el, i, inputs) => {\n            return el === header;\n          });\n          sortColumn(index);\n        }\n      } // DELETE\n\n\n      async function modelDel(el) {\n        if (!confirm('Удалить?')) return;\n        let id = el.dataset['id'];\n        let res = await post(`/adminsc/${modelName}/delete`, {\n          id\n        });\n\n        if (res) {\n          delView(id);\n        }\n      }\n\n      function delView(id) {\n        let arr = common_$(`[data-id='${id}']`);\n        [].forEach.call(arr, function (el) {\n          el.remove();\n        });\n      } // CREATE\n\n\n      async function modelCreate(modelName, e) {\n        let res = await post(`/adminsc/${modelName}/create`, {});\n\n        if (res.arr.id) {\n          newRow(res.arr.id); // window.location.href = `/adminsc/${modelName}/show`\n        }\n      }\n\n      function newRow(id) {\n        let Row = [...rows[0]];\n        [].forEach.call(Row, function (el) {\n          let newEl = el.cloneNode(true);\n          let tableContent = common_$(table).find('.custom-list');\n          tableContent.appendChild(newEl);\n\n          if (['id'].includes(newEl.className)) {\n            newEl.innerText = id;\n          } else if (!['del', 'edit', 'save'].includes(newEl.className)) {\n            newEl.innerText = '';\n          }\n\n          newEl.dataset['id'] = id;\n        });\n      } /// SEARCH\n\n\n      function showAllRows() {\n        [].forEach.call(rows, row => {\n          [].forEach.call(row, el => {\n            el.style.display = 'flex';\n          });\n        });\n      }\n\n      function search(index, input) {\n        showAllRows();\n        const value = input.value;\n        [].forEach.call(inputs, inp => {\n          if (inp !== input) inp.value = '';\n        });\n        [].forEach.call(rows, function (row) {\n          const str = row[index].innerText;\n          const regexp = new RegExp(`${value}`, 'gi');\n\n          if (!str.match(regexp)) {\n            [].forEach.call(row, el => {\n              el.style.display = 'none';\n            });\n          }\n        });\n      }\n\n      ; // SORT\n\n      function sortColumn(index) {\n        // Получить текущее направление\n        const direction = directions[index] || 'asc'; // Фактор по направлению\n\n        const multiplier = direction === 'asc' ? 1 : -1;\n        const newRows = Array.from(rows);\n        newRows.sort(function (rowA, rowB) {\n          const cellA = rowA[index].innerHTML;\n          const cellB = rowB[index].innerHTML;\n          const a = transform(index, cellA);\n          const b = transform(index, cellB);\n\n          switch (true) {\n            case a > b:\n              return 1 * multiplier;\n\n            case a < b:\n              return -1 * multiplier;\n\n            case a === b:\n              return 0;\n          }\n        }); // Удалить старые строки\n\n        [].forEach.call(rows, function (nodeList) {\n          [].forEach.call(nodeList, el => {\n            el.remove();\n          });\n        }); // Поменять направление\n\n        directions[index] = direction === 'asc' ? 'desc' : 'asc'; // Добавить новую строку\n\n        newRows.forEach(function (newRow) {\n          newRow = Array.from(newRow);\n          newRow.reverse();\n          [].forEach.call(newRow, el => {\n            headers[headers.length - 1].after(el);\n          });\n        });\n      }\n\n      ; /// get table rows array\n\n      for (let i = 0; i < ids.length; i++) {\n        let id = ids[i].dataset.id;\n        let row = common_$(table)[0].querySelectorAll(`[data-id='${id}']`);\n        rows.push(row);\n      } // Направление сортировки\n\n\n      const directions = Array.from(sortables).map(function (sortable) {\n        return '';\n      }); // Преобразовать содержимое данной ячейки в заданном столбце\n\n      function transform(index, content) {\n        // Получить тип данных столбца\n        const type = sortables[index].getAttribute('data-type');\n\n        switch (type) {\n          case 'number':\n            return parseFloat(content);\n\n          case 'string':\n          default:\n            return content;\n        }\n      }\n\n      ; /// INPUT\n\n      function handleInput(table, contenteditable, target) {\n        if (!target.hasAttribute('contenteditable')) return false;\n        let model = makeServerModel(target, modelName);\n        save(model);\n      }\n\n      async function save(model) {\n        let url = `/adminsc/${model.modelName}/updateOrCreate`;\n        let res = await post(url, model.model);\n      }\n\n      function makeServerModel(target, modelName) {\n        let field = target.dataset['field'];\n        return {\n          model: {\n            id: target.dataset.id,\n            [field]: target.innerText\n          },\n          modelName\n        };\n      }\n    });\n  } // })\n\n}\n;// CONCATENATED MODULE: ./public/src/Admin/Rights/rights.js\n\n\n // import contenteditable from '../../components/contenteditable'\n\nfunction rights() {\n  // debugger\n  // contenteditable()\n  common_$('.rights-table').on('click', handle);\n\n  function handle(_ref) {\n    let {\n      target\n    } = _ref;\n    if (target.closest('.del')) del(target.closest('.del'));\n    if (target.closest('.save')) save(target.closest('.save'));\n\n    function model(el) {\n      let dataId = el.dataset.id ?? 'new';\n      let fields = common_$(`[data-id='${dataId}']`);\n      let model = {};\n      model.toServ = {};\n      model.empty = {};\n      fields.map(f => {\n        if (f.classList.contains('id')) {\n          model.id = f;\n          model.toServ.id = f.dataset.id;\n        } else if (f.classList.contains('name')) {\n          model.name = f;\n          model.toServ.name = f.innerText.trim();\n        } else if (f.classList.contains('description')) {\n          model.description = f;\n          model.toServ.description = f.innerText.trim();\n        } else if (f.classList.contains('save.svg')) {\n          model.save = f;\n        } else if (f.classList.contains('del')) {\n          model.del = f;\n        }\n      });\n      model.empty.del = model.id.previousElementSibling.cloneNode(true);\n      model.empty.save = model.id.previousElementSibling.previousElementSibling.cloneNode(true);\n      model.empty.description = model.id.previousElementSibling.previousElementSibling.previousElementSibling.cloneNode(true);\n      model.empty.name = model.id.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.cloneNode(true);\n      model.empty.id = model.id.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.cloneNode(true);\n      return model;\n    }\n\n    function del(el) {\n      let mod = model(el);\n      if (mod.toServ.id === 'new') return;\n\n      if (confirm(\"Удалить право?\")) {\n        delDom(mod);\n        delServer(mod);\n      }\n    }\n\n    async function delServer(model) {\n      let res = await post('/right/delete', {\n        id: model.toServ.id\n      });\n    }\n\n    function delDom(model) {\n      model.id.remove();\n      model.name.remove();\n      model.description.remove();\n      model.save.remove();\n      model.del.remove();\n    }\n\n    function save(el) {\n      let mod = model(el);\n\n      if (mod.toServ.id !== 'new') {\n        update(mod.toServ);\n      } else {\n        if (!mod.toServ.name || !mod.toServ.description) return false;\n        create(mod);\n      }\n    }\n\n    async function update(toServ) {\n      let res = await post('/right/update', toServ);\n    }\n\n    function clearModel(model) {\n      model.name.innerText = \"\";\n      model.description.innerText = \"\";\n    }\n\n    function createOnDom(model) {\n      let lastElement = common_$(\".id[data-id='new']\")[0];\n      lastElement.before(model.empty.id);\n      lastElement.before(model.empty.name);\n      lastElement.before(model.empty.description);\n      lastElement.before(model.empty.save);\n      lastElement.before(model.empty.del);\n    }\n\n    function assignNewValuesOnClone(model, id) {\n      model.empty.id.dataset.id = id;\n      model.empty.id.innerText = id;\n      model.empty.name.dataset.id = id;\n      model.empty.name.innerText = model.name.innerText.trim();\n      model.empty.description.dataset.id = id;\n      model.empty.description.innerText = model.description.innerText.trim();\n      model.empty.save.dataset.id = id;\n      model.empty.del.dataset.id = id;\n    }\n\n    async function create(model) {\n      let res = await post('/right/create', model.toServ);\n\n      if (res.arr.id) {\n        assignNewValuesOnClone(model, res.id - 1);\n        createOnDom(model);\n        clearModel(model);\n        popup.show('Сохранено');\n      }\n    }\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Auth/getSex.js\n\nfunction getSex() {\n  function sex() {\n    const s = common_$('[name=\"sex\"]');\n\n    for (let f of s) {\n      if (f.checked) {\n        return f.value;\n      }\n    }\n\n    return 'm';\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Admin/user/user.js\n\n\n\nfunction user() {\n  let item = common_$('[data-model=\"user\"]')[0];\n\n  if (item) {\n    common_$(item).on('click', handleClick);\n  }\n\n  async function handleClick(_ref) {\n    let {\n      target\n    } = _ref;\n\n    if (!!target.closest('#save')) {\n      let wrapper = common_$('.user-item')[0];\n      let data = getModel(wrapper);\n      let res = await post('/adminsc/user/update', data);\n    } else if (target.classList.contains('right')) {\n      let rights = common_$('input.right:checked');\n      let str = '';\n      [].map.call(rights, function (right) {\n        let s = right.previousElementSibling.innerText;\n        str += s + ',';\n      });\n      let tab = target.closest('[tab]');\n      tab.dataset.value = str;\n    }\n  }\n\n  function rights() {\n    let right = common_$('.right:checked');\n    let rights = '';\n    [].map.call(right, r => {\n      let str = r.previousElementSibling.innerText + ',';\n      rights += str;\n    }, rights);\n    return rights;\n  }\n\n  function confirm() {\n    const confirm = common_$('#conf option');\n\n    for (let f of confirm) {\n      if (f.selected) {\n        return f.value;\n      }\n    }\n\n    return '0';\n  }\n\n  function getModel(target) {\n    return {\n      id: common_$(target).find(\"#id\").innerText,\n      name: common_$(target).find('#name').innerText,\n      surName: common_$(target).find('#s-name').innerText,\n      middleName: common_$(target).find('#m-name').innerText,\n      birthDate: common_$(target).find('#bday').innerText,\n      phone: common_$(target).find('#phone').innerText,\n      email: common_$(target).find('#email').innerText,\n      hired: common_$(target).find('#hired').innerText,\n      fired: common_$(target).find('#fired').innerText,\n      confirm: confirm(),\n      sex: getSex(),\n      rights: rights()\n    };\n  }\n}\n;// CONCATENATED MODULE: ./public/src/components/accordion-show.js\n\nfunction accordionShow() {\n  let currentTestId = common_$(`[data-testid]`)[0];\n\n  if (currentTestId) {\n    currentTestId = +currentTestId.dataset['testid'];\n    let menuItemCollection = common_$('.test-edit.accordion a');\n    Array.from(menuItemCollection).filter(a => {\n      if (+a.dataset.id === currentTestId) {\n        a.classList.add('current');\n      }\n    });\n  }\n\n  let button = common_$('.accordion-open')[0];\n\n  if (button) {\n    common_$(button).on('click', function () {\n      let menu = common_$('.accordion_wrap')[0];\n      menu.classList.toggle('open');\n    });\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Test/open_test.js\n\n\n\nlet openTest = common_$('.opentest_wrap')[0];\n\nif (openTest) {\n  open_test_showFirstQuest();\n  common_$(openTest).on('click', open_test_handleClick);\n  common_$(openTest).on('keyup', open_test_handleKeyup);\n}\n\nfunction open_test_showFirstQuest() {\n  let q = common_$('.question')[0].classList.add('show');\n}\n\nfunction open_test_handleKeyup(_ref) {\n  let {\n    target\n  } = _ref;\n\n  if (target.classList.contains('textarea')) {\n    let activePagination = common_$('[data-pagination].active')[0];\n\n    if (!target.innerText) {\n      activePagination.classList.remove('filled');\n    } else {\n      activePagination.classList.add('filled');\n    }\n  }\n}\n\nasync function open_test_handleClick(_ref2) {\n  let {\n    target\n  } = _ref2;\n  let testid = target.dataset.id;\n  let activeQuestion = common_$('.question.show')[0];\n  let paginations = common_$('[data-pagination]');\n  let activePagination = common_$('[data-pagination].active')[0];\n  let i = paginations.indexOf(activePagination);\n\n  if (target.id === 'prev') {\n    prevQuest();\n  } else if (target.id === 'next') {\n    nextQuest();\n  } else if (target.dataset.pagination) {\n    paginate();\n  } else if (target.classList.contains('led')) {\n    blink(target);\n  } else if (target.id === 'finish') {\n    finish();\n  }\n\n  async function finish() {\n    let questions = await getAnswers(testid);\n    let correctAnswers = correctCount(questions);\n    let obj = objToServ(correctAnswers);\n    let res = await post('/adminsc/opentestresult/finish', obj);\n\n    if (res.msg === 'ok') {\n      let canv = document.createElement(\"canvas\");\n      canv.id = 'c';\n    }\n  }\n\n  function objToServ(rightAnswers) {\n    return {\n      testId: +testid,\n      questionCnt: paginations.length,\n      html: cachePage('.test'),\n      testname: common_$('.test-name')[0].innerText,\n      username: common_$('.user-menu__fio')[0].innerText,\n      rightAnswers // html: `<!DOCTYPE ${document.doctype.name}>` + document.documentElement.outerHTML,\n\n    };\n  }\n\n  function paginate() {\n    if (target === activePagination) return false;\n    let aimPagination = target;\n    toggleQuestion(aimPagination, activeQuestion);\n    toggleNav(aimPagination, activePagination);\n  }\n\n  function prevQuest() {\n    if (i < 1) return false;\n    let aimPagination = paginations[i - 1];\n    toggleQuestion(aimPagination, activeQuestion);\n    toggleNav(aimPagination, activePagination);\n  }\n\n  function nextQuest() {\n    if (i > paginations.length - 2) return false;\n    let aimPagination = paginations[i + 1];\n    toggleQuestion(aimPagination, activeQuestion);\n    toggleNav(aimPagination, activePagination);\n  }\n}\n\nfunction correctCount(questions) {\n  let correct = 0;\n  questions.forEach(q => {\n    let q_id = q.id;\n    let q_el = common_$(`.question[data-id='${q_id}']`)[0];\n    let textarea = common_$(q_el).find('.textarea');\n    if (!q.Openanswer) return;\n    let word = '';\n    q.Openanswer.forEach(a => {\n      word += `(${a.answer})?`;\n    });\n    correct += highlight(`${word}`, textarea, true);\n  });\n  return correct;\n}\n\nfunction hiliter(word, element, addEventLis) {\n  let text = element.innerHTML;\n  let rgxp = new RegExp(word, 'g');\n  let arr = text.match(rgxp);\n  let correct = 0;\n  arr.forEach(w => {\n    if (!w) return;\n    correct = 1;\n    let r = new RegExp(w, 'g');\n    let repl = `<span style='color:red;'>` + w + '</span>';\n    element.innerHTML = element.innerHTML.replace(r, repl);\n  });\n  return correct;\n}\n\nasync function getAnswers(id) {\n  return await post('/adminsc/opentestresult/getanswers', {\n    id\n  });\n}\n\nfunction toggleNav(aimPagination, activePagination) {\n  activePagination.classList.toggle('active');\n  aimPagination.classList.toggle('active');\n}\n\nfunction toggleQuestion(aimPaginationId, activeQuestion) {\n  let aimQuestionId = aimPaginationId.dataset.pagination;\n  let aimQuestion = common_$(`.question[data-id='${aimQuestionId}']`)[0];\n  aimQuestion.classList.toggle('show');\n  activeQuestion.classList.toggle('show');\n}\n\nfunction highlight(word, el, addEventLis) {\n  return hiliter(word, el, addEventLis);\n}\n;// CONCATENATED MODULE: ./public/src/components/radio/radio.js\n\n\nfunction radio_radio() {\n  let radios = common_$('[custom-radio]');\n  [].map.call(radios, function (radio) {\n    common_$(radio).on('click', handleClick);\n\n    function handleClick(_ref) {\n      let {\n        target\n      } = _ref;\n      let targ = target.closest(\"label\");\n      radio.dataset.value = targ.dataset.value;\n    }\n  });\n}\n;// CONCATENATED MODULE: ./public/src/components/multiselect/multiselect.js\n\n\nfunction multiselect() {\n  function getSelected() {\n    if (multi) {\n      let selected = [].map.call(multi, function (select) {\n        let chips = select.querySelectorAll('.chip-wrap');\n        let objs = [].map.call(chips, function (chip) {\n          return chip.dataset.id;\n        });\n        let obj = {};\n        obj.field = select.dataset.field;\n        obj.ids = objs;\n        return obj;\n      });\n    } // debugger\n\n  }\n\n  let multi = common_$('[multi-select] ');\n\n  if (multi) {\n    [].forEach.call(multi, function (select) {\n      select.addEventListener('click', handleClick, false);\n      select.addEventListener('blur', handleBlur, false);\n\n      function handleBlur(_ref) {\n        let {\n          target\n        } = _ref;\n        let show = common_$(this).find('.show');\n\n        if (show) {\n          show.classList.remove('show');\n        }\n      }\n\n      function handleClick(_ref2) {\n        let {\n          target\n        } = _ref2;\n        let multi = target.closest('[multi-select]'); // открыть выбор элементов\n\n        if (target.closest('.arrow') || ['chip-wrap'].includes(target.className)) {\n          // let multiselect = target.closest('[multi-select] ')\n          let ul = multi.querySelector('ul');\n          ul.classList.toggle('show'); // нажатие по крестику чипа\n        } else if (['del'].includes(target.className)) {\n          let id = target.closest('.chip').dataset.id;\n          toggleBackground(id);\n          let chip = target.closest('.chip');\n          chip.remove(); // выбор элемента, проверка существования чипа и его добавление\n        } else if (target.tagName.toLowerCase() === 'label') {\n          let id = target.dataset.id; // let m = target.closest('[multi-select] ')\n\n          let chips = multi.querySelectorAll('.chip');\n          let exist = [].some.call(chips, chip => {\n            return chip.dataset.id === id;\n          });\n          let wrap = common_$(multi).find('.chip-wrap');\n\n          if (!exist) {\n            target.classList.toggle('selected');\n            let chip = createChip(id);\n            wrap.append(chip);\n          } else {\n            target.classList.toggle('selected');\n            wrap.querySelector(`[data-id='${id}']`).remove();\n          }\n        }\n\n        function toggleBackground(id) {\n          // let multi = target.closest('[multi-select] ')\n          common_$(multi).find(`label[data-id='${id}']`).classList.remove('selected');\n        }\n\n        function createChip(id) {\n          let chip = document.createElement('div');\n          chip.classList.add('chip');\n          chip.innerText = target.innerText;\n          chip.dataset['id'] = id;\n          let del = document.createElement('div');\n          del.classList.add('del');\n          del.innerText = 'X';\n          chip.append(del);\n          return chip;\n        }\n      }\n    });\n  }\n}\n;// CONCATENATED MODULE: ./public/src/components/catalog-item/catalog-item.js\n\n\nfunction catalogItem() {\n  let customCatalogItem = common_$('.item_wrap')[0];\n\n  if (customCatalogItem) {\n    common_$(customCatalogItem).on('click', handleClick.bind(this));\n  }\n\n  async function handleClick(_ref) {\n    let {\n      target\n    } = _ref;\n    let item = customCatalogItem;\n    let modelName = item.dataset.model;\n\n    if (target.closest('.save')) {\n      save(modelName);\n    } else if (target.closest('.del') && target.closest('.del').dataset.model) {\n      del(item, target.closest('.del').dataset.model);\n    } else if (target.classList.contains('tab')) {\n      handleTab(target, modelName);\n    }\n  }\n\n  async function handleTab(target) {\n    let visibleSection = common_$(`section.show`)[0];\n    visibleSection.classList.toggle('show');\n    let section = common_$(`section[data-id='${target.dataset.id}']`)[0];\n    section.classList.toggle('show');\n    let activeTab = common_$(`.tab.active`)[0];\n    activeTab.classList.toggle('active');\n    target.classList.toggle('active');\n  }\n\n  async function del(item, modelName) {\n    let id = item.dataset.id;\n    let res = await post(`/adminsc/${modelName}/delete`, {\n      id\n    });\n\n    if (res) {\n      window.location.href = `/adminsc/${modelName}/edit`;\n    }\n  }\n\n  async function save(modelName) {\n    if (checkRequired()) return false;\n    let model = getModel();\n    let res = await post(`/adminsc/${modelName}/updateorcreate`, { ...model\n    });\n  }\n\n  function checkRequired() {\n    let required = common_$('[required]');\n    let errCount = 0;\n    [].forEach.call(required, function (el) {\n      if (!el.innerText) {\n        el.style.borderColor = 'red';\n        if (common_$(el).find('.error')) return;\n        let error = document.createElement('div');\n        error.innerText = 'Заполните поле';\n        error.classList.add('error');\n        el.closest('.value').appendChild(error);\n        errCount++;\n      }\n    });\n    return errCount;\n  }\n\n  function getModel() {\n    let fields = common_$('[data-field]');\n    let obj = {};\n\n    function r(str) {\n      return str.replace(/^ +| +$|( ) +/g, \"$1\");\n    } // debugger;\n\n\n    [].map.call(fields, field => {\n      if (field.hasAttribute('multi-select')) {\n        let chips = field.querySelectorAll('.chip');\n        let ids = [].map.call(chips, chip => {\n          return chip.dataset.id;\n        });\n        obj[field.dataset.field] = ids.toString();\n      } else if (field.hasAttribute('custom-select')) {\n        obj[field.dataset.field] = field.dataset.value;\n      } else if (field.dataset.type === 'inputs') {\n        obj[field.dataset.field] = getInputs(field);\n      } else if (field.hasAttribute('custom-radio')) {\n        obj[field.dataset.field] = field.dataset.value;\n      } else if (field.hasAttribute('tab')) {\n        obj[field.dataset.field] = field.dataset.value;\n      } else if (field.type === 'date') {\n        obj[field.dataset.field] = field.value;\n      } else {\n        obj[field.dataset.field] = r(trimStr(field.innerText));\n      }\n    }, obj);\n    let isTest = common_$('[data-isTest]')[0];\n\n    if (isTest) {\n      obj.isTest = +isTest.dataset.istest;\n    }\n\n    return obj;\n  }\n\n  function getInputs(field) {\n    let inputs = field.querySelectorAll('input');\n    let names = [];\n    inputs.forEach(inp => {\n      if (!inp.checked) return;\n      let name = inp.parentNode.querySelector('.name').innerText;\n      if (!name) return;\n      names.push(name);\n    });\n    return names.join(',');\n  }\n}\n;// CONCATENATED MODULE: ./public/src/components/tooltip/tooltip.js\n\nfunction tooltips() {\n  document.addEventListener('mouseenter', showTip, true);\n  document.addEventListener('mouseleave', hideTip, true);\n\n  function showTip(_ref) {\n    let {\n      target\n    } = _ref;\n    // debugger\n    // если у нас есть подсказка...\n    if (!target.dataset || !target.dataset.tooltip) return;\n    let tooltipHtml = target.dataset.tooltip; // ...создадим элемент для подсказки\n\n    let tooltipElem = document.createElement('div');\n    tooltipElem.className = 'tooltip';\n    tooltipElem.innerHTML = tooltipHtml;\n    document.body.append(tooltipElem); // спозиционируем его сверху от аннотируемого элемента (top-center)\n\n    let coords = target.getBoundingClientRect();\n    let left = coords.left + (target.offsetWidth - tooltipElem.offsetWidth) / 2;\n    if (left < 0) left = 0; // не заезжать за левый край окна\n\n    let top = coords.top - tooltipElem.offsetHeight - 5;\n\n    if (top < 0) {\n      // если подсказка не помещается сверху, то отображать её снизу\n      top = coords.top + target.offsetHeight + 5;\n    }\n\n    tooltipElem.style.left = left + 'px';\n    tooltipElem.style.top = top + 'px';\n  }\n\n  ;\n\n  function hideTip() {\n    let tooltips = document.querySelectorAll('.tooltip');\n\n    if (tooltips) {\n      [].forEach.call(tooltips, tip => {\n        tip.remove();\n      });\n    }\n  }\n\n  ;\n}\n;// CONCATENATED MODULE: ./public/src/Admin/admin.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommon_$(document).ready(function () {\n  navigate(window.location.pathname);\n  radio_radio();\n  list();\n  multiselect();\n  catalogItem();\n  tooltips();\n  accordionShow();\n  testEdit();\n\n  function navigate(str) {\n    if (/\\/adminsc\\/settings/.test(str) || /\\/adminsc\\/right\\/list/.test(str) || /\\/adminsc\\/post\\/list/.test(str) || /\\/adminsc\\/todo\\/list/.test(str)) {\n      rights();\n      common_$(\"[href='/adminsc/settings']\").addClass('current');\n    } else if (/\\/adminsc\\/testresult\\/results/.test(str)) {\n      common_$(\"[href='/adminsc/test/results']\").addClass('current');\n    } else if (/\\/adminsc\\/testresult\\/results/.test(str)) {\n      common_$(\"[href='/adminsc/test/results']\").addClass('current');\n    } else if (/\\/auth\\/profile/.test(str)) {\n      user();\n    } else if (/\\/adminsc\\/crm/.test(str)) {\n      common_$(\"[href='/adminsc/crm']\").addClass('current');\n    } else if (/\\/adminsc\\/catalog/.test(str)) {\n      common_$(\"[href='/adminsc/catalog']\").addClass('current');\n    } else if (/\\/adminsc\\/planning/.test(str)) {\n      common_$(\"[href='/adminsc/planning']\").addClass('current');\n    } else if (/\\/adminsc\\/test\\/pathshow/.test(str) || /\\/adminsc\\/test\\/edit/.test(str)) {\n      common_$(\"[href='/adminsc/test/edit']\").addClass('current');\n    } else if (/\\/test/.test(str) || /\\/test\\/result/.test(str)) {\n      common_$(\"[href='/test/do']\").addClass('current');\n    } else if (/\\/adminsc\\/Sitemap/.test(str)) {\n      common_$(\"[href='/adminsc/settings']\").addClass('current');\n    } else {\n      common_$(\"[href='/adminsc']\").addClass('current');\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULHdDQUF3QyxxREFBcUQ7OztBQUc3RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxH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VjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTixHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaU1BQWlNOztBQUVqTTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQzs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7O0FBR047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQSxpRUFBaUU7OztBQUdqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTs7O0FBR1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZOzs7QUFHWjtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw0Q0FBNEM7O0FBRTVDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0NBQXdDOzs7QUFHeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7OztBQUdoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHOzs7QUFHaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHOzs7QUFHZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QixZQUFZLDBCQUEwQjtBQUN0Qzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLFlBQVksNEJBQTRCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9DQUFvQztBQUNoRDs7O0FBR0E7QUFDQSx5RUFBeUUsYUFBYTtBQUN0RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjs7QUFFQSx1RUFBdUU7QUFDdkU7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsYUFBYTtBQUN4Qjs7O0FBR0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQ7O0FBRXZEOztBQUVBO0FBQ0EsMkVBQTJFOztBQUUzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUosa0NBQWtDO0FBQ2xDLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixrREFBRTtBQUMxQixzQkFBc0Isa0RBQUU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsOEJBQThCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7O0FBRVY7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRDs7O0FBR2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRzs7QUFFZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFROzs7QUFHUjtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLEdBQUc7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOzs7QUFHWjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFFQUFxRTs7QUFFckUsdURBQXVEOztBQUV2RCwrRkFBK0Y7O0FBRS9GOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRzs7QUFFWjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkIsWUFBWSxhQUFhO0FBQ3pCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsbURBQWUsUUFBUSxFQUFDO0FBQzhDOzs7QUN2c0h0RTtBQUNBO0FBRWUsU0FBUzJCLFFBQVQsQ0FBa0JDLGlCQUFsQixFQUFxQ0MsVUFBckMsRUFBaUR4QixLQUFqRCxFQUF3RDtFQUVyRSxJQUFJeUIsU0FBUyxHQUFHOUwsUUFBQyxDQUFDNEwsaUJBQUQsQ0FBRCxDQUFxQixDQUFyQixDQUFoQjs7RUFDQSxJQUFJRSxTQUFKLEVBQWU7SUFFYixJQUFJSCxRQUFRLEdBQUdELG1CQUFBLENBQWdCSSxTQUFoQixFQUEyQjtNQUN4Q0MsU0FBUyxFQUFFLEdBRDZCO01BRXhDQyxLQUFLLEVBQUUsVUFBVUMsR0FBVixFQUFlO1FBQ3BCLElBQUlDLElBQUksR0FBR0QsR0FBRyxDQUFDRSxRQUFmO1FBQ0EsSUFBSUMsSUFBSSxHQUFHSCxHQUFHLENBQUNJLFFBQWY7O1FBQ0EsSUFBSUgsSUFBSSxHQUFHRSxJQUFYLEVBQWlCO1VBQ2ZwTCxJQUFJLENBQUNrTCxJQUFELENBQUo7UUFDRCxDQUZELE1BRU87VUFDTGxMLElBQUksQ0FBQ29MLElBQUQsQ0FBSjtRQUNEOztRQUVELGVBQWVwTCxJQUFmLENBQW9CK0osaUJBQXBCLEVBQXVDO1VBQ3JDLElBQUl1QixHQUFHLEdBQUd0TSxRQUFDLENBQUM2TCxVQUFELENBQVg7VUFDQSxJQUFJYixZQUFZLEdBQUcsR0FBR3pCLEdBQUgsQ0FBT2xDLElBQVAsQ0FBWWlGLEdBQVosRUFBaUIsVUFBVWpLLEVBQVYsRUFBY21ILENBQWQsRUFBaUI7WUFDakQsSUFBSUEsQ0FBQyxHQUFHLENBQUosR0FBUXVCLGlCQUFaLEVBQStCLE9BQU8xSSxFQUFQO1VBQ2hDLENBRmdCLENBQW5CO1VBS0EsSUFBSTZJLFFBQVEsR0FBR0YsWUFBWSxDQUFDekIsR0FBYixDQUFrQmxILEVBQUQsSUFBUTtZQUN0QyxPQUFPQSxFQUFFLENBQUNnSCxFQUFWO1VBQ0QsQ0FGYyxDQUFmO1VBR0EsSUFBSTFILEdBQUcsR0FBRyxNQUFNbUMsSUFBSSxDQUFFLFlBQVd1RyxLQUFNLE9BQW5CLEVBQTJCO1lBQUNhO1VBQUQsQ0FBM0IsQ0FBcEI7VUFDQUYsWUFBWSxDQUFDekIsR0FBYixDQUFpQixDQUFDbEgsRUFBRCxFQUFLbUgsQ0FBTCxLQUFXO1lBQzFCeEosUUFBQyxDQUFDcUMsRUFBRCxDQUFELENBQU00RixJQUFOLENBQVcsT0FBWCxFQUFvQjNHLFNBQXBCLEdBQWdDa0ksQ0FBQyxHQUFHLENBQXBDO1VBQ0QsQ0FGRDtRQUdEO01BQ0Y7SUExQnVDLENBQTNCLENBQWY7RUE2QkQ7QUFDRixDOztBQ3RDRDtBQUVlLE1BQU0rQyxLQUFOLENBQVk7RUFFekJDLFdBQVcsR0FBRztJQUNaLEtBQUtuQyxLQUFMLEdBQWEsVUFBYjtFQUNEOztFQUVXLE1BQU5ILE1BQU0sR0FBRztJQUNiLElBQUl0SSxJQUFJLEdBQUcySyxLQUFLLENBQUNFLFdBQU4sRUFBWDs7SUFDQTdLLElBQUksQ0FBQ3lILEVBQUwsR0FBVSxDQUFWO0lBQ0F6SCxJQUFJLENBQUM4SyxNQUFMLEdBQWMsQ0FBZDtJQUNBO0lBQ0EsSUFBSTNJLEdBQUcsR0FBSSxJQUFHLEtBQUtzRyxLQUFNLGlCQUF6QjtJQUNBLElBQUkxSSxHQUFHLEdBQUcsTUFBTW1DLElBQUksQ0FBQ0MsR0FBRCxFQUFNbkMsSUFBTixDQUFwQjs7SUFDQSxJQUFJRCxHQUFKLEVBQVM7TUFDUGQsTUFBTSxDQUFDK0MsUUFBUCxDQUFnQitJLElBQWhCLEdBQXdCLFlBQVd0QyxLQUFNLFNBQVExSSxHQUFHLENBQUMwSCxFQUFHLEVBQXhEO0lBQ0Q7RUFDRjs7RUFFRHVELFFBQVEsR0FBRztJQUNULE9BQU87TUFDTHZELEVBQUUsRUFBRXJKLFFBQUMsQ0FBQyxhQUFELENBQUQsQ0FBaUIsQ0FBakIsRUFBb0JzQixTQUFwQixHQUFnQyxDQUQvQjtNQUVMdUwsR0FBRyxFQUFFN00sUUFBQyxDQUFDLGlCQUFELENBQUQsQ0FBcUIsQ0FBckIsQ0FGQTtNQUdMOE0sU0FBUyxFQUFFOU0sUUFBQyxDQUFDLG1CQUFELENBQUQsQ0FBdUIyRixNQUg3QjtNQUlMb0gsTUFBTSxFQUFFL00sUUFBQyxDQUFDLGlCQUFELENBQUQsQ0FBcUIsQ0FBckIsRUFBd0JnTixzQkFKM0I7TUFLTEMsT0FBTyxFQUFFak4sUUFBQyxDQUFDLGlCQUFELENBQUQsQ0FBcUIsQ0FBckIsRUFBd0JrQjtJQUw1QixDQUFQO0VBT0Q7O0VBR0RnTSxTQUFTLEdBQUc7SUFDVixPQUFPO01BQ0w3RCxFQUFFLEVBQUUsQ0FBQ3hJLE1BQU0sQ0FBQytDLFFBQVAsQ0FBZ0IrSSxJQUFoQixDQUFxQlEsS0FBckIsQ0FBMkIsR0FBM0IsRUFBZ0NDLEdBQWhDLEVBREE7TUFFTC9CLFNBQVMsRUFBRXJMLFFBQUMsQ0FBQyxZQUFELENBQUQsQ0FBZ0IwQixJQUFoQixFQUZOO01BR0wyTCxNQUFNLEVBQUVyTixRQUFDLENBQUMsU0FBRCxDQUFELENBQWEsQ0FBYixDQUhIO01BSUxvSSxNQUFNLEVBQUVwSSxRQUFDLENBQUMsUUFBRCxDQUFELENBQVlzTixrQkFBWjtJQUpILENBQVA7RUFNRDs7RUFHRGpFLEVBQUUsR0FBRztJQUNILE9BQU9BLEVBQUUsSUFBSXJKLFFBQUMsQ0FBQyxZQUFELENBQUQsQ0FBZ0IsQ0FBaEIsRUFBbUI2SixPQUFuQixDQUEyQjBELE1BQXhDO0VBQ0Q7O0VBR0RDLFFBQVEsR0FBRztJQUNULElBQUlDLGNBQWMsR0FBR3pOLFFBQUMsQ0FBQyxXQUFELENBQUQsQ0FBZTJGLE1BQXBDO0lBQ0EsSUFBSThILGNBQUosRUFDRSxPQUFPQSxjQUFQO0lBQ0YsT0FBTyxLQUFQO0VBQ0Q7O0VBR2dCLE1BQVhDLFdBQVcsR0FBRztJQUNsQixJQUFJQyxTQUFTLEdBQUdwQixLQUFLLENBQUNFLFdBQU4sRUFBaEI7O0lBQ0FrQixTQUFTLENBQUN0RSxFQUFWLEdBQWUsQ0FBZjtJQUNBc0UsU0FBUyxDQUFDakIsTUFBVixHQUFtQixDQUFuQjtJQUNBLElBQUkzSSxHQUFHLEdBQUksWUFBV3NHLEtBQU0sU0FBNUI7SUFDQSxJQUFJMUksR0FBRyxHQUFHLE1BQU1tQyxJQUFJLENBQUNDLEdBQUQsRUFBTTRKLFNBQU4sQ0FBcEI7O0lBQ0EsSUFBSWhNLEdBQUosRUFBUztNQUNQZCxNQUFNLENBQUMrQyxRQUFQLENBQWdCK0ksSUFBaEIsR0FBd0IsWUFBV3RDLEtBQU0sU0FBUTFJLEdBQUcsQ0FBQzBILEVBQUosR0FBUyxDQUFFLEVBQTVEO0lBQ0Q7RUFDRjs7RUFHRHVFLElBQUksR0FBRztJQUNMLE9BQU81TixRQUFDLENBQUMsWUFBRCxDQUFELENBQWdCLENBQWhCLEVBQW1Cc0IsU0FBMUI7RUFDRDs7RUFJRHVNLHlCQUF5QixDQUFDL04sU0FBRCxFQUFZO0lBRW5DLElBQUlnTyxNQUFNLEdBQUc5TixRQUFDLENBQUUsZUFBY0YsU0FBVSxHQUExQixDQUFELENBQStCLENBQS9CLENBQWI7SUFDQSxJQUFJaU8sUUFBUSxHQUFHLENBQUMsR0FBR0QsTUFBTSxDQUFDakksT0FBWCxFQUFvQlcsTUFBcEIsQ0FBNEJ3SCxHQUFELElBQVNBLEdBQUcsQ0FBQ0QsUUFBeEMsQ0FBZjs7SUFDQSxJQUFJQSxRQUFKLEVBQWM7TUFDWixPQUFPLENBQUNBLFFBQVEsQ0FBQyxDQUFELENBQVIsQ0FBWTNNLEtBQXBCO0lBQ0Q7RUFDRjs7RUFHRHFMLFdBQVcsR0FBRztJQUNaLElBQUlwQyxLQUFLLEdBQUc7TUFDVmhCLEVBQUUsRUFBRSxDQUFDeEksTUFBTSxDQUFDK0MsUUFBUCxDQUFnQitJLElBQWhCLENBQXFCUSxLQUFyQixDQUEyQixHQUEzQixFQUFnQ0MsR0FBaEMsRUFESztNQUVWL0IsU0FBUyxFQUFFckwsUUFBQyxDQUFDLFlBQUQsQ0FBRCxDQUFnQixDQUFoQixFQUFtQm9CLEtBRnBCO01BR1ZzTCxNQUFNLEVBQUUsQ0FBQzFNLFFBQUMsQ0FBQyxVQUFELENBQUQsQ0FBYyxDQUFkLEVBQWlCc0UsWUFBakIsQ0FBOEIsUUFBOUI7SUFIQyxDQUFaO0lBTUEsSUFBSTJKLE1BQU0sR0FBR2pPLFFBQUMsQ0FBQyxnQkFBRCxDQUFkO0lBQ0EsR0FBR2tHLE9BQUgsQ0FBV21CLElBQVgsQ0FBZ0I0RyxNQUFoQixFQUF3QixVQUFVQyxLQUFWLEVBQWlCO01BQ3ZDN0QsS0FBSyxDQUFDNkQsS0FBSyxDQUFDckUsT0FBTixDQUFjLE9BQWQsQ0FBRCxDQUFMLEdBQWdDcUUsS0FBSyxDQUFDckUsT0FBTixDQUFjLElBQWQsQ0FBaEM7SUFDRCxDQUZEO0lBR0EsT0FBT1EsS0FBUDtFQUNEOztFQUVXLE1BQU44RCxNQUFNLEdBQUc7SUFDYixJQUFJOUQsS0FBSyxHQUFHa0MsS0FBSyxDQUFDRSxXQUFOLEVBQVo7O0lBQ0EsSUFBSTFJLEdBQUcsR0FBSSxZQUFXc0csS0FBTSxXQUFVQSxLQUFLLENBQUNoQixFQUFHLEVBQS9DO0lBQ0EsSUFBSTFILEdBQUcsR0FBRyxNQUFNbUMsSUFBSSxDQUFDQyxHQUFELEVBQU1zRyxLQUFOLENBQXBCOztJQUNBLElBQUkxSSxHQUFKLEVBQVM7TUFDUGQsTUFBTSxDQUFDK0MsUUFBUCxDQUFnQitJLElBQWhCLEdBQXdCLFlBQVd0QyxLQUFNLFNBQVFBLEtBQUssQ0FBQ2hCLEVBQUcsRUFBMUQ7SUFDRDtFQUNGOztFQUdRLE1BQUhtQyxHQUFHLEdBQUc7SUFDVixJQUFJZSxLQUFLLENBQUNpQixRQUFOLEVBQUosRUFBc0I7TUFDcEJ4TCxVQUFBLENBQVcsb0NBQVg7TUFDQSxPQUFPLEtBQVA7SUFDRDs7SUFFRCxJQUFJcUgsRUFBRSxHQUFHa0QsS0FBSyxDQUFDbEQsRUFBTixFQUFUOztJQUNBLElBQUkxSCxHQUFHLEdBQUcsTUFBTW1DLElBQUksQ0FBQywwQkFBRCxFQUE2QjtNQUFDdUY7SUFBRCxDQUE3QixDQUFwQjs7SUFDQSxJQUFJMUgsR0FBRyxDQUFDeU0sUUFBUixFQUFrQjtNQUNoQnBNLFVBQUEsQ0FBVyxtRUFBWDtNQUNBL0MsVUFBVSxDQUFDLE1BQU07UUFDZjRCLE1BQU0sQ0FBQytDLFFBQVAsR0FBbUIsWUFBV3lHLEtBQU0sV0FBcEM7TUFDRCxDQUZTLEVBRVAsSUFGTyxDQUFWO0lBR0QsQ0FMRCxNQUtPO01BQ0x4SixNQUFNLENBQUMrQyxRQUFQLEdBQW1CLFlBQVd5RyxLQUFNLFdBQXBDO0lBQ0Q7RUFFRjs7QUF6SHdCLEM7O0FDRjNCO0FBRU8sSUFBSWdFLE9BQU8sR0FBRztFQUVuQixNQUFNbkUsTUFBTixDQUFhb0UsTUFBYixFQUFxQjtJQUVuQixJQUFJNUQsUUFBUSxHQUFHNEQsTUFBTSxDQUFDckwsT0FBUCxDQUFlLGdCQUFmLENBQWY7SUFDQSxJQUFJc0wsZUFBZSxHQUFHN0QsUUFBUSxDQUFDckIsRUFBL0I7SUFDQSxJQUFJckksSUFBSSxHQUFHMEosUUFBUSxDQUFDakUsZ0JBQVQsQ0FBMEIsU0FBMUIsRUFBcUNkLE1BQXJDLEdBQThDLENBQXpEO0lBQ0EsSUFBSWhFLEdBQUcsR0FBRyxNQUFNbUMsSUFBSSxDQUFDLDRCQUFELEVBQ2xCO01BQUN5SyxlQUFEO01BQWtCdk47SUFBbEIsQ0FEa0IsQ0FBcEI7SUFFQSxJQUFJcUksRUFBRSxHQUFHMUgsR0FBRyxDQUFDc0UsR0FBSixDQUFRb0QsRUFBakI7O0lBQ0EsSUFBSUEsRUFBSixFQUFRO01BQ04sSUFBSXRKLElBQUksR0FBRzRCLEdBQUcsQ0FBQzVCLElBQWY7TUFDQXVPLE1BQU0sQ0FBQ0Usa0JBQVAsQ0FBMEIsYUFBMUIsRUFBeUN6TyxJQUF6QztJQUNELENBSEQsTUFHTztNQUNMaUMsVUFBQSxDQUFXLFdBQVg7SUFDRDtFQUNGLENBaEJrQjs7RUFrQm5CLE1BQU13SixHQUFOLENBQVV6SSxNQUFWLEVBQWtCO0lBQ2hCLElBQUkwTCxVQUFVLEdBQUcxTCxNQUFNLENBQUNFLE9BQVAsQ0FBZSxTQUFmLENBQWpCO0lBQ0EsSUFBSSxDQUFDd0wsVUFBTCxFQUFpQixPQUFPLEtBQVA7O0lBQ2pCLElBQUkvRSxPQUFPLENBQUMscUJBQUQsQ0FBWCxFQUFvQztNQUNsQyxJQUFJb0IsTUFBTSxHQUFHMkQsVUFBVSxDQUFDeEwsT0FBWCxDQUFtQixTQUFuQixDQUFiO01BQ0EsSUFBSW9HLEVBQUUsR0FBRyxDQUFDeUIsTUFBTSxDQUFDakIsT0FBUCxDQUFlLFVBQWYsQ0FBVjtNQUNBLElBQUlsSSxHQUFHLEdBQUcsTUFBTW1DLElBQUksQ0FBQyxvQkFBRCxFQUF1QjtRQUFDdUY7TUFBRCxDQUF2QixDQUFwQjs7TUFFQSxJQUFJMUgsR0FBRyxDQUFDdUQsR0FBSixLQUFZLElBQWhCLEVBQXNCO1FBQ3BCNEYsTUFBTSxDQUFDbEksTUFBUDtRQUNBWixVQUFBLENBQVcsY0FBWDtNQUNEO0lBQ0Y7RUFDRjs7QUEvQmtCLENBQWQsQzs7QUNGUDtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0EsSUFBSTBNLFlBQVksR0FBRzFPLFFBQUMsQ0FBQyx3QkFBRCxDQUFELENBQTRCLENBQTVCLENBQW5COztBQUNBLElBQUkwTyxZQUFKLEVBQWtCO0VBRWhCL0MsUUFBUSxDQUFDLG1DQUFELEVBQ04sdUNBRE0sRUFFTixjQUZNLENBQVI7RUFLQTNMLFFBQUMsQ0FBQzBPLFlBQUQsQ0FBRCxDQUFnQmhJLEVBQWhCLENBQW1CLFFBQW5CLEVBQTZCaUksWUFBN0I7RUFFQTNPLFFBQUMsQ0FBQzBPLFlBQUQsQ0FBRCxDQUFnQmhJLEVBQWhCLENBQW1CLE9BQW5CLEVBQTRCLFFBQWM7SUFBQSxJQUFiO01BQUMzRDtJQUFELENBQWE7SUFDdEMsTUFBTW5CLElBQUksR0FBRyxJQUFJMkssS0FBSixFQUFiOztJQUNBLElBQUl4SixNQUFNLENBQUNKLFNBQVAsQ0FBaUJLLFFBQWpCLENBQTBCLG1CQUExQixDQUFKLEVBQW9EO01BQ2xEcEIsSUFBSSxDQUFDdU0sTUFBTDtJQUNELENBRkQsTUFFTyxJQUFJcEwsTUFBTSxDQUFDSixTQUFQLENBQWlCSyxRQUFqQixDQUEwQixjQUExQixDQUFKLEVBQStDO01BQ3BEcEIsSUFBSSxDQUFDdU0sTUFBTDtJQUNELENBRk0sTUFFQSxJQUFJcEwsTUFBTSxDQUFDSixTQUFQLENBQWlCSyxRQUFqQixDQUEwQixZQUExQixDQUFKLEVBQTZDO01BQ2xEcEIsSUFBSSxDQUFDdU0sTUFBTDtJQUNELENBRk0sTUFFQSxJQUFJcEwsTUFBTSxDQUFDSixTQUFQLENBQWlCSyxRQUFqQixDQUEwQixjQUExQixDQUFKLEVBQStDO01BQ3BEcEIsSUFBSSxDQUFDNkgsTUFBTDtJQUNELENBRk0sTUFFQSxJQUFJMUcsTUFBTSxDQUFDSixTQUFQLENBQWlCSyxRQUFqQixDQUEwQixtQkFBMUIsQ0FBSixFQUFvRDtNQUN6RHBCLElBQUksQ0FBQzhMLFdBQUw7SUFDRCxDQUZNLE1BRUEsSUFBSTNLLE1BQU0sQ0FBQ0osU0FBUCxDQUFpQkssUUFBakIsQ0FBMEIsY0FBMUIsQ0FBSixFQUErQztNQUNwRHBCLElBQUksQ0FBQ3NJLE1BQUw7SUFDRCxDQUZNLE1BRUEsSUFBSSxDQUFDLENBQUNuSCxNQUFNLENBQUNFLE9BQVAsQ0FBZSx5QkFBZixDQUFOLEVBQWlEO01BQ3REd0kseUJBQUEsQ0FBMEIxSSxNQUExQjtJQUNELENBRk0sTUFFQSxJQUFJLENBQUMsQ0FBQ0EsTUFBTSxDQUFDRSxPQUFQLENBQWUsbUJBQWYsQ0FBTixFQUEyQztNQUNoRHdJLGlCQUFBLENBQWtCMUksTUFBbEI7SUFDRCxDQUZNLE1BRUEsSUFBSUEsTUFBTSxDQUFDSixTQUFQLENBQWlCSyxRQUFqQixDQUEwQix5QkFBMUIsQ0FBSixFQUEwRDtNQUMvRHlJLG9CQUFBLENBQXFCMUksTUFBckI7SUFDRCxDQUZNLE1BRUEsSUFBSSxDQUFDLENBQUNBLE1BQU0sQ0FBQ0UsT0FBUCxDQUFlLFNBQWYsQ0FBTixFQUFpQztNQUN0Q29MLFdBQUEsQ0FBWXRMLE1BQVo7SUFDRCxDQUZNLE1BRUEsSUFBSUEsTUFBTSxDQUFDSixTQUFQLENBQWlCSyxRQUFqQixDQUEwQix1QkFBMUIsQ0FBSixFQUF3RDtNQUM3RHFMLGNBQUEsQ0FBZXRMLE1BQWY7SUFDRCxDQUZNLE1BRUEsSUFBSSxDQUFDLENBQUNBLE1BQU0sQ0FBQ0UsT0FBUCxDQUFlLCtCQUFmLENBQU4sRUFBdUQ7TUFDNUR3SSwwQkFBQSxDQUEyQjFJLE1BQTNCO0lBQ0QsQ0FGTSxNQUVBLElBQUlBLE1BQU0sQ0FBQ0osU0FBUCxDQUFpQkssUUFBakIsQ0FBMEIsS0FBMUIsQ0FBSixFQUFzQztNQUMzQ0QsTUFBTSxDQUFDSixTQUFQLENBQWlCOEYsTUFBakIsQ0FBd0IsVUFBeEI7SUFDRDtFQUNGLENBN0JIOztFQWdDQSxJQUFJbUcsV0FBVyxHQUFHLHVCQUEwQjtJQUFBLElBQVY7TUFBQzdMO0lBQUQsQ0FBVTs7SUFFMUMsSUFBSUEsTUFBTSxDQUFDSixTQUFQLENBQWlCSyxRQUFqQixDQUEwQixNQUExQixDQUFKLEVBQXVDO01BQ3JDLElBQUk4SCxNQUFNLEdBQUcvSCxNQUFNLENBQUNFLE9BQVAsQ0FBZSxTQUFmLENBQWI7O01BQ0EsSUFBSTZILE1BQUosRUFBWTtRQUNWK0QsVUFBVSxDQUFDL0QsTUFBRCxDQUFWO01BQ0QsQ0FGRCxNQUVPO1FBQ0wsSUFBSXpCLEVBQUUsR0FBR3RHLE1BQU0sQ0FBQ0UsT0FBUCxDQUFlLGdCQUFmLEVBQWlDb0csRUFBMUM7UUFDQSxJQUFJcUIsUUFBUSxHQUFHM0gsTUFBTSxDQUFDekIsU0FBdEI7UUFDQSxJQUFJSyxHQUFHLEdBQUcsTUFBTW1DLElBQUksQ0FBQyxzQ0FBRCxFQUNsQjtVQUFDdUYsRUFBRDtVQUFLcUI7UUFBTCxDQURrQixDQUFwQjtNQUVEO0lBQ0Y7RUFDRixDQWJEOztFQWVBLElBQUlvRSxjQUFjLEdBQUdyUSxRQUFRLENBQUNtUSxXQUFELENBQTdCO0VBQ0E1TyxRQUFDLENBQUMwTyxZQUFELENBQUQsQ0FBZ0JoSSxFQUFoQixDQUFtQixPQUFuQixFQUE0Qm9JLGNBQTVCO0FBRUQ7O0FBR0QsZUFBZUQsVUFBZixDQUEwQkUsUUFBMUIsRUFBb0M7RUFDbEMsSUFBSTFGLEVBQUUsR0FBRzBGLFFBQVEsQ0FBQ2xGLE9BQVQsQ0FBaUJtRixRQUExQjtFQUNBLElBQUlDLFVBQVUsR0FBRyxDQUFDRixRQUFRLENBQUMxSyxhQUFULENBQXVCLE9BQXZCLEVBQWdDeUIsT0FBbEQ7RUFDQSxJQUFJeUksZUFBZSxHQUFHUSxRQUFRLENBQUM5TCxPQUFULENBQWlCLGdCQUFqQixFQUFtQ29HLEVBQXpEO0VBQ0EsSUFBSXlCLE1BQU0sR0FBR2lFLFFBQVEsQ0FBQzFLLGFBQVQsQ0FBdUIsT0FBdkIsRUFBZ0MvQyxTQUE3QztFQUNBLElBQUlLLEdBQUcsR0FBRyxNQUFNbUMsSUFBSSxDQUFDLG9DQUFELEVBQ2xCO0lBQUN1RixFQUFEO0lBQUt5QixNQUFMO0lBQWF5RCxlQUFiO0lBQThCVTtFQUE5QixDQURrQixDQUFwQjtBQUdEOztBQUVELGVBQWVOLFlBQWYsUUFBc0M7RUFBQSxJQUFWO0lBQUM1TDtFQUFELENBQVU7RUFDcEMsSUFBSStILE1BQU0sR0FBRy9ILE1BQU0sQ0FBQ0UsT0FBUCxDQUFlLFNBQWYsQ0FBYjs7RUFFQSxJQUFJNkgsTUFBSixFQUFZO0lBQ1YrRCxVQUFVLENBQUMvRCxNQUFELENBQVY7RUFDRDtBQUVGLEM7O0FDakdEOztBQUVBLE1BQU1BLE1BQU4sQ0FBYTtFQUNYMEIsV0FBVyxHQUFHLENBQ2I7O0VBRWUsTUFBVnFDLFVBQVUsQ0FBQzlMLE1BQUQsRUFBUztJQUN2QixJQUFJbU0sSUFBSSxHQUFHbk0sTUFBTSxDQUFDRSxPQUFQLENBQWUsZ0JBQWYsRUFBaUM0RyxPQUFqQyxDQUF5Q1IsRUFBcEQ7SUFDQSxJQUFJaEgsRUFBRSxHQUFHVSxNQUFNLENBQUNFLE9BQVAsQ0FBZSxTQUFmLENBQVQ7SUFDQSxJQUFJNkgsTUFBTSxHQUFHLEtBQUtxRSxjQUFMLENBQW9COU0sRUFBcEIsRUFBd0I2TSxJQUF4QixDQUFiO0lBQ0EsSUFBSXZOLEdBQUcsR0FBRyxNQUFNbUMsSUFBSSxDQUFDLGdDQUFELEVBQW1DZ0gsTUFBbkMsQ0FBcEI7RUFDRDs7RUFFUSxNQUFIVSxHQUFHLENBQUN6SSxNQUFELEVBQVM7SUFDaEIsSUFBSVYsRUFBRSxHQUFHVSxNQUFNLENBQUNFLE9BQVAsQ0FBZSxTQUFmLENBQVQ7SUFFQSxJQUFJb0csRUFBRSxHQUFHLENBQUN0RyxNQUFNLENBQUM4RyxPQUFQLENBQWVSLEVBQXpCOztJQUNBLElBQUlLLE9BQU8sQ0FBQyxVQUFELENBQVgsRUFBeUI7TUFDdkIsSUFBSS9ILEdBQUcsR0FBRyxNQUFNbUMsSUFBSSxDQUFFLHdCQUFGLEVBQTJCO1FBQUN1RjtNQUFELENBQTNCLENBQXBCOztNQUNBLElBQUkxSCxHQUFKLEVBQVM7UUFDUFUsRUFBRSxDQUFDTyxNQUFIO01BQ0Q7SUFDRjtFQUNGOztFQUVpQixNQUFad00sWUFBWSxDQUFDck0sTUFBRCxFQUFTO0lBQ3pCLElBQUkrSCxNQUFNLEdBQUc5SyxRQUFDLENBQUMseUJBQUQsQ0FBRCxDQUE2QixDQUE3QixDQUFiO0lBQ0EsSUFBSTBLLFFBQVEsR0FBRzNILE1BQU0sQ0FBQ0UsT0FBUCxDQUFlLGdCQUFmLENBQWY7SUFDQSxJQUFJaU0sSUFBSSxHQUFHLENBQUN4RSxRQUFRLENBQUNyQixFQUFyQjtJQUNBLElBQUlpQixLQUFLLEdBQUdRLE1BQU0sQ0FBQ0YsU0FBUCxDQUFpQixJQUFqQixDQUFaO0lBQ0EsSUFBSXlFLFdBQVcsR0FBRyxLQUFLRixjQUFMLENBQW9CN0UsS0FBcEIsRUFBMkI0RSxJQUEzQixDQUFsQjtJQUNBLElBQUl2TixHQUFHLEdBQUcsTUFBTW1DLElBQUksQ0FBRSxnQ0FBRixFQUFtQ3VMLFdBQW5DLENBQXBCOztJQUNBLElBQUkxTixHQUFKLEVBQVM7TUFDUCxJQUFJQSxHQUFHLENBQUNzRSxHQUFKLENBQVFqRSxLQUFaLEVBQW1CQSxVQUFBLENBQVdMLEdBQUcsQ0FBQ3NFLEdBQUosQ0FBUWpFLEtBQW5COztNQUNuQixJQUFJTCxHQUFHLENBQUNzRSxHQUFKLENBQVFvRCxFQUFaLEVBQWlCO1FBQ2YsSUFBSXJJLElBQUksR0FBRzBKLFFBQVEsQ0FBQ2pFLGdCQUFULENBQTBCLFNBQTFCLEVBQXFDZCxNQUFyQyxHQUE4QyxDQUF6RDtRQUNBMkUsS0FBSyxDQUFDakcsYUFBTixDQUFvQixPQUFwQixFQUE2Qi9DLFNBQTdCLEdBQXlDTixJQUF6QztRQUNBc0osS0FBSyxDQUFDakcsYUFBTixDQUFvQixTQUFwQixFQUErQndGLE9BQS9CLENBQXVDUixFQUF2QyxHQUNFaUIsS0FBSyxDQUFDVCxPQUFOLENBQWNSLEVBQWQsR0FBbUIxSCxHQUFHLENBQUNzRSxHQUFKLENBQVFvRCxFQUQ3QjtRQUVBdEcsTUFBTSxDQUFDMEgsTUFBUCxDQUFjSCxLQUFkO01BQ0Q7SUFFRjtFQUNGOztFQUVENkUsY0FBYyxDQUFDOU0sRUFBRCxFQUFLNk0sSUFBTCxFQUFXO0lBQ3ZCLE9BQU87TUFDTDdGLEVBQUUsRUFBRSxDQUFDaEgsRUFBRSxDQUFDd0gsT0FBSCxDQUFXUixFQURYO01BRUx5QixNQUFNLEVBQUU1SyxPQUFPLENBQUNGLFFBQUMsQ0FBQ3FDLEVBQUQsQ0FBRCxDQUFNNEYsSUFBTixDQUFXLE9BQVgsRUFBb0IzRyxTQUFyQixDQUZWO01BR0xnTyxXQUFXLEVBQUVKLElBSFI7TUFJTEssY0FBYyxFQUFFLENBQUN2UCxRQUFDLENBQUNxQyxFQUFELENBQUQsQ0FBTTRGLElBQU4sQ0FBVyxPQUFYLEVBQW9CbkMsT0FKaEM7TUFLTDBKLElBQUksRUFBRTtJQUxELENBQVA7RUFPRDs7QUFuRFU7O0FBc0ROLElBQUluQixhQUFPLEdBQUcsSUFBSXZELE1BQUosRUFBZCxDOztBQ3hEUDtBQUNBOztBQUVBLE1BQU1KLFFBQU4sQ0FBZTtFQUViOEIsV0FBVyxDQUFDbkssRUFBRCxFQUFLO0lBQ2QsS0FBS3JCLElBQUwsR0FBWVYsUUFBUSxDQUFDbUcsZ0JBQVQsQ0FBMEIsMkJBQTFCLEVBQXVEZCxNQUF2RCxHQUE4RCxDQUE5RCxJQUFvRSxDQUFoRjtFQUNEOztFQUVtQixNQUFkOEosY0FBYyxDQUFDMU0sTUFBRCxFQUFTO0lBQzNCLElBQUkySCxRQUFRLEdBQUcxSyxRQUFDLENBQUMsa0NBQUQsQ0FBRCxDQUFzQyxDQUF0QyxDQUFmO0lBQ0EsSUFBSXNLLEtBQUssR0FBR0ksUUFBUSxDQUFDRSxTQUFULENBQW1CLElBQW5CLENBQVo7SUFDQSxJQUFJOEUsYUFBYSxHQUFHLEtBQUtDLGdCQUFMLENBQXNCckYsS0FBdEIsQ0FBcEI7SUFDQSxJQUFJM0ksR0FBRyxHQUFHLE1BQU1tQyxJQUFJLENBQUUsa0NBQUYsRUFBcUM0TCxhQUFyQyxDQUFwQjs7SUFDQSxJQUFJL04sR0FBSixFQUFTO01BQ1AySSxLQUFLLENBQUNqRyxhQUFOLENBQW9CLE9BQXBCLEVBQTZCL0MsU0FBN0IsR0FBeUMsS0FBS04sSUFBOUM7TUFDQXNKLEtBQUssQ0FBQ2pHLGFBQU4sQ0FBb0IsbUJBQXBCLEVBQXlDd0YsT0FBekMsQ0FBaURSLEVBQWpELEdBQ0VpQixLQUFLLENBQUNULE9BQU4sQ0FBY1IsRUFBZCxHQUFtQjFILEdBQUcsQ0FBQ3NFLEdBQUosQ0FBUW9ELEVBRDdCO01BRUF0RyxNQUFNLENBQUMwSCxNQUFQLENBQWNILEtBQWQ7SUFDRDtFQUNGOztFQUVEcUYsZ0JBQWdCLENBQUN0TixFQUFELEVBQUs7SUFDbkIsT0FBTztNQUNMZ0gsRUFBRSxFQUFFaEgsRUFBRSxDQUFDd0gsT0FBSCxDQUFXUixFQURWO01BRUx1RyxPQUFPLEVBQUUxUCxPQUFPLENBQUNtQyxFQUFFLENBQUNnQyxhQUFILENBQWlCLE9BQWpCLEVBQTBCL0MsU0FBM0IsQ0FGWDtNQUdMOEcsTUFBTSxFQUFFLENBQUN2SCxNQUFNLENBQUMrQyxRQUFQLENBQWdCK0ksSUFBaEIsQ0FBcUJRLEtBQXJCLENBQTJCLEdBQTNCLEVBQWdDQyxHQUFoQyxFQUhKO01BSUxwTSxJQUFJLEVBQUVxQixFQUFFLENBQUNnQyxhQUFILENBQWlCLE9BQWpCLEVBQTBCL0M7SUFKM0IsQ0FBUDtFQU1EOztFQUVpQixNQUFaNkosWUFBWSxDQUFDcEksTUFBRCxFQUFTO0lBQ3pCO0lBQ0EsSUFBSWlMLEdBQUcsR0FBR2pMLE1BQU0sQ0FBQzhDLE9BQVAsQ0FBZTlDLE1BQU0sQ0FBQzhNLGFBQXRCLENBQVY7SUFDQSxJQUFJeEcsRUFBRSxHQUFHdEcsTUFBTSxDQUFDRSxPQUFQLENBQWUsZ0JBQWYsRUFBaUNvRyxFQUExQztJQUNBLElBQUkrQixPQUFPLEdBQUc0QyxHQUFHLENBQUNuRSxPQUFKLENBQVksa0JBQVosQ0FBZDtJQUNBLElBQUl3QixTQUFTLEdBQUcyQyxHQUFHLENBQUM1TSxLQUFwQjtJQUNBLElBQUlPLEdBQUcsR0FBRyxNQUFNbUMsSUFBSSxDQUFDLGdDQUFELEVBQW1DO01BQUN1RixFQUFEO01BQUsrQjtJQUFMLENBQW5DLENBQXBCO0lBQ0EsSUFBSVYsUUFBUSxHQUFHM0gsTUFBTSxDQUFDRSxPQUFQLENBQWUsZ0JBQWYsQ0FBZjtJQUNBeUgsUUFBUSxDQUFDOUgsTUFBVDtFQUNEOztFQUVEMEksV0FBVyxDQUFDdkksTUFBRCxFQUFTO0lBQ2xCLElBQUkrRyxHQUFHLEdBQUcvRyxNQUFNLENBQUNFLE9BQVAsQ0FBZSxnQkFBZixDQUFWO0lBQ0EsSUFBSXNJLE9BQU8sR0FBR3ZMLFFBQUMsQ0FBQzhKLEdBQUQsQ0FBRCxDQUFPN0IsSUFBUCxDQUFZLG9CQUFaLENBQWQ7SUFDQXNELE9BQU8sQ0FBQzVJLFNBQVIsQ0FBa0I4RixNQUFsQixDQUF5QixRQUF6QjtJQUNBOEMsT0FBTyxDQUFDNUksU0FBUixDQUFrQjhGLE1BQWxCLENBQXlCLE9BQXpCO0lBQ0ExRixNQUFNLENBQUNKLFNBQVAsQ0FBaUI4RixNQUFqQixDQUF3QixRQUF4QjtFQUNEOztFQUVRLE1BQUgrQyxHQUFHLENBQUN6SSxNQUFELEVBQVM7SUFDaEIsSUFBSXNILEtBQUssR0FBR3RILE1BQU0sQ0FBQzhHLE9BQVAsQ0FBZVEsS0FBM0I7SUFDQSxJQUFJaEksRUFBRSxHQUFHLElBQVQ7O0lBQ0EsSUFBSWdJLEtBQUssS0FBSyxRQUFkLEVBQXdCO01BQ3RCaEksRUFBRSxHQUFHVSxNQUFNLENBQUNFLE9BQVAsQ0FBZSxTQUFmLENBQUw7SUFDRCxDQUZELE1BRU8sSUFBSW9ILEtBQUssS0FBSyxVQUFkLEVBQTBCO01BQy9CaEksRUFBRSxHQUFHVSxNQUFNLENBQUNFLE9BQVAsQ0FBZSxnQkFBZixDQUFMO0lBQ0Q7O0lBQ0QsSUFBSW9HLEVBQUUsR0FBRyxDQUFDdEcsTUFBTSxDQUFDOEcsT0FBUCxDQUFlUixFQUF6Qjs7SUFDQSxJQUFJSyxPQUFPLENBQUMsVUFBRCxDQUFYLEVBQXlCO01BQ3ZCLElBQUkvSCxHQUFHLEdBQUcsTUFBTW1DLElBQUksQ0FBRSxZQUFXdUcsS0FBTSxTQUFuQixFQUE2QjtRQUFDaEI7TUFBRCxDQUE3QixDQUFwQjs7TUFDQSxJQUFJMUgsR0FBSixFQUFTO1FBQ1BVLEVBQUUsQ0FBQ08sTUFBSDtNQUNEO0lBQ0Y7RUFDRjs7RUFFaUIsTUFBWmtOLFlBQVksQ0FBQy9NLE1BQUQsRUFBUztJQUN6QixJQUFJVixFQUFFLEdBQUdVLE1BQU0sQ0FBQ0UsT0FBUCxDQUFlLGdCQUFmLENBQVQ7O0lBQ0EsSUFBSXlILFFBQVEsR0FBR3FGLFNBQVMsQ0FBQ0osZ0JBQVYsQ0FBMkJ0TixFQUEzQixDQUFmOztJQUNBLElBQUlWLEdBQUcsR0FBRyxNQUFNbUMsSUFBSSxDQUFDLGtDQUFELEVBQXFDNEcsUUFBckMsQ0FBcEI7RUFDRCxDQXBFWSxDQXNFYjtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7OztBQWpGYTs7QUFvRlIsSUFBSXFGLFNBQVMsR0FBRyxJQUFJckYsUUFBSixFQUFoQixDOztBQ3ZGUDtBQUVPLE1BQU02QixTQUFLLEdBQUc7RUFHbkJXLFNBQVMsRUFBRSxNQUFNO0lBQ2YsT0FBTztNQUNMN0QsRUFBRSxFQUFFLENBQUN4SSxNQUFNLENBQUMrQyxRQUFQLENBQWdCK0ksSUFBaEIsQ0FBcUJRLEtBQXJCLENBQTJCLEdBQTNCLEVBQWdDQyxHQUFoQyxFQURBO01BRUxRLElBQUksRUFBRTVOLFFBQUMsQ0FBQyxZQUFELENBQUQsQ0FBZ0IwQixJQUFoQixFQUZEO01BR0wyTCxNQUFNLEVBQUVyTixRQUFDLENBQUMsU0FBRCxDQUFELENBQWEsQ0FBYixDQUhIO01BSUxvSSxNQUFNLEVBQUVwSSxRQUFDLENBQUMsUUFBRCxDQUFELENBQVlzTixrQkFBWjtJQUpILENBQVA7RUFNRCxDQVZrQjtFQVluQkUsUUFBUSxFQUFFLE1BQU07SUFDZCxJQUFJQyxjQUFjLEdBQUd6TixRQUFDLENBQUMsV0FBRCxDQUFELENBQWUyRixNQUFwQztJQUNBLElBQUk4SCxjQUFKLEVBQ0UsT0FBT0EsY0FBUDtJQUNGLE9BQU8sS0FBUDtFQUNELENBakJrQjtFQW1CbkJDLFdBQVcsRUFBRSxZQUFZO0lBQ3ZCLElBQUlDLFNBQVMsR0FBR3BCLFNBQUssQ0FBQ0UsV0FBTixFQUFoQjs7SUFDQWtCLFNBQVMsQ0FBQ3RFLEVBQVYsR0FBZSxDQUFmO0lBQ0FzRSxTQUFTLENBQUNqQixNQUFWLEdBQW1CLENBQW5CO0lBQ0EsSUFBSTNJLEdBQUcsR0FBSSw4QkFBWDtJQUNBLElBQUlwQyxHQUFHLEdBQUcsTUFBTW1DLElBQUksQ0FBQ0MsR0FBRCxFQUFNNEosU0FBTixDQUFwQjs7SUFDQSxJQUFJaE0sR0FBSixFQUFTO01BQ1BkLE1BQU0sQ0FBQytDLFFBQVAsQ0FBZ0IrSSxJQUFoQixHQUF3QixzQkFBcUJoTCxHQUFHLENBQUNzRSxHQUFKLENBQVFvRCxFQUFJLEVBQXpEO0lBQ0Q7RUFDRixDQTVCa0I7RUE4Qm5CQSxFQUFFLEVBQUdBLEVBQUQsSUFBUTtJQUNWLE9BQU9BLEVBQUUsSUFBSXJKLFFBQUMsQ0FBQyxZQUFELENBQUQsQ0FBZ0IsQ0FBaEIsRUFBbUI2SixPQUFuQixDQUEyQjBELE1BQXhDO0VBQ0QsQ0FoQ2tCO0VBaUNuQkssSUFBSSxFQUFFLE1BQU07SUFDVixPQUFPNU4sUUFBQyxDQUFDLFlBQUQsQ0FBRCxDQUFnQixDQUFoQixFQUFtQnNCLFNBQTFCO0VBQ0QsQ0FuQ2tCO0VBcUNuQjRJLE1BQU0sRUFBRSxZQUFZO0lBQ2xCLElBQUl0SSxJQUFJLEdBQUcySyxTQUFLLENBQUNFLFdBQU4sRUFBWDs7SUFDQTdLLElBQUksQ0FBQ3lILEVBQUwsR0FBVSxDQUFWO0lBQ0F6SCxJQUFJLENBQUM4SyxNQUFMLEdBQWMsQ0FBZDtJQUNBLElBQUkzSSxHQUFHLEdBQUksc0JBQVg7SUFDQSxJQUFJcEMsR0FBRyxHQUFHLE1BQU1tQyxJQUFJLENBQUNDLEdBQUQsRUFBTW5DLElBQU4sQ0FBcEI7SUFDQTs7SUFDQSxJQUFJRCxHQUFKLEVBQVM7TUFDUGQsTUFBTSxDQUFDK0MsUUFBUCxDQUFnQitJLElBQWhCLEdBQXdCLHNCQUFxQmhMLEdBQUcsQ0FBQ3NFLEdBQUosQ0FBUW9ELEVBQUcsRUFBeEQ7SUFDRDtFQUNGLENBL0NrQjtFQWtEbkJvRCxXQUFXLEVBQUUsTUFBTTtJQUNqQixJQUFJcEQsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDeEksTUFBTSxDQUFDK0MsUUFBUCxDQUFnQitJLElBQWhCLENBQXFCUSxLQUFyQixDQUEyQixHQUEzQixFQUFnQ0MsR0FBaEMsRUFBWjtJQUNBL0QsRUFBRSxHQUFHQSxFQUFFLEdBQUdBLEVBQUgsR0FBUSxDQUFmO0lBQ0EsSUFBSWdCLEtBQUssR0FBRztNQUNWaEIsRUFEVTtNQUVWdUUsSUFBSSxFQUFFNU4sUUFBQyxDQUFDLGFBQUQsQ0FBRCxDQUFpQixDQUFqQixFQUFvQm9CLEtBRmhCO01BR1ZzTCxNQUFNLEVBQUUsQ0FBQzFNLFFBQUMsQ0FBQyxVQUFELENBQUQsQ0FBYyxDQUFkLEVBQWlCc0UsWUFBakIsQ0FBOEIsUUFBOUI7SUFIQyxDQUFaLENBSGlCLENBUWpCOztJQUNBLElBQUkySixNQUFNLEdBQUdqTyxRQUFDLENBQUMsaUJBQUQsQ0FBZDtJQUNBLEdBQUdrRyxPQUFILENBQVdtQixJQUFYLENBQWdCNEcsTUFBaEIsRUFBd0IsVUFBVUMsS0FBVixFQUFpQjtNQUN2QzdELEtBQUssQ0FBQzZELEtBQUssQ0FBQ3JFLE9BQU4sQ0FBYyxPQUFkLENBQUQsQ0FBTCxHQUFnQ3FFLEtBQUssQ0FBQ3JFLE9BQU4sQ0FBYyxJQUFkLENBQWhDO0lBQ0QsQ0FGRDtJQUdBLE9BQU9RLEtBQVA7RUFDRCxDQWhFa0I7RUFrRW5COEQsTUFBTSxFQUFFLFlBQVk7SUFDbEIsSUFBSTlELEtBQUssR0FBR2tDLFNBQUssQ0FBQ0UsV0FBTixFQUFaOztJQUNBLElBQUkxSSxHQUFHLEdBQUksd0JBQXVCc0csS0FBSyxDQUFDaEIsRUFBRyxFQUEzQztJQUNBLElBQUkxSCxHQUFHLEdBQUcsTUFBTW1DLElBQUksQ0FBQ0MsR0FBRCxFQUFNc0csS0FBTixDQUFwQjs7SUFDQSxJQUFJMUksR0FBSixFQUFTO01BQ1BkLE1BQU0sQ0FBQytDLFFBQVAsQ0FBZ0IrSSxJQUFoQixHQUF3QixzQkFBcUJ0QyxLQUFLLENBQUNoQixFQUFHLEVBQXREO0lBQ0Q7RUFDRixDQXpFa0I7RUEyRW5CSSxNQUFNLEVBQUUsa0JBQWtCO0lBRXhCLElBQUk4QyxTQUFLLENBQUNpQixRQUFOLEVBQUosRUFBc0I7TUFDcEJ4TCxVQUFBLENBQVcsb0NBQVg7TUFDQSxPQUFPLEtBQVA7SUFDRDs7SUFFRCxJQUFJcUgsRUFBRSxHQUFHa0QsU0FBSyxDQUFDbEQsRUFBTixFQUFUOztJQUNBLElBQUkxSCxHQUFHLEdBQUcsTUFBTW1DLElBQUksQ0FBQyxzQkFBRCxFQUF5QjtNQUFDdUY7SUFBRCxDQUF6QixDQUFwQjs7SUFDQSxJQUFJMUgsR0FBRyxDQUFDeU0sUUFBUixFQUFrQjtNQUNoQnBNLFVBQUEsQ0FBVyxtRUFBWDtNQUNBL0MsVUFBVSxDQUFDLE1BQU07UUFDZjRCLE1BQU0sQ0FBQytDLFFBQVAsR0FBa0Isd0JBQWxCO01BQ0QsQ0FGUyxFQUVQLElBRk8sQ0FBVjtJQUdELENBTEQsTUFLTztNQUNML0MsTUFBTSxDQUFDK0MsUUFBUCxHQUFrQix3QkFBbEI7SUFDRDtFQUVGLENBN0ZrQixDQThGbkI7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7O0FBcEdtQixDQUFkLEM7O0FDRlA7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHZSxTQUFTcU0sUUFBVCxHQUFvQjtFQUVqQyxJQUFJQSxRQUFRLEdBQUdqUSxRQUFDLENBQUMsb0JBQUQsQ0FBRCxDQUF3QixDQUF4QixDQUFmOztFQUNBLElBQUlpUSxRQUFKLEVBQWM7SUFFWnRFLFFBQVEsQ0FBQywrQkFBRCxFQUNOLDJCQURNLEVBRU4sVUFGTSxDQUFSLENBRlksQ0FLWjs7SUFFQTNMLFFBQUMsQ0FBQ2lRLFFBQUQsQ0FBRCxDQUFZdkosRUFBWixDQUFlLE9BQWYsRUFBd0J3SixvQkFBeEI7SUFDQWxRLFFBQUMsQ0FBQ2lRLFFBQUQsQ0FBRCxDQUFZdkosRUFBWixDQUFlLFFBQWYsRUFBeUJpSSxzQkFBekI7SUFDQTNPLFFBQUMsQ0FBQ2lRLFFBQUQsQ0FBRCxDQUFZdkosRUFBWixDQUFlLE9BQWYsRUFBd0JrRCxxQkFBeEI7RUFDRDtBQUNGOztBQUVELFNBQVNBLHFCQUFULE9BQStCO0VBQUEsSUFBVjtJQUFDN0c7RUFBRCxDQUFVOztFQUU3QixJQUFJQSxNQUFNLENBQUNKLFNBQVAsQ0FBaUJLLFFBQWpCLENBQTBCLG1CQUExQixDQUFKLEVBQW9EO0lBQ2xEdUosZ0JBQUE7RUFDRCxDQUZELE1BRU8sSUFBSXhKLE1BQU0sQ0FBQ0osU0FBUCxDQUFpQkssUUFBakIsQ0FBMEIsY0FBMUIsQ0FBSixFQUErQztJQUNwRHVKLGdCQUFBO0VBQ0QsQ0FGTSxNQUVBLElBQUl4SixNQUFNLENBQUNKLFNBQVAsQ0FBaUJLLFFBQWpCLENBQTBCLFlBQTFCLENBQUosRUFBNkM7SUFDbER1SixnQkFBQTtFQUNELENBRk0sTUFFQSxJQUFJeEosTUFBTSxDQUFDSixTQUFQLENBQWlCSyxRQUFqQixDQUEwQixjQUExQixDQUFKLEVBQStDO0lBQ3BEdUosbUJBQUE7RUFDRCxDQUZNLE1BRUEsSUFBSXhKLE1BQU0sQ0FBQ0osU0FBUCxDQUFpQkssUUFBakIsQ0FBMEIsbUJBQTFCLENBQUosRUFBb0Q7SUFDekR1SixxQkFBQTtFQUNELENBRk0sTUFFQSxJQUFJeEosTUFBTSxDQUFDSixTQUFQLENBQWlCSyxRQUFqQixDQUEwQixjQUExQixDQUFKLEVBQStDO0lBQ3BEdUosZ0JBQUE7RUFDRCxDQUZNLE1BRUEsSUFBSSxDQUFDLENBQUN4SixNQUFNLENBQUNFLE9BQVAsQ0FBZSx5QkFBZixDQUFOLEVBQWlEO0lBQ3REOE0scUJBQUEsQ0FBc0JoTixNQUF0QjtFQUNELENBRk0sTUFFQSxJQUFJQSxNQUFNLENBQUNKLFNBQVAsQ0FBaUJLLFFBQWpCLENBQTBCLHlCQUExQixDQUFKLEVBQTBEO0lBQy9EK00sd0JBQUEsQ0FBeUJoTixNQUF6QjtFQUNELENBRk0sTUFFQSxJQUFJLENBQUMsQ0FBQ0EsTUFBTSxDQUFDRSxPQUFQLENBQWUsbUJBQWYsQ0FBTixFQUEyQztJQUNoRDhNLGFBQUEsQ0FBY2hOLE1BQWQ7RUFDRCxDQUZNLE1BRUEsSUFBSSxDQUFDLENBQUNBLE1BQU0sQ0FBQ0UsT0FBUCxDQUFlLFNBQWYsQ0FBTixFQUFpQztJQUN0Q29MLGlCQUFBLENBQVl0TCxNQUFaO0VBQ0QsQ0FGTSxNQUVBLElBQUlBLE1BQU0sQ0FBQ0osU0FBUCxDQUFpQkssUUFBakIsQ0FBMEIsdUJBQTFCLENBQUosRUFBd0Q7SUFDN0RxTCwwQkFBQSxDQUFxQnRMLE1BQXJCO0VBQ0QsQ0FGTSxNQUVBLElBQUlBLE1BQU0sQ0FBQ0osU0FBUCxDQUFpQkssUUFBakIsQ0FBMEIsU0FBMUIsQ0FBSixFQUEwQztJQUMvQ3FMLHdCQUFBLENBQW1CdEwsTUFBbkI7RUFDRDtBQUNGOztBQUVELElBQUltTixvQkFBb0IsR0FBR3pSLFFBQVEsQ0FBQ21RLFdBQUQsQ0FBbkM7O0FBRUEsZUFBZUEsV0FBZixRQUFxQztFQUFBLElBQVY7SUFBQzdMO0VBQUQsQ0FBVTs7RUFDbkMsSUFBSUEsTUFBTSxDQUFDSixTQUFQLENBQWlCSyxRQUFqQixDQUEwQixNQUExQixDQUFKLEVBQXVDO0lBQ3JDLElBQUk4SCxNQUFNLEdBQUcvSCxNQUFNLENBQUNFLE9BQVAsQ0FBZSxTQUFmLENBQWI7O0lBQ0EsSUFBSTZILE1BQUosRUFBWTtNQUNWdUQsd0JBQUEsQ0FBbUJ0TCxNQUFuQjtJQUNELENBRkQsTUFFTztNQUNMZ04sc0JBQUEsQ0FBdUJoTixNQUF2QjtJQUNEO0VBQ0Y7QUFDRjs7QUFFRCxlQUFlNEwsc0JBQWYsUUFBc0M7RUFBQSxJQUFWO0lBQUM1TDtFQUFELENBQVU7O0VBQ3BDLElBQUksQ0FBQyxDQUFDQSxNQUFNLENBQUNFLE9BQVAsQ0FBZSwrQkFBZixDQUFOLEVBQXVEO0lBQ3JEOE0sc0JBQUEsQ0FBdUJoTixNQUF2QjtFQUNEO0FBQ0YsQzs7QUMvRUQ7QUFDQTtBQUVBLElBQUlvTixVQUFVLEdBQUduUSxRQUFDLENBQUMsYUFBRCxDQUFELENBQWlCLENBQWpCLENBQWpCOztBQUVBLElBQUltUSxVQUFKLEVBQWdCO0VBQ2RDLE9BQU87RUFDUHBRLFFBQUMsQ0FBQ21RLFVBQUQsQ0FBRCxDQUFjekosRUFBZCxDQUFpQixPQUFqQixFQUEwQmtELDJCQUExQjtBQUNEOztBQUVELFNBQVNBLDJCQUFULE9BQStCO0VBQUEsSUFBVjtJQUFDN0c7RUFBRCxDQUFVO0VBRTdCLElBQUksQ0FBQ0EsTUFBTSxDQUFDOEcsT0FBUCxDQUFlc0csVUFBcEIsRUFBZ0M7RUFFaEMsSUFBSXBOLE1BQU0sQ0FBQ0osU0FBUCxDQUFpQkssUUFBakIsQ0FBMEIsUUFBMUIsQ0FBSixFQUF5QztFQUV6QyxJQUFJcU4sVUFBVSxHQUFHclEsUUFBQyxDQUFDLHFCQUFELENBQUQsQ0FBeUIsQ0FBekIsQ0FBakI7RUFDQXFRLFVBQVUsQ0FBQzFOLFNBQVgsQ0FBcUJDLE1BQXJCLENBQTRCLFFBQTVCO0VBQ0FHLE1BQU0sQ0FBQ0osU0FBUCxDQUFpQkUsR0FBakIsQ0FBcUIsUUFBckI7RUFFQSxJQUFJeU4sVUFBVSxHQUFHRCxVQUFVLENBQUN4RyxPQUFYLENBQW1CLFlBQW5CLENBQWpCO0VBQ0E3SixRQUFDLENBQUUsc0JBQXFCc1EsVUFBVyxJQUFsQyxDQUFELENBQXdDbEwsV0FBeEMsQ0FBb0QsTUFBcEQ7RUFFQSxJQUFJbUwsVUFBVSxHQUFHeE4sTUFBTSxDQUFDOEcsT0FBUCxDQUFlLFlBQWYsQ0FBakI7RUFDQTdKLFFBQUMsQ0FBRSxzQkFBcUJ1USxVQUFXLElBQWxDLENBQUQsQ0FBd0NqTCxRQUF4QyxDQUFpRCxNQUFqRDtBQUNEOztBQUVELFNBQVM4SyxPQUFULEdBQW1CO0VBQ2pCLElBQUlJLFdBQVcsR0FBR3hRLFFBQUMsQ0FBQyxtQkFBRCxDQUFuQjtFQUNBLElBQUksQ0FBQ3dRLFdBQVcsQ0FBQyxDQUFELENBQWhCLEVBQXFCLE9BQU8sS0FBUDtFQUNyQmxOLEtBQUssQ0FBQ0MsSUFBTixDQUFXaU4sV0FBWCxFQUF3QmpILEdBQXhCLENBQTZCa0gsR0FBRCxJQUFTO0lBQ25DQSxHQUFHLENBQUM5TixTQUFKLENBQWNDLE1BQWQsQ0FBcUIsUUFBckI7RUFDRCxDQUZEO0VBR0E0TixXQUFXLENBQUMsQ0FBRCxDQUFYLENBQWU3TixTQUFmLENBQXlCRSxHQUF6QixDQUE2QixRQUE3QjtBQUNELEVBRUQsbUI7O0FDcENBO0FBQ0E7QUFFQTtBQUVBLElBQUk2TixNQUFNLEdBQUcxUSxRQUFDLENBQUMsVUFBRCxDQUFkOztBQUNBLElBQUkwUSxNQUFKLEVBQVk7RUFDVkMsY0FBYztFQUNkQyxhQUFhO0VBQ2I1USxRQUFDLENBQUMsVUFBRCxDQUFELENBQWMwRyxFQUFkLENBQWlCLE9BQWpCLEVBQTBCa0QsY0FBMUI7QUFDRDs7QUFFRCxTQUFTZ0gsYUFBVCxHQUF5QjtFQUN2QixJQUFJdEMsTUFBTSxHQUFHdE8sUUFBQyxDQUFDLHNCQUFELENBQUQsQ0FBMEIsQ0FBMUIsQ0FBYjs7RUFDQSxJQUFJc08sTUFBSixFQUFZO0lBQ1YsSUFBSXpOLE1BQU0sQ0FBQytDLFFBQVAsQ0FBZ0JpTixRQUFoQixDQUF5QnhQLEtBQXpCLENBQStCLGtCQUEvQixDQUFKLEVBQXdEO01BQ3REaU4sTUFBTSxDQUFDM0wsU0FBUCxDQUFpQkUsR0FBakIsQ0FBcUIsVUFBckI7SUFDRDtFQUNGO0FBQ0Y7O0FBRUQsU0FBUytHLGNBQVQsT0FBK0I7RUFBQSxJQUFWO0lBQUM3RztFQUFELENBQVU7RUFDN0IsSUFBSUEsTUFBTSxDQUFDSixTQUFQLENBQWlCSyxRQUFqQixDQUEwQixnQkFBMUIsQ0FBSixFQUFpRDtFQUNqRCxJQUFJOE4sU0FBUyxHQUFHOVEsUUFBQyxDQUFDLGdCQUFELENBQUQsQ0FBb0IsQ0FBcEIsS0FBd0IsRUFBeEM7RUFDQSxJQUFJcUosRUFBRSxHQUFHLENBQUN5SCxTQUFTLEVBQUVqSCxPQUFYLENBQW1CUixFQUFwQixJQUF3QixFQUFqQztFQUNBLElBQUkwSCxJQUFJLEdBQUcvUSxRQUFDLENBQUMsbUJBQUQsQ0FBRCxJQUF3QixFQUFuQztFQUNBLElBQUlnUixRQUFRLEdBQUdELElBQUksQ0FBQ0UsU0FBTCxDQUFlNU8sRUFBRSxJQUFFQSxFQUFFLENBQUNNLFNBQUgsQ0FBYUssUUFBYixDQUFzQixRQUF0QixDQUFuQixLQUFxRCxFQUFwRTs7RUFFQSxJQUFJRCxNQUFNLENBQUNtTyxJQUFQLEtBQWdCLFVBQXBCLEVBQWdDO0lBQzlCLElBQUlDLENBQUMsR0FBR3BPLE1BQU0sQ0FBQ3FPLE1BQVAsQ0FBYyxDQUFkLENBQVI7SUFDQUQsQ0FBQyxDQUFDeE8sU0FBRixDQUFZOEYsTUFBWixDQUFtQixRQUFuQjtFQUNELENBSEQsTUFHTyxJQUFJMUYsTUFBTSxDQUFDc0csRUFBUCxLQUFjLE1BQWxCLEVBQTBCO0lBQy9CZ0ksS0FBSztFQUNOLENBRk0sTUFFQSxJQUFJdE8sTUFBTSxDQUFDc0csRUFBUCxLQUFjLE1BQWxCLEVBQTBCO0lBQy9CaUksS0FBSztFQUNOOztFQUVELFNBQVNELEtBQVQsR0FBaUI7SUFDZixJQUFJTCxRQUFRLEdBQUcsQ0FBZixFQUFrQixPQUFPLEtBQVA7SUFDbEIsSUFBSU8sS0FBSyxHQUFHLENBQUNSLElBQUksQ0FBQ0MsUUFBUSxHQUFHLENBQVosQ0FBSixDQUFtQm5ILE9BQW5CLENBQTJCc0csVUFBeEM7SUFDQXFCLE9BQU8sQ0FBQ25JLEVBQUQsRUFBS2tJLEtBQUwsQ0FBUDtJQUNBRSxLQUFLLENBQUNGLEtBQUQsQ0FBTDtFQUNEOztFQUVELFNBQVNELEtBQVQsR0FBaUI7SUFDZixJQUFJTixRQUFRLEtBQUtELElBQUksQ0FBQ3BMLE1BQUwsR0FBWSxDQUE3QixFQUFnQyxPQUFPLEtBQVA7SUFDaEMsSUFBSTRMLEtBQUssR0FBRyxDQUFDUixJQUFJLENBQUNDLFFBQVEsR0FBRyxDQUFaLENBQUosQ0FBbUJuSCxPQUFuQixDQUEyQnNHLFVBQXhDO0lBRUFxQixPQUFPLENBQUNuSSxFQUFELEVBQUtrSSxLQUFMLENBQVA7SUFDQUUsS0FBSyxDQUFDRixLQUFELENBQUw7RUFDRDs7RUFFRCxTQUFTQyxPQUFULENBQWlCRSxTQUFqQixFQUE0QkMsUUFBNUIsRUFBc0M7SUFDcEMsSUFBSUMsU0FBUyxHQUFHNVIsUUFBQyxDQUFFLHFCQUFvQjBSLFNBQVUsSUFBaEMsQ0FBRCxDQUFzQyxDQUF0QyxDQUFoQjtJQUNBRSxTQUFTLENBQUNqUCxTQUFWLENBQW9COEYsTUFBcEIsQ0FBMkIsUUFBM0I7SUFFQSxJQUFJb0osS0FBSyxHQUFHN1IsUUFBQyxDQUFFLHFCQUFvQjJSLFFBQVMsSUFBL0IsQ0FBRCxDQUFxQyxDQUFyQyxDQUFaO0lBQ0FFLEtBQUssQ0FBQ2xQLFNBQU4sQ0FBZ0I4RixNQUFoQixDQUF1QixRQUF2QjtFQUNEOztFQUVELFNBQVNnSixLQUFULENBQWVGLEtBQWYsRUFBc0I7SUFDcEJULFNBQVMsQ0FBQ25PLFNBQVYsQ0FBb0I4RixNQUFwQixDQUEyQixNQUEzQjtJQUNBLElBQUlxSixXQUFXLEdBQUc5UixRQUFDLENBQUUsc0JBQXFCdVIsS0FBTSxJQUE3QixDQUFELENBQW1DLENBQW5DLENBQWxCO0lBQ0FPLFdBQVcsQ0FBQ25QLFNBQVosQ0FBc0I4RixNQUF0QixDQUE2QixNQUE3QjtFQUNEO0FBQ0Y7O0FBRUQsU0FBU2tJLGNBQVQsR0FBMEI7RUFDeEIzUSxRQUFDLENBQUMsV0FBRCxDQUFELENBQWVvRixXQUFmLENBQTJCLE1BQTNCO0VBQ0FwRixRQUFDLENBQUMsdUJBQUQsQ0FBRCxDQUEyQnNGLFFBQTNCLENBQW9DLE1BQXBDO0FBQ0Q7O0FBRUR0RixRQUFDLENBQUMsc0JBQUQsQ0FBRCxDQUEwQjBHLEVBQTFCLENBQTZCLE9BQTdCLEVBQXNDLGdCQUFnQnBILENBQWhCLEVBQW1CO0VBRXZELElBQUlnUCxNQUFNLEdBQUdoUCxDQUFDLENBQUN5RCxNQUFmO0VBQ0EsSUFBSXVMLE1BQU0sQ0FBQ2pGLEVBQVAsS0FBYyxNQUFsQixFQUEwQixPQUFPLEtBQVA7O0VBRTFCLElBQUlpRixNQUFNLENBQUM1TSxJQUFQLEtBQWdCLG9CQUFwQixFQUEwQztJQUN4Q2tDLFFBQVEsQ0FBQ21PLE1BQVQ7SUFDQTtFQUNEOztFQUNEekQsTUFBTSxDQUFDNU0sSUFBUCxHQUFjLG9CQUFkO0VBRUE0TSxNQUFNLENBQUMzTCxTQUFQLENBQWlCRSxHQUFqQixDQUFxQixVQUFyQjtFQUVBLElBQUltUCxXQUFXLEdBQUcsTUFBTWxPLElBQUksQ0FBQyx5QkFBRCxFQUE0QixFQUE1QixDQUE1QjtFQUNBa08sV0FBVyxHQUFHQSxXQUFXLENBQUMsS0FBRCxDQUF6QjtFQUNBLElBQUlDLFFBQVEsR0FBR0MsU0FBUyxDQUFDRixXQUFELENBQXhCO0VBRUEsSUFBSWhPLElBQUksR0FBR21PLFdBQVcsQ0FBQ0YsUUFBRCxDQUF0QjtFQUNBLElBQUl0USxHQUFHLEdBQUcsTUFBTW1DLElBQUksQ0FBQyw0QkFBRCxFQUErQkUsSUFBL0IsQ0FBcEI7O0VBQ0EsSUFBSXJDLEdBQUosRUFBUztJQUNQM0IsUUFBQyxDQUFDLE9BQUQsQ0FBRCxDQUFXLENBQVgsRUFBYzJNLElBQWQsR0FBcUIvSSxRQUFRLENBQUMrSSxJQUE5QjtJQUNBM00sUUFBQyxDQUFDLE9BQUQsQ0FBRCxDQUFXLENBQVgsRUFBYzBCLElBQWQsR0FBcUIsb0JBQXJCO0VBQ0Q7QUFDRixDQXZCRDs7QUEwQkEsU0FBU3lRLFdBQVQsQ0FBcUJGLFFBQXJCLEVBQStCO0VBQzdCLE9BQU87SUFDTDdILFdBQVcsRUFBRXBLLFFBQUMsQ0FBQyxXQUFELENBQUQsQ0FBZTJGLE1BRHZCO0lBRUxzTSxRQUFRLEVBQUVBLFFBRkw7SUFHTGxTLElBQUksRUFBRUYsU0FBUyxDQUFDLFVBQUQsQ0FIVjtJQUlMME4sTUFBTSxFQUFFdk4sUUFBQyxDQUFDLGdCQUFELENBQUQsQ0FBb0IsQ0FBcEIsRUFBdUI2SixPQUF2QixDQUErQkksTUFKbEM7SUFLTG1JLFFBQVEsRUFBRXBTLFFBQUMsQ0FBQyxZQUFELENBQUQsQ0FBZ0IsQ0FBaEIsRUFBbUJzQixTQUx4QjtJQU1MK1EsSUFBSSxFQUFFclMsUUFBQyxDQUFDLGlCQUFELENBQUQsQ0FBcUIsQ0FBckIsRUFBd0JzQjtFQU56QixDQUFQO0FBUUQ7O0FBR0QsU0FBUzRRLFNBQVQsQ0FBbUJJLGNBQW5CLEVBQW1DO0VBQ2pDLElBQUkzSCxDQUFDLEdBQUczSyxRQUFDLENBQUMsV0FBRCxDQUFUO0VBQ0EsR0FBR3VKLEdBQUgsQ0FBT2xDLElBQVAsQ0FBWXNELENBQVosRUFBZSxVQUFVRCxRQUFWLEVBQW9CO0lBQ2pDLElBQUlhLE9BQU8sR0FBR2IsUUFBUSxDQUFDakUsZ0JBQVQsQ0FBMEIsSUFBMUIsQ0FBZDtJQUNBLElBQUk4TCxNQUFNLEdBQUcsRUFBYjtJQUNBLEdBQUdoSixHQUFILENBQU9sQyxJQUFQLENBQVlrRSxPQUFaLEVBQXFCLFVBQVVULE1BQVYsRUFBa0I7TUFDckMsSUFBSTBILEtBQUssR0FBR3hTLFFBQUMsQ0FBQzhLLE1BQUQsQ0FBRCxDQUFVN0MsSUFBVixDQUFlLE9BQWYsQ0FBWjtNQUNBLElBQUlvQixFQUFFLEdBQUd5QixNQUFNLENBQUNqQixPQUFQLENBQWVSLEVBQXhCO01BQ0FvSixtQkFBbUIsQ0FBQ0YsTUFBRCxFQUFTbEosRUFBVCxFQUFhaUosY0FBYixFQUE2QkUsS0FBN0IsRUFBb0MxSCxNQUFwQyxDQUFuQjtJQUNELENBSkQ7SUFNQSxJQUFJekIsRUFBRSxHQUFHcUIsUUFBUSxDQUFDYixPQUFULENBQWlCLElBQWpCLENBQVQsQ0FUaUMsQ0FTRDs7SUFDaEMsSUFBSTZJLFNBQVMsR0FBRzFTLFFBQUMsQ0FBRSxpQ0FBZ0MsQ0FBQ3FKLEVBQUcsSUFBdEMsQ0FBRCxDQUE0QyxDQUE1QyxDQUFoQjs7SUFDQSxJQUFJa0osTUFBTSxDQUFDNU0sTUFBWCxFQUFtQjtNQUNqQjNGLFFBQUMsQ0FBQzBTLFNBQUQsQ0FBRCxDQUFhcE4sUUFBYixDQUFzQixXQUF0QjtJQUNELENBRkQsTUFFTztNQUNMdEYsUUFBQyxDQUFDMFMsU0FBRCxDQUFELENBQWFwTixRQUFiLENBQXNCLGFBQXRCO0lBQ0Q7RUFDRixDQWhCRDtFQWlCQSxPQUFPdEYsUUFBQyxDQUFDLFlBQUQsQ0FBRCxDQUFnQjJGLE1BQXZCO0FBQ0Q7O0FBRUQsU0FBUzhNLG1CQUFULENBQTZCRixNQUE3QixFQUFxQ2xKLEVBQXJDLEVBQXlDaUosY0FBekMsRUFBeURFLEtBQXpELEVBQWdFMUgsTUFBaEUsRUFBd0U7RUFDdEUsSUFBSTZILFlBQVksR0FBR0wsY0FBYyxDQUFDTSxPQUFmLENBQXVCdkosRUFBdkIsTUFBK0IsQ0FBQyxDQUFuRDtFQUNBLElBQUl2RCxPQUFPLEdBQUcwTSxLQUFLLENBQUMxTSxPQUFwQjs7RUFFQSxJQUFJQSxPQUFPLElBQUk2TSxZQUFmLEVBQTZCO0lBQUM7SUFDNUI3SCxNQUFNLENBQUNuSSxTQUFQLENBQWlCRSxHQUFqQixDQUFxQixNQUFyQixFQUQyQixDQUNHO0VBQy9CLENBRkQsTUFFTyxJQUFJaUQsT0FBTyxJQUFJLENBQUM2TSxZQUFoQixFQUE4QjtJQUFDO0lBQ3BDSixNQUFNLENBQUNuTSxJQUFQLENBQVksSUFBWjtFQUNELENBRk0sTUFFQSxJQUFJLENBQUNOLE9BQUQsSUFBWTZNLFlBQWhCLEVBQThCO0lBQUM7SUFDcEM3SCxNQUFNLENBQUNuSSxTQUFQLENBQWlCRSxHQUFqQixDQUFxQixNQUFyQixFQURtQyxDQUNMOztJQUM5QjBQLE1BQU0sQ0FBQ25NLElBQVAsQ0FBWSxJQUFaO0VBQ0QsQ0FITSxNQUdBLElBQUksQ0FBQ04sT0FBRCxJQUFZLENBQUM2TSxZQUFqQixFQUErQixDQUFDO0VBQ3RDO0FBQ0YsQzs7QUNqSkQ7QUFDQTtBQUVlLFNBQVNFLElBQVQsR0FBZ0I7RUFDN0IsTUFBTUMsTUFBTSxHQUFHOVMsUUFBQyxDQUFDLHVCQUFELENBQWhCOztFQUNBLElBQUk4UyxNQUFKLEVBQVk7SUFDVixHQUFHNU0sT0FBSCxDQUFXbUIsSUFBWCxDQUFnQnlMLE1BQWhCLEVBQXdCLFVBQVVDLEtBQVYsRUFBaUI7TUFFdkMsTUFBTUMsZUFBZSxHQUFHaFQsUUFBQyxDQUFDLG1CQUFELENBQXpCO01BQ0EsTUFBTWlULE9BQU8sR0FBR0YsS0FBSyxDQUFDdE0sZ0JBQU4sQ0FBdUIsT0FBdkIsQ0FBaEI7TUFDQSxNQUFNeU0sU0FBUyxHQUFHSCxLQUFLLENBQUN0TSxnQkFBTixDQUF1QixhQUF2QixDQUFsQjtNQUNBLE1BQU0wTSxNQUFNLEdBQUduVCxRQUFDLENBQUMrUyxLQUFELENBQUQsQ0FBU0ssT0FBVCxDQUFpQixhQUFqQixDQUFmO01BQ0EsTUFBTUMsR0FBRyxHQUFHclQsUUFBQyxDQUFDK1MsS0FBRCxDQUFELENBQVMsQ0FBVCxFQUFZdE0sZ0JBQVosQ0FBNkIsZUFBN0IsQ0FBWjtNQUNBLE1BQU02TSxTQUFTLEdBQUdQLEtBQUssQ0FBQ2xKLE9BQU4sQ0FBYyxPQUFkLENBQWxCO01BQ0EsTUFBTTBKLElBQUksR0FBRyxFQUFiO01BRUF2VCxRQUFDLENBQUMrUyxLQUFELENBQUQsQ0FBU3JNLEVBQVQsQ0FBWSxPQUFaLEVBQXFCa0QsV0FBVyxDQUFDbkMsSUFBWixDQUFpQixJQUFqQixDQUFyQjtNQUNBekgsUUFBQyxDQUFDK1MsS0FBRCxDQUFELENBQVNyTSxFQUFULENBQVksT0FBWixFQUFxQjhNLFdBQVcsQ0FBQy9MLElBQVosQ0FBaUIsSUFBakIsQ0FBckI7TUFFQSxJQUFJcUgsY0FBYyxHQUFHclEsUUFBUSxDQUFDZ1YsV0FBRCxDQUE3Qjs7TUFFQSxTQUFTRCxXQUFULE9BQStCO1FBQUEsSUFBVjtVQUFDelE7UUFBRCxDQUFVOztRQUU3QjtRQUNBLElBQUlBLE1BQU0sQ0FBQzJRLFlBQVAsQ0FBb0IsaUJBQXBCLENBQUosRUFBNEM7VUFDMUM1RSxjQUFjLENBQUNpRSxLQUFELEVBQVFDLGVBQVIsRUFBeUJqUSxNQUF6QixDQUFkLENBRDBDLENBRzFDO1FBQ0QsQ0FKRCxNQUlPLElBQUlBLE1BQU0sQ0FBQ0UsT0FBUCxDQUFlLE9BQWYsQ0FBSixFQUE2QjtVQUNsQyxJQUFJMFEsTUFBTSxHQUFHNVEsTUFBTSxDQUFDRSxPQUFQLENBQWUsT0FBZixDQUFiO1VBQ0EsSUFBSTJRLEtBQUssR0FBRyxHQUFHM0MsU0FBSCxDQUFhNUosSUFBYixDQUFrQjRMLE9BQWxCLEVBQTJCLENBQUM1USxFQUFELEVBQUttSCxDQUFMLEVBQVEySixNQUFSLEtBQW1CO1lBQ3hELE9BQU85USxFQUFFLEtBQUtzUixNQUFkO1VBQ0QsQ0FGVyxDQUFaO1VBR0E5UCxNQUFNLENBQUMrUCxLQUFELEVBQVE3USxNQUFSLENBQU47UUFDRDtNQUNGOztNQUVELFNBQVM2RyxXQUFULFFBQStCO1FBQUEsSUFBVjtVQUFDN0c7UUFBRCxDQUFVOztRQUU3QjtRQUNBLElBQUlBLE1BQU0sQ0FBQ2pELFNBQVAsS0FBcUIsV0FBekIsRUFBc0M7VUFDcEMrVCxXQUFXLENBQUNQLFNBQUQsQ0FBWCxDQURvQyxDQUdwQztRQUNELENBSkQsTUFJTyxJQUNMdlEsTUFBTSxDQUFDakQsU0FBUCxLQUFxQixpQkFBckIsSUFDQWlELE1BQU0sQ0FBQ0UsT0FBUCxDQUFlLGlCQUFmLENBRkssRUFFOEI7VUFDbkM2USxRQUFRLENBQUMvUSxNQUFNLENBQUNFLE9BQVAsQ0FBZSxpQkFBZixDQUFELENBQVIsQ0FEbUMsQ0FHbkM7UUFDRCxDQU5NLE1BTUEsSUFBSUYsTUFBTSxDQUFDakQsU0FBUCxLQUFxQixrQkFBckIsSUFDVGlELE1BQU0sQ0FBQ0UsT0FBUCxDQUFlLGtCQUFmLENBREssRUFDK0I7VUFDcEMsSUFBSW9HLEVBQUUsR0FBR3RHLE1BQU0sQ0FBQ0UsT0FBUCxDQUFlLGtCQUFmLEVBQW1DNEcsT0FBbkMsQ0FBMkMsSUFBM0MsQ0FBVDtVQUNBaEosTUFBTSxDQUFDK0MsUUFBUCxHQUFtQixZQUFXMFAsU0FBVSxTQUFRakssRUFBRyxFQUFuRCxDQUZvQyxDQUlwQztRQUNELENBTk0sTUFNQSxJQUFJdEcsTUFBTSxDQUFDSixTQUFQLENBQWlCSyxRQUFqQixDQUEwQixNQUExQixDQUFKLEVBQXVDO1VBQzVDLElBQUkyUSxNQUFNLEdBQUc1USxNQUFNLENBQUNFLE9BQVAsQ0FBZSxPQUFmLENBQWI7VUFDQSxJQUFJMlEsS0FBSyxHQUFHLEdBQUczQyxTQUFILENBQWE1SixJQUFiLENBQWtCNEwsT0FBbEIsRUFBMkIsQ0FBQzVRLEVBQUQsRUFBS21ILENBQUwsRUFBUTJKLE1BQVIsS0FBbUI7WUFDeEQsT0FBTzlRLEVBQUUsS0FBS3NSLE1BQWQ7VUFDRCxDQUZXLENBQVo7VUFHQUksVUFBVSxDQUFDSCxLQUFELENBQVY7UUFDRDtNQUNGLENBekRzQyxDQTJEdkM7OztNQUNBLGVBQWVFLFFBQWYsQ0FBd0J6UixFQUF4QixFQUE0QjtRQUMxQixJQUFJLENBQUNxSCxPQUFPLENBQUMsVUFBRCxDQUFaLEVBQTBCO1FBQzFCLElBQUlMLEVBQUUsR0FBR2hILEVBQUUsQ0FBQ3dILE9BQUgsQ0FBVyxJQUFYLENBQVQ7UUFDQSxJQUFJbEksR0FBRyxHQUFHLE1BQU1tQyxJQUFJLENBQUUsWUFBV3dQLFNBQVUsU0FBdkIsRUFBaUM7VUFBQ2pLO1FBQUQsQ0FBakMsQ0FBcEI7O1FBQ0EsSUFBSTFILEdBQUosRUFBUztVQUNQcVMsT0FBTyxDQUFDM0ssRUFBRCxDQUFQO1FBQ0Q7TUFDRjs7TUFFRCxTQUFTMkssT0FBVCxDQUFpQjNLLEVBQWpCLEVBQXFCO1FBQ25CLElBQUlwRCxHQUFHLEdBQUdqRyxRQUFDLENBQUUsYUFBWXFKLEVBQUcsSUFBakIsQ0FBWDtRQUNBLEdBQUduRCxPQUFILENBQVdtQixJQUFYLENBQWdCcEIsR0FBaEIsRUFBcUIsVUFBVTVELEVBQVYsRUFBYztVQUNqQ0EsRUFBRSxDQUFDTyxNQUFIO1FBQ0QsQ0FGRDtNQUdELENBMUVzQyxDQTZFdkM7OztNQUNBLGVBQWVpUixXQUFmLENBQTJCUCxTQUEzQixFQUFzQ2hVLENBQXRDLEVBQXlDO1FBQ3ZDLElBQUlxQyxHQUFHLEdBQUcsTUFBTW1DLElBQUksQ0FBRSxZQUFXd1AsU0FBVSxTQUF2QixFQUFpQyxFQUFqQyxDQUFwQjs7UUFDQSxJQUFJM1IsR0FBRyxDQUFDc0UsR0FBSixDQUFRb0QsRUFBWixFQUFnQjtVQUNkNEssTUFBTSxDQUFDdFMsR0FBRyxDQUFDc0UsR0FBSixDQUFRb0QsRUFBVCxDQUFOLENBRGMsQ0FFZDtRQUNEO01BQ0Y7O01BRUQsU0FBUzRLLE1BQVQsQ0FBZ0I1SyxFQUFoQixFQUFvQjtRQUNsQixJQUFJNkssR0FBRyxHQUFHLENBQUMsR0FBR1gsSUFBSSxDQUFDLENBQUQsQ0FBUixDQUFWO1FBQ0EsR0FBR3JOLE9BQUgsQ0FBV21CLElBQVgsQ0FBZ0I2TSxHQUFoQixFQUFxQixVQUFVN1IsRUFBVixFQUFjO1VBQ2pDLElBQUk4UixLQUFLLEdBQUc5UixFQUFFLENBQUN1SSxTQUFILENBQWEsSUFBYixDQUFaO1VBQ0EsSUFBSXdKLFlBQVksR0FBR3BVLFFBQUMsQ0FBQytTLEtBQUQsQ0FBRCxDQUFTOUssSUFBVCxDQUFjLGNBQWQsQ0FBbkI7VUFDQW1NLFlBQVksQ0FBQy9OLFdBQWIsQ0FBeUI4TixLQUF6Qjs7VUFDQSxJQUFJLENBQUMsSUFBRCxFQUFPRSxRQUFQLENBQWdCRixLQUFLLENBQUNyVSxTQUF0QixDQUFKLEVBQXNDO1lBQ3BDcVUsS0FBSyxDQUFDN1MsU0FBTixHQUFrQitILEVBQWxCO1VBQ0QsQ0FGRCxNQUVPLElBQUksQ0FBQyxDQUFDLEtBQUQsRUFBUSxNQUFSLEVBQWdCLE1BQWhCLEVBQXdCZ0wsUUFBeEIsQ0FBaUNGLEtBQUssQ0FBQ3JVLFNBQXZDLENBQUwsRUFBd0Q7WUFDN0RxVSxLQUFLLENBQUM3UyxTQUFOLEdBQWtCLEVBQWxCO1VBQ0Q7O1VBQ0Q2UyxLQUFLLENBQUN0SyxPQUFOLENBQWMsSUFBZCxJQUFzQlIsRUFBdEI7UUFFRCxDQVhEO01BWUQsQ0FwR3NDLENBc0d2Qzs7O01BQ0EsU0FBU2lMLFdBQVQsR0FBdUI7UUFDckIsR0FBR3BPLE9BQUgsQ0FBV21CLElBQVgsQ0FBZ0JrTSxJQUFoQixFQUF1QnpKLEdBQUQsSUFBUztVQUM3QixHQUFHNUQsT0FBSCxDQUFXbUIsSUFBWCxDQUFnQnlDLEdBQWhCLEVBQXFCekgsRUFBRSxJQUFJO1lBQ3pCQSxFQUFFLENBQUNkLEtBQUgsQ0FBU2dULE9BQVQsR0FBbUIsTUFBbkI7VUFDRCxDQUZEO1FBR0QsQ0FKRDtNQUtEOztNQUVELFNBQVMxUSxNQUFULENBQWdCK1AsS0FBaEIsRUFBdUJwQixLQUF2QixFQUE4QjtRQUM1QjhCLFdBQVc7UUFDWCxNQUFNbFQsS0FBSyxHQUFHb1IsS0FBSyxDQUFDcFIsS0FBcEI7UUFFQSxHQUFHOEUsT0FBSCxDQUFXbUIsSUFBWCxDQUFnQjhMLE1BQWhCLEVBQXlCcUIsR0FBRCxJQUFTO1VBQy9CLElBQUlBLEdBQUcsS0FBS2hDLEtBQVosRUFBbUJnQyxHQUFHLENBQUNwVCxLQUFKLEdBQVksRUFBWjtRQUNwQixDQUZEO1FBSUEsR0FBRzhFLE9BQUgsQ0FBV21CLElBQVgsQ0FBZ0JrTSxJQUFoQixFQUFzQixVQUFVekosR0FBVixFQUFlO1VBQ25DLE1BQU0zSyxHQUFHLEdBQUcySyxHQUFHLENBQUM4SixLQUFELENBQUgsQ0FBV3RTLFNBQXZCO1VBQ0EsTUFBTW1ULE1BQU0sR0FBRyxJQUFJaFYsTUFBSixDQUFZLEdBQUUyQixLQUFNLEVBQXBCLEVBQXVCLElBQXZCLENBQWY7O1VBQ0EsSUFBSSxDQUFDakMsR0FBRyxDQUFDa0MsS0FBSixDQUFVb1QsTUFBVixDQUFMLEVBQXdCO1lBQ3RCLEdBQUd2TyxPQUFILENBQVdtQixJQUFYLENBQWdCeUMsR0FBaEIsRUFBcUJ6SCxFQUFFLElBQUk7Y0FDekJBLEVBQUUsQ0FBQ2QsS0FBSCxDQUFTZ1QsT0FBVCxHQUFtQixNQUFuQjtZQUNELENBRkQ7VUFHRDtRQUNGLENBUkQ7TUFTRDs7TUFBQSxDQWhJc0MsQ0FrSXZDOztNQUNBLFNBQVNSLFVBQVQsQ0FBb0JILEtBQXBCLEVBQTJCO1FBQ3pCO1FBQ0EsTUFBTWMsU0FBUyxHQUFHQyxVQUFVLENBQUNmLEtBQUQsQ0FBVixJQUFxQixLQUF2QyxDQUZ5QixDQUl6Qjs7UUFDQSxNQUFNZ0IsVUFBVSxHQUFJRixTQUFTLEtBQUssS0FBZixHQUF3QixDQUF4QixHQUE0QixDQUFDLENBQWhEO1FBRUEsTUFBTUcsT0FBTyxHQUFHdlIsS0FBSyxDQUFDQyxJQUFOLENBQVdnUSxJQUFYLENBQWhCO1FBRUFzQixPQUFPLENBQUM3VCxJQUFSLENBQWEsVUFBVThULElBQVYsRUFBZ0JDLElBQWhCLEVBQXNCO1VBQ2pDLE1BQU1DLEtBQUssR0FBR0YsSUFBSSxDQUFDbEIsS0FBRCxDQUFKLENBQVl6TyxTQUExQjtVQUNBLE1BQU04UCxLQUFLLEdBQUdGLElBQUksQ0FBQ25CLEtBQUQsQ0FBSixDQUFZek8sU0FBMUI7VUFFQSxNQUFNZ00sQ0FBQyxHQUFHK0QsU0FBUyxDQUFDdEIsS0FBRCxFQUFRb0IsS0FBUixDQUFuQjtVQUNBLE1BQU1HLENBQUMsR0FBR0QsU0FBUyxDQUFDdEIsS0FBRCxFQUFRcUIsS0FBUixDQUFuQjs7VUFFQSxRQUFRLElBQVI7WUFDRSxLQUFLOUQsQ0FBQyxHQUFHZ0UsQ0FBVDtjQUNFLE9BQU8sSUFBSVAsVUFBWDs7WUFDRixLQUFLekQsQ0FBQyxHQUFHZ0UsQ0FBVDtjQUNFLE9BQU8sQ0FBQyxDQUFELEdBQUtQLFVBQVo7O1lBQ0YsS0FBS3pELENBQUMsS0FBS2dFLENBQVg7Y0FDRSxPQUFPLENBQVA7VUFOSjtRQVFELENBZkQsRUFUeUIsQ0EwQnpCOztRQUNBLEdBQUdqUCxPQUFILENBQVdtQixJQUFYLENBQWdCa00sSUFBaEIsRUFBc0IsVUFBVTZCLFFBQVYsRUFBb0I7VUFDeEMsR0FBR2xQLE9BQUgsQ0FBV21CLElBQVgsQ0FBZ0IrTixRQUFoQixFQUEwQi9TLEVBQUUsSUFBSTtZQUM5QkEsRUFBRSxDQUFDTyxNQUFIO1VBQ0QsQ0FGRDtRQUdELENBSkQsRUEzQnlCLENBaUN6Qjs7UUFDQStSLFVBQVUsQ0FBQ2YsS0FBRCxDQUFWLEdBQW9CYyxTQUFTLEtBQUssS0FBZCxHQUFzQixNQUF0QixHQUErQixLQUFuRCxDQWxDeUIsQ0FvQ3pCOztRQUNBRyxPQUFPLENBQUMzTyxPQUFSLENBQWdCLFVBQVUrTixNQUFWLEVBQWtCO1VBQ2hDQSxNQUFNLEdBQUczUSxLQUFLLENBQUNDLElBQU4sQ0FBVzBRLE1BQVgsQ0FBVDtVQUNBQSxNQUFNLENBQUNvQixPQUFQO1VBQ0EsR0FBR25QLE9BQUgsQ0FBV21CLElBQVgsQ0FBZ0I0TSxNQUFoQixFQUF3QjVSLEVBQUUsSUFBSTtZQUM1QjRRLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDdE4sTUFBUixHQUFpQixDQUFsQixDQUFQLENBQTRCMlAsS0FBNUIsQ0FBa0NqVCxFQUFsQztVQUNELENBRkQ7UUFHRCxDQU5EO01BT0Q7O01BQUEsQ0EvS3NDLENBaUx2Qzs7TUFDQSxLQUFLLElBQUltSCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNkosR0FBRyxDQUFDMU4sTUFBeEIsRUFBZ0M2RCxDQUFDLEVBQWpDLEVBQXFDO1FBQ25DLElBQUlILEVBQUUsR0FBR2dLLEdBQUcsQ0FBQzdKLENBQUQsQ0FBSCxDQUFPSyxPQUFQLENBQWVSLEVBQXhCO1FBQ0EsSUFBSVMsR0FBRyxHQUFHOUosUUFBQyxDQUFDK1MsS0FBRCxDQUFELENBQVMsQ0FBVCxFQUFZdE0sZ0JBQVosQ0FBOEIsYUFBWTRDLEVBQUcsSUFBN0MsQ0FBVjtRQUNBa0ssSUFBSSxDQUFDbk4sSUFBTCxDQUFVMEQsR0FBVjtNQUNELENBdExzQyxDQXdMdkM7OztNQUNBLE1BQU02SyxVQUFVLEdBQUdyUixLQUFLLENBQUNDLElBQU4sQ0FBVzJQLFNBQVgsRUFBc0IzSixHQUF0QixDQUEwQixVQUFVb0MsUUFBVixFQUFvQjtRQUMvRCxPQUFPLEVBQVA7TUFDRCxDQUZrQixDQUFuQixDQXpMdUMsQ0E2THZDOztNQUNBLFNBQVN1SixTQUFULENBQW1CdEIsS0FBbkIsRUFBMEIyQixPQUExQixFQUFtQztRQUNqQztRQUNBLE1BQU1yRSxJQUFJLEdBQUdnQyxTQUFTLENBQUNVLEtBQUQsQ0FBVCxDQUFpQnRQLFlBQWpCLENBQThCLFdBQTlCLENBQWI7O1FBQ0EsUUFBUTRNLElBQVI7VUFDRSxLQUFLLFFBQUw7WUFDRSxPQUFPc0UsVUFBVSxDQUFDRCxPQUFELENBQWpCOztVQUNGLEtBQUssUUFBTDtVQUNBO1lBQ0UsT0FBT0EsT0FBUDtRQUxKO01BT0Q7O01BQUEsQ0F4TXNDLENBME12Qzs7TUFDQSxTQUFTOUIsV0FBVCxDQUFxQlYsS0FBckIsRUFBNEJDLGVBQTVCLEVBQTZDalEsTUFBN0MsRUFBcUQ7UUFDbkQsSUFBSSxDQUFDQSxNQUFNLENBQUMyUSxZQUFQLENBQW9CLGlCQUFwQixDQUFMLEVBQTZDLE9BQU8sS0FBUDtRQUM3QyxJQUFJckosS0FBSyxHQUFHb0wsZUFBZSxDQUFDMVMsTUFBRCxFQUFTdVEsU0FBVCxDQUEzQjtRQUNBb0MsSUFBSSxDQUFDckwsS0FBRCxDQUFKO01BQ0Q7O01BRUQsZUFBZXFMLElBQWYsQ0FBb0JyTCxLQUFwQixFQUEyQjtRQUN6QixJQUFJdEcsR0FBRyxHQUFJLFlBQVdzRyxLQUFLLENBQUNpSixTQUFVLGlCQUF0QztRQUNBLElBQUkzUixHQUFHLEdBQUcsTUFBTW1DLElBQUksQ0FBQ0MsR0FBRCxFQUFNc0csS0FBSyxDQUFDQSxLQUFaLENBQXBCO01BQ0Q7O01BRUQsU0FBU29MLGVBQVQsQ0FBeUIxUyxNQUF6QixFQUFpQ3VRLFNBQWpDLEVBQTRDO1FBQzFDLElBQUlwRixLQUFLLEdBQUduTCxNQUFNLENBQUM4RyxPQUFQLENBQWUsT0FBZixDQUFaO1FBQ0EsT0FBTztVQUNMUSxLQUFLLEVBQUU7WUFDTGhCLEVBQUUsRUFBRXRHLE1BQU0sQ0FBQzhHLE9BQVAsQ0FBZVIsRUFEZDtZQUVMLENBQUM2RSxLQUFELEdBQVNuTCxNQUFNLENBQUN6QjtVQUZYLENBREY7VUFLTGdTO1FBTEssQ0FBUDtNQU9EO0lBRUYsQ0FqT0Q7RUFrT0QsQ0FyTzRCLENBc083Qjs7QUFDRCxDOztBQzFPRDtBQUNBO0NBRUE7O0FBRWUsU0FBU3FDLE1BQVQsR0FBa0I7RUFDL0I7RUFDQTtFQUlBM1YsUUFBQyxDQUFDLGVBQUQsQ0FBRCxDQUFtQjBHLEVBQW5CLENBQXNCLE9BQXRCLEVBQStCb0IsTUFBL0I7O0VBRUEsU0FBU0EsTUFBVCxPQUEwQjtJQUFBLElBQVY7TUFBQy9FO0lBQUQsQ0FBVTtJQUN4QixJQUFJQSxNQUFNLENBQUNFLE9BQVAsQ0FBZSxNQUFmLENBQUosRUFBNEJ1SSxHQUFHLENBQUN6SSxNQUFNLENBQUNFLE9BQVAsQ0FBZSxNQUFmLENBQUQsQ0FBSDtJQUM1QixJQUFJRixNQUFNLENBQUNFLE9BQVAsQ0FBZSxPQUFmLENBQUosRUFBNkJ5UyxJQUFJLENBQUMzUyxNQUFNLENBQUNFLE9BQVAsQ0FBZSxPQUFmLENBQUQsQ0FBSjs7SUFFN0IsU0FBU29ILEtBQVQsQ0FBZWhJLEVBQWYsRUFBbUI7TUFDakIsSUFBSXVULE1BQU0sR0FBR3ZULEVBQUUsQ0FBQ3dILE9BQUgsQ0FBV1IsRUFBWCxJQUFpQixLQUE5QjtNQUNBLElBQUk0RSxNQUFNLEdBQUdqTyxRQUFDLENBQUUsYUFBWTRWLE1BQU8sSUFBckIsQ0FBZDtNQUNBLElBQUl2TCxLQUFLLEdBQUcsRUFBWjtNQUNBQSxLQUFLLENBQUN3TCxNQUFOLEdBQWUsRUFBZjtNQUNBeEwsS0FBSyxDQUFDeUwsS0FBTixHQUFjLEVBQWQ7TUFFQTdILE1BQU0sQ0FBQzFFLEdBQVAsQ0FBWXdNLENBQUQsSUFBTztRQUNoQixJQUFJQSxDQUFDLENBQUNwVCxTQUFGLENBQVlLLFFBQVosQ0FBcUIsSUFBckIsQ0FBSixFQUFnQztVQUM5QnFILEtBQUssQ0FBQ2hCLEVBQU4sR0FBVzBNLENBQVg7VUFDQTFMLEtBQUssQ0FBQ3dMLE1BQU4sQ0FBYXhNLEVBQWIsR0FBa0IwTSxDQUFDLENBQUNsTSxPQUFGLENBQVVSLEVBQTVCO1FBQ0QsQ0FIRCxNQUdPLElBQUkwTSxDQUFDLENBQUNwVCxTQUFGLENBQVlLLFFBQVosQ0FBcUIsTUFBckIsQ0FBSixFQUFrQztVQUN2Q3FILEtBQUssQ0FBQ3VELElBQU4sR0FBYW1JLENBQWI7VUFDQTFMLEtBQUssQ0FBQ3dMLE1BQU4sQ0FBYWpJLElBQWIsR0FBb0JtSSxDQUFDLENBQUN6VSxTQUFGLENBQVkwVSxJQUFaLEVBQXBCO1FBQ0QsQ0FITSxNQUdBLElBQUlELENBQUMsQ0FBQ3BULFNBQUYsQ0FBWUssUUFBWixDQUFxQixhQUFyQixDQUFKLEVBQXlDO1VBQzlDcUgsS0FBSyxDQUFDNEwsV0FBTixHQUFvQkYsQ0FBcEI7VUFDQTFMLEtBQUssQ0FBQ3dMLE1BQU4sQ0FBYUksV0FBYixHQUEyQkYsQ0FBQyxDQUFDelUsU0FBRixDQUFZMFUsSUFBWixFQUEzQjtRQUNELENBSE0sTUFHQSxJQUFJRCxDQUFDLENBQUNwVCxTQUFGLENBQVlLLFFBQVosQ0FBcUIsVUFBckIsQ0FBSixFQUFzQztVQUMzQ3FILEtBQUssQ0FBQ3FMLElBQU4sR0FBYUssQ0FBYjtRQUNELENBRk0sTUFFQSxJQUFJQSxDQUFDLENBQUNwVCxTQUFGLENBQVlLLFFBQVosQ0FBcUIsS0FBckIsQ0FBSixFQUFpQztVQUN0Q3FILEtBQUssQ0FBQ21CLEdBQU4sR0FBWXVLLENBQVo7UUFDRDtNQUNGLENBZkQ7TUFpQkExTCxLQUFLLENBQUN5TCxLQUFOLENBQVl0SyxHQUFaLEdBQWtCbkIsS0FBSyxDQUFDaEIsRUFBTixDQUFTMkQsc0JBQVQsQ0FBZ0NwQyxTQUFoQyxDQUEwQyxJQUExQyxDQUFsQjtNQUNBUCxLQUFLLENBQUN5TCxLQUFOLENBQVlKLElBQVosR0FBbUJyTCxLQUFLLENBQUNoQixFQUFOLENBQVMyRCxzQkFBVCxDQUFnQ0Esc0JBQWhDLENBQXVEcEMsU0FBdkQsQ0FBaUUsSUFBakUsQ0FBbkI7TUFDQVAsS0FBSyxDQUFDeUwsS0FBTixDQUFZRyxXQUFaLEdBQTBCNUwsS0FBSyxDQUFDaEIsRUFBTixDQUFTMkQsc0JBQVQsQ0FBZ0NBLHNCQUFoQyxDQUF1REEsc0JBQXZELENBQThFcEMsU0FBOUUsQ0FBd0YsSUFBeEYsQ0FBMUI7TUFDQVAsS0FBSyxDQUFDeUwsS0FBTixDQUFZbEksSUFBWixHQUFtQnZELEtBQUssQ0FBQ2hCLEVBQU4sQ0FBUzJELHNCQUFULENBQWdDQSxzQkFBaEMsQ0FBdURBLHNCQUF2RCxDQUE4RUEsc0JBQTlFLENBQXFHcEMsU0FBckcsQ0FBK0csSUFBL0csQ0FBbkI7TUFDQVAsS0FBSyxDQUFDeUwsS0FBTixDQUFZek0sRUFBWixHQUFpQmdCLEtBQUssQ0FBQ2hCLEVBQU4sQ0FBUzJELHNCQUFULENBQWdDQSxzQkFBaEMsQ0FBdURBLHNCQUF2RCxDQUE4RUEsc0JBQTlFLENBQXFHQSxzQkFBckcsQ0FBNEhwQyxTQUE1SCxDQUFzSSxJQUF0SSxDQUFqQjtNQUVBLE9BQU9QLEtBQVA7SUFDRDs7SUFHRCxTQUFTbUIsR0FBVCxDQUFhbkosRUFBYixFQUFpQjtNQUNmLElBQUk2VCxHQUFHLEdBQUc3TCxLQUFLLENBQUNoSSxFQUFELENBQWY7TUFDQSxJQUFJNlQsR0FBRyxDQUFDTCxNQUFKLENBQVd4TSxFQUFYLEtBQWtCLEtBQXRCLEVBQTZCOztNQUM3QixJQUFJSyxPQUFPLENBQUMsZ0JBQUQsQ0FBWCxFQUErQjtRQUM3QkosTUFBTSxDQUFDNE0sR0FBRCxDQUFOO1FBQ0E5TSxTQUFTLENBQUM4TSxHQUFELENBQVQ7TUFDRDtJQUNGOztJQUVELGVBQWU5TSxTQUFmLENBQXlCaUIsS0FBekIsRUFBZ0M7TUFDOUIsSUFBSTFJLEdBQUcsR0FBRyxNQUFNbUMsSUFBSSxDQUFDLGVBQUQsRUFBa0I7UUFBQ3VGLEVBQUUsRUFBRWdCLEtBQUssQ0FBQ3dMLE1BQU4sQ0FBYXhNO01BQWxCLENBQWxCLENBQXBCO0lBQ0Q7O0lBRUQsU0FBU0MsTUFBVCxDQUFnQmUsS0FBaEIsRUFBdUI7TUFDckJBLEtBQUssQ0FBQ2hCLEVBQU4sQ0FBU3pHLE1BQVQ7TUFDQXlILEtBQUssQ0FBQ3VELElBQU4sQ0FBV2hMLE1BQVg7TUFDQXlILEtBQUssQ0FBQzRMLFdBQU4sQ0FBa0JyVCxNQUFsQjtNQUNBeUgsS0FBSyxDQUFDcUwsSUFBTixDQUFXOVMsTUFBWDtNQUNBeUgsS0FBSyxDQUFDbUIsR0FBTixDQUFVNUksTUFBVjtJQUNEOztJQUdELFNBQVM4UyxJQUFULENBQWNyVCxFQUFkLEVBQWtCO01BQ2hCLElBQUk2VCxHQUFHLEdBQUc3TCxLQUFLLENBQUNoSSxFQUFELENBQWY7O01BQ0EsSUFBSTZULEdBQUcsQ0FBQ0wsTUFBSixDQUFXeE0sRUFBWCxLQUFrQixLQUF0QixFQUE2QjtRQUMzQjhFLE1BQU0sQ0FBQytILEdBQUcsQ0FBQ0wsTUFBTCxDQUFOO01BQ0QsQ0FGRCxNQUVPO1FBQ0wsSUFBSSxDQUFDSyxHQUFHLENBQUNMLE1BQUosQ0FBV2pJLElBQVosSUFBb0IsQ0FBQ3NJLEdBQUcsQ0FBQ0wsTUFBSixDQUFXSSxXQUFwQyxFQUFpRCxPQUFPLEtBQVA7UUFDakQvTCxNQUFNLENBQUNnTSxHQUFELENBQU47TUFDRDtJQUNGOztJQUVELGVBQWUvSCxNQUFmLENBQXNCMEgsTUFBdEIsRUFBOEI7TUFDNUIsSUFBSWxVLEdBQUcsR0FBRyxNQUFNbUMsSUFBSSxDQUFDLGVBQUQsRUFBa0IrUixNQUFsQixDQUFwQjtJQUNEOztJQUVELFNBQVNNLFVBQVQsQ0FBb0I5TCxLQUFwQixFQUEwQjtNQUN4QkEsS0FBSyxDQUFDdUQsSUFBTixDQUFXdE0sU0FBWCxHQUF1QixFQUF2QjtNQUNBK0ksS0FBSyxDQUFDNEwsV0FBTixDQUFrQjNVLFNBQWxCLEdBQThCLEVBQTlCO0lBQ0Q7O0lBRUQsU0FBUzhVLFdBQVQsQ0FBcUIvTCxLQUFyQixFQUEyQjtNQUN6QixJQUFJZ00sV0FBVyxHQUFHclcsUUFBQyxDQUFDLG9CQUFELENBQUQsQ0FBd0IsQ0FBeEIsQ0FBbEI7TUFDQXFXLFdBQVcsQ0FBQzVMLE1BQVosQ0FBbUJKLEtBQUssQ0FBQ3lMLEtBQU4sQ0FBWXpNLEVBQS9CO01BQ0FnTixXQUFXLENBQUM1TCxNQUFaLENBQW1CSixLQUFLLENBQUN5TCxLQUFOLENBQVlsSSxJQUEvQjtNQUNBeUksV0FBVyxDQUFDNUwsTUFBWixDQUFtQkosS0FBSyxDQUFDeUwsS0FBTixDQUFZRyxXQUEvQjtNQUNBSSxXQUFXLENBQUM1TCxNQUFaLENBQW1CSixLQUFLLENBQUN5TCxLQUFOLENBQVlKLElBQS9CO01BQ0FXLFdBQVcsQ0FBQzVMLE1BQVosQ0FBbUJKLEtBQUssQ0FBQ3lMLEtBQU4sQ0FBWXRLLEdBQS9CO0lBQ0Q7O0lBRUQsU0FBUzhLLHNCQUFULENBQWdDak0sS0FBaEMsRUFBdUNoQixFQUF2QyxFQUEwQztNQUN4Q2dCLEtBQUssQ0FBQ3lMLEtBQU4sQ0FBWXpNLEVBQVosQ0FBZVEsT0FBZixDQUF1QlIsRUFBdkIsR0FBNEJBLEVBQTVCO01BQ0FnQixLQUFLLENBQUN5TCxLQUFOLENBQVl6TSxFQUFaLENBQWUvSCxTQUFmLEdBQTJCK0gsRUFBM0I7TUFDQWdCLEtBQUssQ0FBQ3lMLEtBQU4sQ0FBWWxJLElBQVosQ0FBaUIvRCxPQUFqQixDQUF5QlIsRUFBekIsR0FBOEJBLEVBQTlCO01BQ0FnQixLQUFLLENBQUN5TCxLQUFOLENBQVlsSSxJQUFaLENBQWlCdE0sU0FBakIsR0FBNkIrSSxLQUFLLENBQUN1RCxJQUFOLENBQVd0TSxTQUFYLENBQXFCMFUsSUFBckIsRUFBN0I7TUFDQTNMLEtBQUssQ0FBQ3lMLEtBQU4sQ0FBWUcsV0FBWixDQUF3QnBNLE9BQXhCLENBQWdDUixFQUFoQyxHQUFxQ0EsRUFBckM7TUFDQWdCLEtBQUssQ0FBQ3lMLEtBQU4sQ0FBWUcsV0FBWixDQUF3QjNVLFNBQXhCLEdBQW9DK0ksS0FBSyxDQUFDNEwsV0FBTixDQUFrQjNVLFNBQWxCLENBQTRCMFUsSUFBNUIsRUFBcEM7TUFDQTNMLEtBQUssQ0FBQ3lMLEtBQU4sQ0FBWUosSUFBWixDQUFpQjdMLE9BQWpCLENBQXlCUixFQUF6QixHQUE4QkEsRUFBOUI7TUFDQWdCLEtBQUssQ0FBQ3lMLEtBQU4sQ0FBWXRLLEdBQVosQ0FBZ0IzQixPQUFoQixDQUF3QlIsRUFBeEIsR0FBNkJBLEVBQTdCO0lBQ0Q7O0lBRUQsZUFBZWEsTUFBZixDQUFzQkcsS0FBdEIsRUFBNkI7TUFDM0IsSUFBSTFJLEdBQUcsR0FBRyxNQUFNbUMsSUFBSSxDQUFDLGVBQUQsRUFBa0J1RyxLQUFLLENBQUN3TCxNQUF4QixDQUFwQjs7TUFFQSxJQUFJbFUsR0FBRyxDQUFDc0UsR0FBSixDQUFRb0QsRUFBWixFQUFnQjtRQUVkaU4sc0JBQXNCLENBQUNqTSxLQUFELEVBQVExSSxHQUFHLENBQUMwSCxFQUFKLEdBQU8sQ0FBZixDQUF0QjtRQUNBK00sV0FBVyxDQUFDL0wsS0FBRCxDQUFYO1FBQ0E4TCxVQUFVLENBQUM5TCxLQUFELENBQVY7UUFFQXJJLFVBQUEsQ0FBVyxXQUFYO01BQ0Q7SUFFRjtFQUdGO0FBQ0YsQzs7QUNoSUQ7QUFFZSxTQUFTdVUsTUFBVCxHQUFrQjtFQUMvQixTQUFTQyxHQUFULEdBQWU7SUFDYixNQUFNclEsQ0FBQyxHQUFHbkcsUUFBQyxDQUFDLGNBQUQsQ0FBWDs7SUFDQSxLQUFLLElBQUkrVixDQUFULElBQWM1UCxDQUFkLEVBQWlCO01BQ2YsSUFBSTRQLENBQUMsQ0FBQ2pRLE9BQU4sRUFBZTtRQUNiLE9BQU9pUSxDQUFDLENBQUMzVSxLQUFUO01BQ0Q7SUFDRjs7SUFDRCxPQUFPLEdBQVA7RUFDRDtBQUNGLEM7O0FDWkQ7QUFFQTtBQUNBO0FBRWUsU0FBU2lSLElBQVQsR0FBZ0I7RUFFN0IsSUFBSS9MLElBQUksR0FBR3RHLFFBQUMsQ0FBQyxxQkFBRCxDQUFELENBQXlCLENBQXpCLENBQVg7O0VBQ0EsSUFBSXNHLElBQUosRUFBVTtJQUNSdEcsUUFBQyxDQUFDc0csSUFBRCxDQUFELENBQVFJLEVBQVIsQ0FBVyxPQUFYLEVBQW9Ca0QsV0FBcEI7RUFDRDs7RUFFRCxlQUFlQSxXQUFmLE9BQXFDO0lBQUEsSUFBVjtNQUFDN0c7SUFBRCxDQUFVOztJQUNuQyxJQUFJLENBQUMsQ0FBQ0EsTUFBTSxDQUFDRSxPQUFQLENBQWUsT0FBZixDQUFOLEVBQStCO01BRTdCLElBQUl3VCxPQUFPLEdBQUd6VyxRQUFDLENBQUMsWUFBRCxDQUFELENBQWdCLENBQWhCLENBQWQ7TUFDQSxJQUFJZ0UsSUFBSSxHQUFHMFMsUUFBUSxDQUFDRCxPQUFELENBQW5CO01BRUEsSUFBSTlVLEdBQUcsR0FBRyxNQUFNbUMsSUFBSSxDQUFDLHNCQUFELEVBQXlCRSxJQUF6QixDQUFwQjtJQUVELENBUEQsTUFPTyxJQUFJakIsTUFBTSxDQUFDSixTQUFQLENBQWlCSyxRQUFqQixDQUEwQixPQUExQixDQUFKLEVBQXdDO01BQzdDLElBQUkyUyxNQUFNLEdBQUczVixRQUFDLENBQUMscUJBQUQsQ0FBZDtNQUNBLElBQUliLEdBQUcsR0FBRyxFQUFWO01BQ0EsR0FBR29LLEdBQUgsQ0FBT2xDLElBQVAsQ0FBWXNPLE1BQVosRUFBb0IsVUFBVWdCLEtBQVYsRUFBaUI7UUFDbkMsSUFBSXhRLENBQUMsR0FBR3dRLEtBQUssQ0FBQzNKLHNCQUFOLENBQTZCMUwsU0FBckM7UUFDQW5DLEdBQUcsSUFBRWdILENBQUMsR0FBQyxHQUFQO01BQ0QsQ0FIRDtNQUlFLElBQUl5USxHQUFHLEdBQUc3VCxNQUFNLENBQUNFLE9BQVAsQ0FBZSxPQUFmLENBQVY7TUFDQTJULEdBQUcsQ0FBQy9NLE9BQUosQ0FBWXpJLEtBQVosR0FBb0JqQyxHQUFwQjtJQUNIO0VBQ0Y7O0VBRUQsU0FBU3dXLE1BQVQsR0FBa0I7SUFDaEIsSUFBSWdCLEtBQUssR0FBRzNXLFFBQUMsQ0FBQyxnQkFBRCxDQUFiO0lBQ0EsSUFBSTJWLE1BQU0sR0FBRyxFQUFiO0lBQ0EsR0FBR3BNLEdBQUgsQ0FBT2xDLElBQVAsQ0FBWXNQLEtBQVosRUFBb0JFLENBQUQsSUFBTztNQUN4QixJQUFJMVgsR0FBRyxHQUFHMFgsQ0FBQyxDQUFDN0osc0JBQUYsQ0FBeUIxTCxTQUF6QixHQUFxQyxHQUEvQztNQUNBcVUsTUFBTSxJQUFJeFcsR0FBVjtJQUNELENBSEQsRUFHR3dXLE1BSEg7SUFJQSxPQUFPQSxNQUFQO0VBQ0Q7O0VBRUQsU0FBU2pNLE9BQVQsR0FBbUI7SUFDakIsTUFBTUEsT0FBTyxHQUFHMUosUUFBQyxDQUFDLGNBQUQsQ0FBakI7O0lBQ0EsS0FBSyxJQUFJK1YsQ0FBVCxJQUFjck0sT0FBZCxFQUF1QjtNQUNyQixJQUFJcU0sQ0FBQyxDQUFDaEksUUFBTixFQUFnQjtRQUNkLE9BQU9nSSxDQUFDLENBQUMzVSxLQUFUO01BQ0Q7SUFDRjs7SUFDRCxPQUFPLEdBQVA7RUFDRDs7RUFHRCxTQUFTc1YsUUFBVCxDQUFrQjNULE1BQWxCLEVBQTBCO0lBQ3hCLE9BQU87TUFDTHNHLEVBQUUsRUFBRXJKLFFBQUMsQ0FBQytDLE1BQUQsQ0FBRCxDQUFVa0YsSUFBVixDQUFlLEtBQWYsRUFBc0IzRyxTQURyQjtNQUVMc00sSUFBSSxFQUFFNU4sUUFBQyxDQUFDK0MsTUFBRCxDQUFELENBQVVrRixJQUFWLENBQWUsT0FBZixFQUF3QjNHLFNBRnpCO01BR0x3VixPQUFPLEVBQUU5VyxRQUFDLENBQUMrQyxNQUFELENBQUQsQ0FBVWtGLElBQVYsQ0FBZSxTQUFmLEVBQTBCM0csU0FIOUI7TUFJTHlWLFVBQVUsRUFBRS9XLFFBQUMsQ0FBQytDLE1BQUQsQ0FBRCxDQUFVa0YsSUFBVixDQUFlLFNBQWYsRUFBMEIzRyxTQUpqQztNQUtMMFYsU0FBUyxFQUFFaFgsUUFBQyxDQUFDK0MsTUFBRCxDQUFELENBQVVrRixJQUFWLENBQWUsT0FBZixFQUF3QjNHLFNBTDlCO01BTUwyVixLQUFLLEVBQUVqWCxRQUFDLENBQUMrQyxNQUFELENBQUQsQ0FBVWtGLElBQVYsQ0FBZSxRQUFmLEVBQXlCM0csU0FOM0I7TUFPTEcsS0FBSyxFQUFFekIsUUFBQyxDQUFDK0MsTUFBRCxDQUFELENBQVVrRixJQUFWLENBQWUsUUFBZixFQUF5QjNHLFNBUDNCO01BUUw0VixLQUFLLEVBQUVsWCxRQUFDLENBQUMrQyxNQUFELENBQUQsQ0FBVWtGLElBQVYsQ0FBZSxRQUFmLEVBQXlCM0csU0FSM0I7TUFTTDZWLEtBQUssRUFBRW5YLFFBQUMsQ0FBQytDLE1BQUQsQ0FBRCxDQUFVa0YsSUFBVixDQUFlLFFBQWYsRUFBeUIzRyxTQVQzQjtNQVVMb0ksT0FBTyxFQUFFQSxPQUFPLEVBVlg7TUFXTDhNLEdBQUcsRUFBRUQsTUFBTSxFQVhOO01BWUxaLE1BQU0sRUFBRUEsTUFBTTtJQVpULENBQVA7RUFjRDtBQUNGLEM7O0FDckVEO0FBRWUsU0FBU3lCLGFBQVQsR0FBeUI7RUFFdEMsSUFBSUMsYUFBYSxHQUFHclgsUUFBQyxDQUFFLGVBQUYsQ0FBRCxDQUFtQixDQUFuQixDQUFwQjs7RUFDQSxJQUFJcVgsYUFBSixFQUFtQjtJQUNqQkEsYUFBYSxHQUFHLENBQUNBLGFBQWEsQ0FBQ3hOLE9BQWQsQ0FBc0IsUUFBdEIsQ0FBakI7SUFDQSxJQUFJeU4sa0JBQWtCLEdBQUd0WCxRQUFDLENBQUMsd0JBQUQsQ0FBMUI7SUFDQXNELEtBQUssQ0FBQ0MsSUFBTixDQUFXK1Qsa0JBQVgsRUFBK0I5USxNQUEvQixDQUF1QzJLLENBQUQsSUFBTztNQUMzQyxJQUFJLENBQUNBLENBQUMsQ0FBQ3RILE9BQUYsQ0FBVVIsRUFBWCxLQUFrQmdPLGFBQXRCLEVBQXFDO1FBQ25DbEcsQ0FBQyxDQUFDeE8sU0FBRixDQUFZRSxHQUFaLENBQWdCLFNBQWhCO01BQ0Q7SUFDRixDQUpEO0VBS0Q7O0VBR0QsSUFBSXlMLE1BQU0sR0FBR3RPLFFBQUMsQ0FBQyxpQkFBRCxDQUFELENBQXFCLENBQXJCLENBQWI7O0VBQ0EsSUFBSXNPLE1BQUosRUFBWTtJQUNWdE8sUUFBQyxDQUFDc08sTUFBRCxDQUFELENBQVU1SCxFQUFWLENBQWEsT0FBYixFQUFzQixZQUFZO01BQ2hDLElBQUk2USxJQUFJLEdBQUd2WCxRQUFDLENBQUMsaUJBQUQsQ0FBRCxDQUFxQixDQUFyQixDQUFYO01BQ0F1WCxJQUFJLENBQUM1VSxTQUFMLENBQWU4RixNQUFmLENBQXNCLE1BQXRCO0lBQ0QsQ0FIRDtFQUlEO0FBRUYsQzs7QUN4QkQ7QUFDQTtBQUVBO0FBRUEsSUFBSStPLFFBQVEsR0FBR3hYLFFBQUMsQ0FBQyxnQkFBRCxDQUFELENBQW9CLENBQXBCLENBQWY7O0FBQ0EsSUFBSXdYLFFBQUosRUFBYztFQUNaN0csd0JBQWM7RUFDZDNRLFFBQUMsQ0FBQ3dYLFFBQUQsQ0FBRCxDQUFZOVEsRUFBWixDQUFlLE9BQWYsRUFBd0JrRCxxQkFBeEI7RUFFQTVKLFFBQUMsQ0FBQ3dYLFFBQUQsQ0FBRCxDQUFZOVEsRUFBWixDQUFlLE9BQWYsRUFBd0JrSSxxQkFBeEI7QUFDRDs7QUFHRCxTQUFTK0Isd0JBQVQsR0FBMEI7RUFDeEIsSUFBSWhHLENBQUMsR0FBRzNLLFFBQUMsQ0FBQyxXQUFELENBQUQsQ0FBZSxDQUFmLEVBQWtCMkMsU0FBbEIsQ0FBNEJFLEdBQTVCLENBQWdDLE1BQWhDLENBQVI7QUFDRDs7QUFFRCxTQUFTK0wscUJBQVQsT0FBK0I7RUFBQSxJQUFWO0lBQUM3TDtFQUFELENBQVU7O0VBQzdCLElBQUlBLE1BQU0sQ0FBQ0osU0FBUCxDQUFpQkssUUFBakIsQ0FBMEIsVUFBMUIsQ0FBSixFQUEyQztJQUN6QyxJQUFJeVUsZ0JBQWdCLEdBQUd6WCxRQUFDLENBQUMsMEJBQUQsQ0FBRCxDQUE4QixDQUE5QixDQUF2Qjs7SUFDQSxJQUFJLENBQUMrQyxNQUFNLENBQUN6QixTQUFaLEVBQXVCO01BQ3JCbVcsZ0JBQWdCLENBQUM5VSxTQUFqQixDQUEyQkMsTUFBM0IsQ0FBa0MsUUFBbEM7SUFDRCxDQUZELE1BRU87TUFDTDZVLGdCQUFnQixDQUFDOVUsU0FBakIsQ0FBMkJFLEdBQTNCLENBQStCLFFBQS9CO0lBQ0Q7RUFDRjtBQUNGOztBQUVELGVBQWUrRyxxQkFBZixRQUFxQztFQUFBLElBQVY7SUFBQzdHO0VBQUQsQ0FBVTtFQUNuQyxJQUFJd0ssTUFBTSxHQUFHeEssTUFBTSxDQUFDOEcsT0FBUCxDQUFlUixFQUE1QjtFQUNBLElBQUlxTyxjQUFjLEdBQUcxWCxRQUFDLENBQUMsZ0JBQUQsQ0FBRCxDQUFvQixDQUFwQixDQUFyQjtFQUNBLElBQUkyWCxXQUFXLEdBQUczWCxRQUFDLENBQUMsbUJBQUQsQ0FBbkI7RUFDQSxJQUFJeVgsZ0JBQWdCLEdBQUd6WCxRQUFDLENBQUMsMEJBQUQsQ0FBRCxDQUE4QixDQUE5QixDQUF2QjtFQUNBLElBQUl3SixDQUFDLEdBQUdtTyxXQUFXLENBQUMvRSxPQUFaLENBQW9CNkUsZ0JBQXBCLENBQVI7O0VBRUEsSUFBSTFVLE1BQU0sQ0FBQ3NHLEVBQVAsS0FBYyxNQUFsQixFQUEwQjtJQUN4QnVPLFNBQVM7RUFDVixDQUZELE1BRU8sSUFBSTdVLE1BQU0sQ0FBQ3NHLEVBQVAsS0FBYyxNQUFsQixFQUEwQjtJQUMvQndPLFNBQVM7RUFDVixDQUZNLE1BRUEsSUFBSTlVLE1BQU0sQ0FBQzhHLE9BQVAsQ0FBZXNHLFVBQW5CLEVBQStCO0lBQ3BDMkgsUUFBUTtFQUNULENBRk0sTUFFQSxJQUFJL1UsTUFBTSxDQUFDSixTQUFQLENBQWlCSyxRQUFqQixDQUEwQixLQUExQixDQUFKLEVBQXNDO0lBQzNDK1UsS0FBSyxDQUFDaFYsTUFBRCxDQUFMO0VBQ0QsQ0FGTSxNQUVBLElBQUlBLE1BQU0sQ0FBQ3NHLEVBQVAsS0FBYyxRQUFsQixFQUE0QjtJQUNqQzJPLE1BQU07RUFDUDs7RUFFRCxlQUFlQSxNQUFmLEdBQXdCO0lBQ3RCLElBQUkvTSxTQUFTLEdBQUcsTUFBTWdOLFVBQVUsQ0FBQzFLLE1BQUQsQ0FBaEM7SUFDQSxJQUFJK0UsY0FBYyxHQUFHNEYsWUFBWSxDQUFDak4sU0FBRCxDQUFqQztJQUNBLElBQUlrTixHQUFHLEdBQUdDLFNBQVMsQ0FBQzlGLGNBQUQsQ0FBbkI7SUFDQSxJQUFJM1EsR0FBRyxHQUFHLE1BQU1tQyxJQUFJLENBQUMsZ0NBQUQsRUFBbUNxVSxHQUFuQyxDQUFwQjs7SUFDQSxJQUFJeFcsR0FBRyxDQUFDdUQsR0FBSixLQUFZLElBQWhCLEVBQXNCO01BQ3BCLElBQUltVCxJQUFJLEdBQUcvWCxRQUFRLENBQUM2QyxhQUFULENBQXVCLFFBQXZCLENBQVg7TUFDQWtWLElBQUksQ0FBQ2hQLEVBQUwsR0FBVSxHQUFWO0lBRUQ7RUFDRjs7RUFFRCxTQUFTK08sU0FBVCxDQUFtQkUsWUFBbkIsRUFBaUM7SUFDL0IsT0FBTztNQUNMck8sTUFBTSxFQUFFLENBQUNzRCxNQURKO01BRUxuRCxXQUFXLEVBQUV1TixXQUFXLENBQUNoUyxNQUZwQjtNQUdMNUYsSUFBSSxFQUFFRixTQUFTLENBQUMsT0FBRCxDQUhWO01BSUx1UyxRQUFRLEVBQUVwUyxRQUFDLENBQUMsWUFBRCxDQUFELENBQWdCLENBQWhCLEVBQW1Cc0IsU0FKeEI7TUFLTGlYLFFBQVEsRUFBRXZZLFFBQUMsQ0FBQyxpQkFBRCxDQUFELENBQXFCLENBQXJCLEVBQXdCc0IsU0FMN0I7TUFNTGdYLFlBTkssQ0FPTDs7SUFQSyxDQUFQO0VBVUQ7O0VBR0QsU0FBU1IsUUFBVCxHQUFvQjtJQUNsQixJQUFJL1UsTUFBTSxLQUFLMFUsZ0JBQWYsRUFBaUMsT0FBTyxLQUFQO0lBQ2pDLElBQUllLGFBQWEsR0FBR3pWLE1BQXBCO0lBQ0EwVixjQUFjLENBQUNELGFBQUQsRUFBZ0JkLGNBQWhCLENBQWQ7SUFDQWdCLFNBQVMsQ0FBQ0YsYUFBRCxFQUFnQmYsZ0JBQWhCLENBQVQ7RUFDRDs7RUFFRCxTQUFTRyxTQUFULEdBQXFCO0lBQ25CLElBQUlwTyxDQUFDLEdBQUcsQ0FBUixFQUFXLE9BQU8sS0FBUDtJQUNYLElBQUlnUCxhQUFhLEdBQUdiLFdBQVcsQ0FBQ25PLENBQUMsR0FBRyxDQUFMLENBQS9CO0lBQ0FpUCxjQUFjLENBQUNELGFBQUQsRUFBZ0JkLGNBQWhCLENBQWQ7SUFDQWdCLFNBQVMsQ0FBQ0YsYUFBRCxFQUFnQmYsZ0JBQWhCLENBQVQ7RUFDRDs7RUFFRCxTQUFTSSxTQUFULEdBQXFCO0lBQ25CLElBQUlyTyxDQUFDLEdBQUdtTyxXQUFXLENBQUNoUyxNQUFaLEdBQXFCLENBQTdCLEVBQWdDLE9BQU8sS0FBUDtJQUNoQyxJQUFJNlMsYUFBYSxHQUFHYixXQUFXLENBQUNuTyxDQUFDLEdBQUcsQ0FBTCxDQUEvQjtJQUNBaVAsY0FBYyxDQUFDRCxhQUFELEVBQWdCZCxjQUFoQixDQUFkO0lBQ0FnQixTQUFTLENBQUNGLGFBQUQsRUFBZ0JmLGdCQUFoQixDQUFUO0VBQ0Q7QUFDRjs7QUFHRCxTQUFTUyxZQUFULENBQXNCak4sU0FBdEIsRUFBaUM7RUFDL0IsSUFBSTBOLE9BQU8sR0FBRyxDQUFkO0VBQ0ExTixTQUFTLENBQUMvRSxPQUFWLENBQW1CeUUsQ0FBRCxJQUFPO0lBQ3ZCLElBQUl1RSxJQUFJLEdBQUd2RSxDQUFDLENBQUN0QixFQUFiO0lBQ0EsSUFBSXVQLElBQUksR0FBRzVZLFFBQUMsQ0FBRSxzQkFBcUJrUCxJQUFLLElBQTVCLENBQUQsQ0FBa0MsQ0FBbEMsQ0FBWDtJQUNBLElBQUkySixRQUFRLEdBQUc3WSxRQUFDLENBQUM0WSxJQUFELENBQUQsQ0FBUTNRLElBQVIsQ0FBYSxXQUFiLENBQWY7SUFDQSxJQUFJLENBQUMwQyxDQUFDLENBQUNtTyxVQUFQLEVBQW1CO0lBQ25CLElBQUlDLElBQUksR0FBRyxFQUFYO0lBQ0FwTyxDQUFDLENBQUNtTyxVQUFGLENBQWE1UyxPQUFiLENBQXNCaUwsQ0FBRCxJQUFPO01BQzFCNEgsSUFBSSxJQUFLLElBQUc1SCxDQUFDLENBQUNyRyxNQUFPLElBQXJCO0lBQ0QsQ0FGRDtJQUdBNk4sT0FBTyxJQUFJSyxTQUFTLENBQUUsR0FBRUQsSUFBSyxFQUFULEVBQVlGLFFBQVosRUFBc0IsSUFBdEIsQ0FBcEI7RUFDRCxDQVZEO0VBV0EsT0FBT0YsT0FBUDtBQUNEOztBQUVELFNBQVNNLE9BQVQsQ0FBaUJGLElBQWpCLEVBQXVCdFksT0FBdkIsRUFBZ0N5WSxXQUFoQyxFQUE2QztFQUMzQyxJQUFJeFgsSUFBSSxHQUFHakIsT0FBTyxDQUFDMEUsU0FBbkI7RUFDQSxJQUFJZ1UsSUFBSSxHQUFHLElBQUkxWixNQUFKLENBQVdzWixJQUFYLEVBQWlCLEdBQWpCLENBQVg7RUFDQSxJQUFJOVMsR0FBRyxHQUFHdkUsSUFBSSxDQUFDTCxLQUFMLENBQVc4WCxJQUFYLENBQVY7RUFDQSxJQUFJUixPQUFPLEdBQUcsQ0FBZDtFQUVBMVMsR0FBRyxDQUFDQyxPQUFKLENBQWFrVCxDQUFELElBQU87SUFDakIsSUFBSSxDQUFDQSxDQUFMLEVBQVE7SUFDUlQsT0FBTyxHQUFHLENBQVY7SUFDQSxJQUFJOUIsQ0FBQyxHQUFHLElBQUlwWCxNQUFKLENBQVcyWixDQUFYLEVBQWMsR0FBZCxDQUFSO0lBQ0EsSUFBSUMsSUFBSSxHQUFJLDJCQUFELEdBQThCRCxDQUE5QixHQUFrQyxTQUE3QztJQUNBM1ksT0FBTyxDQUFDMEUsU0FBUixHQUFvQjFFLE9BQU8sQ0FBQzBFLFNBQVIsQ0FBa0J6RixPQUFsQixDQUEwQm1YLENBQTFCLEVBQTZCd0MsSUFBN0IsQ0FBcEI7RUFDRCxDQU5EO0VBT0EsT0FBT1YsT0FBUDtBQUVEOztBQUVELGVBQWVWLFVBQWYsQ0FBMEI1TyxFQUExQixFQUE4QjtFQUM1QixPQUFPLE1BQU12RixJQUFJLENBQUMsb0NBQUQsRUFBdUM7SUFBQ3VGO0VBQUQsQ0FBdkMsQ0FBakI7QUFDRDs7QUFFRCxTQUFTcVAsU0FBVCxDQUFtQkYsYUFBbkIsRUFBa0NmLGdCQUFsQyxFQUFvRDtFQUNsREEsZ0JBQWdCLENBQUM5VSxTQUFqQixDQUEyQjhGLE1BQTNCLENBQWtDLFFBQWxDO0VBQ0ErUCxhQUFhLENBQUM3VixTQUFkLENBQXdCOEYsTUFBeEIsQ0FBK0IsUUFBL0I7QUFDRDs7QUFFRCxTQUFTZ1EsY0FBVCxDQUF3QmEsZUFBeEIsRUFBeUM1QixjQUF6QyxFQUF5RDtFQUN2RCxJQUFJNkIsYUFBYSxHQUFHRCxlQUFlLENBQUN6UCxPQUFoQixDQUF3QnNHLFVBQTVDO0VBQ0EsSUFBSTJCLFdBQVcsR0FBRzlSLFFBQUMsQ0FBRSxzQkFBcUJ1WixhQUFjLElBQXJDLENBQUQsQ0FBMkMsQ0FBM0MsQ0FBbEI7RUFDQXpILFdBQVcsQ0FBQ25QLFNBQVosQ0FBc0I4RixNQUF0QixDQUE2QixNQUE3QjtFQUNBaVAsY0FBYyxDQUFDL1UsU0FBZixDQUF5QjhGLE1BQXpCLENBQWdDLE1BQWhDO0FBQ0Q7O0FBRUQsU0FBU3VRLFNBQVQsQ0FBbUJELElBQW5CLEVBQXlCMVcsRUFBekIsRUFBNkI2VyxXQUE3QixFQUEwQztFQUN4QyxPQUFPRCxPQUFPLENBQUNGLElBQUQsRUFBTzFXLEVBQVAsRUFBVzZXLFdBQVgsQ0FBZDtBQUNELEM7O0FDcEpEO0FBQ0E7QUFFZSxTQUFTTSxXQUFULEdBQWdCO0VBQzdCLElBQUlDLE1BQU0sR0FBR3paLFFBQUMsQ0FBQyxnQkFBRCxDQUFkO0VBRUEsR0FBR3VKLEdBQUgsQ0FBT2xDLElBQVAsQ0FBWW9TLE1BQVosRUFBb0IsVUFBVUQsS0FBVixFQUFpQjtJQUNuQ3haLFFBQUMsQ0FBQ3daLEtBQUQsQ0FBRCxDQUFTOVMsRUFBVCxDQUFZLE9BQVosRUFBb0JrRCxXQUFwQjs7SUFFQSxTQUFTQSxXQUFULE9BQStCO01BQUEsSUFBVjtRQUFDN0c7TUFBRCxDQUFVO01BQzdCLElBQUkyVyxJQUFJLEdBQUczVyxNQUFNLENBQUNFLE9BQVAsQ0FBZSxPQUFmLENBQVg7TUFDQXVXLEtBQUssQ0FBQzNQLE9BQU4sQ0FBY3pJLEtBQWQsR0FBc0JzWSxJQUFJLENBQUM3UCxPQUFMLENBQWF6SSxLQUFuQztJQUNEO0VBRUYsQ0FSRDtBQVVELEM7O0FDaEJEO0FBQ0E7QUFFZSxTQUFTdVksV0FBVCxHQUF1QjtFQUVwQyxTQUFTQyxXQUFULEdBQXNCO0lBQ3BCLElBQUlDLEtBQUosRUFBVTtNQUNSLElBQUk5TCxRQUFRLEdBQUcsR0FBR3hFLEdBQUgsQ0FBT2xDLElBQVAsQ0FBWXdTLEtBQVosRUFBbUIsVUFBVS9MLE1BQVYsRUFBa0I7UUFDbEQsSUFBSWdNLEtBQUssR0FBR2hNLE1BQU0sQ0FBQ3JILGdCQUFQLENBQXdCLFlBQXhCLENBQVo7UUFDQSxJQUFJc1QsSUFBSSxHQUFHLEdBQUd4USxHQUFILENBQU9sQyxJQUFQLENBQVl5UyxLQUFaLEVBQW1CLFVBQVVFLElBQVYsRUFBZ0I7VUFDNUMsT0FBT0EsSUFBSSxDQUFDblEsT0FBTCxDQUFhUixFQUFwQjtRQUNELENBRlUsQ0FBWDtRQUdBLElBQUk4TyxHQUFHLEdBQUcsRUFBVjtRQUNBQSxHQUFHLENBQUNqSyxLQUFKLEdBQWFKLE1BQU0sQ0FBQ2pFLE9BQVAsQ0FBZXFFLEtBQTVCO1FBQ0FpSyxHQUFHLENBQUM5RSxHQUFKLEdBQVUwRyxJQUFWO1FBQ0EsT0FBTzVCLEdBQVA7TUFDRCxDQVRjLENBQWY7SUFVRCxDQVptQixDQWFwQjs7RUFDRDs7RUFFRCxJQUFJMEIsS0FBSyxHQUFHN1osUUFBQyxDQUFDLGlCQUFELENBQWI7O0VBQ0EsSUFBSTZaLEtBQUosRUFBVztJQUVULEdBQUczVCxPQUFILENBQVdtQixJQUFYLENBQWdCd1MsS0FBaEIsRUFBdUIsVUFBVS9MLE1BQVYsRUFBa0I7TUFFdkNBLE1BQU0sQ0FBQ3RMLGdCQUFQLENBQXdCLE9BQXhCLEVBQWlDb0gsV0FBakMsRUFBOEMsS0FBOUM7TUFDQWtFLE1BQU0sQ0FBQ3RMLGdCQUFQLENBQXdCLE1BQXhCLEVBQWdDeVgsVUFBaEMsRUFBNEMsS0FBNUM7O01BRUEsU0FBU0EsVUFBVCxPQUE4QjtRQUFBLElBQVY7VUFBQ2xYO1FBQUQsQ0FBVTtRQUM1QixJQUFJZCxJQUFJLEdBQUdqQyxRQUFDLENBQUMsSUFBRCxDQUFELENBQVFpSSxJQUFSLENBQWEsT0FBYixDQUFYOztRQUNBLElBQUloRyxJQUFKLEVBQVU7VUFDUkEsSUFBSSxDQUFDVSxTQUFMLENBQWVDLE1BQWYsQ0FBc0IsTUFBdEI7UUFDRDtNQUNGOztNQUVELFNBQVNnSCxXQUFULFFBQStCO1FBQUEsSUFBVjtVQUFDN0c7UUFBRCxDQUFVO1FBQzdCLElBQUk4VyxLQUFLLEdBQUc5VyxNQUFNLENBQUNFLE9BQVAsQ0FBZSxnQkFBZixDQUFaLENBRDZCLENBRXJDOztRQUNRLElBQUlGLE1BQU0sQ0FBQ0UsT0FBUCxDQUFlLFFBQWYsS0FBMEIsQ0FBQyxXQUFELEVBQWNvUixRQUFkLENBQXVCdFIsTUFBTSxDQUFDakQsU0FBOUIsQ0FBOUIsRUFBeUU7VUFDdkU7VUFDQSxJQUFJa0ksRUFBRSxHQUFHNlIsS0FBSyxDQUFDeFYsYUFBTixDQUFvQixJQUFwQixDQUFUO1VBQ0EyRCxFQUFFLENBQUNyRixTQUFILENBQWE4RixNQUFiLENBQW9CLE1BQXBCLEVBSHVFLENBS2pGO1FBQ1MsQ0FORCxNQU1PLElBQUksQ0FBQyxLQUFELEVBQVE0TCxRQUFSLENBQWlCdFIsTUFBTSxDQUFDakQsU0FBeEIsQ0FBSixFQUF3QztVQUM3QyxJQUFJdUosRUFBRSxHQUFHdEcsTUFBTSxDQUFDRSxPQUFQLENBQWUsT0FBZixFQUF3QjRHLE9BQXhCLENBQWdDUixFQUF6QztVQUNBNlEsZ0JBQWdCLENBQUM3USxFQUFELENBQWhCO1VBQ0EsSUFBSTJRLElBQUksR0FBR2pYLE1BQU0sQ0FBQ0UsT0FBUCxDQUFlLE9BQWYsQ0FBWDtVQUNBK1csSUFBSSxDQUFDcFgsTUFBTCxHQUo2QyxDQU12RDtRQUNTLENBUE0sTUFPQSxJQUFJRyxNQUFNLENBQUNHLE9BQVAsQ0FBZXBCLFdBQWYsT0FBaUMsT0FBckMsRUFBOEM7VUFDbkQsSUFBSXVILEVBQUUsR0FBR3RHLE1BQU0sQ0FBQzhHLE9BQVAsQ0FBZVIsRUFBeEIsQ0FEbUQsQ0FFbkQ7O1VBQ0EsSUFBSXlRLEtBQUssR0FBR0QsS0FBSyxDQUFDcFQsZ0JBQU4sQ0FBdUIsT0FBdkIsQ0FBWjtVQUNBLElBQUkwVCxLQUFLLEdBQUcsR0FBR25ULElBQUgsQ0FBUUssSUFBUixDQUFheVMsS0FBYixFQUFxQkUsSUFBRCxJQUFVO1lBQ3hDLE9BQU9BLElBQUksQ0FBQ25RLE9BQUwsQ0FBYVIsRUFBYixLQUFvQkEsRUFBM0I7VUFDRCxDQUZXLENBQVo7VUFJQSxJQUFJK1EsSUFBSSxHQUFHcGEsUUFBQyxDQUFDNlosS0FBRCxDQUFELENBQVM1UixJQUFULENBQWMsWUFBZCxDQUFYOztVQUNBLElBQUksQ0FBQ2tTLEtBQUwsRUFBWTtZQUNWcFgsTUFBTSxDQUFDSixTQUFQLENBQWlCOEYsTUFBakIsQ0FBd0IsVUFBeEI7WUFDQSxJQUFJdVIsSUFBSSxHQUFHSyxVQUFVLENBQUNoUixFQUFELENBQXJCO1lBQ0ErUSxJQUFJLENBQUM3WCxNQUFMLENBQVl5WCxJQUFaO1VBQ0QsQ0FKRCxNQUlPO1lBQ0xqWCxNQUFNLENBQUNKLFNBQVAsQ0FBaUI4RixNQUFqQixDQUF3QixVQUF4QjtZQUNBMlIsSUFBSSxDQUFDL1YsYUFBTCxDQUFvQixhQUFZZ0YsRUFBRyxJQUFuQyxFQUF3Q3pHLE1BQXhDO1VBQ0Q7UUFDRjs7UUFDRCxTQUFTc1gsZ0JBQVQsQ0FBMEI3USxFQUExQixFQUE4QjtVQUM1QjtVQUNBckosUUFBQyxDQUFDNlosS0FBRCxDQUFELENBQVM1UixJQUFULENBQWUsa0JBQWlCb0IsRUFBRyxJQUFuQyxFQUF3QzFHLFNBQXhDLENBQWtEQyxNQUFsRCxDQUF5RCxVQUF6RDtRQUNEOztRQUVELFNBQVN5WCxVQUFULENBQW9CaFIsRUFBcEIsRUFBd0I7VUFDdEIsSUFBSTJRLElBQUksR0FBRzFaLFFBQVEsQ0FBQzZDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBWDtVQUNBNlcsSUFBSSxDQUFDclgsU0FBTCxDQUFlRSxHQUFmLENBQW1CLE1BQW5CO1VBQ0FtWCxJQUFJLENBQUMxWSxTQUFMLEdBQWlCeUIsTUFBTSxDQUFDekIsU0FBeEI7VUFDQTBZLElBQUksQ0FBQ25RLE9BQUwsQ0FBYSxJQUFiLElBQXFCUixFQUFyQjtVQUVBLElBQUltQyxHQUFHLEdBQUdsTCxRQUFRLENBQUM2QyxhQUFULENBQXVCLEtBQXZCLENBQVY7VUFDQXFJLEdBQUcsQ0FBQzdJLFNBQUosQ0FBY0UsR0FBZCxDQUFrQixLQUFsQjtVQUNBMkksR0FBRyxDQUFDbEssU0FBSixHQUFnQixHQUFoQjtVQUVBMFksSUFBSSxDQUFDelgsTUFBTCxDQUFZaUosR0FBWjtVQUVBLE9BQU93TyxJQUFQO1FBQ0Q7TUFDRjtJQUNGLENBbEVEO0VBbUVEO0FBQ0YsQzs7QUM1RkQ7QUFDQTtBQUVlLFNBQVNNLFdBQVQsR0FBdUI7RUFDcEMsSUFBSUMsaUJBQWlCLEdBQUd2YSxRQUFDLENBQUMsWUFBRCxDQUFELENBQWdCLENBQWhCLENBQXhCOztFQUNBLElBQUl1YSxpQkFBSixFQUF1QjtJQUNyQnZhLFFBQUMsQ0FBQ3VhLGlCQUFELENBQUQsQ0FBcUI3VCxFQUFyQixDQUF3QixPQUF4QixFQUFpQ2tELFdBQVcsQ0FBQ25DLElBQVosQ0FBaUIsSUFBakIsQ0FBakM7RUFDRDs7RUFFRCxlQUFlbUMsV0FBZixPQUFxQztJQUFBLElBQVY7TUFBQzdHO0lBQUQsQ0FBVTtJQUVuQyxJQUFJdUQsSUFBSSxHQUFHaVUsaUJBQVg7SUFDQSxJQUFJakgsU0FBUyxHQUFHaE4sSUFBSSxDQUFDdUQsT0FBTCxDQUFhUSxLQUE3Qjs7SUFDQSxJQUFJdEgsTUFBTSxDQUFDRSxPQUFQLENBQWUsT0FBZixDQUFKLEVBQTZCO01BQzNCeVMsSUFBSSxDQUFDcEMsU0FBRCxDQUFKO0lBQ0QsQ0FGRCxNQUVPLElBQUl2USxNQUFNLENBQUNFLE9BQVAsQ0FBZSxNQUFmLEtBQ05GLE1BQU0sQ0FBQ0UsT0FBUCxDQUFlLE1BQWYsRUFBdUI0RyxPQUF2QixDQUErQlEsS0FEN0IsRUFDb0M7TUFDekNtQixHQUFHLENBQUNsRixJQUFELEVBQU92RCxNQUFNLENBQUNFLE9BQVAsQ0FBZSxNQUFmLEVBQXVCNEcsT0FBdkIsQ0FBK0JRLEtBQXRDLENBQUg7SUFDRCxDQUhNLE1BR0EsSUFBS3RILE1BQU0sQ0FBQ0osU0FBUCxDQUFpQkssUUFBakIsQ0FBMEIsS0FBMUIsQ0FBTCxFQUF3QztNQUM3Q3dYLFNBQVMsQ0FBQ3pYLE1BQUQsRUFBU3VRLFNBQVQsQ0FBVDtJQUNEO0VBQ0Y7O0VBRUQsZUFBZWtILFNBQWYsQ0FBeUJ6WCxNQUF6QixFQUFpQztJQUMvQixJQUFJMFgsY0FBYyxHQUFHemEsUUFBQyxDQUFFLGNBQUYsQ0FBRCxDQUFrQixDQUFsQixDQUFyQjtJQUNBeWEsY0FBYyxDQUFDOVgsU0FBZixDQUF5QjhGLE1BQXpCLENBQWdDLE1BQWhDO0lBQ0EsSUFBSWlTLE9BQU8sR0FBRzFhLFFBQUMsQ0FBRSxvQkFBbUIrQyxNQUFNLENBQUM4RyxPQUFQLENBQWVSLEVBQUcsSUFBdkMsQ0FBRCxDQUE2QyxDQUE3QyxDQUFkO0lBQ0FxUixPQUFPLENBQUMvWCxTQUFSLENBQWtCOEYsTUFBbEIsQ0FBeUIsTUFBekI7SUFDQSxJQUFJa1MsU0FBUyxHQUFHM2EsUUFBQyxDQUFFLGFBQUYsQ0FBRCxDQUFpQixDQUFqQixDQUFoQjtJQUNBMmEsU0FBUyxDQUFDaFksU0FBVixDQUFvQjhGLE1BQXBCLENBQTJCLFFBQTNCO0lBQ0ExRixNQUFNLENBQUNKLFNBQVAsQ0FBaUI4RixNQUFqQixDQUF3QixRQUF4QjtFQUNEOztFQUVELGVBQWUrQyxHQUFmLENBQW1CbEYsSUFBbkIsRUFBeUJnTixTQUF6QixFQUFvQztJQUNsQyxJQUFJakssRUFBRSxHQUFHL0MsSUFBSSxDQUFDdUQsT0FBTCxDQUFhUixFQUF0QjtJQUNBLElBQUkxSCxHQUFHLEdBQUcsTUFBTW1DLElBQUksQ0FBRSxZQUFXd1AsU0FBVSxTQUF2QixFQUFpQztNQUFDaks7SUFBRCxDQUFqQyxDQUFwQjs7SUFDQSxJQUFJMUgsR0FBSixFQUFTO01BQ1BkLE1BQU0sQ0FBQytDLFFBQVAsQ0FBZ0IrSSxJQUFoQixHQUF3QixZQUFXMkcsU0FBVSxPQUE3QztJQUNEO0VBQ0Y7O0VBRUQsZUFBZW9DLElBQWYsQ0FBb0JwQyxTQUFwQixFQUErQjtJQUM3QixJQUFJc0gsYUFBYSxFQUFqQixFQUFxQixPQUFPLEtBQVA7SUFDckIsSUFBSXZRLEtBQUssR0FBR3FNLFFBQVEsRUFBcEI7SUFDQSxJQUFJL1UsR0FBRyxHQUFHLE1BQU1tQyxJQUFJLENBQUUsWUFBV3dQLFNBQVUsaUJBQXZCLEVBQXlDLEVBQUMsR0FBR2pKO0lBQUosQ0FBekMsQ0FBcEI7RUFDRDs7RUFFRCxTQUFTdVEsYUFBVCxHQUF5QjtJQUN2QixJQUFJQyxRQUFRLEdBQUc3YSxRQUFDLENBQUMsWUFBRCxDQUFoQjtJQUNBLElBQUk4YSxRQUFRLEdBQUcsQ0FBZjtJQUNBLEdBQUc1VSxPQUFILENBQVdtQixJQUFYLENBQWdCd1QsUUFBaEIsRUFBMEIsVUFBVXhZLEVBQVYsRUFBYztNQUN0QyxJQUFJLENBQUNBLEVBQUUsQ0FBQ2YsU0FBUixFQUFtQjtRQUNqQmUsRUFBRSxDQUFDZCxLQUFILENBQVN3WixXQUFULEdBQXVCLEtBQXZCO1FBQ0EsSUFBSS9hLFFBQUMsQ0FBQ3FDLEVBQUQsQ0FBRCxDQUFNNEYsSUFBTixDQUFXLFFBQVgsQ0FBSixFQUEwQjtRQUMxQixJQUFJaEgsS0FBSyxHQUFHWCxRQUFRLENBQUM2QyxhQUFULENBQXVCLEtBQXZCLENBQVo7UUFDQWxDLEtBQUssQ0FBQ0ssU0FBTixHQUFrQixnQkFBbEI7UUFDQUwsS0FBSyxDQUFDMEIsU0FBTixDQUFnQkUsR0FBaEIsQ0FBb0IsT0FBcEI7UUFDQVIsRUFBRSxDQUFDWSxPQUFILENBQVcsUUFBWCxFQUFxQm9ELFdBQXJCLENBQWlDcEYsS0FBakM7UUFDQTZaLFFBQVE7TUFDVDtJQUNGLENBVkQ7SUFXQSxPQUFPQSxRQUFQO0VBQ0Q7O0VBRUQsU0FBU3BFLFFBQVQsR0FBb0I7SUFDbEIsSUFBSXpJLE1BQU0sR0FBR2pPLFFBQUMsQ0FBQyxjQUFELENBQWQ7SUFDQSxJQUFJbVksR0FBRyxHQUFHLEVBQVY7O0lBRUEsU0FBU3RCLENBQVQsQ0FBVzFYLEdBQVgsRUFBZ0I7TUFDZCxPQUFPQSxHQUFHLENBQUNPLE9BQUosQ0FBWSxnQkFBWixFQUE4QixJQUE5QixDQUFQO0lBQ0QsQ0FOaUIsQ0FRbEI7OztJQUNBLEdBQUc2SixHQUFILENBQU9sQyxJQUFQLENBQVk0RyxNQUFaLEVBQXFCQyxLQUFELElBQVc7TUFDN0IsSUFBSUEsS0FBSyxDQUFDd0YsWUFBTixDQUFtQixjQUFuQixDQUFKLEVBQXdDO1FBQ3RDLElBQUlvRyxLQUFLLEdBQUc1TCxLQUFLLENBQUN6SCxnQkFBTixDQUF1QixPQUF2QixDQUFaO1FBQ0EsSUFBSTRNLEdBQUcsR0FBRyxHQUFHOUosR0FBSCxDQUFPbEMsSUFBUCxDQUFZeVMsS0FBWixFQUFvQkUsSUFBRCxJQUFVO1VBQ3JDLE9BQU9BLElBQUksQ0FBQ25RLE9BQUwsQ0FBYVIsRUFBcEI7UUFDRCxDQUZTLENBQVY7UUFHQThPLEdBQUcsQ0FBQ2pLLEtBQUssQ0FBQ3JFLE9BQU4sQ0FBY3FFLEtBQWYsQ0FBSCxHQUEyQm1GLEdBQUcsQ0FBQzJILFFBQUosRUFBM0I7TUFDRCxDQU5ELE1BTU8sSUFBSTlNLEtBQUssQ0FBQ3dGLFlBQU4sQ0FBbUIsZUFBbkIsQ0FBSixFQUF5QztRQUM5Q3lFLEdBQUcsQ0FBQ2pLLEtBQUssQ0FBQ3JFLE9BQU4sQ0FBY3FFLEtBQWYsQ0FBSCxHQUEyQkEsS0FBSyxDQUFDckUsT0FBTixDQUFjekksS0FBekM7TUFDRCxDQUZNLE1BRUEsSUFBSThNLEtBQUssQ0FBQ3JFLE9BQU4sQ0FBY3FILElBQWQsS0FBdUIsUUFBM0IsRUFBcUM7UUFDMUNpSCxHQUFHLENBQUNqSyxLQUFLLENBQUNyRSxPQUFOLENBQWNxRSxLQUFmLENBQUgsR0FBMkIrTSxTQUFTLENBQUMvTSxLQUFELENBQXBDO01BQ0QsQ0FGTSxNQUVBLElBQUlBLEtBQUssQ0FBQ3dGLFlBQU4sQ0FBbUIsY0FBbkIsQ0FBSixFQUF3QztRQUM3Q3lFLEdBQUcsQ0FBQ2pLLEtBQUssQ0FBQ3JFLE9BQU4sQ0FBY3FFLEtBQWYsQ0FBSCxHQUEyQkEsS0FBSyxDQUFDckUsT0FBTixDQUFjekksS0FBekM7TUFDRCxDQUZNLE1BRUEsSUFBSThNLEtBQUssQ0FBQ3dGLFlBQU4sQ0FBbUIsS0FBbkIsQ0FBSixFQUErQjtRQUNwQ3lFLEdBQUcsQ0FBQ2pLLEtBQUssQ0FBQ3JFLE9BQU4sQ0FBY3FFLEtBQWYsQ0FBSCxHQUEyQkEsS0FBSyxDQUFDckUsT0FBTixDQUFjekksS0FBekM7TUFDRCxDQUZNLE1BRUEsSUFBSThNLEtBQUssQ0FBQ2dELElBQU4sS0FBZSxNQUFuQixFQUEyQjtRQUNoQ2lILEdBQUcsQ0FBQ2pLLEtBQUssQ0FBQ3JFLE9BQU4sQ0FBY3FFLEtBQWYsQ0FBSCxHQUEyQkEsS0FBSyxDQUFDOU0sS0FBakM7TUFDRCxDQUZNLE1BRUE7UUFDTCtXLEdBQUcsQ0FBQ2pLLEtBQUssQ0FBQ3JFLE9BQU4sQ0FBY3FFLEtBQWYsQ0FBSCxHQUEyQjJJLENBQUMsQ0FBQzNXLE9BQU8sQ0FBQ2dPLEtBQUssQ0FBQzVNLFNBQVAsQ0FBUixDQUE1QjtNQUNEO0lBQ0YsQ0FwQkQsRUFvQkc2VyxHQXBCSDtJQXFCQSxJQUFJekwsTUFBTSxHQUFHMU0sUUFBQyxDQUFDLGVBQUQsQ0FBRCxDQUFtQixDQUFuQixDQUFiOztJQUNBLElBQUkwTSxNQUFKLEVBQVk7TUFDVnlMLEdBQUcsQ0FBQ3pMLE1BQUosR0FBYSxDQUFDQSxNQUFNLENBQUM3QyxPQUFQLENBQWVxUixNQUE3QjtJQUNEOztJQUNELE9BQU8vQyxHQUFQO0VBQ0Q7O0VBRUQsU0FBUzhDLFNBQVQsQ0FBbUIvTSxLQUFuQixFQUEwQjtJQUN4QixJQUFJaUYsTUFBTSxHQUFHakYsS0FBSyxDQUFDekgsZ0JBQU4sQ0FBdUIsT0FBdkIsQ0FBYjtJQUNBLElBQUkwVSxLQUFLLEdBQUcsRUFBWjtJQUNBaEksTUFBTSxDQUFDak4sT0FBUCxDQUFnQnNPLEdBQUQsSUFBUztNQUN0QixJQUFJLENBQUNBLEdBQUcsQ0FBQzFPLE9BQVQsRUFBa0I7TUFDbEIsSUFBSThILElBQUksR0FBRzRHLEdBQUcsQ0FBQzRHLFVBQUosQ0FBZS9XLGFBQWYsQ0FBNkIsT0FBN0IsRUFBc0MvQyxTQUFqRDtNQUNBLElBQUksQ0FBQ3NNLElBQUwsRUFBVztNQUNYdU4sS0FBSyxDQUFDL1UsSUFBTixDQUFXd0gsSUFBWDtJQUNELENBTEQ7SUFNQSxPQUFPdU4sS0FBSyxDQUFDRSxJQUFOLENBQVcsR0FBWCxDQUFQO0VBRUQ7QUFDRixDOztBQ2pIRDtBQUVlLFNBQVNDLFFBQVQsR0FBb0I7RUFFakNoYixRQUFRLENBQUNrQyxnQkFBVCxDQUEwQixZQUExQixFQUF3QytZLE9BQXhDLEVBQWlELElBQWpEO0VBQ0FqYixRQUFRLENBQUNrQyxnQkFBVCxDQUEwQixZQUExQixFQUF3Q2daLE9BQXhDLEVBQWlELElBQWpEOztFQUdBLFNBQVNELE9BQVQsT0FBMkI7SUFBQSxJQUFWO01BQUN4WTtJQUFELENBQVU7SUFDN0I7SUFDSTtJQUNBLElBQUksQ0FBQ0EsTUFBTSxDQUFDOEcsT0FBUixJQUFpQixDQUFDOUcsTUFBTSxDQUFDOEcsT0FBUCxDQUFlNFIsT0FBckMsRUFBOEM7SUFFOUMsSUFBSUMsV0FBVyxHQUFHM1ksTUFBTSxDQUFDOEcsT0FBUCxDQUFlNFIsT0FBakMsQ0FMeUIsQ0FNekI7O0lBQ0EsSUFBSUUsV0FBVyxHQUFHcmIsUUFBUSxDQUFDNkMsYUFBVCxDQUF1QixLQUF2QixDQUFsQjtJQUNBd1ksV0FBVyxDQUFDN2IsU0FBWixHQUF3QixTQUF4QjtJQUNBNmIsV0FBVyxDQUFDeFcsU0FBWixHQUF3QnVXLFdBQXhCO0lBQ0FwYixRQUFRLENBQUNtQyxJQUFULENBQWNGLE1BQWQsQ0FBcUJvWixXQUFyQixFQVZ5QixDQVl6Qjs7SUFDQSxJQUFJQyxNQUFNLEdBQUc3WSxNQUFNLENBQUM4WSxxQkFBUCxFQUFiO0lBRUEsSUFBSUMsSUFBSSxHQUFHRixNQUFNLENBQUNFLElBQVAsR0FBYyxDQUFDL1ksTUFBTSxDQUFDZ1osV0FBUCxHQUFxQkosV0FBVyxDQUFDSSxXQUFsQyxJQUFpRCxDQUExRTtJQUNBLElBQUlELElBQUksR0FBRyxDQUFYLEVBQWNBLElBQUksR0FBRyxDQUFQLENBaEJXLENBZ0JEOztJQUV4QixJQUFJRSxHQUFHLEdBQUdKLE1BQU0sQ0FBQ0ksR0FBUCxHQUFhTCxXQUFXLENBQUNNLFlBQXpCLEdBQXdDLENBQWxEOztJQUNBLElBQUlELEdBQUcsR0FBRyxDQUFWLEVBQWE7TUFBRTtNQUNiQSxHQUFHLEdBQUdKLE1BQU0sQ0FBQ0ksR0FBUCxHQUFhalosTUFBTSxDQUFDa1osWUFBcEIsR0FBbUMsQ0FBekM7SUFDRDs7SUFFRE4sV0FBVyxDQUFDcGEsS0FBWixDQUFrQnVhLElBQWxCLEdBQXlCQSxJQUFJLEdBQUcsSUFBaEM7SUFDQUgsV0FBVyxDQUFDcGEsS0FBWixDQUFrQnlhLEdBQWxCLEdBQXdCQSxHQUFHLEdBQUcsSUFBOUI7RUFDRDs7RUFBQTs7RUFFRCxTQUFTUixPQUFULEdBQW1CO0lBQ2pCLElBQUlGLFFBQVEsR0FBR2hiLFFBQVEsQ0FBQ21HLGdCQUFULENBQTBCLFVBQTFCLENBQWY7O0lBQ0EsSUFBSTZVLFFBQUosRUFBYztNQUNaLEdBQUdwVixPQUFILENBQVdtQixJQUFYLENBQWdCaVUsUUFBaEIsRUFBMkIvVCxHQUFELElBQVM7UUFDL0JBLEdBQUcsQ0FBQzNFLE1BQUo7TUFDRCxDQUZIO0lBSUQ7RUFDRjs7RUFBQTtBQUNGLEM7O0FDNUNEO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE1QyxRQUFDLENBQUNNLFFBQUQsQ0FBRCxDQUFZd0csS0FBWixDQUFrQixZQUFZO0VBRTVCcVYsUUFBUSxDQUFDdGIsTUFBTSxDQUFDK0MsUUFBUCxDQUFnQmlOLFFBQWpCLENBQVI7RUFDQTJJLFdBQUs7RUFDTDNHLElBQUk7RUFDSjhHLFdBQVc7RUFDWFcsV0FBVztFQUNYZ0IsUUFBUTtFQUVSbEUsYUFBYTtFQUVibkgsUUFBUTs7RUFFUixTQUFTa00sUUFBVCxDQUFrQmhkLEdBQWxCLEVBQXVCO0lBQ3JCLElBQUksc0JBQXNCeUMsSUFBdEIsQ0FBMkJ6QyxHQUEzQixLQUNDLHlCQUF5QnlDLElBQXpCLENBQThCekMsR0FBOUIsQ0FERCxJQUVDLHdCQUF3QnlDLElBQXhCLENBQTZCekMsR0FBN0IsQ0FGRCxJQUdGLHdCQUF3QnlDLElBQXhCLENBQTZCekMsR0FBN0IsQ0FIRixFQUdxQztNQUNuQ3dXLE1BQU07TUFDTjNWLFFBQUMsQ0FBQyw0QkFBRCxDQUFELENBQWdDc0YsUUFBaEMsQ0FBeUMsU0FBekM7SUFDRCxDQU5ELE1BTU8sSUFBSSxpQ0FBaUMxRCxJQUFqQyxDQUFzQ3pDLEdBQXRDLENBQUosRUFBZ0Q7TUFDckRhLFFBQUMsQ0FBQyxnQ0FBRCxDQUFELENBQW9Dc0YsUUFBcEMsQ0FBNkMsU0FBN0M7SUFDRCxDQUZNLE1BRUEsSUFBSSxpQ0FBaUMxRCxJQUFqQyxDQUFzQ3pDLEdBQXRDLENBQUosRUFBZ0Q7TUFDckRhLFFBQUMsQ0FBQyxnQ0FBRCxDQUFELENBQW9Dc0YsUUFBcEMsQ0FBNkMsU0FBN0M7SUFDRCxDQUZNLE1BRUEsSUFBSSxrQkFBa0IxRCxJQUFsQixDQUF1QnpDLEdBQXZCLENBQUosRUFBaUM7TUFDdENrVCxJQUFJO0lBQ0wsQ0FGTSxNQUVBLElBQUksaUJBQWlCelEsSUFBakIsQ0FBc0J6QyxHQUF0QixDQUFKLEVBQWdDO01BQ3JDYSxRQUFDLENBQUMsdUJBQUQsQ0FBRCxDQUEyQnNGLFFBQTNCLENBQW9DLFNBQXBDO0lBQ0QsQ0FGTSxNQUVBLElBQUkscUJBQXFCMUQsSUFBckIsQ0FBMEJ6QyxHQUExQixDQUFKLEVBQW9DO01BQ3pDYSxRQUFDLENBQUMsMkJBQUQsQ0FBRCxDQUErQnNGLFFBQS9CLENBQXdDLFNBQXhDO0lBQ0QsQ0FGTSxNQUVBLElBQUksc0JBQXNCMUQsSUFBdEIsQ0FBMkJ6QyxHQUEzQixDQUFKLEVBQXFDO01BQzFDYSxRQUFDLENBQUMsNEJBQUQsQ0FBRCxDQUFnQ3NGLFFBQWhDLENBQXlDLFNBQXpDO0lBQ0QsQ0FGTSxNQUVBLElBQUksNEJBQTRCMUQsSUFBNUIsQ0FBaUN6QyxHQUFqQyxLQUNOLHdCQUF3QnlDLElBQXhCLENBQTZCekMsR0FBN0IsQ0FERSxFQUNpQztNQUN0Q2EsUUFBQyxDQUFDLDZCQUFELENBQUQsQ0FBaUNzRixRQUFqQyxDQUEwQyxTQUExQztJQUNELENBSE0sTUFHQSxJQUFJLFNBQVMxRCxJQUFULENBQWN6QyxHQUFkLEtBQXNCLGlCQUFpQnlDLElBQWpCLENBQXNCekMsR0FBdEIsQ0FBMUIsRUFBc0Q7TUFDM0RhLFFBQUMsQ0FBQyxtQkFBRCxDQUFELENBQXVCc0YsUUFBdkIsQ0FBZ0MsU0FBaEM7SUFDRCxDQUZNLE1BRUEsSUFBSSxxQkFBcUIxRCxJQUFyQixDQUEwQnpDLEdBQTFCLENBQUosRUFBb0M7TUFDekNhLFFBQUMsQ0FBQyw0QkFBRCxDQUFELENBQWdDc0YsUUFBaEMsQ0FBeUMsU0FBekM7SUFDRCxDQUZNLE1BRUE7TUFDTHRGLFFBQUMsQ0FBQyxtQkFBRCxDQUFELENBQXVCc0YsUUFBdkIsQ0FBZ0MsU0FBaEM7SUFDRDtFQUVGO0FBRUYsQ0E3Q0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL2NvbW1vbi5qcz81OTIxIiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvY29tcG9uZW50cy9hY2NvcmRpb24vYWNjb3JkaW9uLmpzPzI1YjUiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9jb21wb25lbnRzL2FkbWluX3NpZGViYXIuanM/ZGVmZiIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL0FkbWluL21vZGVsL2NhY2hlLmpzPzFlMTciLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9UZXN0L21vZGVsL190ZXN0UmVzdWx0LmpzPzE2NjgiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9UZXN0L3Rlc3RfcmVzdWx0cy90ZXN0X3Jlc3VsdHMuanM/NTM0YSIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL1Rlc3QvbW9kZWwvb3BlbnRlc3Qvb3BlbnF1ZXN0aW9uLmpzPzI0OTMiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3NvcnRhYmxlanMvbW9kdWxhci9zb3J0YWJsZS5lc20uanM/YWE0NyIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL2NvbXBvbmVudHMvc29ydGFibGUuanM/ZGNmNSIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL1Rlc3QvbW9kZWwvb3BlbnRlc3Qvb3BlbnRlc3QuanM/YjU3NyIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL1Rlc3QvbW9kZWwvb3BlbnRlc3Qvb3BlbmFuc3dlci5qcz8wNmRlIiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvVGVzdC9vcGVudGVzdC1lZGl0LmpzPzYyOGYiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9UZXN0L21vZGVsL2Fuc3dlci5qcz85OWFkIiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvVGVzdC9tb2RlbC9xdWVzdGlvbi5qcz8yM2Q5Iiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvVGVzdC9tb2RlbC90ZXN0LmpzPzlhNmEiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9UZXN0L3Rlc3QtZWRpdC5qcz9hZDVhIiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvVGVzdC90ZXN0LXBhZ2luYXRpb24vdGVzdC1wYWdpbmF0aW9uLmpzP2M2YzYiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9UZXN0L2RvLmpzPzRjMzUiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9jb21wb25lbnRzL2xpc3QvbGlzdC5qcz9mMDIzIiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvQWRtaW4vUmlnaHRzL3JpZ2h0cy5qcz82ZWUzIiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvQXV0aC9nZXRTZXguanM/NTVmNCIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL0FkbWluL3VzZXIvdXNlci5qcz8wZDFhIiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvY29tcG9uZW50cy9hY2NvcmRpb24tc2hvdy5qcz81ZmM5Iiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvVGVzdC9vcGVuX3Rlc3QuanM/MmQ3NiIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL2NvbXBvbmVudHMvcmFkaW8vcmFkaW8uanM/ZWU0YiIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL2NvbXBvbmVudHMvbXVsdGlzZWxlY3QvbXVsdGlzZWxlY3QuanM/NWE1MCIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL2NvbXBvbmVudHMvY2F0YWxvZy1pdGVtL2NhdGFsb2ctaXRlbS5qcz85NjMxIiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvY29tcG9uZW50cy90b29sdGlwL3Rvb2x0aXAuanM/YTAxOCIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL0FkbWluL2FkbWluLmpzPzI1YzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICcuL2NvbW1vbi5zY3NzJ1xyXG5cclxuY29uc3QgZGVib3VuY2UgPSAoZm4sIHRpbWUgPSA3MDApID0+IHtcclxuICBsZXQgdGltZW91dDtcclxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgY29uc3QgZnVuY3Rpb25DYWxsID0gKCkgPT4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uQ2FsbCwgdGltZSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBJc0pzb24oc3RyKSB7XHJcbiAgdHJ5IHtcclxuICAgIEpTT04ucGFyc2Uoc3RyKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIHJlcGxhY2VOYnNwcyhzdHIpIHtcclxuICB2YXIgcmUgPSBuZXcgUmVnRXhwKCcmbmJzcDs/JywgXCJnXCIpO1xyXG4gIHJldHVybiBzdHIucmVwbGFjZShyZSwgXCIgXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXBsYWNlTnMoc3RyKSB7XHJcbiAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnXFxcXG4/JywgXCJnXCIpO1xyXG4gIHJldHVybiBzdHIucmVwbGFjZShyZSwgXCJcIik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlcGxhY2VUcyhzdHIpIHtcclxuICB2YXIgcmUgPSBuZXcgUmVnRXhwKCdcXFxcdD8nLCBcImdcIik7XHJcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlLCBcIlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2FjaGVQYWdlKGNsYXNzTmFtZSkge1xyXG4gIGxldCBodG1sID0gJChjbGFzc05hbWUpWzBdLm91dGVySFRNTFxyXG4gIHJldHVybiB0cmltU3RyKGh0bWwpXHJcbn1cclxuZnVuY3Rpb24gdHJpbVN0cihzdHIpIHtcclxuICBzdHIgPSByZXBsYWNlTmJzcHMoc3RyKVxyXG4gIHN0ciA9IHJlcGxhY2VOcyhzdHIpXHJcbiAgc3RyID0gcmVwbGFjZVRzKHN0cilcclxuICByZXR1cm4gc3RyXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyb3BEb3duKGVsZW1lbnRJZCkge1xyXG4gIHZhciBkcm9wZG93biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRJZCk7XHJcbiAgdHJ5IHtcclxuICAgIHNob3dEcm9wZG93bihkcm9wZG93bik7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG5cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gc2hvd0Ryb3Bkb3duKGVsZW1lbnQpIHtcclxuICB2YXIgZXZlbnQ7XHJcbiAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcclxuICBldmVudC5pbml0TW91c2VFdmVudCgnbW91c2Vkb3duJywgdHJ1ZSwgdHJ1ZSwgd2luZG93KTtcclxuICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG59O1xyXG5cclxuXHJcbmxldCB2YWxpZGF0ZSA9IHtcclxuICBzb3J0OiAoKSA9PiB7XHJcbiAgICBsZXQgZXJyb3IgPSB0aGlzLm5leHRFbGVtZW50U2libGluZ1xyXG4gICAgbGV0IGFyID0gdGhpcy52YWx1ZS5tYXRjaCgvXFxEKy8pXHJcbiAgICBpZiAoYXIpIHtcclxuICAgICAgZXJyb3IuaW5uZXJUZXh0ID0gJ9Ci0L7Qu9GM0LrQviDRhtC40YTRgNGLJ1xyXG4gICAgICBlcnJvci5zdHlsZS5vcGFjaXR5ID0gJzEnXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoZXJyb3Iuc3R5bGUub3BhY2l0eSA9PT0gXCIxXCIpIHtcclxuICAgICAgICBlcnJvci5zdHlsZS5vcGFjaXR5ID0gJzAnXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG4gIGVtYWlsOiAoZW1haWwpID0+IHtcclxuICAgIGlmICghZW1haWwpIHJldHVybiBmYWxzZVxyXG4gICAgbGV0IHRleHQgPSBcItCd0LXQv9GA0LDQstC40LvRjNC90YvQuSDRhNC+0YDQvNCw0YIg0L/QvtGH0YLRi1wiXHJcbiAgICBsZXQgcmUgPSAvXigoW148PigpW1xcXVxcXFwuLDs6XFxzQFwiXSsoXFwuW148PigpW1xcXVxcXFwuLDs6XFxzQFwiXSspKil8KFwiLitcIikpQCgoXFxbWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcXSl8KChbYS16QS1aXFwtMC05XStcXC4pK1thLXpBLVpdezIsfSkpJC87XHJcbiAgICBsZXQgcmVzID0gcmUudGVzdChTdHJpbmcoZW1haWwpLnRvTG93ZXJDYXNlKCkpXHJcbiAgICBpZiAoIXJlcykgcmV0dXJuIHRleHRcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH0sXHJcbiAgcGFzc3dvcmQ6IChwYXNzd29yZCkgPT4ge1xyXG4gICAgaWYgKCFwYXNzd29yZCkgcmV0dXJuIGZhbHNlXHJcbiAgICBsZXQgdGV4dCA9IFwi0J/QsNGA0L7Qu9GMINC80L7QttC10YIg0YHQvtGB0YLQvtGP0YLRjCDQuNC3IFxcbiBcIiArXHJcbiAgICAgIFwiLSDQkdC+0LvRjNGI0LjQtSDQu9Cw0YLQuNC90YHQutC40LUg0LHQutGD0LLRiyBcXG5cIiArXHJcbiAgICAgIFwiLSDQnNCw0LvQtdC90YzQutC40LUg0LvQsNGC0LjQvdGB0LrQuNC1INCx0YPQutCy0YsgXFxuXCIgK1xyXG4gICAgICBcIi0g0KbQuNGE0YDRiyBcXG5cIiArXHJcbiAgICAgIFwiLSDQlNC+0LvQttC10L0g0YHQvtC00LXRgNC20LDRgtGMINC90LUg0LzQtdC90LXQtSA2INGB0LjQvNCy0L7Qu9C+0LJcIlxyXG4gICAgbGV0IHJlcyA9IC9eW2EtekEtWlxcLTAtOV17NiwyMH0kLy50ZXN0KHBhc3N3b3JkKVxyXG4gICAgaWYgKCFyZXMpIHJldHVybiB0ZXh0XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcbn1cclxuXHJcblxyXG4vLyBmdW5jdGlvbiB1cCgpIHtcclxuLy8gICAgdmFyIHRvcCA9IE1hdGgubWF4KGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wLCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKTtcclxuLy8gICAgaWYgKHRvcCA+IDApIHtcclxuLy8gICAgICAgd2luZG93LnNjcm9sbEJ5KDAsIC0xMDApO1xyXG4vLyAgICAgICB2YXIgdCA9IHNldFRpbWVvdXQoJ3VwKCknLCAyMCk7XHJcbi8vICAgIH1cclxuLy8gICAgZWxzZVxyXG4vLyAgICAgICBjbGVhclRpbWVvdXQodCk7XHJcbi8vICAgIHJldHVybiBmYWxzZTtcclxuLy8gfVxyXG5cclxubGV0IHBvcHVwID0ge1xyXG5cclxuICBzaG93OiBmdW5jdGlvbiAodHh0LCBjYWxsYmFjaykge1xyXG4gICAgbGV0IGNsb3NlID0gdGhpcy5lbCgnZGl2JywgJ3BvcHVwX19jbG9zZScpXHJcbiAgICBjbG9zZS5pbm5lclRleHQgPSAnWCdcclxuICAgIGxldCBwb3B1cF9faXRlbSA9IHRoaXMuZWwoJ2RpdicsICdwb3B1cF9faXRlbScpXHJcblxyXG4gICAgcG9wdXBfX2l0ZW0uaW5uZXJUZXh0ID0gdHh0XHJcbiAgICBwb3B1cF9faXRlbS5hcHBlbmQoY2xvc2UpXHJcbiAgICBsZXQgcG9wdXAgPSAkKCcucG9wdXAnKVswXVxyXG4gICAgaWYgKCFwb3B1cCkge1xyXG4gICAgICBwb3B1cCA9IHRoaXMuZWwoJ2RpdicsICdwb3B1cCcpXHJcbiAgICB9XHJcbiAgICBwb3B1cC5hcHBlbmQocG9wdXBfX2l0ZW0pXHJcbiAgICBwb3B1cC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuY2xvc2UsIHRydWUpXHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChwb3B1cClcclxuICAgIGxldCBoaWRlRGVsYXkgPSA1MDAwO1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHBvcHVwX19pdGVtLmNsYXNzTGlzdC5yZW1vdmUoJ3BvcHVwX19pdGVtJylcclxuICAgICAgcG9wdXBfX2l0ZW0uY2xhc3NMaXN0LmFkZCgncG9wdXAtaGlkZScpXHJcbiAgICB9LCBoaWRlRGVsYXkpXHJcbiAgICBsZXQgcmVtb3ZlRGVsYXkgPSBoaWRlRGVsYXkgKyA5NTA7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgcG9wdXBfX2l0ZW0ucmVtb3ZlKClcclxuICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY2FsbGJhY2soKVxyXG4gICAgICB9XHJcbiAgICB9LCByZW1vdmVEZWxheSlcclxuICB9LFxyXG5cclxuICBjbG9zZTogZnVuY3Rpb24gKGUpIHtcclxuICAgIGlmIChlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3BvcHVwX19jbG9zZScpKSB7XHJcbiAgICAgIGxldCBwb3B1cCA9IHRoaXMuY2xvc2VzdCgnLnBvcHVwJykucmVtb3ZlKClcclxuICAgIH1cclxuICB9LFxyXG4gIGVsOiBmdW5jdGlvbiAodGFnTmFtZSwgY2xhc3NOYW1lKSB7XHJcbiAgICBsZXQgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpXHJcbiAgICBlbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSlcclxuICAgIHJldHVybiBlbFxyXG4gIH1cclxufVxyXG5cclxuY29uc3QgdW5pcSA9IChhcnJheSkgPT4gQXJyYXkuZnJvbShuZXcgU2V0KGFycmF5KSk7XHJcblxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZ2V0KGtleSkge1xyXG4gIGxldCBwID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaDtcclxuICBwID0gcC5tYXRjaChuZXcgUmVnRXhwKGtleSArICc9KFteJj1dKyknKSk7XHJcbiAgcmV0dXJuIHAgPyBwWzFdIDogZmFsc2U7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHBvc3QodXJsLCBkYXRhID0ge30pIHtcclxuXHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgZGF0YS50b2tlbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT1cInRva2VuXCJdJykuZ2V0QXR0cmlidXRlKCdjb250ZW50JylcclxuICAgICAgbGV0IHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICByZXEub3BlbignUE9TVCcsIHVybCwgdHJ1ZSk7XHJcbiAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKFwiWC1SZXF1ZXN0ZWQtV2l0aFwiLCBcIlhNTEh0dHBSZXF1ZXN0XCIpO1xyXG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XHJcbiAgICAgICAgcmVxLnNlbmQoZGF0YSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcclxuICAgICAgICByZXEuc2VuZCgncGFyYW09JyArIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcclxuICAgICAgfVxyXG4gICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgcmVqZWN0KEVycm9yKFwiTmV0d29yayBFcnJvclwiICsgZSkpO1xyXG4gICAgICB9O1xyXG4gICAgICByZXEub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGxldCByZXMgPSBKU09OLnBhcnNlKHJlcS5yZXNwb25zZSlcclxuICAgICAgICBsZXQgbXNnID0gJCgnLm1lc3NhZ2UnKVswXVxyXG4gICAgICAgIGlmIChyZXMucG9wdXApIHtcclxuICAgICAgICAgIHBvcHVwLnNob3cocmVzLnBvcHVwKVxyXG4gICAgICAgIH0gZWxzZSBpZiAocmVzLm1zZykge1xyXG4gICAgICAgICAgaWYgKG1zZykge1xyXG4gICAgICAgICAgICBtc2cuaW5uZXJIVE1MID0gcmVzLm1zZ1xyXG4gICAgICAgICAgICBtc2cuaW5uZXJIVE1MID0gcmVzLm1zZ1xyXG4gICAgICAgICAgICAkKG1zZykucmVtb3ZlQ2xhc3MoJ3N1Y2Nlc3MnKVxyXG4gICAgICAgICAgICAkKG1zZykucmVtb3ZlQ2xhc3MoJ2Vycm9yJylcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKHJlcy5zdWNjZXNzKSB7XHJcbiAgICAgICAgICBpZiAobXNnKSB7XHJcbiAgICAgICAgICAgIG1zZy5pbm5lckhUTUwgPSByZXMuc3VjY2Vzc1xyXG4gICAgICAgICAgICAkKG1zZykuYWRkQ2xhc3MoJ3N1Y2Nlc3MnKVxyXG4gICAgICAgICAgICAkKG1zZykucmVtb3ZlQ2xhc3MoJ2Vycm9yJylcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKHJlcy5lcnJvcikge1xyXG4gICAgICAgICAgaWYgKG1zZykge1xyXG4gICAgICAgICAgICBtc2cuaW5uZXJIVE1MID0gJydcclxuICAgICAgICAgICAgbXNnLmlubmVySFRNTCA9IHJlcy5lcnJvclxyXG4gICAgICAgICAgICAkKG1zZykucmVtb3ZlQ2xhc3MoJ3N1Y2Nlc3MnKVxyXG4gICAgICAgICAgICAkKG1zZykuYWRkQ2xhc3MoJ2Vycm9yJylcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzb2x2ZShyZXMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgKVxyXG5cclxufVxyXG5cclxuY2xhc3MgRWxlbWVudENvbGxlY3Rpb24gZXh0ZW5kcyBBcnJheSB7XHJcblxyXG4gIC8vIGVsID0gdGhpc1xyXG4gIC8vIGVsVHlwZSA9IGZ1bmN0aW9uKCl7cmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwodGhpcyl9XHJcblxyXG4gIG9uKGV2ZW50LCBjYk9yU2VsZWN0b3IsIGNiKSB7XHJcbiAgICBpZiAodHlwZW9mIGNiT3JTZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aGlzLmZvckVhY2goZSA9PiBlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNiT3JTZWxlY3RvcikpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmZvckVhY2goZWxlbSA9PiB7XHJcbiAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBlID0+IHtcclxuICAgICAgICAgIGlmIChlLnRhcmdldCA9PT0gY2JPclNlbGVjdG9yKSBjYihlKVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzWzBdLmdldEF0dHJpYnV0ZSgndmFsdWUnKVxyXG4gIH1cclxuICBhdHRyID0gZnVuY3Rpb24gKGF0dHJOYW1lLCBhdHRyVmFsKSB7XHJcbiAgICBpZiAoYXR0clZhbCkge1xyXG4gICAgICB0aGlzWzBdLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbClcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzWzBdLmdldEF0dHJpYnV0ZShhdHRyTmFtZSlcclxuICB9XHJcbiAgc2VsZWN0ZWRJbmRleFZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMubGVuZ3RoKVxyXG4gICAgICByZXR1cm4gdGhpc1swXS5zZWxlY3RlZE9wdGlvbnNbMF0udmFsdWVcclxuICB9XHJcbiAgb3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLmxlbmd0aCkgcmV0dXJuIHRoaXNbMF0ub3B0aW9uc1xyXG4gIH1cclxuICBjb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLmxlbmd0aFxyXG4gIH1cclxuICB0ZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMubGVuZ3RoKSByZXR1cm4gdGhpc1swXS5pbm5lclRleHRcclxuICB9XHJcbiAgY2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLmxlbmd0aCkgcmV0dXJuIHRoaXNbMF0uY2hlY2tlZFxyXG4gIH1cclxuICBnZXRXaXRoU3R5bGUgPSBmdW5jdGlvbiAoYXR0ciwgdmFsKSB7XHJcbiAgICBsZXQgYXJyID0gW11cclxuICAgIHRoaXMuZm9yRWFjaCgocykgPT4ge1xyXG4gICAgICBpZiAocy5zdHlsZVthdHRyXSA9PT0gdmFsKSB7XHJcbiAgICAgICAgYXJyLnB1c2gocylcclxuICAgICAgfVxyXG4gICAgfSlcclxuICAgIHJldHVybiBhcnJcclxuICB9XHJcbiAgYWRkQ2xhc3MgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XHJcbiAgICB0aGlzLmZvckVhY2goKHMpID0+IHtcclxuICAgICAgcy5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSlcclxuICAgIH0pXHJcbiAgfVxyXG4gIHJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xyXG4gICAgdGhpcy5mb3JFYWNoKChzKSA9PiB7XHJcbiAgICAgIHMuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpXHJcbiAgICB9KVxyXG4gIH1cclxuICBoYXNDbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcclxuICAgIGlmICh0aGlzLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpKSByZXR1cm4gdHJ1ZVxyXG4gIH1cclxuICBhcHBlbmQgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgIHRoaXNbMF0uYXBwZW5kQ2hpbGQoZWwpXHJcbiAgfVxyXG4gIGZpbmQgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm4gdGhpc1swXS5xdWVyeVNlbGVjdG9yKGl0ZW0pXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZXQgZmlsdGVyZWQgPSB0aGlzWzBdLmZpbHRlcigoZWwpID0+IHtcclxuICAgICAgICByZXR1cm4gZWwgPT09IGl0ZW1cclxuICAgICAgfSlcclxuICAgICAgcmV0dXJuIGZpbHRlcmVkWzBdXHJcbiAgICB9XHJcbiAgfVxyXG4gIGZpbmRBbGwgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm4gdGhpc1swXS5xdWVyeVNlbGVjdG9yQWxsKGl0ZW0pXHJcbiAgICB9XHJcbiAgfVxyXG4gIGNzcyA9IGZ1bmN0aW9uIChhdHRyLCB2YWwpIHtcclxuICAgIGlmICghdmFsKSB7XHJcbiAgICAgIHJldHVybiB0aGlzWzBdLnN0eWxlW2F0dHJdXHJcbiAgICB9XHJcbiAgICB0aGlzLmZvckVhY2goKHMpID0+IHtcclxuICAgICAgcy5zdHlsZVthdHRyXSA9IHZhbFxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIHJlYWR5KGNiKSB7XHJcbiAgICBjb25zdCBpc1JlYWR5ID0gdGhpcy5zb21lKGUgPT4ge1xyXG4gICAgICByZXR1cm4gZS5yZWFkeVN0YXRlICE9IG51bGwgJiYgZS5yZWFkeVN0YXRlICE9ICdsb2FkaW5nJ1xyXG4gICAgfSlcclxuICAgIGlmIChpc1JlYWR5KSB7XHJcbiAgICAgIGNiKClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBjYilcclxuICAgIH1cclxuICB9XHJcblxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gJChzZWxlY3Rvcikge1xyXG4gIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnIHx8IHNlbGVjdG9yIGluc3RhbmNlb2YgU3RyaW5nKSB7XHJcbiAgICByZXR1cm4gbmV3IEVsZW1lbnRDb2xsZWN0aW9uKC4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gbmV3IEVsZW1lbnRDb2xsZWN0aW9uKHNlbGVjdG9yKVxyXG4gIH1cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGFkZFRvb2x0aXAoYXJncykge1xyXG5cclxuICBbXS5mb3JFYWNoLmNhbGwoYXJncywgKGVsKSA9PiB7XHJcbiAgICBlbC5vbm1vdXNlZW50ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGxldCB0aXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxyXG4gICAgICB0aXAuY2xhc3NMaXN0LmFkZCgndGlwJylcclxuICAgICAgdGlwLmlubmVyVGV4dCA9IGFyZ3MubWVzc2FnZVxyXG5cclxuICAgICAgZWwuYXBwZW5kKHRpcClcclxuICAgICAgbGV0IHJlbW92ZSA9ICgpID0+IHRpcC5yZW1vdmUoKVxyXG4gICAgICB0aXAuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgcmVtb3ZlLmJpbmQodGlwKSwgdHJ1ZSlcclxuICAgIH0uYmluZChhcmdzKVxyXG5cclxuICAgIGVsLm9ubW91c2VsZWF2ZSA9ICgpID0+IHtcclxuICAgICAgbGV0IHRpcCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy50aXAnKVxyXG4gICAgICB0aXAucmVtb3ZlKClcclxuICAgIH1cclxuICB9KVxyXG59XHJcblxyXG5cclxuZXhwb3J0IHtcclxuICBjYWNoZVBhZ2UsXHJcbiAgdHJpbVN0cixcclxuICBkcm9wRG93bixcclxuICBhZGRUb29sdGlwLFxyXG4gIHBvcHVwLFxyXG4gIGRlYm91bmNlLFxyXG4gIElzSnNvbixcclxuICBwb3N0LCBnZXQsIHVuaXEsXHJcbiAgdmFsaWRhdGUsICRcclxufVxyXG4iLCJpbXBvcnQgJy4vYWNjb3JkaW9uLnNjc3MnXHJcbmltcG9ydCB7JH0gZnJvbSAnLi4vLi4vY29tbW9uJ1xyXG5cclxubGV0IGFjY29yZGlvbnMgPSAkKCdbYWNjb3JkaW9uXScpXHJcbmlmIChhY2NvcmRpb25zKSB7XHJcblxyXG4gIGxldCBjaGVja2JveGVzID0gJChgW2FjY29yZGlvbl0gW3R5cGU9J2NoZWNrYm94J11gKVxyXG4gIGlmIChjaGVja2JveGVzKSB7XHJcbiAgICBbLi4uY2hlY2tib3hlc10uZmlsdGVyKGNoID0+IHtcclxuICAgICAgY2guY2hlY2tlZCA9IGZhbHNlXHJcbiAgICB9KVxyXG4gIH1cclxuICAkKCdbYWNjb3JkaW9uXScpLm9uKCdjbGljaycsIGhhbmRsZSlcclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlKHt0YXJnZXR9KSB7XHJcbiAgbGV0IGxpID0gdGFyZ2V0LmNsb3Nlc3QoJ2xpJylcclxuICBpZiAoIWxpKSByZXR1cm5cclxuXHJcbiAgLy8gbGV0IGFjY29yZGlvbiA9IGxpLmNsb3Nlc3QoJ1thY2NvcmRpb25dJylcclxuICBsZXQgdWwgPSAkKGxpKS5maW5kKCd1bCcpXHJcbiAgaWYgKCF1bCkge1xyXG4gICAgcm90YXRlQXJyb3cobGkpXHJcbiAgfSBlbHNlIHtcclxuICAgIGlmICh1bC5jbGFzc0xpc3QuY29udGFpbnMoJ29wZW4nKSkge1xyXG4gICAgICBzbGlkZVVwKHVsLCBsaSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGFjY29yZGlvbi5zdHlsZS5oZWlnaHQgPSBcImF1dG9cIlxyXG4gICAgICBpZiAoIXVsKSByZXR1cm5cclxuICAgICAgbGV0IHBhcmVudCA9IGxpLmNsb3Nlc3QoJ3VsJylcclxuICAgICAgY2xvc2VTaWJsaW5ncyhwYXJlbnQpXHJcbiAgICAgIHNsaWRlRG93bih1bCwgbGksIHBhcmVudClcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsb3NlU2libGluZ3MocGFyZW50KSB7XHJcbiAgaWYgKCFwYXJlbnQpIHJldHVyblxyXG4gIGxldCBvcGVuID0gJChwYXJlbnQpLmZpbmQoJ2xpPnVsLm9wZW4nKVxyXG4gIGlmIChvcGVuKSB7XHJcbiAgICBsZXQgbGkgPSBvcGVuLmNsb3Nlc3QoJ2xpJylcclxuICAgIHNsaWRlVXAob3BlbiwgbGkpXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzbGlkZURvd24odWwsIGxpLCBwYXJlbnQpIHtcclxuICBpZiAocGFyZW50KSB7XHJcbiAgICBwYXJlbnQuc3R5bGUubWF4SGVpZ2h0ID0gdWwuc2Nyb2xsSGVpZ2h0ICsgcGFyZW50LnNjcm9sbEhlaWdodCArIFwicHhcIjtcclxuICB9XHJcbiAgdWwuc3R5bGUubWF4SGVpZ2h0ID0gdWwuc2Nyb2xsSGVpZ2h0ICsgXCJweFwiO1xyXG4gIHVsLmNsYXNzTGlzdC50b2dnbGUoJ29wZW4nKVxyXG4gIGxpLmNsYXNzTGlzdC50b2dnbGUoJ3JvdGF0ZScpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNsaWRlVXAodWwsIGxpKSB7XHJcbiAgdWwuc3R5bGUubWF4SGVpZ2h0ID0gMCArIFwicHhcIjtcclxuICB1bC5jbGFzc0xpc3QudG9nZ2xlKCdvcGVuJylcclxuICBsaS5jbGFzc0xpc3QudG9nZ2xlKCdyb3RhdGUnKVxyXG59XHJcblxyXG5mdW5jdGlvbiByb3RhdGVBcnJvdyhsaSkge1xyXG4gIGxpLmNsYXNzTGlzdC50b2dnbGUoJ3JvdGF0ZScpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluY3JlYXNlUGFyZW50KHBhcmVudCwgdWxIZWlnaHQpIHtcclxuICBpZiAoIXBhcmVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2FjY29yZGlvbicpKSB7XHJcbiAgICBsZXQgcGFyZW50SGVpZ2h0ID0gcGFyc2VJbnQocGFyZW50LnN0eWxlLm1heEhlaWdodCkgKyB1bEhlaWdodFxyXG4gICAgcGFyZW50LnN0eWxlLm1heEhlaWdodCA9IHBhcmVudEhlaWdodCArIFwicHhcIjtcclxuICB9XHJcbn0iLCJpbXBvcnQgeyR9IGZyb20gJy4uL2NvbW1vbidcclxubGV0IHNpZGViYXIgPSAkKCcuYWRtaW5fc2lkZWJhcicpWzBdXHJcbmlmIChzaWRlYmFyKSB7XHJcbiAgJCgnc3ZnI2J1cmdlcicpLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgIGxldCBhY2NvcmRpb24gPSAkKCcuYWRtaW5fc2lkZWJhciBbYWNjb3JkaW9uXScpWzBdXHJcbiAgICBhY2NvcmRpb24uY2xhc3NMaXN0LnRvZ2dsZSgnc2hvdycpXHJcbiAgfSlcclxufVxyXG5cclxuIiwiaW1wb3J0IHskLCBwb3B1cCwgcG9zdH0gZnJvbSBcIi4uLy4uL2NvbW1vblwiO1xyXG5pbXBvcnQgXCIuLi8uLi9jb21wb25lbnRzL3BvcHVwLnNjc3NcIjtcclxuXHJcblxyXG5sZXQgX2NhY2hlID0ge1xyXG4gICAgY2xlYXJDYWNoZTogYXN5bmMgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KCcvYWRtaW5zYy9jbGVhckNhY2hlJywge30pXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNhY2hlKCkge1xyXG4gICAgJCgnLmNsZWFyQ2FjaGUnKS5vbignY2xpY2snLCBfY2FjaGUuY2xlYXJDYWNoZSlcclxufSIsImltcG9ydCB7JCwgcG9zdCwgcG9wdXB9IGZyb20gXCIuLi8uLi9jb21tb25cIjtcclxuXHJcbmV4cG9ydCBjb25zdCBfdGVzdFJlc3VsdCA9IHtcclxuXHJcblxyXG4gIGRlbFNlcnZlcjogYXN5bmMgKGlkKSA9PiB7XHJcbiAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCgnL2FkbWluc2MvdGVzdHJlc3VsdC9kZWxldGUnLCB7aWR9KVxyXG4gIH0sXHJcblxyXG4gIGRlbERvbTogKGlkKSA9PiB7XHJcbiAgICBbXS5tYXAuY2FsbCgkKGBbZGF0YS1yb3cgPSBcIiR7aWR9XCJdYCksIGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgaS5yZW1vdmUoKVxyXG4gICAgICB9XHJcbiAgICApXHJcbiAgfSxcclxuXHJcbiAgZGVsZXRlOiAoaWQpID0+IHtcclxuICAgIGlmIChjb25maXJtKFwi0KPQtNCw0LvQuNGC0Ywg0YDQtdC30YPQu9GM0YLQsNGCINGC0LXRgdGC0LA/XCIpKSB7XHJcbiAgICAgIF90ZXN0UmVzdWx0LmRlbERvbShpZClcclxuICAgICAgX3Rlc3RSZXN1bHQuZGVsU2VydmVyKGlkKVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG59IiwiaW1wb3J0ICcuL3Rlc3QtcmVzdWx0c19fdGFibGUuc2NzcydcclxuaW1wb3J0IHskfSBmcm9tICcuLi8uLi9jb21tb24nXHJcbmltcG9ydCB7X3Rlc3RSZXN1bHR9IGZyb20gJy4uL21vZGVsL190ZXN0UmVzdWx0J1xyXG5cclxubGV0IHRlc3RSZXN1bHRzID0gJCgnLnRlc3QtcmVzdWx0c19fdGFibGUnKVswXVxyXG5pZiAodGVzdFJlc3VsdHMpIHtcclxuICAkKHRlc3RSZXN1bHRzKS5vbignY2xpY2snLCBoYW5kbGVDbGljaylcclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlQ2xpY2soe3RhcmdldH0pIHtcclxuICBpZiAoISF0YXJnZXQuY2xvc2VzdCgnLmRlbC1idG4nKSkge1xyXG4gICAgbGV0IGlkID0gdGFyZ2V0LmNsb3Nlc3QoJy5kZWwtYnRuJykuZGF0YXNldC5yb3dcclxuICAgIF90ZXN0UmVzdWx0LmRlbGV0ZShpZClcclxuICB9XHJcbn1cclxuXHJcblxyXG5sZXQgdGVzdFJlc3VsdCA9ICQoJy50ZXN0cmVzdWx0JylbMF1cclxuaWYgKHRlc3RSZXN1bHQpIHtcclxuICAkKCcuYWNjb3JkaW9uX3dyYXAnKVswXS5yZW1vdmUoKVxyXG4gICQoJy5wYWdlLW5hbWUnKVswXS5yZW1vdmUoKVxyXG4gICQoJy50ZXN0LW5hbWUnKVswXS5yZW1vdmUoKVxyXG4gICQoJy50ZXN0LWRvX19maW5pc2gtYnRuJylbMF0ucmVtb3ZlKClcclxufSIsImltcG9ydCB7JCwgcG9wdXAsIHBvc3QsIGFkZFRvb2x0aXB9IGZyb20gXCIuLi8uLi8uLi9jb21tb25cIlxyXG5cclxuY2xhc3Mgb3BlbnF1ZXN0aW9uIHtcclxuXHJcbiAgbW9kZWwgPSAnb3BlbnF1ZXN0aW9uJ1xyXG4gIHF1ZXN0aW9ucyA9ICQoJy5xdWVzdGlvbnM+LnF1ZXN0aW9uLWVkaXQnKVxyXG4gIHRlc3RJZCA9ICskKCcucXVlc3Rpb25zJylbMF0/LmRhdGFzZXQudGVzdElkID8/IG51bGxcclxuICBxdWVzdGlvbkNudCA9ICQoJy5xdWVzdGlvbnM+LnF1ZXN0aW9uLWVkaXQnKS5sZW5ndGggPz8gbnVsbFxyXG5cclxuICBhc3luYyBjcmVhdGUodGFyZ2V0KSB7XHJcbiAgICBsZXQgaWQgPSAwXHJcbiAgICBsZXQgb3BlbnRlc3RfaWQgPSB0aGlzLnRlc3RJZFxyXG4gICAgbGV0IHNvcnQgPSB0aGlzLnF1ZXN0aW9uQ250KzFcclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KGAvYWRtaW5zYy8ke3RoaXMubW9kZWx9L3VwZGF0ZU9yQ3JlYXRlYCxcclxuICAgICAge2lkLG9wZW50ZXN0X2lkLHNvcnR9KVxyXG4gICAgaWYgKHJlcy5hcnIuaWQpIHtcclxuICAgICAgbGV0IGNsb25lID0gdGhpcy5jbG9uZUVtcHR5TW9kZWwoKVxyXG4gICAgICBsZXQgYWRkQnRuID0gdGFyZ2V0LmNsb3Nlc3QoJy5xdWVzdGlvbl9fY3JlYXRlLWJ1dHRvbicpXHJcblxyXG4gICAgICBjbG9uZS5xdWVyeVNlbGVjdG9yKCcuc29ydCcpLmlubmVyVGV4dCA9IHRoaXMucXVlc3Rpb25DbnQgKyAxXHJcbiAgICAgIGNsb25lLnF1ZXJ5U2VsZWN0b3IoJy50ZXh0JykuaW5uZXJUZXh0ID0gJydcclxuICAgICAgY2xvbmUuaWQgPSByZXMuaWRcclxuICAgICAgYWRkQnRuLmJlZm9yZShjbG9uZSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNsb25lRW1wdHlNb2RlbCgpIHtcclxuICAgIGxldCBxdWVzdGlvbiA9ICQoJy5xdWVzdGlvbnMgLnF1ZXN0aW9uLWVkaXQnKVswXVxyXG4gICAgaWYgKHF1ZXN0aW9uKSB7XHJcbiAgICAgIGxldCBxID0gcXVlc3Rpb24uY2xvbmVOb2RlKHRydWUpXHJcbiAgICAgIGxldCBhbnMgPSBxLnF1ZXJ5U2VsZWN0b3JBbGwoJy5yb3cgLmFuc3dlcicpO1xyXG4gICAgICBbXS5mb3JFYWNoLmNhbGwoYW5zLCBmdW5jdGlvbiAoYW5zd2VyKSB7XHJcbiAgICAgICAgYW5zd2VyLnJlbW92ZSgpXHJcbiAgICAgIH0pXHJcbiAgICAgIHJldHVybiBxXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBzb3J0KHVwVG9RZXN0aW9uTnVtYmVyKSB7XHJcblxyXG4gICAgbGV0IHF1ZXN0aW9uc0VscyA9IHRoaXMucXVlc3Rpb25zLmZpbHRlcihmdW5jdGlvbiAoZWwsIGkpIHtcclxuICAgICAgICBpZiAoaSArIDEgPCB1cFRvUWVzdGlvbk51bWJlcikgcmV0dXJuIGVsXHJcbiAgICAgIH1cclxuICAgIClcclxuICAgIGxldCB0b0NoYW5nZSA9IHF1ZXN0aW9uc0Vscy5tYXAoKGVsKSA9PiB7XHJcbiAgICAgIHJldHVybiBlbC5pZFxyXG4gICAgfSlcclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KGAvJHt0aGlzLm1vZGVsfS9zb3J0YCwge3RvQ2hhbmdlfSlcclxuXHJcbiAgICBxdWVzdGlvbnNFbHMubWFwKChlbCwgaSkgPT4ge1xyXG4gICAgICAkKGVsKS5maW5kKCcuc29ydCcpLmlubmVyVGV4dCA9IGkgKyAxXHJcblxyXG4gICAgfSlcclxuICB9XHJcblxyXG5cclxuICBhc3luYyBjaGFuZ2VQYXJlbnQodGFyZ2V0KSB7XHJcbiAgICAvLyBkZWJ1Z2dlclxyXG5cclxuICAgIGlmICh0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnbGknKSByZXR1cm5cclxuXHJcbiAgICBsZXQgaWQgPSB0YXJnZXQuY2xvc2VzdCgnLnF1ZXN0aW9uLWVkaXQnKS5pZFxyXG4gICAgbGV0IHRlc3RfaWQgPSB0YXJnZXQuZGF0YXNldFsndmFsdWUnXVxyXG4gICAgbGV0IHRlc3RfbmFtZSA9IHRhcmdldC5pbm5lclRleHRcclxuICAgIGlmICghK2lkIHx8ICErdGVzdF9pZCB8fCAhdGVzdF9uYW1lKSByZXR1cm5cclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KGAvYWRtaW5zYy8ke3RoaXMubW9kZWx9L2NoYW5nZVBhcmVudGAsIHtpZCwgdGVzdF9pZH0pXHJcbiAgICBpZiAocmVzLm1zZyAhPT0gJ29rJykgdGhyb3cgKGUpO1xyXG4gICAgbGV0IHF1ZXN0aW9uID0gdGFyZ2V0LmNsb3Nlc3QoJy5xdWVzdGlvbi1lZGl0JylcclxuICAgIHF1ZXN0aW9uLnJlbW92ZSgpXHJcbiAgICBwb3B1cC5zaG93KCfQn9C10YDQtdC80LXRidC10L0g0LIgJyArIHRlc3RfbmFtZSlcclxuICB9XHJcblxyXG4gIHNob3dBbnN3ZXJzKHRhcmdldCkge1xyXG4gICAgbGV0IHJvdyA9IHRhcmdldC5jbG9zZXN0KCcucXVlc3Rpb24tZWRpdCcpXHJcbiAgICBsZXQgYW5zd2VycyA9ICQocm93KS5maW5kKCcucXVlc3Rpb25fX2Fuc3dlcnMnKVxyXG4gICAgYW5zd2Vycy5jbGFzc0xpc3QudG9nZ2xlKCdoZWlnaHQnKVxyXG4gICAgYW5zd2Vycy5jbGFzc0xpc3QudG9nZ2xlKCdzY2FsZScpXHJcbiAgICB0YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSgncm90YXRlJylcclxuICB9XHJcblxyXG4gIGFzeW5jIGRlbCh0YXJnZXQpIHtcclxuICAgIGlmIChjb25maXJtKFwi0KPQtNCw0LvQuNGC0Ywg0LLQvtC/0YDQvtGBINGB0L4g0LLRgdC10LzQuCDQtdCz0L4g0L7RgtCy0LXRgtCw0LzQuD9cIikpIHtcclxuICAgICAgbGV0IHF1ZXN0aW9uID0gdGFyZ2V0LmNsb3Nlc3QoJy5xdWVzdGlvbi1lZGl0JylcclxuICAgICAgbGV0IGlkID0gcXVlc3Rpb24uaWRcclxuXHJcbiAgICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KGAvYWRtaW5zYy8ke3RoaXMubW9kZWx9L2RlbGV0ZWAsIHtpZH0pXHJcbiAgICAgIGlmIChyZXMpIHtcclxuICAgICAgICBxdWVzdGlvbi5yZW1vdmUoKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IF9vcGVucXVlc3Rpb24gPSBuZXcgb3BlbnF1ZXN0aW9uKCkiLCIvKiohXG4gKiBTb3J0YWJsZSAxLjE1LjBcbiAqIEBhdXRob3JcdFJ1YmFYYSAgIDx0cmFzaEBydWJheGEub3JnPlxuICogQGF1dGhvclx0b3dlbm0gICAgPG93ZW4yMzM1NUBnbWFpbC5jb20+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuXG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSB7XG4gICAgICBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcblxuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG5cbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG52YXIgdmVyc2lvbiA9IFwiMS4xNS4wXCI7XG5cbmZ1bmN0aW9uIHVzZXJBZ2VudChwYXR0ZXJuKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmF2aWdhdG9yKSB7XG4gICAgcmV0dXJuICEhIC8qQF9fUFVSRV9fKi9uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKHBhdHRlcm4pO1xuICB9XG59XG5cbnZhciBJRTExT3JMZXNzID0gdXNlckFnZW50KC8oPzpUcmlkZW50LipydlsgOl0/MTFcXC58bXNpZXxpZW1vYmlsZXxXaW5kb3dzIFBob25lKS9pKTtcbnZhciBFZGdlID0gdXNlckFnZW50KC9FZGdlL2kpO1xudmFyIEZpcmVGb3ggPSB1c2VyQWdlbnQoL2ZpcmVmb3gvaSk7XG52YXIgU2FmYXJpID0gdXNlckFnZW50KC9zYWZhcmkvaSkgJiYgIXVzZXJBZ2VudCgvY2hyb21lL2kpICYmICF1c2VyQWdlbnQoL2FuZHJvaWQvaSk7XG52YXIgSU9TID0gdXNlckFnZW50KC9pUChhZHxvZHxob25lKS9pKTtcbnZhciBDaHJvbWVGb3JBbmRyb2lkID0gdXNlckFnZW50KC9jaHJvbWUvaSkgJiYgdXNlckFnZW50KC9hbmRyb2lkL2kpO1xuXG52YXIgY2FwdHVyZU1vZGUgPSB7XG4gIGNhcHR1cmU6IGZhbHNlLFxuICBwYXNzaXZlOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gb24oZWwsIGV2ZW50LCBmbikge1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmbiwgIUlFMTFPckxlc3MgJiYgY2FwdHVyZU1vZGUpO1xufVxuXG5mdW5jdGlvbiBvZmYoZWwsIGV2ZW50LCBmbikge1xuICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBmbiwgIUlFMTFPckxlc3MgJiYgY2FwdHVyZU1vZGUpO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVzKFxuLyoqSFRNTEVsZW1lbnQqL1xuZWwsXG4vKipTdHJpbmcqL1xuc2VsZWN0b3IpIHtcbiAgaWYgKCFzZWxlY3RvcikgcmV0dXJuO1xuICBzZWxlY3RvclswXSA9PT0gJz4nICYmIChzZWxlY3RvciA9IHNlbGVjdG9yLnN1YnN0cmluZygxKSk7XG5cbiAgaWYgKGVsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChlbC5tYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiBlbC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoZWwubXNNYXRjaGVzU2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGVsLm1zTWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoZWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudE9ySG9zdChlbCkge1xuICByZXR1cm4gZWwuaG9zdCAmJiBlbCAhPT0gZG9jdW1lbnQgJiYgZWwuaG9zdC5ub2RlVHlwZSA/IGVsLmhvc3QgOiBlbC5wYXJlbnROb2RlO1xufVxuXG5mdW5jdGlvbiBjbG9zZXN0KFxuLyoqSFRNTEVsZW1lbnQqL1xuZWwsXG4vKipTdHJpbmcqL1xuc2VsZWN0b3IsXG4vKipIVE1MRWxlbWVudCovXG5jdHgsIGluY2x1ZGVDVFgpIHtcbiAgaWYgKGVsKSB7XG4gICAgY3R4ID0gY3R4IHx8IGRvY3VtZW50O1xuXG4gICAgZG8ge1xuICAgICAgaWYgKHNlbGVjdG9yICE9IG51bGwgJiYgKHNlbGVjdG9yWzBdID09PSAnPicgPyBlbC5wYXJlbnROb2RlID09PSBjdHggJiYgbWF0Y2hlcyhlbCwgc2VsZWN0b3IpIDogbWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSB8fCBpbmNsdWRlQ1RYICYmIGVsID09PSBjdHgpIHtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWwgPT09IGN0eCkgYnJlYWs7XG4gICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG4gICAgfSB3aGlsZSAoZWwgPSBnZXRQYXJlbnRPckhvc3QoZWwpKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUl9TUEFDRSA9IC9cXHMrL2c7XG5cbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsLCBuYW1lLCBzdGF0ZSkge1xuICBpZiAoZWwgJiYgbmFtZSkge1xuICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICAgIGVsLmNsYXNzTGlzdFtzdGF0ZSA/ICdhZGQnIDogJ3JlbW92ZSddKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gKCcgJyArIGVsLmNsYXNzTmFtZSArICcgJykucmVwbGFjZShSX1NQQUNFLCAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKTtcbiAgICAgIGVsLmNsYXNzTmFtZSA9IChjbGFzc05hbWUgKyAoc3RhdGUgPyAnICcgKyBuYW1lIDogJycpKS5yZXBsYWNlKFJfU1BBQ0UsICcgJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNzcyhlbCwgcHJvcCwgdmFsKSB7XG4gIHZhciBzdHlsZSA9IGVsICYmIGVsLnN0eWxlO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKGRvY3VtZW50LmRlZmF1bHRWaWV3ICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgdmFsID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgJycpO1xuICAgICAgfSBlbHNlIGlmIChlbC5jdXJyZW50U3R5bGUpIHtcbiAgICAgICAgdmFsID0gZWwuY3VycmVudFN0eWxlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvcCA9PT0gdm9pZCAwID8gdmFsIDogdmFsW3Byb3BdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIShwcm9wIGluIHN0eWxlKSAmJiBwcm9wLmluZGV4T2YoJ3dlYmtpdCcpID09PSAtMSkge1xuICAgICAgICBwcm9wID0gJy13ZWJraXQtJyArIHByb3A7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlW3Byb3BdID0gdmFsICsgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gJycgOiAncHgnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0cml4KGVsLCBzZWxmT25seSkge1xuICB2YXIgYXBwbGllZFRyYW5zZm9ybXMgPSAnJztcblxuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIGFwcGxpZWRUcmFuc2Zvcm1zID0gZWw7XG4gIH0gZWxzZSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGNzcyhlbCwgJ3RyYW5zZm9ybScpO1xuXG4gICAgICBpZiAodHJhbnNmb3JtICYmIHRyYW5zZm9ybSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGFwcGxpZWRUcmFuc2Zvcm1zID0gdHJhbnNmb3JtICsgJyAnICsgYXBwbGllZFRyYW5zZm9ybXM7XG4gICAgICB9XG4gICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cbiAgICB9IHdoaWxlICghc2VsZk9ubHkgJiYgKGVsID0gZWwucGFyZW50Tm9kZSkpO1xuICB9XG5cbiAgdmFyIG1hdHJpeEZuID0gd2luZG93LkRPTU1hdHJpeCB8fCB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4IHx8IHdpbmRvdy5DU1NNYXRyaXggfHwgd2luZG93Lk1TQ1NTTWF0cml4O1xuICAvKmpzaGludCAtVzA1NiAqL1xuXG4gIHJldHVybiBtYXRyaXhGbiAmJiBuZXcgbWF0cml4Rm4oYXBwbGllZFRyYW5zZm9ybXMpO1xufVxuXG5mdW5jdGlvbiBmaW5kKGN0eCwgdGFnTmFtZSwgaXRlcmF0b3IpIHtcbiAgaWYgKGN0eCkge1xuICAgIHZhciBsaXN0ID0gY3R4LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgbiA9IGxpc3QubGVuZ3RoO1xuXG4gICAgaWYgKGl0ZXJhdG9yKSB7XG4gICAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgICBpdGVyYXRvcihsaXN0W2ldLCBpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpIHtcbiAgdmFyIHNjcm9sbGluZ0VsZW1lbnQgPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50O1xuXG4gIGlmIChzY3JvbGxpbmdFbGVtZW50KSB7XG4gICAgcmV0dXJuIHNjcm9sbGluZ0VsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBcImJvdW5kaW5nIGNsaWVudCByZWN0XCIgb2YgZ2l2ZW4gZWxlbWVudFxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgICAgICAgICAgICAgICAgICAgICBUaGUgZWxlbWVudCB3aG9zZSBib3VuZGluZ0NsaWVudFJlY3QgaXMgd2FudGVkXG4gKiBAcGFyYW0gIHtbQm9vbGVhbl19IHJlbGF0aXZlVG9Db250YWluaW5nQmxvY2sgIFdoZXRoZXIgdGhlIHJlY3Qgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBjb250YWluaW5nIGJsb2NrIG9mIChpbmNsdWRpbmcpIHRoZSBjb250YWluZXJcbiAqIEBwYXJhbSAge1tCb29sZWFuXX0gcmVsYXRpdmVUb05vblN0YXRpY1BhcmVudCAgV2hldGhlciB0aGUgcmVjdCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIHJlbGF0aXZlIHBhcmVudCBvZiAoaW5jbHVkaW5nKSB0aGUgY29udGFpZW5yXG4gKiBAcGFyYW0gIHtbQm9vbGVhbl19IHVuZG9TY2FsZSAgICAgICAgICAgICAgICAgIFdoZXRoZXIgdGhlIGNvbnRhaW5lcidzIHNjYWxlKCkgc2hvdWxkIGJlIHVuZG9uZVxuICogQHBhcmFtICB7W0hUTUxFbGVtZW50XX0gY29udGFpbmVyICAgICAgICAgICAgICBUaGUgcGFyZW50IHRoZSBlbGVtZW50IHdpbGwgYmUgcGxhY2VkIGluXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBib3VuZGluZ0NsaWVudFJlY3Qgb2YgZWwsIHdpdGggc3BlY2lmaWVkIGFkanVzdG1lbnRzXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRSZWN0KGVsLCByZWxhdGl2ZVRvQ29udGFpbmluZ0Jsb2NrLCByZWxhdGl2ZVRvTm9uU3RhdGljUGFyZW50LCB1bmRvU2NhbGUsIGNvbnRhaW5lcikge1xuICBpZiAoIWVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiBlbCAhPT0gd2luZG93KSByZXR1cm47XG4gIHZhciBlbFJlY3QsIHRvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgaGVpZ2h0LCB3aWR0aDtcblxuICBpZiAoZWwgIT09IHdpbmRvdyAmJiBlbC5wYXJlbnROb2RlICYmIGVsICE9PSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCkpIHtcbiAgICBlbFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB0b3AgPSBlbFJlY3QudG9wO1xuICAgIGxlZnQgPSBlbFJlY3QubGVmdDtcbiAgICBib3R0b20gPSBlbFJlY3QuYm90dG9tO1xuICAgIHJpZ2h0ID0gZWxSZWN0LnJpZ2h0O1xuICAgIGhlaWdodCA9IGVsUmVjdC5oZWlnaHQ7XG4gICAgd2lkdGggPSBlbFJlY3Qud2lkdGg7XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gMDtcbiAgICBsZWZ0ID0gMDtcbiAgICBib3R0b20gPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgcmlnaHQgPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgfVxuXG4gIGlmICgocmVsYXRpdmVUb0NvbnRhaW5pbmdCbG9jayB8fCByZWxhdGl2ZVRvTm9uU3RhdGljUGFyZW50KSAmJiBlbCAhPT0gd2luZG93KSB7XG4gICAgLy8gQWRqdXN0IGZvciB0cmFuc2xhdGUoKVxuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBlbC5wYXJlbnROb2RlOyAvLyBzb2x2ZXMgIzExMjMgKHNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM3OTUzODA2LzYwODgzMTIpXG4gICAgLy8gTm90IG5lZWRlZCBvbiA8PSBJRTExXG5cbiAgICBpZiAoIUlFMTFPckxlc3MpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIChjc3MoY29udGFpbmVyLCAndHJhbnNmb3JtJykgIT09ICdub25lJyB8fCByZWxhdGl2ZVRvTm9uU3RhdGljUGFyZW50ICYmIGNzcyhjb250YWluZXIsICdwb3NpdGlvbicpICE9PSAnc3RhdGljJykpIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gU2V0IHJlbGF0aXZlIHRvIGVkZ2VzIG9mIHBhZGRpbmcgYm94IG9mIGNvbnRhaW5lclxuXG4gICAgICAgICAgdG9wIC09IGNvbnRhaW5lclJlY3QudG9wICsgcGFyc2VJbnQoY3NzKGNvbnRhaW5lciwgJ2JvcmRlci10b3Atd2lkdGgnKSk7XG4gICAgICAgICAgbGVmdCAtPSBjb250YWluZXJSZWN0LmxlZnQgKyBwYXJzZUludChjc3MoY29udGFpbmVyLCAnYm9yZGVyLWxlZnQtd2lkdGgnKSk7XG4gICAgICAgICAgYm90dG9tID0gdG9wICsgZWxSZWN0LmhlaWdodDtcbiAgICAgICAgICByaWdodCA9IGxlZnQgKyBlbFJlY3Qud2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuXG4gICAgICB9IHdoaWxlIChjb250YWluZXIgPSBjb250YWluZXIucGFyZW50Tm9kZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHVuZG9TY2FsZSAmJiBlbCAhPT0gd2luZG93KSB7XG4gICAgLy8gQWRqdXN0IGZvciBzY2FsZSgpXG4gICAgdmFyIGVsTWF0cml4ID0gbWF0cml4KGNvbnRhaW5lciB8fCBlbCksXG4gICAgICAgIHNjYWxlWCA9IGVsTWF0cml4ICYmIGVsTWF0cml4LmEsXG4gICAgICAgIHNjYWxlWSA9IGVsTWF0cml4ICYmIGVsTWF0cml4LmQ7XG5cbiAgICBpZiAoZWxNYXRyaXgpIHtcbiAgICAgIHRvcCAvPSBzY2FsZVk7XG4gICAgICBsZWZ0IC89IHNjYWxlWDtcbiAgICAgIHdpZHRoIC89IHNjYWxlWDtcbiAgICAgIGhlaWdodCAvPSBzY2FsZVk7XG4gICAgICBib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gICAgICByaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvcDogdG9wLFxuICAgIGxlZnQ6IGxlZnQsXG4gICAgYm90dG9tOiBib3R0b20sXG4gICAgcmlnaHQ6IHJpZ2h0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYSBzaWRlIG9mIGFuIGVsZW1lbnQgaXMgc2Nyb2xsZWQgcGFzdCBhIHNpZGUgb2YgaXRzIHBhcmVudHNcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSAgZWwgICAgICAgICAgIFRoZSBlbGVtZW50IHdobydzIHNpZGUgYmVpbmcgc2Nyb2xsZWQgb3V0IG9mIHZpZXcgaXMgaW4gcXVlc3Rpb25cbiAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgZWxTaWRlICAgICAgIFNpZGUgb2YgdGhlIGVsZW1lbnQgaW4gcXVlc3Rpb24gKCd0b3AnLCAnbGVmdCcsICdyaWdodCcsICdib3R0b20nKVxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICBwYXJlbnRTaWRlICAgU2lkZSBvZiB0aGUgcGFyZW50IGluIHF1ZXN0aW9uICgndG9wJywgJ2xlZnQnLCAncmlnaHQnLCAnYm90dG9tJylcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgICAgICAgICAgICAgIFRoZSBwYXJlbnQgc2Nyb2xsIGVsZW1lbnQgdGhhdCB0aGUgZWwncyBzaWRlIGlzIHNjcm9sbGVkIHBhc3QsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gc3VjaCBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiBpc1Njcm9sbGVkUGFzdChlbCwgZWxTaWRlLCBwYXJlbnRTaWRlKSB7XG4gIHZhciBwYXJlbnQgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbCwgdHJ1ZSksXG4gICAgICBlbFNpZGVWYWwgPSBnZXRSZWN0KGVsKVtlbFNpZGVdO1xuICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIHZhciBwYXJlbnRTaWRlVmFsID0gZ2V0UmVjdChwYXJlbnQpW3BhcmVudFNpZGVdLFxuICAgICAgICB2aXNpYmxlID0gdm9pZCAwO1xuXG4gICAgaWYgKHBhcmVudFNpZGUgPT09ICd0b3AnIHx8IHBhcmVudFNpZGUgPT09ICdsZWZ0Jykge1xuICAgICAgdmlzaWJsZSA9IGVsU2lkZVZhbCA+PSBwYXJlbnRTaWRlVmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aXNpYmxlID0gZWxTaWRlVmFsIDw9IHBhcmVudFNpZGVWYWw7XG4gICAgfVxuXG4gICAgaWYgKCF2aXNpYmxlKSByZXR1cm4gcGFyZW50O1xuICAgIGlmIChwYXJlbnQgPT09IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKSkgYnJlYWs7XG4gICAgcGFyZW50ID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQocGFyZW50LCBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEdldHMgbnRoIGNoaWxkIG9mIGVsLCBpZ25vcmluZyBoaWRkZW4gY2hpbGRyZW4sIHNvcnRhYmxlJ3MgZWxlbWVudHMgKGRvZXMgbm90IGlnbm9yZSBjbG9uZSBpZiBpdCdzIHZpc2libGUpXG4gKiBhbmQgbm9uLWRyYWdnYWJsZSBlbGVtZW50c1xuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgICAgIFRoZSBwYXJlbnQgZWxlbWVudFxuICogQHBhcmFtICB7TnVtYmVyfSBjaGlsZE51bSAgICAgIFRoZSBpbmRleCBvZiB0aGUgY2hpbGRcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyAgICAgICBQYXJlbnQgU29ydGFibGUncyBvcHRpb25zXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gICAgICAgICAgVGhlIGNoaWxkIGF0IGluZGV4IGNoaWxkTnVtLCBvciBudWxsIGlmIG5vdCBmb3VuZFxuICovXG5cblxuZnVuY3Rpb24gZ2V0Q2hpbGQoZWwsIGNoaWxkTnVtLCBvcHRpb25zLCBpbmNsdWRlRHJhZ0VsKSB7XG4gIHZhciBjdXJyZW50Q2hpbGQgPSAwLFxuICAgICAgaSA9IDAsXG4gICAgICBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuXG4gIHdoaWxlIChpIDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJyAmJiBjaGlsZHJlbltpXSAhPT0gU29ydGFibGUuZ2hvc3QgJiYgKGluY2x1ZGVEcmFnRWwgfHwgY2hpbGRyZW5baV0gIT09IFNvcnRhYmxlLmRyYWdnZWQpICYmIGNsb3Nlc3QoY2hpbGRyZW5baV0sIG9wdGlvbnMuZHJhZ2dhYmxlLCBlbCwgZmFsc2UpKSB7XG4gICAgICBpZiAoY3VycmVudENoaWxkID09PSBjaGlsZE51bSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5baV07XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRDaGlsZCsrO1xuICAgIH1cblxuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGNoaWxkIGluIHRoZSBlbCwgaWdub3JpbmcgZ2hvc3RFbCBvciBpbnZpc2libGUgZWxlbWVudHMgKGNsb25lcylcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICAgICBQYXJlbnQgZWxlbWVudFxuICogQHBhcmFtICB7c2VsZWN0b3J9IHNlbGVjdG9yICAgIEFueSBvdGhlciBlbGVtZW50cyB0aGF0IHNob3VsZCBiZSBpZ25vcmVkXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gICAgICAgICAgVGhlIGxhc3QgY2hpbGQsIGlnbm9yaW5nIGdob3N0RWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGxhc3RDaGlsZChlbCwgc2VsZWN0b3IpIHtcbiAgdmFyIGxhc3QgPSBlbC5sYXN0RWxlbWVudENoaWxkO1xuXG4gIHdoaWxlIChsYXN0ICYmIChsYXN0ID09PSBTb3J0YWJsZS5naG9zdCB8fCBjc3MobGFzdCwgJ2Rpc3BsYXknKSA9PT0gJ25vbmUnIHx8IHNlbGVjdG9yICYmICFtYXRjaGVzKGxhc3QsIHNlbGVjdG9yKSkpIHtcbiAgICBsYXN0ID0gbGFzdC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIGxhc3QgfHwgbnVsbDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgaW5kZXggb2YgYW4gZWxlbWVudCB3aXRoaW4gaXRzIHBhcmVudCBmb3IgYSBzZWxlY3RlZCBzZXQgb2ZcbiAqIGVsZW1lbnRzXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWxcbiAqIEBwYXJhbSAge3NlbGVjdG9yfSBzZWxlY3RvclxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gaW5kZXgoZWwsIHNlbGVjdG9yKSB7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgaWYgKCFlbCB8fCAhZWwucGFyZW50Tm9kZSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cblxuICB3aGlsZSAoZWwgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XG4gICAgaWYgKGVsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdURU1QTEFURScgJiYgZWwgIT09IFNvcnRhYmxlLmNsb25lICYmICghc2VsZWN0b3IgfHwgbWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSkge1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHNjcm9sbCBvZmZzZXQgb2YgdGhlIGdpdmVuIGVsZW1lbnQsIGFkZGVkIHdpdGggYWxsIHRoZSBzY3JvbGwgb2Zmc2V0cyBvZiBwYXJlbnQgZWxlbWVudHMuXG4gKiBUaGUgdmFsdWUgaXMgcmV0dXJuZWQgaW4gcmVhbCBwaXhlbHMuXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICBPZmZzZXRzIGluIHRoZSBmb3JtYXQgb2YgW2xlZnQsIHRvcF1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFJlbGF0aXZlU2Nyb2xsT2Zmc2V0KGVsKSB7XG4gIHZhciBvZmZzZXRMZWZ0ID0gMCxcbiAgICAgIG9mZnNldFRvcCA9IDAsXG4gICAgICB3aW5TY3JvbGxlciA9IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcblxuICBpZiAoZWwpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgZWxNYXRyaXggPSBtYXRyaXgoZWwpLFxuICAgICAgICAgIHNjYWxlWCA9IGVsTWF0cml4LmEsXG4gICAgICAgICAgc2NhbGVZID0gZWxNYXRyaXguZDtcbiAgICAgIG9mZnNldExlZnQgKz0gZWwuc2Nyb2xsTGVmdCAqIHNjYWxlWDtcbiAgICAgIG9mZnNldFRvcCArPSBlbC5zY3JvbGxUb3AgKiBzY2FsZVk7XG4gICAgfSB3aGlsZSAoZWwgIT09IHdpblNjcm9sbGVyICYmIChlbCA9IGVsLnBhcmVudE5vZGUpKTtcbiAgfVxuXG4gIHJldHVybiBbb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wXTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG9iamVjdCB3aXRoaW4gdGhlIGdpdmVuIGFycmF5XG4gKiBAcGFyYW0gIHtBcnJheX0gYXJyICAgQXJyYXkgdGhhdCBtYXkgb3IgbWF5IG5vdCBob2xkIHRoZSBvYmplY3RcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqICBBbiBvYmplY3QgdGhhdCBoYXMgYSBrZXktdmFsdWUgcGFpciB1bmlxdWUgdG8gYW5kIGlkZW50aWNhbCB0byBhIGtleS12YWx1ZSBwYWlyIGluIHRoZSBvYmplY3QgeW91IHdhbnQgdG8gZmluZFxuICogQHJldHVybiB7TnVtYmVyfSAgICAgIFRoZSBpbmRleCBvZiB0aGUgb2JqZWN0IGluIHRoZSBhcnJheSwgb3IgLTFcbiAqL1xuXG5cbmZ1bmN0aW9uIGluZGV4T2ZPYmplY3QoYXJyLCBvYmopIHtcbiAgZm9yICh2YXIgaSBpbiBhcnIpIHtcbiAgICBpZiAoIWFyci5oYXNPd25Qcm9wZXJ0eShpKSkgY29udGludWU7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkgJiYgb2JqW2tleV0gPT09IGFycltpXVtrZXldKSByZXR1cm4gTnVtYmVyKGkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWwsIGluY2x1ZGVTZWxmKSB7XG4gIC8vIHNraXAgdG8gd2luZG93XG4gIGlmICghZWwgfHwgIWVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkgcmV0dXJuIGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgdmFyIGVsZW0gPSBlbDtcbiAgdmFyIGdvdFNlbGYgPSBmYWxzZTtcblxuICBkbyB7XG4gICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBnZXQgZWxlbSBjc3MgaWYgaXQgaXNuJ3QgZXZlbiBvdmVyZmxvd2luZyBpbiB0aGUgZmlyc3QgcGxhY2UgKHBlcmZvcm1hbmNlKVxuICAgIGlmIChlbGVtLmNsaWVudFdpZHRoIDwgZWxlbS5zY3JvbGxXaWR0aCB8fCBlbGVtLmNsaWVudEhlaWdodCA8IGVsZW0uc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICB2YXIgZWxlbUNTUyA9IGNzcyhlbGVtKTtcblxuICAgICAgaWYgKGVsZW0uY2xpZW50V2lkdGggPCBlbGVtLnNjcm9sbFdpZHRoICYmIChlbGVtQ1NTLm92ZXJmbG93WCA9PSAnYXV0bycgfHwgZWxlbUNTUy5vdmVyZmxvd1ggPT0gJ3Njcm9sbCcpIHx8IGVsZW0uY2xpZW50SGVpZ2h0IDwgZWxlbS5zY3JvbGxIZWlnaHQgJiYgKGVsZW1DU1Mub3ZlcmZsb3dZID09ICdhdXRvJyB8fCBlbGVtQ1NTLm92ZXJmbG93WSA9PSAnc2Nyb2xsJykpIHtcbiAgICAgICAgaWYgKCFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCB8fCBlbGVtID09PSBkb2N1bWVudC5ib2R5KSByZXR1cm4gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgICAgICBpZiAoZ290U2VsZiB8fCBpbmNsdWRlU2VsZikgcmV0dXJuIGVsZW07XG4gICAgICAgIGdvdFNlbGYgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cbiAgfSB3aGlsZSAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSk7XG5cbiAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKGRzdCwgc3JjKSB7XG4gIGlmIChkc3QgJiYgc3JjKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgICAgaWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGRzdFtrZXldID0gc3JjW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuZnVuY3Rpb24gaXNSZWN0RXF1YWwocmVjdDEsIHJlY3QyKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHJlY3QxLnRvcCkgPT09IE1hdGgucm91bmQocmVjdDIudG9wKSAmJiBNYXRoLnJvdW5kKHJlY3QxLmxlZnQpID09PSBNYXRoLnJvdW5kKHJlY3QyLmxlZnQpICYmIE1hdGgucm91bmQocmVjdDEuaGVpZ2h0KSA9PT0gTWF0aC5yb3VuZChyZWN0Mi5oZWlnaHQpICYmIE1hdGgucm91bmQocmVjdDEud2lkdGgpID09PSBNYXRoLnJvdW5kKHJlY3QyLndpZHRoKTtcbn1cblxudmFyIF90aHJvdHRsZVRpbWVvdXQ7XG5cbmZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrLCBtcykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghX3Rocm90dGxlVGltZW91dCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChfdGhpcywgYXJnc1swXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjay5hcHBseShfdGhpcywgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIF90aHJvdHRsZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3Rocm90dGxlVGltZW91dCA9IHZvaWQgMDtcbiAgICAgIH0sIG1zKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhbmNlbFRocm90dGxlKCkge1xuICBjbGVhclRpbWVvdXQoX3Rocm90dGxlVGltZW91dCk7XG4gIF90aHJvdHRsZVRpbWVvdXQgPSB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIHNjcm9sbEJ5KGVsLCB4LCB5KSB7XG4gIGVsLnNjcm9sbExlZnQgKz0geDtcbiAgZWwuc2Nyb2xsVG9wICs9IHk7XG59XG5cbmZ1bmN0aW9uIGNsb25lKGVsKSB7XG4gIHZhciBQb2x5bWVyID0gd2luZG93LlBvbHltZXI7XG4gIHZhciAkID0gd2luZG93LmpRdWVyeSB8fCB3aW5kb3cuWmVwdG87XG5cbiAgaWYgKFBvbHltZXIgJiYgUG9seW1lci5kb20pIHtcbiAgICByZXR1cm4gUG9seW1lci5kb20oZWwpLmNsb25lTm9kZSh0cnVlKTtcbiAgfSBlbHNlIGlmICgkKSB7XG4gICAgcmV0dXJuICQoZWwpLmNsb25lKHRydWUpWzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbC5jbG9uZU5vZGUodHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0UmVjdChlbCwgcmVjdCkge1xuICBjc3MoZWwsICdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xuICBjc3MoZWwsICd0b3AnLCByZWN0LnRvcCk7XG4gIGNzcyhlbCwgJ2xlZnQnLCByZWN0LmxlZnQpO1xuICBjc3MoZWwsICd3aWR0aCcsIHJlY3Qud2lkdGgpO1xuICBjc3MoZWwsICdoZWlnaHQnLCByZWN0LmhlaWdodCk7XG59XG5cbmZ1bmN0aW9uIHVuc2V0UmVjdChlbCkge1xuICBjc3MoZWwsICdwb3NpdGlvbicsICcnKTtcbiAgY3NzKGVsLCAndG9wJywgJycpO1xuICBjc3MoZWwsICdsZWZ0JywgJycpO1xuICBjc3MoZWwsICd3aWR0aCcsICcnKTtcbiAgY3NzKGVsLCAnaGVpZ2h0JywgJycpO1xufVxuXG52YXIgZXhwYW5kbyA9ICdTb3J0YWJsZScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuZnVuY3Rpb24gQW5pbWF0aW9uU3RhdGVNYW5hZ2VyKCkge1xuICB2YXIgYW5pbWF0aW9uU3RhdGVzID0gW10sXG4gICAgICBhbmltYXRpb25DYWxsYmFja0lkO1xuICByZXR1cm4ge1xuICAgIGNhcHR1cmVBbmltYXRpb25TdGF0ZTogZnVuY3Rpb24gY2FwdHVyZUFuaW1hdGlvblN0YXRlKCkge1xuICAgICAgYW5pbWF0aW9uU3RhdGVzID0gW107XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbmltYXRpb24pIHJldHVybjtcbiAgICAgIHZhciBjaGlsZHJlbiA9IFtdLnNsaWNlLmNhbGwodGhpcy5lbC5jaGlsZHJlbik7XG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoY3NzKGNoaWxkLCAnZGlzcGxheScpID09PSAnbm9uZScgfHwgY2hpbGQgPT09IFNvcnRhYmxlLmdob3N0KSByZXR1cm47XG4gICAgICAgIGFuaW1hdGlvblN0YXRlcy5wdXNoKHtcbiAgICAgICAgICB0YXJnZXQ6IGNoaWxkLFxuICAgICAgICAgIHJlY3Q6IGdldFJlY3QoY2hpbGQpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBmcm9tUmVjdCA9IF9vYmplY3RTcHJlYWQyKHt9LCBhbmltYXRpb25TdGF0ZXNbYW5pbWF0aW9uU3RhdGVzLmxlbmd0aCAtIDFdLnJlY3QpOyAvLyBJZiBhbmltYXRpbmc6IGNvbXBlbnNhdGUgZm9yIGN1cnJlbnQgYW5pbWF0aW9uXG5cblxuICAgICAgICBpZiAoY2hpbGQudGhpc0FuaW1hdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgdmFyIGNoaWxkTWF0cml4ID0gbWF0cml4KGNoaWxkLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChjaGlsZE1hdHJpeCkge1xuICAgICAgICAgICAgZnJvbVJlY3QudG9wIC09IGNoaWxkTWF0cml4LmY7XG4gICAgICAgICAgICBmcm9tUmVjdC5sZWZ0IC09IGNoaWxkTWF0cml4LmU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQuZnJvbVJlY3QgPSBmcm9tUmVjdDtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYWRkQW5pbWF0aW9uU3RhdGU6IGZ1bmN0aW9uIGFkZEFuaW1hdGlvblN0YXRlKHN0YXRlKSB7XG4gICAgICBhbmltYXRpb25TdGF0ZXMucHVzaChzdGF0ZSk7XG4gICAgfSxcbiAgICByZW1vdmVBbmltYXRpb25TdGF0ZTogZnVuY3Rpb24gcmVtb3ZlQW5pbWF0aW9uU3RhdGUodGFyZ2V0KSB7XG4gICAgICBhbmltYXRpb25TdGF0ZXMuc3BsaWNlKGluZGV4T2ZPYmplY3QoYW5pbWF0aW9uU3RhdGVzLCB7XG4gICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICB9KSwgMSk7XG4gICAgfSxcbiAgICBhbmltYXRlQWxsOiBmdW5jdGlvbiBhbmltYXRlQWxsKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvbkNhbGxiYWNrSWQpO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBhbmltYXRpbmcgPSBmYWxzZSxcbiAgICAgICAgICBhbmltYXRpb25UaW1lID0gMDtcbiAgICAgIGFuaW1hdGlvblN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgdGltZSA9IDAsXG4gICAgICAgICAgICB0YXJnZXQgPSBzdGF0ZS50YXJnZXQsXG4gICAgICAgICAgICBmcm9tUmVjdCA9IHRhcmdldC5mcm9tUmVjdCxcbiAgICAgICAgICAgIHRvUmVjdCA9IGdldFJlY3QodGFyZ2V0KSxcbiAgICAgICAgICAgIHByZXZGcm9tUmVjdCA9IHRhcmdldC5wcmV2RnJvbVJlY3QsXG4gICAgICAgICAgICBwcmV2VG9SZWN0ID0gdGFyZ2V0LnByZXZUb1JlY3QsXG4gICAgICAgICAgICBhbmltYXRpbmdSZWN0ID0gc3RhdGUucmVjdCxcbiAgICAgICAgICAgIHRhcmdldE1hdHJpeCA9IG1hdHJpeCh0YXJnZXQsIHRydWUpO1xuXG4gICAgICAgIGlmICh0YXJnZXRNYXRyaXgpIHtcbiAgICAgICAgICAvLyBDb21wZW5zYXRlIGZvciBjdXJyZW50IGFuaW1hdGlvblxuICAgICAgICAgIHRvUmVjdC50b3AgLT0gdGFyZ2V0TWF0cml4LmY7XG4gICAgICAgICAgdG9SZWN0LmxlZnQgLT0gdGFyZ2V0TWF0cml4LmU7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQudG9SZWN0ID0gdG9SZWN0O1xuXG4gICAgICAgIGlmICh0YXJnZXQudGhpc0FuaW1hdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgLy8gQ291bGQgYWxzbyBjaGVjayBpZiBhbmltYXRpbmdSZWN0IGlzIGJldHdlZW4gZnJvbVJlY3QgYW5kIHRvUmVjdFxuICAgICAgICAgIGlmIChpc1JlY3RFcXVhbChwcmV2RnJvbVJlY3QsIHRvUmVjdCkgJiYgIWlzUmVjdEVxdWFsKGZyb21SZWN0LCB0b1JlY3QpICYmIC8vIE1ha2Ugc3VyZSBhbmltYXRpbmdSZWN0IGlzIG9uIGxpbmUgYmV0d2VlbiB0b1JlY3QgJiBmcm9tUmVjdFxuICAgICAgICAgIChhbmltYXRpbmdSZWN0LnRvcCAtIHRvUmVjdC50b3ApIC8gKGFuaW1hdGluZ1JlY3QubGVmdCAtIHRvUmVjdC5sZWZ0KSA9PT0gKGZyb21SZWN0LnRvcCAtIHRvUmVjdC50b3ApIC8gKGZyb21SZWN0LmxlZnQgLSB0b1JlY3QubGVmdCkpIHtcbiAgICAgICAgICAgIC8vIElmIHJldHVybmluZyB0byBzYW1lIHBsYWNlIGFzIHN0YXJ0ZWQgZnJvbSBhbmltYXRpb24gYW5kIG9uIHNhbWUgYXhpc1xuICAgICAgICAgICAgdGltZSA9IGNhbGN1bGF0ZVJlYWxUaW1lKGFuaW1hdGluZ1JlY3QsIHByZXZGcm9tUmVjdCwgcHJldlRvUmVjdCwgX3RoaXMub3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGlmIGZyb21SZWN0ICE9IHRvUmVjdDogYW5pbWF0ZVxuXG5cbiAgICAgICAgaWYgKCFpc1JlY3RFcXVhbCh0b1JlY3QsIGZyb21SZWN0KSkge1xuICAgICAgICAgIHRhcmdldC5wcmV2RnJvbVJlY3QgPSBmcm9tUmVjdDtcbiAgICAgICAgICB0YXJnZXQucHJldlRvUmVjdCA9IHRvUmVjdDtcblxuICAgICAgICAgIGlmICghdGltZSkge1xuICAgICAgICAgICAgdGltZSA9IF90aGlzLm9wdGlvbnMuYW5pbWF0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLmFuaW1hdGUodGFyZ2V0LCBhbmltYXRpbmdSZWN0LCB0b1JlY3QsIHRpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICBhbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIGFuaW1hdGlvblRpbWUgPSBNYXRoLm1heChhbmltYXRpb25UaW1lLCB0aW1lKTtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGFyZ2V0LmFuaW1hdGlvblJlc2V0VGltZXIpO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRpb25SZXNldFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0YXJnZXQuYW5pbWF0aW9uVGltZSA9IDA7XG4gICAgICAgICAgICB0YXJnZXQucHJldkZyb21SZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRhcmdldC5mcm9tUmVjdCA9IG51bGw7XG4gICAgICAgICAgICB0YXJnZXQucHJldlRvUmVjdCA9IG51bGw7XG4gICAgICAgICAgICB0YXJnZXQudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgICB9LCB0aW1lKTtcbiAgICAgICAgICB0YXJnZXQudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gdGltZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjbGVhclRpbWVvdXQoYW5pbWF0aW9uQ2FsbGJhY2tJZCk7XG5cbiAgICAgIGlmICghYW5pbWF0aW5nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmltYXRpb25DYWxsYmFja0lkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcbiAgICAgICAgfSwgYW5pbWF0aW9uVGltZSk7XG4gICAgICB9XG5cbiAgICAgIGFuaW1hdGlvblN0YXRlcyA9IFtdO1xuICAgIH0sXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24gYW5pbWF0ZSh0YXJnZXQsIGN1cnJlbnRSZWN0LCB0b1JlY3QsIGR1cmF0aW9uKSB7XG4gICAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgICAgIHZhciBlbE1hdHJpeCA9IG1hdHJpeCh0aGlzLmVsKSxcbiAgICAgICAgICAgIHNjYWxlWCA9IGVsTWF0cml4ICYmIGVsTWF0cml4LmEsXG4gICAgICAgICAgICBzY2FsZVkgPSBlbE1hdHJpeCAmJiBlbE1hdHJpeC5kLFxuICAgICAgICAgICAgdHJhbnNsYXRlWCA9IChjdXJyZW50UmVjdC5sZWZ0IC0gdG9SZWN0LmxlZnQpIC8gKHNjYWxlWCB8fCAxKSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVkgPSAoY3VycmVudFJlY3QudG9wIC0gdG9SZWN0LnRvcCkgLyAoc2NhbGVZIHx8IDEpO1xuICAgICAgICB0YXJnZXQuYW5pbWF0aW5nWCA9ICEhdHJhbnNsYXRlWDtcbiAgICAgICAgdGFyZ2V0LmFuaW1hdGluZ1kgPSAhIXRyYW5zbGF0ZVk7XG4gICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlM2QoJyArIHRyYW5zbGF0ZVggKyAncHgsJyArIHRyYW5zbGF0ZVkgKyAncHgsMCknKTtcbiAgICAgICAgdGhpcy5mb3JSZXBhaW50RHVtbXkgPSByZXBhaW50KHRhcmdldCk7IC8vIHJlcGFpbnRcblxuICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNpdGlvbicsICd0cmFuc2Zvcm0gJyArIGR1cmF0aW9uICsgJ21zJyArICh0aGlzLm9wdGlvbnMuZWFzaW5nID8gJyAnICsgdGhpcy5vcHRpb25zLmVhc2luZyA6ICcnKSk7XG4gICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlM2QoMCwwLDApJyk7XG4gICAgICAgIHR5cGVvZiB0YXJnZXQuYW5pbWF0ZWQgPT09ICdudW1iZXInICYmIGNsZWFyVGltZW91dCh0YXJnZXQuYW5pbWF0ZWQpO1xuICAgICAgICB0YXJnZXQuYW5pbWF0ZWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNpdGlvbicsICcnKTtcbiAgICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJycpO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRlZCA9IGZhbHNlO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRpbmdYID0gZmFsc2U7XG4gICAgICAgICAgdGFyZ2V0LmFuaW1hdGluZ1kgPSBmYWxzZTtcbiAgICAgICAgfSwgZHVyYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVwYWludCh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldC5vZmZzZXRXaWR0aDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUmVhbFRpbWUoYW5pbWF0aW5nUmVjdCwgZnJvbVJlY3QsIHRvUmVjdCwgb3B0aW9ucykge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGZyb21SZWN0LnRvcCAtIGFuaW1hdGluZ1JlY3QudG9wLCAyKSArIE1hdGgucG93KGZyb21SZWN0LmxlZnQgLSBhbmltYXRpbmdSZWN0LmxlZnQsIDIpKSAvIE1hdGguc3FydChNYXRoLnBvdyhmcm9tUmVjdC50b3AgLSB0b1JlY3QudG9wLCAyKSArIE1hdGgucG93KGZyb21SZWN0LmxlZnQgLSB0b1JlY3QubGVmdCwgMikpICogb3B0aW9ucy5hbmltYXRpb247XG59XG5cbnZhciBwbHVnaW5zID0gW107XG52YXIgZGVmYXVsdHMgPSB7XG4gIGluaXRpYWxpemVCeURlZmF1bHQ6IHRydWVcbn07XG52YXIgUGx1Z2luTWFuYWdlciA9IHtcbiAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KHBsdWdpbikge1xuICAgIC8vIFNldCBkZWZhdWx0IHN0YXRpYyBwcm9wZXJ0aWVzXG4gICAgZm9yICh2YXIgb3B0aW9uIGluIGRlZmF1bHRzKSB7XG4gICAgICBpZiAoZGVmYXVsdHMuaGFzT3duUHJvcGVydHkob3B0aW9uKSAmJiAhKG9wdGlvbiBpbiBwbHVnaW4pKSB7XG4gICAgICAgIHBsdWdpbltvcHRpb25dID0gZGVmYXVsdHNbb3B0aW9uXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgIGlmIChwLnBsdWdpbk5hbWUgPT09IHBsdWdpbi5wbHVnaW5OYW1lKSB7XG4gICAgICAgIHRocm93IFwiU29ydGFibGU6IENhbm5vdCBtb3VudCBwbHVnaW4gXCIuY29uY2F0KHBsdWdpbi5wbHVnaW5OYW1lLCBcIiBtb3JlIHRoYW4gb25jZVwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgfSxcbiAgcGx1Z2luRXZlbnQ6IGZ1bmN0aW9uIHBsdWdpbkV2ZW50KGV2ZW50TmFtZSwgc29ydGFibGUsIGV2dCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmV2ZW50Q2FuY2VsZWQgPSBmYWxzZTtcblxuICAgIGV2dC5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5ldmVudENhbmNlbGVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGV2ZW50TmFtZUdsb2JhbCA9IGV2ZW50TmFtZSArICdHbG9iYWwnO1xuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICBpZiAoIXNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXSkgcmV0dXJuOyAvLyBGaXJlIGdsb2JhbCBldmVudHMgaWYgaXQgZXhpc3RzIGluIHRoaXMgc29ydGFibGVcblxuICAgICAgaWYgKHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVHbG9iYWxdKSB7XG4gICAgICAgIHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVHbG9iYWxdKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGVcbiAgICAgICAgfSwgZXZ0KSk7XG4gICAgICB9IC8vIE9ubHkgZmlyZSBwbHVnaW4gZXZlbnQgaWYgcGx1Z2luIGlzIGVuYWJsZWQgaW4gdGhpcyBzb3J0YWJsZSxcbiAgICAgIC8vIGFuZCBwbHVnaW4gaGFzIGV2ZW50IGRlZmluZWRcblxuXG4gICAgICBpZiAoc29ydGFibGUub3B0aW9uc1twbHVnaW4ucGx1Z2luTmFtZV0gJiYgc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdW2V2ZW50TmFtZV0oX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZVxuICAgICAgICB9LCBldnQpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgaW5pdGlhbGl6ZVBsdWdpbnM6IGZ1bmN0aW9uIGluaXRpYWxpemVQbHVnaW5zKHNvcnRhYmxlLCBlbCwgZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgdmFyIHBsdWdpbk5hbWUgPSBwbHVnaW4ucGx1Z2luTmFtZTtcbiAgICAgIGlmICghc29ydGFibGUub3B0aW9uc1twbHVnaW5OYW1lXSAmJiAhcGx1Z2luLmluaXRpYWxpemVCeURlZmF1bHQpIHJldHVybjtcbiAgICAgIHZhciBpbml0aWFsaXplZCA9IG5ldyBwbHVnaW4oc29ydGFibGUsIGVsLCBzb3J0YWJsZS5vcHRpb25zKTtcbiAgICAgIGluaXRpYWxpemVkLnNvcnRhYmxlID0gc29ydGFibGU7XG4gICAgICBpbml0aWFsaXplZC5vcHRpb25zID0gc29ydGFibGUub3B0aW9ucztcbiAgICAgIHNvcnRhYmxlW3BsdWdpbk5hbWVdID0gaW5pdGlhbGl6ZWQ7IC8vIEFkZCBkZWZhdWx0IG9wdGlvbnMgZnJvbSBwbHVnaW5cblxuICAgICAgX2V4dGVuZHMoZGVmYXVsdHMsIGluaXRpYWxpemVkLmRlZmF1bHRzKTtcbiAgICB9KTtcblxuICAgIGZvciAodmFyIG9wdGlvbiBpbiBzb3J0YWJsZS5vcHRpb25zKSB7XG4gICAgICBpZiAoIXNvcnRhYmxlLm9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkgY29udGludWU7XG4gICAgICB2YXIgbW9kaWZpZWQgPSB0aGlzLm1vZGlmeU9wdGlvbihzb3J0YWJsZSwgb3B0aW9uLCBzb3J0YWJsZS5vcHRpb25zW29wdGlvbl0pO1xuXG4gICAgICBpZiAodHlwZW9mIG1vZGlmaWVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzb3J0YWJsZS5vcHRpb25zW29wdGlvbl0gPSBtb2RpZmllZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGdldEV2ZW50UHJvcGVydGllczogZnVuY3Rpb24gZ2V0RXZlbnRQcm9wZXJ0aWVzKG5hbWUsIHNvcnRhYmxlKSB7XG4gICAgdmFyIGV2ZW50UHJvcGVydGllcyA9IHt9O1xuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbi5ldmVudFByb3BlcnRpZXMgIT09ICdmdW5jdGlvbicpIHJldHVybjtcblxuICAgICAgX2V4dGVuZHMoZXZlbnRQcm9wZXJ0aWVzLCBwbHVnaW4uZXZlbnRQcm9wZXJ0aWVzLmNhbGwoc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdLCBuYW1lKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGV2ZW50UHJvcGVydGllcztcbiAgfSxcbiAgbW9kaWZ5T3B0aW9uOiBmdW5jdGlvbiBtb2RpZnlPcHRpb24oc29ydGFibGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIG1vZGlmaWVkVmFsdWU7XG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIC8vIFBsdWdpbiBtdXN0IGV4aXN0IG9uIHRoZSBTb3J0YWJsZVxuICAgICAgaWYgKCFzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV0pIHJldHVybjsgLy8gSWYgc3RhdGljIG9wdGlvbiBsaXN0ZW5lciBleGlzdHMgZm9yIHRoaXMgb3B0aW9uLCBjYWxsIGluIHRoZSBjb250ZXh0IG9mIHRoZSBTb3J0YWJsZSdzIGluc3RhbmNlIG9mIHRoaXMgcGx1Z2luXG5cbiAgICAgIGlmIChwbHVnaW4ub3B0aW9uTGlzdGVuZXJzICYmIHR5cGVvZiBwbHVnaW4ub3B0aW9uTGlzdGVuZXJzW25hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1vZGlmaWVkVmFsdWUgPSBwbHVnaW4ub3B0aW9uTGlzdGVuZXJzW25hbWVdLmNhbGwoc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1vZGlmaWVkVmFsdWU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoX3JlZikge1xuICB2YXIgc29ydGFibGUgPSBfcmVmLnNvcnRhYmxlLFxuICAgICAgcm9vdEVsID0gX3JlZi5yb290RWwsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgdGFyZ2V0RWwgPSBfcmVmLnRhcmdldEVsLFxuICAgICAgY2xvbmVFbCA9IF9yZWYuY2xvbmVFbCxcbiAgICAgIHRvRWwgPSBfcmVmLnRvRWwsXG4gICAgICBmcm9tRWwgPSBfcmVmLmZyb21FbCxcbiAgICAgIG9sZEluZGV4ID0gX3JlZi5vbGRJbmRleCxcbiAgICAgIG5ld0luZGV4ID0gX3JlZi5uZXdJbmRleCxcbiAgICAgIG9sZERyYWdnYWJsZUluZGV4ID0gX3JlZi5vbGREcmFnZ2FibGVJbmRleCxcbiAgICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gX3JlZi5uZXdEcmFnZ2FibGVJbmRleCxcbiAgICAgIG9yaWdpbmFsRXZlbnQgPSBfcmVmLm9yaWdpbmFsRXZlbnQsXG4gICAgICBwdXRTb3J0YWJsZSA9IF9yZWYucHV0U29ydGFibGUsXG4gICAgICBleHRyYUV2ZW50UHJvcGVydGllcyA9IF9yZWYuZXh0cmFFdmVudFByb3BlcnRpZXM7XG4gIHNvcnRhYmxlID0gc29ydGFibGUgfHwgcm9vdEVsICYmIHJvb3RFbFtleHBhbmRvXTtcbiAgaWYgKCFzb3J0YWJsZSkgcmV0dXJuO1xuICB2YXIgZXZ0LFxuICAgICAgb3B0aW9ucyA9IHNvcnRhYmxlLm9wdGlvbnMsXG4gICAgICBvbk5hbWUgPSAnb24nICsgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpOyAvLyBTdXBwb3J0IGZvciBuZXcgQ3VzdG9tRXZlbnQgZmVhdHVyZVxuXG4gIGlmICh3aW5kb3cuQ3VzdG9tRXZlbnQgJiYgIUlFMTFPckxlc3MgJiYgIUVkZ2UpIHtcbiAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQobmFtZSwge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldnQuaW5pdEV2ZW50KG5hbWUsIHRydWUsIHRydWUpO1xuICB9XG5cbiAgZXZ0LnRvID0gdG9FbCB8fCByb290RWw7XG4gIGV2dC5mcm9tID0gZnJvbUVsIHx8IHJvb3RFbDtcbiAgZXZ0Lml0ZW0gPSB0YXJnZXRFbCB8fCByb290RWw7XG4gIGV2dC5jbG9uZSA9IGNsb25lRWw7XG4gIGV2dC5vbGRJbmRleCA9IG9sZEluZGV4O1xuICBldnQubmV3SW5kZXggPSBuZXdJbmRleDtcbiAgZXZ0Lm9sZERyYWdnYWJsZUluZGV4ID0gb2xkRHJhZ2dhYmxlSW5kZXg7XG4gIGV2dC5uZXdEcmFnZ2FibGVJbmRleCA9IG5ld0RyYWdnYWJsZUluZGV4O1xuICBldnQub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gIGV2dC5wdWxsTW9kZSA9IHB1dFNvcnRhYmxlID8gcHV0U29ydGFibGUubGFzdFB1dE1vZGUgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGFsbEV2ZW50UHJvcGVydGllcyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBleHRyYUV2ZW50UHJvcGVydGllcyksIFBsdWdpbk1hbmFnZXIuZ2V0RXZlbnRQcm9wZXJ0aWVzKG5hbWUsIHNvcnRhYmxlKSk7XG5cbiAgZm9yICh2YXIgb3B0aW9uIGluIGFsbEV2ZW50UHJvcGVydGllcykge1xuICAgIGV2dFtvcHRpb25dID0gYWxsRXZlbnRQcm9wZXJ0aWVzW29wdGlvbl07XG4gIH1cblxuICBpZiAocm9vdEVsKSB7XG4gICAgcm9vdEVsLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfVxuXG4gIGlmIChvcHRpb25zW29uTmFtZV0pIHtcbiAgICBvcHRpb25zW29uTmFtZV0uY2FsbChzb3J0YWJsZSwgZXZ0KTtcbiAgfVxufVxuXG52YXIgX2V4Y2x1ZGVkID0gW1wiZXZ0XCJdO1xuXG52YXIgcGx1Z2luRXZlbnQgPSBmdW5jdGlvbiBwbHVnaW5FdmVudChldmVudE5hbWUsIHNvcnRhYmxlKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgIG9yaWdpbmFsRXZlbnQgPSBfcmVmLmV2dCxcbiAgICAgIGRhdGEgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkKTtcblxuICBQbHVnaW5NYW5hZ2VyLnBsdWdpbkV2ZW50LmJpbmQoU29ydGFibGUpKGV2ZW50TmFtZSwgc29ydGFibGUsIF9vYmplY3RTcHJlYWQyKHtcbiAgICBkcmFnRWw6IGRyYWdFbCxcbiAgICBwYXJlbnRFbDogcGFyZW50RWwsXG4gICAgZ2hvc3RFbDogZ2hvc3RFbCxcbiAgICByb290RWw6IHJvb3RFbCxcbiAgICBuZXh0RWw6IG5leHRFbCxcbiAgICBsYXN0RG93bkVsOiBsYXN0RG93bkVsLFxuICAgIGNsb25lRWw6IGNsb25lRWwsXG4gICAgY2xvbmVIaWRkZW46IGNsb25lSGlkZGVuLFxuICAgIGRyYWdTdGFydGVkOiBtb3ZlZCxcbiAgICBwdXRTb3J0YWJsZTogcHV0U29ydGFibGUsXG4gICAgYWN0aXZlU29ydGFibGU6IFNvcnRhYmxlLmFjdGl2ZSxcbiAgICBvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50LFxuICAgIG9sZEluZGV4OiBvbGRJbmRleCxcbiAgICBvbGREcmFnZ2FibGVJbmRleDogb2xkRHJhZ2dhYmxlSW5kZXgsXG4gICAgbmV3SW5kZXg6IG5ld0luZGV4LFxuICAgIG5ld0RyYWdnYWJsZUluZGV4OiBuZXdEcmFnZ2FibGVJbmRleCxcbiAgICBoaWRlR2hvc3RGb3JUYXJnZXQ6IF9oaWRlR2hvc3RGb3JUYXJnZXQsXG4gICAgdW5oaWRlR2hvc3RGb3JUYXJnZXQ6IF91bmhpZGVHaG9zdEZvclRhcmdldCxcbiAgICBjbG9uZU5vd0hpZGRlbjogZnVuY3Rpb24gY2xvbmVOb3dIaWRkZW4oKSB7XG4gICAgICBjbG9uZUhpZGRlbiA9IHRydWU7XG4gICAgfSxcbiAgICBjbG9uZU5vd1Nob3duOiBmdW5jdGlvbiBjbG9uZU5vd1Nob3duKCkge1xuICAgICAgY2xvbmVIaWRkZW4gPSBmYWxzZTtcbiAgICB9LFxuICAgIGRpc3BhdGNoU29ydGFibGVFdmVudDogZnVuY3Rpb24gZGlzcGF0Y2hTb3J0YWJsZUV2ZW50KG5hbWUpIHtcbiAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIGRhdGEpKTtcbn07XG5cbmZ1bmN0aW9uIF9kaXNwYXRjaEV2ZW50KGluZm8pIHtcbiAgZGlzcGF0Y2hFdmVudChfb2JqZWN0U3ByZWFkMih7XG4gICAgcHV0U29ydGFibGU6IHB1dFNvcnRhYmxlLFxuICAgIGNsb25lRWw6IGNsb25lRWwsXG4gICAgdGFyZ2V0RWw6IGRyYWdFbCxcbiAgICByb290RWw6IHJvb3RFbCxcbiAgICBvbGRJbmRleDogb2xkSW5kZXgsXG4gICAgb2xkRHJhZ2dhYmxlSW5kZXg6IG9sZERyYWdnYWJsZUluZGV4LFxuICAgIG5ld0luZGV4OiBuZXdJbmRleCxcbiAgICBuZXdEcmFnZ2FibGVJbmRleDogbmV3RHJhZ2dhYmxlSW5kZXhcbiAgfSwgaW5mbykpO1xufVxuXG52YXIgZHJhZ0VsLFxuICAgIHBhcmVudEVsLFxuICAgIGdob3N0RWwsXG4gICAgcm9vdEVsLFxuICAgIG5leHRFbCxcbiAgICBsYXN0RG93bkVsLFxuICAgIGNsb25lRWwsXG4gICAgY2xvbmVIaWRkZW4sXG4gICAgb2xkSW5kZXgsXG4gICAgbmV3SW5kZXgsXG4gICAgb2xkRHJhZ2dhYmxlSW5kZXgsXG4gICAgbmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgYWN0aXZlR3JvdXAsXG4gICAgcHV0U29ydGFibGUsXG4gICAgYXdhaXRpbmdEcmFnU3RhcnRlZCA9IGZhbHNlLFxuICAgIGlnbm9yZU5leHRDbGljayA9IGZhbHNlLFxuICAgIHNvcnRhYmxlcyA9IFtdLFxuICAgIHRhcEV2dCxcbiAgICB0b3VjaEV2dCxcbiAgICBsYXN0RHgsXG4gICAgbGFzdER5LFxuICAgIHRhcERpc3RhbmNlTGVmdCxcbiAgICB0YXBEaXN0YW5jZVRvcCxcbiAgICBtb3ZlZCxcbiAgICBsYXN0VGFyZ2V0LFxuICAgIGxhc3REaXJlY3Rpb24sXG4gICAgcGFzdEZpcnN0SW52ZXJ0VGhyZXNoID0gZmFsc2UsXG4gICAgaXNDaXJjdW1zdGFudGlhbEludmVydCA9IGZhbHNlLFxuICAgIHRhcmdldE1vdmVEaXN0YW5jZSxcbiAgICAvLyBGb3IgcG9zaXRpb25pbmcgZ2hvc3QgYWJzb2x1dGVseVxuZ2hvc3RSZWxhdGl2ZVBhcmVudCxcbiAgICBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbCA9IFtdLFxuICAgIC8vIChsZWZ0LCB0b3ApXG5fc2lsZW50ID0gZmFsc2UsXG4gICAgc2F2ZWRJbnB1dENoZWNrZWQgPSBbXTtcbi8qKiBAY29uc3QgKi9cblxudmFyIGRvY3VtZW50RXhpc3RzID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyxcbiAgICBQb3NpdGlvbkdob3N0QWJzb2x1dGVseSA9IElPUyxcbiAgICBDU1NGbG9hdFByb3BlcnR5ID0gRWRnZSB8fCBJRTExT3JMZXNzID8gJ2Nzc0Zsb2F0JyA6ICdmbG9hdCcsXG4gICAgLy8gVGhpcyB3aWxsIG5vdCBwYXNzIGZvciBJRTksIGJlY2F1c2UgSUU5IERuRCBvbmx5IHdvcmtzIG9uIGFuY2hvcnNcbnN1cHBvcnREcmFnZ2FibGUgPSBkb2N1bWVudEV4aXN0cyAmJiAhQ2hyb21lRm9yQW5kcm9pZCAmJiAhSU9TICYmICdkcmFnZ2FibGUnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgIHN1cHBvcnRDc3NQb2ludGVyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIWRvY3VtZW50RXhpc3RzKSByZXR1cm47IC8vIGZhbHNlIHdoZW4gPD0gSUUxMVxuXG4gIGlmIChJRTExT3JMZXNzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgneCcpO1xuICBlbC5zdHlsZS5jc3NUZXh0ID0gJ3BvaW50ZXItZXZlbnRzOmF1dG8nO1xuICByZXR1cm4gZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9PT0gJ2F1dG8nO1xufSgpLFxuICAgIF9kZXRlY3REaXJlY3Rpb24gPSBmdW5jdGlvbiBfZGV0ZWN0RGlyZWN0aW9uKGVsLCBvcHRpb25zKSB7XG4gIHZhciBlbENTUyA9IGNzcyhlbCksXG4gICAgICBlbFdpZHRoID0gcGFyc2VJbnQoZWxDU1Mud2lkdGgpIC0gcGFyc2VJbnQoZWxDU1MucGFkZGluZ0xlZnQpIC0gcGFyc2VJbnQoZWxDU1MucGFkZGluZ1JpZ2h0KSAtIHBhcnNlSW50KGVsQ1NTLmJvcmRlckxlZnRXaWR0aCkgLSBwYXJzZUludChlbENTUy5ib3JkZXJSaWdodFdpZHRoKSxcbiAgICAgIGNoaWxkMSA9IGdldENoaWxkKGVsLCAwLCBvcHRpb25zKSxcbiAgICAgIGNoaWxkMiA9IGdldENoaWxkKGVsLCAxLCBvcHRpb25zKSxcbiAgICAgIGZpcnN0Q2hpbGRDU1MgPSBjaGlsZDEgJiYgY3NzKGNoaWxkMSksXG4gICAgICBzZWNvbmRDaGlsZENTUyA9IGNoaWxkMiAmJiBjc3MoY2hpbGQyKSxcbiAgICAgIGZpcnN0Q2hpbGRXaWR0aCA9IGZpcnN0Q2hpbGRDU1MgJiYgcGFyc2VJbnQoZmlyc3RDaGlsZENTUy5tYXJnaW5MZWZ0KSArIHBhcnNlSW50KGZpcnN0Q2hpbGRDU1MubWFyZ2luUmlnaHQpICsgZ2V0UmVjdChjaGlsZDEpLndpZHRoLFxuICAgICAgc2Vjb25kQ2hpbGRXaWR0aCA9IHNlY29uZENoaWxkQ1NTICYmIHBhcnNlSW50KHNlY29uZENoaWxkQ1NTLm1hcmdpbkxlZnQpICsgcGFyc2VJbnQoc2Vjb25kQ2hpbGRDU1MubWFyZ2luUmlnaHQpICsgZ2V0UmVjdChjaGlsZDIpLndpZHRoO1xuXG4gIGlmIChlbENTUy5kaXNwbGF5ID09PSAnZmxleCcpIHtcbiAgICByZXR1cm4gZWxDU1MuZmxleERpcmVjdGlvbiA9PT0gJ2NvbHVtbicgfHwgZWxDU1MuZmxleERpcmVjdGlvbiA9PT0gJ2NvbHVtbi1yZXZlcnNlJyA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gIH1cblxuICBpZiAoZWxDU1MuZGlzcGxheSA9PT0gJ2dyaWQnKSB7XG4gICAgcmV0dXJuIGVsQ1NTLmdyaWRUZW1wbGF0ZUNvbHVtbnMuc3BsaXQoJyAnKS5sZW5ndGggPD0gMSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gIH1cblxuICBpZiAoY2hpbGQxICYmIGZpcnN0Q2hpbGRDU1NbXCJmbG9hdFwiXSAmJiBmaXJzdENoaWxkQ1NTW1wiZmxvYXRcIl0gIT09ICdub25lJykge1xuICAgIHZhciB0b3VjaGluZ1NpZGVDaGlsZDIgPSBmaXJzdENoaWxkQ1NTW1wiZmxvYXRcIl0gPT09ICdsZWZ0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgcmV0dXJuIGNoaWxkMiAmJiAoc2Vjb25kQ2hpbGRDU1MuY2xlYXIgPT09ICdib3RoJyB8fCBzZWNvbmRDaGlsZENTUy5jbGVhciA9PT0gdG91Y2hpbmdTaWRlQ2hpbGQyKSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gIH1cblxuICByZXR1cm4gY2hpbGQxICYmIChmaXJzdENoaWxkQ1NTLmRpc3BsYXkgPT09ICdibG9jaycgfHwgZmlyc3RDaGlsZENTUy5kaXNwbGF5ID09PSAnZmxleCcgfHwgZmlyc3RDaGlsZENTUy5kaXNwbGF5ID09PSAndGFibGUnIHx8IGZpcnN0Q2hpbGRDU1MuZGlzcGxheSA9PT0gJ2dyaWQnIHx8IGZpcnN0Q2hpbGRXaWR0aCA+PSBlbFdpZHRoICYmIGVsQ1NTW0NTU0Zsb2F0UHJvcGVydHldID09PSAnbm9uZScgfHwgY2hpbGQyICYmIGVsQ1NTW0NTU0Zsb2F0UHJvcGVydHldID09PSAnbm9uZScgJiYgZmlyc3RDaGlsZFdpZHRoICsgc2Vjb25kQ2hpbGRXaWR0aCA+IGVsV2lkdGgpID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbn0sXG4gICAgX2RyYWdFbEluUm93Q29sdW1uID0gZnVuY3Rpb24gX2RyYWdFbEluUm93Q29sdW1uKGRyYWdSZWN0LCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCkge1xuICB2YXIgZHJhZ0VsUzFPcHAgPSB2ZXJ0aWNhbCA/IGRyYWdSZWN0LmxlZnQgOiBkcmFnUmVjdC50b3AsXG4gICAgICBkcmFnRWxTMk9wcCA9IHZlcnRpY2FsID8gZHJhZ1JlY3QucmlnaHQgOiBkcmFnUmVjdC5ib3R0b20sXG4gICAgICBkcmFnRWxPcHBMZW5ndGggPSB2ZXJ0aWNhbCA/IGRyYWdSZWN0LndpZHRoIDogZHJhZ1JlY3QuaGVpZ2h0LFxuICAgICAgdGFyZ2V0UzFPcHAgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QubGVmdCA6IHRhcmdldFJlY3QudG9wLFxuICAgICAgdGFyZ2V0UzJPcHAgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QucmlnaHQgOiB0YXJnZXRSZWN0LmJvdHRvbSxcbiAgICAgIHRhcmdldE9wcExlbmd0aCA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC53aWR0aCA6IHRhcmdldFJlY3QuaGVpZ2h0O1xuICByZXR1cm4gZHJhZ0VsUzFPcHAgPT09IHRhcmdldFMxT3BwIHx8IGRyYWdFbFMyT3BwID09PSB0YXJnZXRTMk9wcCB8fCBkcmFnRWxTMU9wcCArIGRyYWdFbE9wcExlbmd0aCAvIDIgPT09IHRhcmdldFMxT3BwICsgdGFyZ2V0T3BwTGVuZ3RoIC8gMjtcbn0sXG5cbi8qKlxyXG4gKiBEZXRlY3RzIGZpcnN0IG5lYXJlc3QgZW1wdHkgc29ydGFibGUgdG8gWCBhbmQgWSBwb3NpdGlvbiB1c2luZyBlbXB0eUluc2VydFRocmVzaG9sZC5cclxuICogQHBhcmFtICB7TnVtYmVyfSB4ICAgICAgWCBwb3NpdGlvblxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHkgICAgICBZIHBvc2l0aW9uXHJcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgIEVsZW1lbnQgb2YgdGhlIGZpcnN0IGZvdW5kIG5lYXJlc3QgU29ydGFibGVcclxuICovXG5fZGV0ZWN0TmVhcmVzdEVtcHR5U29ydGFibGUgPSBmdW5jdGlvbiBfZGV0ZWN0TmVhcmVzdEVtcHR5U29ydGFibGUoeCwgeSkge1xuICB2YXIgcmV0O1xuICBzb3J0YWJsZXMuc29tZShmdW5jdGlvbiAoc29ydGFibGUpIHtcbiAgICB2YXIgdGhyZXNob2xkID0gc29ydGFibGVbZXhwYW5kb10ub3B0aW9ucy5lbXB0eUluc2VydFRocmVzaG9sZDtcbiAgICBpZiAoIXRocmVzaG9sZCB8fCBsYXN0Q2hpbGQoc29ydGFibGUpKSByZXR1cm47XG4gICAgdmFyIHJlY3QgPSBnZXRSZWN0KHNvcnRhYmxlKSxcbiAgICAgICAgaW5zaWRlSG9yaXpvbnRhbGx5ID0geCA+PSByZWN0LmxlZnQgLSB0aHJlc2hvbGQgJiYgeCA8PSByZWN0LnJpZ2h0ICsgdGhyZXNob2xkLFxuICAgICAgICBpbnNpZGVWZXJ0aWNhbGx5ID0geSA+PSByZWN0LnRvcCAtIHRocmVzaG9sZCAmJiB5IDw9IHJlY3QuYm90dG9tICsgdGhyZXNob2xkO1xuXG4gICAgaWYgKGluc2lkZUhvcml6b250YWxseSAmJiBpbnNpZGVWZXJ0aWNhbGx5KSB7XG4gICAgICByZXR1cm4gcmV0ID0gc29ydGFibGU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJldDtcbn0sXG4gICAgX3ByZXBhcmVHcm91cCA9IGZ1bmN0aW9uIF9wcmVwYXJlR3JvdXAob3B0aW9ucykge1xuICBmdW5jdGlvbiB0b0ZuKHZhbHVlLCBwdWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0bywgZnJvbSwgZHJhZ0VsLCBldnQpIHtcbiAgICAgIHZhciBzYW1lR3JvdXAgPSB0by5vcHRpb25zLmdyb3VwLm5hbWUgJiYgZnJvbS5vcHRpb25zLmdyb3VwLm5hbWUgJiYgdG8ub3B0aW9ucy5ncm91cC5uYW1lID09PSBmcm9tLm9wdGlvbnMuZ3JvdXAubmFtZTtcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgKHB1bGwgfHwgc2FtZUdyb3VwKSkge1xuICAgICAgICAvLyBEZWZhdWx0IHB1bGwgdmFsdWVcbiAgICAgICAgLy8gRGVmYXVsdCBwdWxsIGFuZCBwdXQgdmFsdWUgaWYgc2FtZSBncm91cFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChwdWxsICYmIHZhbHVlID09PSAnY2xvbmUnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0b0ZuKHZhbHVlKHRvLCBmcm9tLCBkcmFnRWwsIGV2dCksIHB1bGwpKHRvLCBmcm9tLCBkcmFnRWwsIGV2dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3RoZXJHcm91cCA9IChwdWxsID8gdG8gOiBmcm9tKS5vcHRpb25zLmdyb3VwLm5hbWU7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlID09PSBvdGhlckdyb3VwIHx8IHZhbHVlLmpvaW4gJiYgdmFsdWUuaW5kZXhPZihvdGhlckdyb3VwKSA+IC0xO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgZ3JvdXAgPSB7fTtcbiAgdmFyIG9yaWdpbmFsR3JvdXAgPSBvcHRpb25zLmdyb3VwO1xuXG4gIGlmICghb3JpZ2luYWxHcm91cCB8fCBfdHlwZW9mKG9yaWdpbmFsR3JvdXApICE9ICdvYmplY3QnKSB7XG4gICAgb3JpZ2luYWxHcm91cCA9IHtcbiAgICAgIG5hbWU6IG9yaWdpbmFsR3JvdXBcbiAgICB9O1xuICB9XG5cbiAgZ3JvdXAubmFtZSA9IG9yaWdpbmFsR3JvdXAubmFtZTtcbiAgZ3JvdXAuY2hlY2tQdWxsID0gdG9GbihvcmlnaW5hbEdyb3VwLnB1bGwsIHRydWUpO1xuICBncm91cC5jaGVja1B1dCA9IHRvRm4ob3JpZ2luYWxHcm91cC5wdXQpO1xuICBncm91cC5yZXZlcnRDbG9uZSA9IG9yaWdpbmFsR3JvdXAucmV2ZXJ0Q2xvbmU7XG4gIG9wdGlvbnMuZ3JvdXAgPSBncm91cDtcbn0sXG4gICAgX2hpZGVHaG9zdEZvclRhcmdldCA9IGZ1bmN0aW9uIF9oaWRlR2hvc3RGb3JUYXJnZXQoKSB7XG4gIGlmICghc3VwcG9ydENzc1BvaW50ZXJFdmVudHMgJiYgZ2hvc3RFbCkge1xuICAgIGNzcyhnaG9zdEVsLCAnZGlzcGxheScsICdub25lJyk7XG4gIH1cbn0sXG4gICAgX3VuaGlkZUdob3N0Rm9yVGFyZ2V0ID0gZnVuY3Rpb24gX3VuaGlkZUdob3N0Rm9yVGFyZ2V0KCkge1xuICBpZiAoIXN1cHBvcnRDc3NQb2ludGVyRXZlbnRzICYmIGdob3N0RWwpIHtcbiAgICBjc3MoZ2hvc3RFbCwgJ2Rpc3BsYXknLCAnJyk7XG4gIH1cbn07IC8vICMxMTg0IGZpeCAtIFByZXZlbnQgY2xpY2sgZXZlbnQgb24gZmFsbGJhY2sgaWYgZHJhZ2dlZCBidXQgaXRlbSBub3QgY2hhbmdlZCBwb3NpdGlvblxuXG5cbmlmIChkb2N1bWVudEV4aXN0cyAmJiAhQ2hyb21lRm9yQW5kcm9pZCkge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICBpZiAoaWdub3JlTmV4dENsaWNrKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24gJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZXZ0LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAmJiBldnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICBpZ25vcmVOZXh0Q2xpY2sgPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHRydWUpO1xufVxuXG52YXIgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQgPSBmdW5jdGlvbiBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudChldnQpIHtcbiAgaWYgKGRyYWdFbCkge1xuICAgIGV2dCA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQ7XG5cbiAgICB2YXIgbmVhcmVzdCA9IF9kZXRlY3ROZWFyZXN0RW1wdHlTb3J0YWJsZShldnQuY2xpZW50WCwgZXZ0LmNsaWVudFkpO1xuXG4gICAgaWYgKG5lYXJlc3QpIHtcbiAgICAgIC8vIENyZWF0ZSBpbWl0YXRpb24gZXZlbnRcbiAgICAgIHZhciBldmVudCA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpIGluIGV2dCkge1xuICAgICAgICBpZiAoZXZ0Lmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgZXZlbnRbaV0gPSBldnRbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXZlbnQudGFyZ2V0ID0gZXZlbnQucm9vdEVsID0gbmVhcmVzdDtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gdm9pZCAwO1xuXG4gICAgICBuZWFyZXN0W2V4cGFuZG9dLl9vbkRyYWdPdmVyKGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBfY2hlY2tPdXRzaWRlVGFyZ2V0RWwgPSBmdW5jdGlvbiBfY2hlY2tPdXRzaWRlVGFyZ2V0RWwoZXZ0KSB7XG4gIGlmIChkcmFnRWwpIHtcbiAgICBkcmFnRWwucGFyZW50Tm9kZVtleHBhbmRvXS5faXNPdXRzaWRlVGhpc0VsKGV2dC50YXJnZXQpO1xuICB9XG59O1xuLyoqXHJcbiAqIEBjbGFzcyAgU29ydGFibGVcclxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9ICBlbFxyXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgIFtvcHRpb25zXVxyXG4gKi9cblxuXG5mdW5jdGlvbiBTb3J0YWJsZShlbCwgb3B0aW9ucykge1xuICBpZiAoIShlbCAmJiBlbC5ub2RlVHlwZSAmJiBlbC5ub2RlVHlwZSA9PT0gMSkpIHtcbiAgICB0aHJvdyBcIlNvcnRhYmxlOiBgZWxgIG11c3QgYmUgYW4gSFRNTEVsZW1lbnQsIG5vdCBcIi5jb25jYXQoe30udG9TdHJpbmcuY2FsbChlbCkpO1xuICB9XG5cbiAgdGhpcy5lbCA9IGVsOyAvLyByb290IGVsZW1lbnRcblxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gX2V4dGVuZHMoe30sIG9wdGlvbnMpOyAvLyBFeHBvcnQgaW5zdGFuY2VcblxuICBlbFtleHBhbmRvXSA9IHRoaXM7XG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBncm91cDogbnVsbCxcbiAgICBzb3J0OiB0cnVlLFxuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICBzdG9yZTogbnVsbCxcbiAgICBoYW5kbGU6IG51bGwsXG4gICAgZHJhZ2dhYmxlOiAvXlt1b11sJC9pLnRlc3QoZWwubm9kZU5hbWUpID8gJz5saScgOiAnPionLFxuICAgIHN3YXBUaHJlc2hvbGQ6IDEsXG4gICAgLy8gcGVyY2VudGFnZTsgMCA8PSB4IDw9IDFcbiAgICBpbnZlcnRTd2FwOiBmYWxzZSxcbiAgICAvLyBpbnZlcnQgYWx3YXlzXG4gICAgaW52ZXJ0ZWRTd2FwVGhyZXNob2xkOiBudWxsLFxuICAgIC8vIHdpbGwgYmUgc2V0IHRvIHNhbWUgYXMgc3dhcFRocmVzaG9sZCBpZiBkZWZhdWx0XG4gICAgcmVtb3ZlQ2xvbmVPbkhpZGU6IHRydWUsXG4gICAgZGlyZWN0aW9uOiBmdW5jdGlvbiBkaXJlY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX2RldGVjdERpcmVjdGlvbihlbCwgdGhpcy5vcHRpb25zKTtcbiAgICB9LFxuICAgIGdob3N0Q2xhc3M6ICdzb3J0YWJsZS1naG9zdCcsXG4gICAgY2hvc2VuQ2xhc3M6ICdzb3J0YWJsZS1jaG9zZW4nLFxuICAgIGRyYWdDbGFzczogJ3NvcnRhYmxlLWRyYWcnLFxuICAgIGlnbm9yZTogJ2EsIGltZycsXG4gICAgZmlsdGVyOiBudWxsLFxuICAgIHByZXZlbnRPbkZpbHRlcjogdHJ1ZSxcbiAgICBhbmltYXRpb246IDAsXG4gICAgZWFzaW5nOiBudWxsLFxuICAgIHNldERhdGE6IGZ1bmN0aW9uIHNldERhdGEoZGF0YVRyYW5zZmVyLCBkcmFnRWwpIHtcbiAgICAgIGRhdGFUcmFuc2Zlci5zZXREYXRhKCdUZXh0JywgZHJhZ0VsLnRleHRDb250ZW50KTtcbiAgICB9LFxuICAgIGRyb3BCdWJibGU6IGZhbHNlLFxuICAgIGRyYWdvdmVyQnViYmxlOiBmYWxzZSxcbiAgICBkYXRhSWRBdHRyOiAnZGF0YS1pZCcsXG4gICAgZGVsYXk6IDAsXG4gICAgZGVsYXlPblRvdWNoT25seTogZmFsc2UsXG4gICAgdG91Y2hTdGFydFRocmVzaG9sZDogKE51bWJlci5wYXJzZUludCA/IE51bWJlciA6IHdpbmRvdykucGFyc2VJbnQod2luZG93LmRldmljZVBpeGVsUmF0aW8sIDEwKSB8fCAxLFxuICAgIGZvcmNlRmFsbGJhY2s6IGZhbHNlLFxuICAgIGZhbGxiYWNrQ2xhc3M6ICdzb3J0YWJsZS1mYWxsYmFjaycsXG4gICAgZmFsbGJhY2tPbkJvZHk6IGZhbHNlLFxuICAgIGZhbGxiYWNrVG9sZXJhbmNlOiAwLFxuICAgIGZhbGxiYWNrT2Zmc2V0OiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH0sXG4gICAgc3VwcG9ydFBvaW50ZXI6IFNvcnRhYmxlLnN1cHBvcnRQb2ludGVyICE9PSBmYWxzZSAmJiAnUG9pbnRlckV2ZW50JyBpbiB3aW5kb3cgJiYgIVNhZmFyaSxcbiAgICBlbXB0eUluc2VydFRocmVzaG9sZDogNVxuICB9O1xuICBQbHVnaW5NYW5hZ2VyLmluaXRpYWxpemVQbHVnaW5zKHRoaXMsIGVsLCBkZWZhdWx0cyk7IC8vIFNldCBkZWZhdWx0IG9wdGlvbnNcblxuICBmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRzKSB7XG4gICAgIShuYW1lIGluIG9wdGlvbnMpICYmIChvcHRpb25zW25hbWVdID0gZGVmYXVsdHNbbmFtZV0pO1xuICB9XG5cbiAgX3ByZXBhcmVHcm91cChvcHRpb25zKTsgLy8gQmluZCBhbGwgcHJpdmF0ZSBtZXRob2RzXG5cblxuICBmb3IgKHZhciBmbiBpbiB0aGlzKSB7XG4gICAgaWYgKGZuLmNoYXJBdCgwKSA9PT0gJ18nICYmIHR5cGVvZiB0aGlzW2ZuXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tmbl0gPSB0aGlzW2ZuXS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgfSAvLyBTZXR1cCBkcmFnIG1vZGVcblxuXG4gIHRoaXMubmF0aXZlRHJhZ2dhYmxlID0gb3B0aW9ucy5mb3JjZUZhbGxiYWNrID8gZmFsc2UgOiBzdXBwb3J0RHJhZ2dhYmxlO1xuXG4gIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgIC8vIFRvdWNoIHN0YXJ0IHRocmVzaG9sZCBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIHRoZSBuYXRpdmUgZHJhZ3N0YXJ0IHRocmVzaG9sZFxuICAgIHRoaXMub3B0aW9ucy50b3VjaFN0YXJ0VGhyZXNob2xkID0gMTtcbiAgfSAvLyBCaW5kIGV2ZW50c1xuXG5cbiAgaWYgKG9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcbiAgICBvbihlbCwgJ3BvaW50ZXJkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XG4gIH0gZWxzZSB7XG4gICAgb24oZWwsICdtb3VzZWRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgICBvbihlbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgfVxuXG4gIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgIG9uKGVsLCAnZHJhZ292ZXInLCB0aGlzKTtcbiAgICBvbihlbCwgJ2RyYWdlbnRlcicsIHRoaXMpO1xuICB9XG5cbiAgc29ydGFibGVzLnB1c2godGhpcy5lbCk7IC8vIFJlc3RvcmUgc29ydGluZ1xuXG4gIG9wdGlvbnMuc3RvcmUgJiYgb3B0aW9ucy5zdG9yZS5nZXQgJiYgdGhpcy5zb3J0KG9wdGlvbnMuc3RvcmUuZ2V0KHRoaXMpIHx8IFtdKTsgLy8gQWRkIGFuaW1hdGlvbiBzdGF0ZSBtYW5hZ2VyXG5cbiAgX2V4dGVuZHModGhpcywgQW5pbWF0aW9uU3RhdGVNYW5hZ2VyKCkpO1xufVxuXG5Tb3J0YWJsZS5wcm90b3R5cGUgPVxuLyoqIEBsZW5kcyBTb3J0YWJsZS5wcm90b3R5cGUgKi9cbntcbiAgY29uc3RydWN0b3I6IFNvcnRhYmxlLFxuICBfaXNPdXRzaWRlVGhpc0VsOiBmdW5jdGlvbiBfaXNPdXRzaWRlVGhpc0VsKHRhcmdldCkge1xuICAgIGlmICghdGhpcy5lbC5jb250YWlucyh0YXJnZXQpICYmIHRhcmdldCAhPT0gdGhpcy5lbCkge1xuICAgICAgbGFzdFRhcmdldCA9IG51bGw7XG4gICAgfVxuICB9LFxuICBfZ2V0RGlyZWN0aW9uOiBmdW5jdGlvbiBfZ2V0RGlyZWN0aW9uKGV2dCwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uID09PSAnZnVuY3Rpb24nID8gdGhpcy5vcHRpb25zLmRpcmVjdGlvbi5jYWxsKHRoaXMsIGV2dCwgdGFyZ2V0LCBkcmFnRWwpIDogdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgfSxcbiAgX29uVGFwU3RhcnQ6IGZ1bmN0aW9uIF9vblRhcFN0YXJ0KFxuICAvKiogRXZlbnR8VG91Y2hFdmVudCAqL1xuICBldnQpIHtcbiAgICBpZiAoIWV2dC5jYW5jZWxhYmxlKSByZXR1cm47XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBlbCA9IHRoaXMuZWwsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHByZXZlbnRPbkZpbHRlciA9IG9wdGlvbnMucHJldmVudE9uRmlsdGVyLFxuICAgICAgICB0eXBlID0gZXZ0LnR5cGUsXG4gICAgICAgIHRvdWNoID0gZXZ0LnRvdWNoZXMgJiYgZXZ0LnRvdWNoZXNbMF0gfHwgZXZ0LnBvaW50ZXJUeXBlICYmIGV2dC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyAmJiBldnQsXG4gICAgICAgIHRhcmdldCA9ICh0b3VjaCB8fCBldnQpLnRhcmdldCxcbiAgICAgICAgb3JpZ2luYWxUYXJnZXQgPSBldnQudGFyZ2V0LnNoYWRvd1Jvb3QgJiYgKGV2dC5wYXRoICYmIGV2dC5wYXRoWzBdIHx8IGV2dC5jb21wb3NlZFBhdGggJiYgZXZ0LmNvbXBvc2VkUGF0aCgpWzBdKSB8fCB0YXJnZXQsXG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuXG4gICAgX3NhdmVJbnB1dENoZWNrZWRTdGF0ZShlbCk7IC8vIERvbid0IHRyaWdnZXIgc3RhcnQgZXZlbnQgd2hlbiBhbiBlbGVtZW50IGlzIGJlZW4gZHJhZ2dlZCwgb3RoZXJ3aXNlIHRoZSBldnQub2xkaW5kZXggYWx3YXlzIHdyb25nIHdoZW4gc2V0IG9wdGlvbi5ncm91cC5cblxuXG4gICAgaWYgKGRyYWdFbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICgvbW91c2Vkb3dufHBvaW50ZXJkb3duLy50ZXN0KHR5cGUpICYmIGV2dC5idXR0b24gIT09IDAgfHwgb3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuOyAvLyBvbmx5IGxlZnQgYnV0dG9uIGFuZCBlbmFibGVkXG4gICAgfSAvLyBjYW5jZWwgZG5kIGlmIG9yaWdpbmFsIHRhcmdldCBpcyBjb250ZW50IGVkaXRhYmxlXG5cblxuICAgIGlmIChvcmlnaW5hbFRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gU2FmYXJpIGlnbm9yZXMgZnVydGhlciBldmVudCBoYW5kbGluZyBhZnRlciBtb3VzZWRvd25cblxuXG4gICAgaWYgKCF0aGlzLm5hdGl2ZURyYWdnYWJsZSAmJiBTYWZhcmkgJiYgdGFyZ2V0ICYmIHRhcmdldC50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdTRUxFQ1QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gY2xvc2VzdCh0YXJnZXQsIG9wdGlvbnMuZHJhZ2dhYmxlLCBlbCwgZmFsc2UpO1xuXG4gICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuYW5pbWF0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGFzdERvd25FbCA9PT0gdGFyZ2V0KSB7XG4gICAgICAvLyBJZ25vcmluZyBkdXBsaWNhdGUgYGRvd25gXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkcmFnZ2VkIGVsZW1lbnQgd2l0aGluIGl0cyBwYXJlbnRcblxuXG4gICAgb2xkSW5kZXggPSBpbmRleCh0YXJnZXQpO1xuICAgIG9sZERyYWdnYWJsZUluZGV4ID0gaW5kZXgodGFyZ2V0LCBvcHRpb25zLmRyYWdnYWJsZSk7IC8vIENoZWNrIGZpbHRlclxuXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChmaWx0ZXIuY2FsbCh0aGlzLCBldnQsIHRhcmdldCwgdGhpcykpIHtcbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgICByb290RWw6IG9yaWdpbmFsVGFyZ2V0LFxuICAgICAgICAgIG5hbWU6ICdmaWx0ZXInLFxuICAgICAgICAgIHRhcmdldEVsOiB0YXJnZXQsXG4gICAgICAgICAgdG9FbDogZWwsXG4gICAgICAgICAgZnJvbUVsOiBlbFxuICAgICAgICB9KTtcblxuICAgICAgICBwbHVnaW5FdmVudCgnZmlsdGVyJywgX3RoaXMsIHtcbiAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICB9KTtcbiAgICAgICAgcHJldmVudE9uRmlsdGVyICYmIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47IC8vIGNhbmNlbCBkbmRcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZpbHRlcikge1xuICAgICAgZmlsdGVyID0gZmlsdGVyLnNwbGl0KCcsJykuc29tZShmdW5jdGlvbiAoY3JpdGVyaWEpIHtcbiAgICAgICAgY3JpdGVyaWEgPSBjbG9zZXN0KG9yaWdpbmFsVGFyZ2V0LCBjcml0ZXJpYS50cmltKCksIGVsLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKGNyaXRlcmlhKSB7XG4gICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgc29ydGFibGU6IF90aGlzLFxuICAgICAgICAgICAgcm9vdEVsOiBjcml0ZXJpYSxcbiAgICAgICAgICAgIG5hbWU6ICdmaWx0ZXInLFxuICAgICAgICAgICAgdGFyZ2V0RWw6IHRhcmdldCxcbiAgICAgICAgICAgIGZyb21FbDogZWwsXG4gICAgICAgICAgICB0b0VsOiBlbFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcGx1Z2luRXZlbnQoJ2ZpbHRlcicsIF90aGlzLCB7XG4gICAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICBwcmV2ZW50T25GaWx0ZXIgJiYgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjsgLy8gY2FuY2VsIGRuZFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmhhbmRsZSAmJiAhY2xvc2VzdChvcmlnaW5hbFRhcmdldCwgb3B0aW9ucy5oYW5kbGUsIGVsLCBmYWxzZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFByZXBhcmUgYGRyYWdzdGFydGBcblxuXG4gICAgdGhpcy5fcHJlcGFyZURyYWdTdGFydChldnQsIHRvdWNoLCB0YXJnZXQpO1xuICB9LFxuICBfcHJlcGFyZURyYWdTdGFydDogZnVuY3Rpb24gX3ByZXBhcmVEcmFnU3RhcnQoXG4gIC8qKiBFdmVudCAqL1xuICBldnQsXG4gIC8qKiBUb3VjaCAqL1xuICB0b3VjaCxcbiAgLyoqIEhUTUxFbGVtZW50ICovXG4gIHRhcmdldCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIGVsID0gX3RoaXMuZWwsXG4gICAgICAgIG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zLFxuICAgICAgICBvd25lckRvY3VtZW50ID0gZWwub3duZXJEb2N1bWVudCxcbiAgICAgICAgZHJhZ1N0YXJ0Rm47XG5cbiAgICBpZiAodGFyZ2V0ICYmICFkcmFnRWwgJiYgdGFyZ2V0LnBhcmVudE5vZGUgPT09IGVsKSB7XG4gICAgICB2YXIgZHJhZ1JlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG4gICAgICByb290RWwgPSBlbDtcbiAgICAgIGRyYWdFbCA9IHRhcmdldDtcbiAgICAgIHBhcmVudEVsID0gZHJhZ0VsLnBhcmVudE5vZGU7XG4gICAgICBuZXh0RWwgPSBkcmFnRWwubmV4dFNpYmxpbmc7XG4gICAgICBsYXN0RG93bkVsID0gdGFyZ2V0O1xuICAgICAgYWN0aXZlR3JvdXAgPSBvcHRpb25zLmdyb3VwO1xuICAgICAgU29ydGFibGUuZHJhZ2dlZCA9IGRyYWdFbDtcbiAgICAgIHRhcEV2dCA9IHtcbiAgICAgICAgdGFyZ2V0OiBkcmFnRWwsXG4gICAgICAgIGNsaWVudFg6ICh0b3VjaCB8fCBldnQpLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6ICh0b3VjaCB8fCBldnQpLmNsaWVudFlcbiAgICAgIH07XG4gICAgICB0YXBEaXN0YW5jZUxlZnQgPSB0YXBFdnQuY2xpZW50WCAtIGRyYWdSZWN0LmxlZnQ7XG4gICAgICB0YXBEaXN0YW5jZVRvcCA9IHRhcEV2dC5jbGllbnRZIC0gZHJhZ1JlY3QudG9wO1xuICAgICAgdGhpcy5fbGFzdFggPSAodG91Y2ggfHwgZXZ0KS5jbGllbnRYO1xuICAgICAgdGhpcy5fbGFzdFkgPSAodG91Y2ggfHwgZXZ0KS5jbGllbnRZO1xuICAgICAgZHJhZ0VsLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJ2FsbCc7XG5cbiAgICAgIGRyYWdTdGFydEZuID0gZnVuY3Rpb24gZHJhZ1N0YXJ0Rm4oKSB7XG4gICAgICAgIHBsdWdpbkV2ZW50KCdkZWxheUVuZGVkJywgX3RoaXMsIHtcbiAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgICAgIF90aGlzLl9vbkRyb3AoKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBEZWxheWVkIGRyYWcgaGFzIGJlZW4gdHJpZ2dlcmVkXG4gICAgICAgIC8vIHdlIGNhbiByZS1lbmFibGUgdGhlIGV2ZW50czogdG91Y2htb3ZlL21vdXNlbW92ZVxuXG5cbiAgICAgICAgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cygpO1xuXG4gICAgICAgIGlmICghRmlyZUZveCAmJiBfdGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgICBkcmFnRWwuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgfSAvLyBCaW5kIHRoZSBldmVudHM6IGRyYWdzdGFydC9kcmFnZW5kXG5cblxuICAgICAgICBfdGhpcy5fdHJpZ2dlckRyYWdTdGFydChldnQsIHRvdWNoKTsgLy8gRHJhZyBzdGFydCBldmVudFxuXG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgICBuYW1lOiAnY2hvb3NlJyxcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgfSk7IC8vIENob3NlbiBpdGVtXG5cblxuICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuY2hvc2VuQ2xhc3MsIHRydWUpO1xuICAgICAgfTsgLy8gRGlzYWJsZSBcImRyYWdnYWJsZVwiXG5cblxuICAgICAgb3B0aW9ucy5pZ25vcmUuc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uIChjcml0ZXJpYSkge1xuICAgICAgICBmaW5kKGRyYWdFbCwgY3JpdGVyaWEudHJpbSgpLCBfZGlzYWJsZURyYWdnYWJsZSk7XG4gICAgICB9KTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdkcmFnb3ZlcicsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2htb3ZlJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgICAgb24ob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCBfdGhpcy5fb25Ecm9wKTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgX3RoaXMuX29uRHJvcCk7IC8vIE1ha2UgZHJhZ0VsIGRyYWdnYWJsZSAobXVzdCBiZSBiZWZvcmUgZGVsYXkgZm9yIEZpcmVGb3gpXG5cbiAgICAgIGlmIChGaXJlRm94ICYmIHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy50b3VjaFN0YXJ0VGhyZXNob2xkID0gNDtcbiAgICAgICAgZHJhZ0VsLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHBsdWdpbkV2ZW50KCdkZWxheVN0YXJ0JywgdGhpcywge1xuICAgICAgICBldnQ6IGV2dFxuICAgICAgfSk7IC8vIERlbGF5IGlzIGltcG9zc2libGUgZm9yIG5hdGl2ZSBEbkQgaW4gRWRnZSBvciBJRVxuXG4gICAgICBpZiAob3B0aW9ucy5kZWxheSAmJiAoIW9wdGlvbnMuZGVsYXlPblRvdWNoT25seSB8fCB0b3VjaCkgJiYgKCF0aGlzLm5hdGl2ZURyYWdnYWJsZSB8fCAhKEVkZ2UgfHwgSUUxMU9yTGVzcykpKSB7XG4gICAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICAgICAgdGhpcy5fb25Ecm9wKCk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gSWYgdGhlIHVzZXIgbW92ZXMgdGhlIHBvaW50ZXIgb3IgbGV0IGdvIHRoZSBjbGljayBvciB0b3VjaFxuICAgICAgICAvLyBiZWZvcmUgdGhlIGRlbGF5IGhhcyBiZWVuIHJlYWNoZWQ6XG4gICAgICAgIC8vIGRpc2FibGUgdGhlIGRlbGF5ZWQgZHJhZ1xuXG5cbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgX3RoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaG1vdmUnLCBfdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICAgICAgb3B0aW9ucy5zdXBwb3J0UG9pbnRlciAmJiBvbihvd25lckRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCBfdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICAgICAgX3RoaXMuX2RyYWdTdGFydFRpbWVyID0gc2V0VGltZW91dChkcmFnU3RhcnRGbiwgb3B0aW9ucy5kZWxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkcmFnU3RhcnRGbigpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcjogZnVuY3Rpb24gX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcihcbiAgLyoqIFRvdWNoRXZlbnR8UG9pbnRlckV2ZW50ICoqL1xuICBlKSB7XG4gICAgdmFyIHRvdWNoID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcblxuICAgIGlmIChNYXRoLm1heChNYXRoLmFicyh0b3VjaC5jbGllbnRYIC0gdGhpcy5fbGFzdFgpLCBNYXRoLmFicyh0b3VjaC5jbGllbnRZIC0gdGhpcy5fbGFzdFkpKSA+PSBNYXRoLmZsb29yKHRoaXMub3B0aW9ucy50b3VjaFN0YXJ0VGhyZXNob2xkIC8gKHRoaXMubmF0aXZlRHJhZ2dhYmxlICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpKSkge1xuICAgICAgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKCk7XG4gICAgfVxuICB9LFxuICBfZGlzYWJsZURlbGF5ZWREcmFnOiBmdW5jdGlvbiBfZGlzYWJsZURlbGF5ZWREcmFnKCkge1xuICAgIGRyYWdFbCAmJiBfZGlzYWJsZURyYWdnYWJsZShkcmFnRWwpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9kcmFnU3RhcnRUaW1lcik7XG5cbiAgICB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMoKTtcbiAgfSxcbiAgX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50czogZnVuY3Rpb24gX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cygpIHtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IHRoaXMuZWwub3duZXJEb2N1bWVudDtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gIH0sXG4gIF90cmlnZ2VyRHJhZ1N0YXJ0OiBmdW5jdGlvbiBfdHJpZ2dlckRyYWdTdGFydChcbiAgLyoqIEV2ZW50ICovXG4gIGV2dCxcbiAgLyoqIFRvdWNoICovXG4gIHRvdWNoKSB7XG4gICAgdG91Y2ggPSB0b3VjaCB8fCBldnQucG9pbnRlclR5cGUgPT0gJ3RvdWNoJyAmJiBldnQ7XG5cbiAgICBpZiAoIXRoaXMubmF0aXZlRHJhZ2dhYmxlIHx8IHRvdWNoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN1cHBvcnRQb2ludGVyKSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgICB9IGVsc2UgaWYgKHRvdWNoKSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uKGRyYWdFbCwgJ2RyYWdlbmQnLCB0aGlzKTtcbiAgICAgIG9uKHJvb3RFbCwgJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuICAgICAgICAvLyBUaW1lb3V0IG5lY2Nlc3NhcnkgZm9yIElFOVxuICAgICAgICBfbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHt9XG4gIH0sXG4gIF9kcmFnU3RhcnRlZDogZnVuY3Rpb24gX2RyYWdTdGFydGVkKGZhbGxiYWNrLCBldnQpIHtcblxuICAgIGF3YWl0aW5nRHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIGlmIChyb290RWwgJiYgZHJhZ0VsKSB7XG4gICAgICBwbHVnaW5FdmVudCgnZHJhZ1N0YXJ0ZWQnLCB0aGlzLCB7XG4gICAgICAgIGV2dDogZXZ0XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAnZHJhZ292ZXInLCBfY2hlY2tPdXRzaWRlVGFyZ2V0RWwpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uczsgLy8gQXBwbHkgZWZmZWN0XG5cbiAgICAgICFmYWxsYmFjayAmJiB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuZHJhZ0NsYXNzLCBmYWxzZSk7XG4gICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuZ2hvc3RDbGFzcywgdHJ1ZSk7XG4gICAgICBTb3J0YWJsZS5hY3RpdmUgPSB0aGlzO1xuICAgICAgZmFsbGJhY2sgJiYgdGhpcy5fYXBwZW5kR2hvc3QoKTsgLy8gRHJhZyBzdGFydCBldmVudFxuXG4gICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICBuYW1lOiAnc3RhcnQnLFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9udWxsaW5nKCk7XG4gICAgfVxuICB9LFxuICBfZW11bGF0ZURyYWdPdmVyOiBmdW5jdGlvbiBfZW11bGF0ZURyYWdPdmVyKCkge1xuICAgIGlmICh0b3VjaEV2dCkge1xuICAgICAgdGhpcy5fbGFzdFggPSB0b3VjaEV2dC5jbGllbnRYO1xuICAgICAgdGhpcy5fbGFzdFkgPSB0b3VjaEV2dC5jbGllbnRZO1xuXG4gICAgICBfaGlkZUdob3N0Rm9yVGFyZ2V0KCk7XG5cbiAgICAgIHZhciB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvdWNoRXZ0LmNsaWVudFgsIHRvdWNoRXZ0LmNsaWVudFkpO1xuICAgICAgdmFyIHBhcmVudCA9IHRhcmdldDtcblxuICAgICAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQuc2hhZG93Um9vdCkge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQuc2hhZG93Um9vdC5lbGVtZW50RnJvbVBvaW50KHRvdWNoRXZ0LmNsaWVudFgsIHRvdWNoRXZ0LmNsaWVudFkpO1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBwYXJlbnQpIGJyZWFrO1xuICAgICAgICBwYXJlbnQgPSB0YXJnZXQ7XG4gICAgICB9XG5cbiAgICAgIGRyYWdFbC5wYXJlbnROb2RlW2V4cGFuZG9dLl9pc091dHNpZGVUaGlzRWwodGFyZ2V0KTtcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKHBhcmVudFtleHBhbmRvXSkge1xuICAgICAgICAgICAgdmFyIGluc2VydGVkID0gdm9pZCAwO1xuICAgICAgICAgICAgaW5zZXJ0ZWQgPSBwYXJlbnRbZXhwYW5kb10uX29uRHJhZ092ZXIoe1xuICAgICAgICAgICAgICBjbGllbnRYOiB0b3VjaEV2dC5jbGllbnRYLFxuICAgICAgICAgICAgICBjbGllbnRZOiB0b3VjaEV2dC5jbGllbnRZLFxuICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgcm9vdEVsOiBwYXJlbnRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaW5zZXJ0ZWQgJiYgIXRoaXMub3B0aW9ucy5kcmFnb3ZlckJ1YmJsZSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0YXJnZXQgPSBwYXJlbnQ7IC8vIHN0b3JlIGxhc3QgZWxlbWVudFxuICAgICAgICB9XG4gICAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cbiAgICAgICAgd2hpbGUgKHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlKTtcbiAgICAgIH1cblxuICAgICAgX3VuaGlkZUdob3N0Rm9yVGFyZ2V0KCk7XG4gICAgfVxuICB9LFxuICBfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIF9vblRvdWNoTW92ZShcbiAgLyoqVG91Y2hFdmVudCovXG4gIGV2dCkge1xuICAgIGlmICh0YXBFdnQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIGZhbGxiYWNrVG9sZXJhbmNlID0gb3B0aW9ucy5mYWxsYmFja1RvbGVyYW5jZSxcbiAgICAgICAgICBmYWxsYmFja09mZnNldCA9IG9wdGlvbnMuZmFsbGJhY2tPZmZzZXQsXG4gICAgICAgICAgdG91Y2ggPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0LFxuICAgICAgICAgIGdob3N0TWF0cml4ID0gZ2hvc3RFbCAmJiBtYXRyaXgoZ2hvc3RFbCwgdHJ1ZSksXG4gICAgICAgICAgc2NhbGVYID0gZ2hvc3RFbCAmJiBnaG9zdE1hdHJpeCAmJiBnaG9zdE1hdHJpeC5hLFxuICAgICAgICAgIHNjYWxlWSA9IGdob3N0RWwgJiYgZ2hvc3RNYXRyaXggJiYgZ2hvc3RNYXRyaXguZCxcbiAgICAgICAgICByZWxhdGl2ZVNjcm9sbE9mZnNldCA9IFBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5ICYmIGdob3N0UmVsYXRpdmVQYXJlbnQgJiYgZ2V0UmVsYXRpdmVTY3JvbGxPZmZzZXQoZ2hvc3RSZWxhdGl2ZVBhcmVudCksXG4gICAgICAgICAgZHggPSAodG91Y2guY2xpZW50WCAtIHRhcEV2dC5jbGllbnRYICsgZmFsbGJhY2tPZmZzZXQueCkgLyAoc2NhbGVYIHx8IDEpICsgKHJlbGF0aXZlU2Nyb2xsT2Zmc2V0ID8gcmVsYXRpdmVTY3JvbGxPZmZzZXRbMF0gLSBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbFswXSA6IDApIC8gKHNjYWxlWCB8fCAxKSxcbiAgICAgICAgICBkeSA9ICh0b3VjaC5jbGllbnRZIC0gdGFwRXZ0LmNsaWVudFkgKyBmYWxsYmFja09mZnNldC55KSAvIChzY2FsZVkgfHwgMSkgKyAocmVsYXRpdmVTY3JvbGxPZmZzZXQgPyByZWxhdGl2ZVNjcm9sbE9mZnNldFsxXSAtIGdob3N0UmVsYXRpdmVQYXJlbnRJbml0aWFsU2Nyb2xsWzFdIDogMCkgLyAoc2NhbGVZIHx8IDEpOyAvLyBvbmx5IHNldCB0aGUgc3RhdHVzIHRvIGRyYWdnaW5nLCB3aGVuIHdlIGFyZSBhY3R1YWxseSBkcmFnZ2luZ1xuXG4gICAgICBpZiAoIVNvcnRhYmxlLmFjdGl2ZSAmJiAhYXdhaXRpbmdEcmFnU3RhcnRlZCkge1xuICAgICAgICBpZiAoZmFsbGJhY2tUb2xlcmFuY2UgJiYgTWF0aC5tYXgoTWF0aC5hYnModG91Y2guY2xpZW50WCAtIHRoaXMuX2xhc3RYKSwgTWF0aC5hYnModG91Y2guY2xpZW50WSAtIHRoaXMuX2xhc3RZKSkgPCBmYWxsYmFja1RvbGVyYW5jZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX29uRHJhZ1N0YXJ0KGV2dCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChnaG9zdEVsKSB7XG4gICAgICAgIGlmIChnaG9zdE1hdHJpeCkge1xuICAgICAgICAgIGdob3N0TWF0cml4LmUgKz0gZHggLSAobGFzdER4IHx8IDApO1xuICAgICAgICAgIGdob3N0TWF0cml4LmYgKz0gZHkgLSAobGFzdER5IHx8IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdob3N0TWF0cml4ID0ge1xuICAgICAgICAgICAgYTogMSxcbiAgICAgICAgICAgIGI6IDAsXG4gICAgICAgICAgICBjOiAwLFxuICAgICAgICAgICAgZDogMSxcbiAgICAgICAgICAgIGU6IGR4LFxuICAgICAgICAgICAgZjogZHlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNzc01hdHJpeCA9IFwibWF0cml4KFwiLmNvbmNhdChnaG9zdE1hdHJpeC5hLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmIsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguYywgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5kLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmUsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguZiwgXCIpXCIpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ3dlYmtpdFRyYW5zZm9ybScsIGNzc01hdHJpeCk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAnbW96VHJhbnNmb3JtJywgY3NzTWF0cml4KTtcbiAgICAgICAgY3NzKGdob3N0RWwsICdtc1RyYW5zZm9ybScsIGNzc01hdHJpeCk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAndHJhbnNmb3JtJywgY3NzTWF0cml4KTtcbiAgICAgICAgbGFzdER4ID0gZHg7XG4gICAgICAgIGxhc3REeSA9IGR5O1xuICAgICAgICB0b3VjaEV2dCA9IHRvdWNoO1xuICAgICAgfVxuXG4gICAgICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sXG4gIF9hcHBlbmRHaG9zdDogZnVuY3Rpb24gX2FwcGVuZEdob3N0KCkge1xuICAgIC8vIEJ1ZyBpZiB1c2luZyBzY2FsZSgpOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNjM3MDU4XG4gICAgLy8gTm90IGJlaW5nIGFkanVzdGVkIGZvclxuICAgIGlmICghZ2hvc3RFbCkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5mYWxsYmFja09uQm9keSA/IGRvY3VtZW50LmJvZHkgOiByb290RWwsXG4gICAgICAgICAgcmVjdCA9IGdldFJlY3QoZHJhZ0VsLCB0cnVlLCBQb3NpdGlvbkdob3N0QWJzb2x1dGVseSwgdHJ1ZSwgY29udGFpbmVyKSxcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zOyAvLyBQb3NpdGlvbiBhYnNvbHV0ZWx5XG5cbiAgICAgIGlmIChQb3NpdGlvbkdob3N0QWJzb2x1dGVseSkge1xuICAgICAgICAvLyBHZXQgcmVsYXRpdmVseSBwb3NpdGlvbmVkIHBhcmVudFxuICAgICAgICBnaG9zdFJlbGF0aXZlUGFyZW50ID0gY29udGFpbmVyO1xuXG4gICAgICAgIHdoaWxlIChjc3MoZ2hvc3RSZWxhdGl2ZVBhcmVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnICYmIGNzcyhnaG9zdFJlbGF0aXZlUGFyZW50LCAndHJhbnNmb3JtJykgPT09ICdub25lJyAmJiBnaG9zdFJlbGF0aXZlUGFyZW50ICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgIGdob3N0UmVsYXRpdmVQYXJlbnQgPSBnaG9zdFJlbGF0aXZlUGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2hvc3RSZWxhdGl2ZVBhcmVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiBnaG9zdFJlbGF0aXZlUGFyZW50ICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoZ2hvc3RSZWxhdGl2ZVBhcmVudCA9PT0gZG9jdW1lbnQpIGdob3N0UmVsYXRpdmVQYXJlbnQgPSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gICAgICAgICAgcmVjdC50b3AgKz0gZ2hvc3RSZWxhdGl2ZVBhcmVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgcmVjdC5sZWZ0ICs9IGdob3N0UmVsYXRpdmVQYXJlbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnaG9zdFJlbGF0aXZlUGFyZW50ID0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2hvc3RSZWxhdGl2ZVBhcmVudEluaXRpYWxTY3JvbGwgPSBnZXRSZWxhdGl2ZVNjcm9sbE9mZnNldChnaG9zdFJlbGF0aXZlUGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgZ2hvc3RFbCA9IGRyYWdFbC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICB0b2dnbGVDbGFzcyhnaG9zdEVsLCBvcHRpb25zLmdob3N0Q2xhc3MsIGZhbHNlKTtcbiAgICAgIHRvZ2dsZUNsYXNzKGdob3N0RWwsIG9wdGlvbnMuZmFsbGJhY2tDbGFzcywgdHJ1ZSk7XG4gICAgICB0b2dnbGVDbGFzcyhnaG9zdEVsLCBvcHRpb25zLmRyYWdDbGFzcywgdHJ1ZSk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zZm9ybScsICcnKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAnYm94LXNpemluZycsICdib3JkZXItYm94Jyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ21hcmdpbicsIDApO1xuICAgICAgY3NzKGdob3N0RWwsICd0b3AnLCByZWN0LnRvcCk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ2xlZnQnLCByZWN0LmxlZnQpO1xuICAgICAgY3NzKGdob3N0RWwsICd3aWR0aCcsIHJlY3Qud2lkdGgpO1xuICAgICAgY3NzKGdob3N0RWwsICdoZWlnaHQnLCByZWN0LmhlaWdodCk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ29wYWNpdHknLCAnMC44Jyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3Bvc2l0aW9uJywgUG9zaXRpb25HaG9zdEFic29sdXRlbHkgPyAnYWJzb2x1dGUnIDogJ2ZpeGVkJyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3pJbmRleCcsICcxMDAwMDAnKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAncG9pbnRlckV2ZW50cycsICdub25lJyk7XG4gICAgICBTb3J0YWJsZS5naG9zdCA9IGdob3N0RWw7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZ2hvc3RFbCk7IC8vIFNldCB0cmFuc2Zvcm0tb3JpZ2luXG5cbiAgICAgIGNzcyhnaG9zdEVsLCAndHJhbnNmb3JtLW9yaWdpbicsIHRhcERpc3RhbmNlTGVmdCAvIHBhcnNlSW50KGdob3N0RWwuc3R5bGUud2lkdGgpICogMTAwICsgJyUgJyArIHRhcERpc3RhbmNlVG9wIC8gcGFyc2VJbnQoZ2hvc3RFbC5zdHlsZS5oZWlnaHQpICogMTAwICsgJyUnKTtcbiAgICB9XG4gIH0sXG4gIF9vbkRyYWdTdGFydDogZnVuY3Rpb24gX29uRHJhZ1N0YXJ0KFxuICAvKipFdmVudCovXG4gIGV2dCxcbiAgLyoqYm9vbGVhbiovXG4gIGZhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBkYXRhVHJhbnNmZXIgPSBldnQuZGF0YVRyYW5zZmVyO1xuICAgIHZhciBvcHRpb25zID0gX3RoaXMub3B0aW9ucztcbiAgICBwbHVnaW5FdmVudCgnZHJhZ1N0YXJ0JywgdGhpcywge1xuICAgICAgZXZ0OiBldnRcbiAgICB9KTtcblxuICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICB0aGlzLl9vbkRyb3AoKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBsdWdpbkV2ZW50KCdzZXR1cENsb25lJywgdGhpcyk7XG5cbiAgICBpZiAoIVNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgIGNsb25lRWwgPSBjbG9uZShkcmFnRWwpO1xuICAgICAgY2xvbmVFbC5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKTtcbiAgICAgIGNsb25lRWwuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICBjbG9uZUVsLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJyc7XG5cbiAgICAgIHRoaXMuX2hpZGVDbG9uZSgpO1xuXG4gICAgICB0b2dnbGVDbGFzcyhjbG9uZUVsLCB0aGlzLm9wdGlvbnMuY2hvc2VuQ2xhc3MsIGZhbHNlKTtcbiAgICAgIFNvcnRhYmxlLmNsb25lID0gY2xvbmVFbDtcbiAgICB9IC8vICMxMTQzOiBJRnJhbWUgc3VwcG9ydCB3b3JrYXJvdW5kXG5cblxuICAgIF90aGlzLmNsb25lSWQgPSBfbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgcGx1Z2luRXZlbnQoJ2Nsb25lJywgX3RoaXMpO1xuICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybjtcblxuICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlKSB7XG4gICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmVFbCwgZHJhZ0VsKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuX2hpZGVDbG9uZSgpO1xuXG4gICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgbmFtZTogJ2Nsb25lJ1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgIWZhbGxiYWNrICYmIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5kcmFnQ2xhc3MsIHRydWUpOyAvLyBTZXQgcHJvcGVyIGRyb3AgZXZlbnRzXG5cbiAgICBpZiAoZmFsbGJhY2spIHtcbiAgICAgIGlnbm9yZU5leHRDbGljayA9IHRydWU7XG4gICAgICBfdGhpcy5fbG9vcElkID0gc2V0SW50ZXJ2YWwoX3RoaXMuX2VtdWxhdGVEcmFnT3ZlciwgNTApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVbmRvIHdoYXQgd2FzIHNldCBpbiBfcHJlcGFyZURyYWdTdGFydCBiZWZvcmUgZHJhZyBzdGFydGVkXG4gICAgICBvZmYoZG9jdW1lbnQsICdtb3VzZXVwJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICBvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgb2ZmKGRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCBfdGhpcy5fb25Ecm9wKTtcblxuICAgICAgaWYgKGRhdGFUcmFuc2Zlcikge1xuICAgICAgICBkYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9ICdtb3ZlJztcbiAgICAgICAgb3B0aW9ucy5zZXREYXRhICYmIG9wdGlvbnMuc2V0RGF0YS5jYWxsKF90aGlzLCBkYXRhVHJhbnNmZXIsIGRyYWdFbCk7XG4gICAgICB9XG5cbiAgICAgIG9uKGRvY3VtZW50LCAnZHJvcCcsIF90aGlzKTsgLy8gIzEyNzYgZml4OlxuXG4gICAgICBjc3MoZHJhZ0VsLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZVooMCknKTtcbiAgICB9XG5cbiAgICBhd2FpdGluZ0RyYWdTdGFydGVkID0gdHJ1ZTtcbiAgICBfdGhpcy5fZHJhZ1N0YXJ0SWQgPSBfbmV4dFRpY2soX3RoaXMuX2RyYWdTdGFydGVkLmJpbmQoX3RoaXMsIGZhbGxiYWNrLCBldnQpKTtcbiAgICBvbihkb2N1bWVudCwgJ3NlbGVjdHN0YXJ0JywgX3RoaXMpO1xuICAgIG1vdmVkID0gdHJ1ZTtcblxuICAgIGlmIChTYWZhcmkpIHtcbiAgICAgIGNzcyhkb2N1bWVudC5ib2R5LCAndXNlci1zZWxlY3QnLCAnbm9uZScpO1xuICAgIH1cbiAgfSxcbiAgLy8gUmV0dXJucyB0cnVlIC0gaWYgbm8gZnVydGhlciBhY3Rpb24gaXMgbmVlZGVkIChlaXRoZXIgaW5zZXJ0ZWQgb3IgYW5vdGhlciBjb25kaXRpb24pXG4gIF9vbkRyYWdPdmVyOiBmdW5jdGlvbiBfb25EcmFnT3ZlcihcbiAgLyoqRXZlbnQqL1xuICBldnQpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsLFxuICAgICAgICB0YXJnZXQgPSBldnQudGFyZ2V0LFxuICAgICAgICBkcmFnUmVjdCxcbiAgICAgICAgdGFyZ2V0UmVjdCxcbiAgICAgICAgcmV2ZXJ0LFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBncm91cCA9IG9wdGlvbnMuZ3JvdXAsXG4gICAgICAgIGFjdGl2ZVNvcnRhYmxlID0gU29ydGFibGUuYWN0aXZlLFxuICAgICAgICBpc093bmVyID0gYWN0aXZlR3JvdXAgPT09IGdyb3VwLFxuICAgICAgICBjYW5Tb3J0ID0gb3B0aW9ucy5zb3J0LFxuICAgICAgICBmcm9tU29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCBhY3RpdmVTb3J0YWJsZSxcbiAgICAgICAgdmVydGljYWwsXG4gICAgICAgIF90aGlzID0gdGhpcyxcbiAgICAgICAgY29tcGxldGVkRmlyZWQgPSBmYWxzZTtcblxuICAgIGlmIChfc2lsZW50KSByZXR1cm47XG5cbiAgICBmdW5jdGlvbiBkcmFnT3ZlckV2ZW50KG5hbWUsIGV4dHJhKSB7XG4gICAgICBwbHVnaW5FdmVudChuYW1lLCBfdGhpcywgX29iamVjdFNwcmVhZDIoe1xuICAgICAgICBldnQ6IGV2dCxcbiAgICAgICAgaXNPd25lcjogaXNPd25lcixcbiAgICAgICAgYXhpczogdmVydGljYWwgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnLFxuICAgICAgICByZXZlcnQ6IHJldmVydCxcbiAgICAgICAgZHJhZ1JlY3Q6IGRyYWdSZWN0LFxuICAgICAgICB0YXJnZXRSZWN0OiB0YXJnZXRSZWN0LFxuICAgICAgICBjYW5Tb3J0OiBjYW5Tb3J0LFxuICAgICAgICBmcm9tU29ydGFibGU6IGZyb21Tb3J0YWJsZSxcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgIGNvbXBsZXRlZDogY29tcGxldGVkLFxuICAgICAgICBvbk1vdmU6IGZ1bmN0aW9uIG9uTW92ZSh0YXJnZXQsIGFmdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIF9vbk1vdmUocm9vdEVsLCBlbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0LCBnZXRSZWN0KHRhcmdldCksIGV2dCwgYWZ0ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBjaGFuZ2VkOiBjaGFuZ2VkXG4gICAgICB9LCBleHRyYSkpO1xuICAgIH0gLy8gQ2FwdHVyZSBhbmltYXRpb24gc3RhdGVcblxuXG4gICAgZnVuY3Rpb24gY2FwdHVyZSgpIHtcbiAgICAgIGRyYWdPdmVyRXZlbnQoJ2RyYWdPdmVyQW5pbWF0aW9uQ2FwdHVyZScpO1xuXG4gICAgICBfdGhpcy5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcblxuICAgICAgaWYgKF90aGlzICE9PSBmcm9tU29ydGFibGUpIHtcbiAgICAgICAgZnJvbVNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgICAgfVxuICAgIH0gLy8gUmV0dXJuIGludm9jYXRpb24gd2hlbiBkcmFnRWwgaXMgaW5zZXJ0ZWQgKG9yIGNvbXBsZXRlZClcblxuXG4gICAgZnVuY3Rpb24gY29tcGxldGVkKGluc2VydGlvbikge1xuICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXJDb21wbGV0ZWQnLCB7XG4gICAgICAgIGluc2VydGlvbjogaW5zZXJ0aW9uXG4gICAgICB9KTtcblxuICAgICAgaWYgKGluc2VydGlvbikge1xuICAgICAgICAvLyBDbG9uZXMgbXVzdCBiZSBoaWRkZW4gYmVmb3JlIGZvbGRpbmcgYW5pbWF0aW9uIHRvIGNhcHR1cmUgZHJhZ1JlY3RBYnNvbHV0ZSBwcm9wZXJseVxuICAgICAgICBpZiAoaXNPd25lcikge1xuICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlLl9oaWRlQ2xvbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5fc2hvd0Nsb25lKF90aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpcyAhPT0gZnJvbVNvcnRhYmxlKSB7XG4gICAgICAgICAgLy8gU2V0IGdob3N0IGNsYXNzIHRvIG5ldyBzb3J0YWJsZSdzIGdob3N0IGNsYXNzXG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBwdXRTb3J0YWJsZSA/IHB1dFNvcnRhYmxlLm9wdGlvbnMuZ2hvc3RDbGFzcyA6IGFjdGl2ZVNvcnRhYmxlLm9wdGlvbnMuZ2hvc3RDbGFzcywgZmFsc2UpO1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5naG9zdENsYXNzLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwdXRTb3J0YWJsZSAhPT0gX3RoaXMgJiYgX3RoaXMgIT09IFNvcnRhYmxlLmFjdGl2ZSkge1xuICAgICAgICAgIHB1dFNvcnRhYmxlID0gX3RoaXM7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RoaXMgPT09IFNvcnRhYmxlLmFjdGl2ZSAmJiBwdXRTb3J0YWJsZSkge1xuICAgICAgICAgIHB1dFNvcnRhYmxlID0gbnVsbDtcbiAgICAgICAgfSAvLyBBbmltYXRpb25cblxuXG4gICAgICAgIGlmIChmcm9tU29ydGFibGUgPT09IF90aGlzKSB7XG4gICAgICAgICAgX3RoaXMuX2lnbm9yZVdoaWxlQW5pbWF0aW5nID0gdGFyZ2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuYW5pbWF0ZUFsbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXJBbmltYXRpb25Db21wbGV0ZScpO1xuICAgICAgICAgIF90aGlzLl9pZ25vcmVXaGlsZUFuaW1hdGluZyA9IG51bGw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChfdGhpcyAhPT0gZnJvbVNvcnRhYmxlKSB7XG4gICAgICAgICAgZnJvbVNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICAgICAgICBmcm9tU29ydGFibGUuX2lnbm9yZVdoaWxlQW5pbWF0aW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBOdWxsIGxhc3RUYXJnZXQgaWYgaXQgaXMgbm90IGluc2lkZSBhIHByZXZpb3VzbHkgc3dhcHBlZCBlbGVtZW50XG5cblxuICAgICAgaWYgKHRhcmdldCA9PT0gZHJhZ0VsICYmICFkcmFnRWwuYW5pbWF0ZWQgfHwgdGFyZ2V0ID09PSBlbCAmJiAhdGFyZ2V0LmFuaW1hdGVkKSB7XG4gICAgICAgIGxhc3RUYXJnZXQgPSBudWxsO1xuICAgICAgfSAvLyBubyBidWJibGluZyBhbmQgbm90IGZhbGxiYWNrXG5cblxuICAgICAgaWYgKCFvcHRpb25zLmRyYWdvdmVyQnViYmxlICYmICFldnQucm9vdEVsICYmIHRhcmdldCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgZHJhZ0VsLnBhcmVudE5vZGVbZXhwYW5kb10uX2lzT3V0c2lkZVRoaXNFbChldnQudGFyZ2V0KTsgLy8gRG8gbm90IGRldGVjdCBmb3IgZW1wdHkgaW5zZXJ0IGlmIGFscmVhZHkgaW5zZXJ0ZWRcblxuXG4gICAgICAgICFpbnNlcnRpb24gJiYgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQoZXZ0KTtcbiAgICAgIH1cblxuICAgICAgIW9wdGlvbnMuZHJhZ292ZXJCdWJibGUgJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbiAmJiBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICByZXR1cm4gY29tcGxldGVkRmlyZWQgPSB0cnVlO1xuICAgIH0gLy8gQ2FsbCB3aGVuIGRyYWdFbCBoYXMgYmVlbiBpbnNlcnRlZFxuXG5cbiAgICBmdW5jdGlvbiBjaGFuZ2VkKCkge1xuICAgICAgbmV3SW5kZXggPSBpbmRleChkcmFnRWwpO1xuICAgICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBpbmRleChkcmFnRWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcblxuICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgIG5hbWU6ICdjaGFuZ2UnLFxuICAgICAgICB0b0VsOiBlbCxcbiAgICAgICAgbmV3SW5kZXg6IG5ld0luZGV4LFxuICAgICAgICBuZXdEcmFnZ2FibGVJbmRleDogbmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGV2dC5wcmV2ZW50RGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSBjbG9zZXN0KHRhcmdldCwgb3B0aW9ucy5kcmFnZ2FibGUsIGVsLCB0cnVlKTtcbiAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlcicpO1xuICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm4gY29tcGxldGVkRmlyZWQ7XG5cbiAgICBpZiAoZHJhZ0VsLmNvbnRhaW5zKGV2dC50YXJnZXQpIHx8IHRhcmdldC5hbmltYXRlZCAmJiB0YXJnZXQuYW5pbWF0aW5nWCAmJiB0YXJnZXQuYW5pbWF0aW5nWSB8fCBfdGhpcy5faWdub3JlV2hpbGVBbmltYXRpbmcgPT09IHRhcmdldCkge1xuICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgfVxuXG4gICAgaWdub3JlTmV4dENsaWNrID0gZmFsc2U7XG5cbiAgICBpZiAoYWN0aXZlU29ydGFibGUgJiYgIW9wdGlvbnMuZGlzYWJsZWQgJiYgKGlzT3duZXIgPyBjYW5Tb3J0IHx8IChyZXZlcnQgPSBwYXJlbnRFbCAhPT0gcm9vdEVsKSAvLyBSZXZlcnRpbmcgaXRlbSBpbnRvIHRoZSBvcmlnaW5hbCBsaXN0XG4gICAgOiBwdXRTb3J0YWJsZSA9PT0gdGhpcyB8fCAodGhpcy5sYXN0UHV0TW9kZSA9IGFjdGl2ZUdyb3VwLmNoZWNrUHVsbCh0aGlzLCBhY3RpdmVTb3J0YWJsZSwgZHJhZ0VsLCBldnQpKSAmJiBncm91cC5jaGVja1B1dCh0aGlzLCBhY3RpdmVTb3J0YWJsZSwgZHJhZ0VsLCBldnQpKSkge1xuICAgICAgdmVydGljYWwgPSB0aGlzLl9nZXREaXJlY3Rpb24oZXZ0LCB0YXJnZXQpID09PSAndmVydGljYWwnO1xuICAgICAgZHJhZ1JlY3QgPSBnZXRSZWN0KGRyYWdFbCk7XG4gICAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlclZhbGlkJyk7XG4gICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuIGNvbXBsZXRlZEZpcmVkO1xuXG4gICAgICBpZiAocmV2ZXJ0KSB7XG4gICAgICAgIHBhcmVudEVsID0gcm9vdEVsOyAvLyBhY3R1YWxpemF0aW9uXG5cbiAgICAgICAgY2FwdHVyZSgpO1xuXG4gICAgICAgIHRoaXMuX2hpZGVDbG9uZSgpO1xuXG4gICAgICAgIGRyYWdPdmVyRXZlbnQoJ3JldmVydCcpO1xuXG4gICAgICAgIGlmICghU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgICAgIGlmIChuZXh0RWwpIHtcbiAgICAgICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoZHJhZ0VsLCBuZXh0RWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb290RWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcGxldGVkKHRydWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxMYXN0Q2hpbGQgPSBsYXN0Q2hpbGQoZWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcblxuICAgICAgaWYgKCFlbExhc3RDaGlsZCB8fCBfZ2hvc3RJc0xhc3QoZXZ0LCB2ZXJ0aWNhbCwgdGhpcykgJiYgIWVsTGFzdENoaWxkLmFuaW1hdGVkKSB7XG4gICAgICAgIC8vIEluc2VydCB0byBlbmQgb2YgbGlzdFxuICAgICAgICAvLyBJZiBhbHJlYWR5IGF0IGVuZCBvZiBsaXN0OiBEbyBub3QgaW5zZXJ0XG4gICAgICAgIGlmIChlbExhc3RDaGlsZCA9PT0gZHJhZ0VsKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICAgIH0gLy8gaWYgdGhlcmUgaXMgYSBsYXN0IGVsZW1lbnQsIGl0IGlzIHRoZSB0YXJnZXRcblxuXG4gICAgICAgIGlmIChlbExhc3RDaGlsZCAmJiBlbCA9PT0gZXZ0LnRhcmdldCkge1xuICAgICAgICAgIHRhcmdldCA9IGVsTGFzdENoaWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgIHRhcmdldFJlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX29uTW92ZShyb290RWwsIGVsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXQsIHRhcmdldFJlY3QsIGV2dCwgISF0YXJnZXQpICE9PSBmYWxzZSkge1xuICAgICAgICAgIGNhcHR1cmUoKTtcblxuICAgICAgICAgIGlmIChlbExhc3RDaGlsZCAmJiBlbExhc3RDaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICAgICAgLy8gdGhlIGxhc3QgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgbm90IHRoZSBsYXN0IG5vZGVcbiAgICAgICAgICAgIGVsLmluc2VydEJlZm9yZShkcmFnRWwsIGVsTGFzdENoaWxkLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJlbnRFbCA9IGVsOyAvLyBhY3R1YWxpemF0aW9uXG5cbiAgICAgICAgICBjaGFuZ2VkKCk7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbExhc3RDaGlsZCAmJiBfZ2hvc3RJc0ZpcnN0KGV2dCwgdmVydGljYWwsIHRoaXMpKSB7XG4gICAgICAgIC8vIEluc2VydCB0byBzdGFydCBvZiBsaXN0XG4gICAgICAgIHZhciBmaXJzdENoaWxkID0gZ2V0Q2hpbGQoZWwsIDAsIG9wdGlvbnMsIHRydWUpO1xuXG4gICAgICAgIGlmIChmaXJzdENoaWxkID09PSBkcmFnRWwpIHtcbiAgICAgICAgICByZXR1cm4gY29tcGxldGVkKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldCA9IGZpcnN0Q2hpbGQ7XG4gICAgICAgIHRhcmdldFJlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG5cbiAgICAgICAgaWYgKF9vbk1vdmUocm9vdEVsLCBlbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCBldnQsIGZhbHNlKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBjYXB0dXJlKCk7XG4gICAgICAgICAgZWwuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgZmlyc3RDaGlsZCk7XG4gICAgICAgICAgcGFyZW50RWwgPSBlbDsgLy8gYWN0dWFsaXphdGlvblxuXG4gICAgICAgICAgY2hhbmdlZCgpO1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LnBhcmVudE5vZGUgPT09IGVsKSB7XG4gICAgICAgIHRhcmdldFJlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSAwLFxuICAgICAgICAgICAgdGFyZ2V0QmVmb3JlRmlyc3RTd2FwLFxuICAgICAgICAgICAgZGlmZmVyZW50TGV2ZWwgPSBkcmFnRWwucGFyZW50Tm9kZSAhPT0gZWwsXG4gICAgICAgICAgICBkaWZmZXJlbnRSb3dDb2wgPSAhX2RyYWdFbEluUm93Q29sdW1uKGRyYWdFbC5hbmltYXRlZCAmJiBkcmFnRWwudG9SZWN0IHx8IGRyYWdSZWN0LCB0YXJnZXQuYW5pbWF0ZWQgJiYgdGFyZ2V0LnRvUmVjdCB8fCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCksXG4gICAgICAgICAgICBzaWRlMSA9IHZlcnRpY2FsID8gJ3RvcCcgOiAnbGVmdCcsXG4gICAgICAgICAgICBzY3JvbGxlZFBhc3RUb3AgPSBpc1Njcm9sbGVkUGFzdCh0YXJnZXQsICd0b3AnLCAndG9wJykgfHwgaXNTY3JvbGxlZFBhc3QoZHJhZ0VsLCAndG9wJywgJ3RvcCcpLFxuICAgICAgICAgICAgc2Nyb2xsQmVmb3JlID0gc2Nyb2xsZWRQYXN0VG9wID8gc2Nyb2xsZWRQYXN0VG9wLnNjcm9sbFRvcCA6IHZvaWQgMDtcblxuICAgICAgICBpZiAobGFzdFRhcmdldCAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgdGFyZ2V0QmVmb3JlRmlyc3RTd2FwID0gdGFyZ2V0UmVjdFtzaWRlMV07XG4gICAgICAgICAgcGFzdEZpcnN0SW52ZXJ0VGhyZXNoID0gZmFsc2U7XG4gICAgICAgICAgaXNDaXJjdW1zdGFudGlhbEludmVydCA9ICFkaWZmZXJlbnRSb3dDb2wgJiYgb3B0aW9ucy5pbnZlcnRTd2FwIHx8IGRpZmZlcmVudExldmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlyZWN0aW9uID0gX2dldFN3YXBEaXJlY3Rpb24oZXZ0LCB0YXJnZXQsIHRhcmdldFJlY3QsIHZlcnRpY2FsLCBkaWZmZXJlbnRSb3dDb2wgPyAxIDogb3B0aW9ucy5zd2FwVGhyZXNob2xkLCBvcHRpb25zLmludmVydGVkU3dhcFRocmVzaG9sZCA9PSBudWxsID8gb3B0aW9ucy5zd2FwVGhyZXNob2xkIDogb3B0aW9ucy5pbnZlcnRlZFN3YXBUaHJlc2hvbGQsIGlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQsIGxhc3RUYXJnZXQgPT09IHRhcmdldCk7XG4gICAgICAgIHZhciBzaWJsaW5nO1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gIT09IDApIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgYmVzaWRlIGRyYWdFbCBpbiByZXNwZWN0aXZlIGRpcmVjdGlvbiAoaWdub3JpbmcgaGlkZGVuIGVsZW1lbnRzKVxuICAgICAgICAgIHZhciBkcmFnSW5kZXggPSBpbmRleChkcmFnRWwpO1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgZHJhZ0luZGV4IC09IGRpcmVjdGlvbjtcbiAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnRFbC5jaGlsZHJlbltkcmFnSW5kZXhdO1xuICAgICAgICAgIH0gd2hpbGUgKHNpYmxpbmcgJiYgKGNzcyhzaWJsaW5nLCAnZGlzcGxheScpID09PSAnbm9uZScgfHwgc2libGluZyA9PT0gZ2hvc3RFbCkpO1xuICAgICAgICB9IC8vIElmIGRyYWdFbCBpcyBhbHJlYWR5IGJlc2lkZSB0YXJnZXQ6IERvIG5vdCBpbnNlcnRcblxuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IDAgfHwgc2libGluZyA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0VGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICBsYXN0RGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSB0YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nLFxuICAgICAgICAgICAgYWZ0ZXIgPSBmYWxzZTtcbiAgICAgICAgYWZ0ZXIgPSBkaXJlY3Rpb24gPT09IDE7XG5cbiAgICAgICAgdmFyIG1vdmVWZWN0b3IgPSBfb25Nb3ZlKHJvb3RFbCwgZWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldCwgdGFyZ2V0UmVjdCwgZXZ0LCBhZnRlcik7XG5cbiAgICAgICAgaWYgKG1vdmVWZWN0b3IgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKG1vdmVWZWN0b3IgPT09IDEgfHwgbW92ZVZlY3RvciA9PT0gLTEpIHtcbiAgICAgICAgICAgIGFmdGVyID0gbW92ZVZlY3RvciA9PT0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfc2lsZW50ID0gdHJ1ZTtcbiAgICAgICAgICBzZXRUaW1lb3V0KF91bnNpbGVudCwgMzApO1xuICAgICAgICAgIGNhcHR1cmUoKTtcblxuICAgICAgICAgIGlmIChhZnRlciAmJiAhbmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkcmFnRWwsIGFmdGVyID8gbmV4dFNpYmxpbmcgOiB0YXJnZXQpO1xuICAgICAgICAgIH0gLy8gVW5kbyBjaHJvbWUncyBzY3JvbGwgYWRqdXN0bWVudCAoaGFzIG5vIGVmZmVjdCBvbiBvdGhlciBicm93c2VycylcblxuXG4gICAgICAgICAgaWYgKHNjcm9sbGVkUGFzdFRvcCkge1xuICAgICAgICAgICAgc2Nyb2xsQnkoc2Nyb2xsZWRQYXN0VG9wLCAwLCBzY3JvbGxCZWZvcmUgLSBzY3JvbGxlZFBhc3RUb3Auc2Nyb2xsVG9wKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJlbnRFbCA9IGRyYWdFbC5wYXJlbnROb2RlOyAvLyBhY3R1YWxpemF0aW9uXG4gICAgICAgICAgLy8gbXVzdCBiZSBkb25lIGJlZm9yZSBhbmltYXRpb25cblxuICAgICAgICAgIGlmICh0YXJnZXRCZWZvcmVGaXJzdFN3YXAgIT09IHVuZGVmaW5lZCAmJiAhaXNDaXJjdW1zdGFudGlhbEludmVydCkge1xuICAgICAgICAgICAgdGFyZ2V0TW92ZURpc3RhbmNlID0gTWF0aC5hYnModGFyZ2V0QmVmb3JlRmlyc3RTd2FwIC0gZ2V0UmVjdCh0YXJnZXQpW3NpZGUxXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hhbmdlZCgpO1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVsLmNvbnRhaW5zKGRyYWdFbCkpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBfaWdub3JlV2hpbGVBbmltYXRpbmc6IG51bGwsXG4gIF9vZmZNb3ZlRXZlbnRzOiBmdW5jdGlvbiBfb2ZmTW92ZUV2ZW50cygpIHtcbiAgICBvZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgb2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgIG9mZihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgIG9mZihkb2N1bWVudCwgJ2RyYWdvdmVyJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgIG9mZihkb2N1bWVudCwgJ21vdXNlbW92ZScsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICBvZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gIH0sXG4gIF9vZmZVcEV2ZW50czogZnVuY3Rpb24gX29mZlVwRXZlbnRzKCkge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gdGhpcy5lbC5vd25lckRvY3VtZW50O1xuICAgIG9mZihvd25lckRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX29uRHJvcCk7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uRHJvcCk7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICdwb2ludGVydXAnLCB0aGlzLl9vbkRyb3ApO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCB0aGlzLl9vbkRyb3ApO1xuICAgIG9mZihkb2N1bWVudCwgJ3NlbGVjdHN0YXJ0JywgdGhpcyk7XG4gIH0sXG4gIF9vbkRyb3A6IGZ1bmN0aW9uIF9vbkRyb3AoXG4gIC8qKkV2ZW50Ki9cbiAgZXZ0KSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbCxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9uczsgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50XG5cbiAgICBuZXdJbmRleCA9IGluZGV4KGRyYWdFbCk7XG4gICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBpbmRleChkcmFnRWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcbiAgICBwbHVnaW5FdmVudCgnZHJvcCcsIHRoaXMsIHtcbiAgICAgIGV2dDogZXZ0XG4gICAgfSk7XG4gICAgcGFyZW50RWwgPSBkcmFnRWwgJiYgZHJhZ0VsLnBhcmVudE5vZGU7IC8vIEdldCBhZ2FpbiBhZnRlciBwbHVnaW4gZXZlbnRcblxuICAgIG5ld0luZGV4ID0gaW5kZXgoZHJhZ0VsKTtcbiAgICBuZXdEcmFnZ2FibGVJbmRleCA9IGluZGV4KGRyYWdFbCwgb3B0aW9ucy5kcmFnZ2FibGUpO1xuXG4gICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgIHRoaXMuX251bGxpbmcoKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGF3YWl0aW5nRHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICBpc0NpcmN1bXN0YW50aWFsSW52ZXJ0ID0gZmFsc2U7XG4gICAgcGFzdEZpcnN0SW52ZXJ0VGhyZXNoID0gZmFsc2U7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9sb29wSWQpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9kcmFnU3RhcnRUaW1lcik7XG5cbiAgICBfY2FuY2VsTmV4dFRpY2sodGhpcy5jbG9uZUlkKTtcblxuICAgIF9jYW5jZWxOZXh0VGljayh0aGlzLl9kcmFnU3RhcnRJZCk7IC8vIFVuYmluZCBldmVudHNcblxuXG4gICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICBvZmYoZG9jdW1lbnQsICdkcm9wJywgdGhpcyk7XG4gICAgICBvZmYoZWwsICdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgfVxuXG4gICAgdGhpcy5fb2ZmTW92ZUV2ZW50cygpO1xuXG4gICAgdGhpcy5fb2ZmVXBFdmVudHMoKTtcblxuICAgIGlmIChTYWZhcmkpIHtcbiAgICAgIGNzcyhkb2N1bWVudC5ib2R5LCAndXNlci1zZWxlY3QnLCAnJyk7XG4gICAgfVxuXG4gICAgY3NzKGRyYWdFbCwgJ3RyYW5zZm9ybScsICcnKTtcblxuICAgIGlmIChldnQpIHtcbiAgICAgIGlmIChtb3ZlZCkge1xuICAgICAgICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgIW9wdGlvbnMuZHJvcEJ1YmJsZSAmJiBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIGdob3N0RWwgJiYgZ2hvc3RFbC5wYXJlbnROb2RlICYmIGdob3N0RWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChnaG9zdEVsKTtcblxuICAgICAgaWYgKHJvb3RFbCA9PT0gcGFyZW50RWwgfHwgcHV0U29ydGFibGUgJiYgcHV0U29ydGFibGUubGFzdFB1dE1vZGUgIT09ICdjbG9uZScpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGNsb25lKHMpXG4gICAgICAgIGNsb25lRWwgJiYgY2xvbmVFbC5wYXJlbnROb2RlICYmIGNsb25lRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZUVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRyYWdFbCkge1xuICAgICAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgICBvZmYoZHJhZ0VsLCAnZHJhZ2VuZCcsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2Rpc2FibGVEcmFnZ2FibGUoZHJhZ0VsKTtcblxuICAgICAgICBkcmFnRWwuc3R5bGVbJ3dpbGwtY2hhbmdlJ10gPSAnJzsgLy8gUmVtb3ZlIGNsYXNzZXNcbiAgICAgICAgLy8gZ2hvc3RDbGFzcyBpcyBhZGRlZCBpbiBkcmFnU3RhcnRlZFxuXG4gICAgICAgIGlmIChtb3ZlZCAmJiAhYXdhaXRpbmdEcmFnU3RhcnRlZCkge1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgcHV0U29ydGFibGUgPyBwdXRTb3J0YWJsZS5vcHRpb25zLmdob3N0Q2xhc3MgOiB0aGlzLm9wdGlvbnMuZ2hvc3RDbGFzcywgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCB0aGlzLm9wdGlvbnMuY2hvc2VuQ2xhc3MsIGZhbHNlKTsgLy8gRHJhZyBzdG9wIGV2ZW50XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgIG5hbWU6ICd1bmNob29zZScsXG4gICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgbmV3SW5kZXg6IG51bGwsXG4gICAgICAgICAgbmV3RHJhZ2dhYmxlSW5kZXg6IG51bGwsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyb290RWwgIT09IHBhcmVudEVsKSB7XG4gICAgICAgICAgaWYgKG5ld0luZGV4ID49IDApIHtcbiAgICAgICAgICAgIC8vIEFkZCBldmVudFxuICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICByb290RWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBuYW1lOiAnYWRkJyxcbiAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIGZyb21FbDogcm9vdEVsLFxuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgIH0pOyAvLyBSZW1vdmUgZXZlbnRcblxuXG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICBuYW1lOiAncmVtb3ZlJyxcbiAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgfSk7IC8vIGRyYWcgZnJvbSBvbmUgbGlzdCBhbmQgZHJvcCBpbnRvIGFub3RoZXJcblxuXG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHJvb3RFbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIG5hbWU6ICdzb3J0JyxcbiAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIGZyb21FbDogcm9vdEVsLFxuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICBuYW1lOiAnc29ydCcsXG4gICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLnNhdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobmV3SW5kZXggIT09IG9sZEluZGV4KSB7XG4gICAgICAgICAgICBpZiAobmV3SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAvLyBkcmFnICYgZHJvcCB3aXRoaW4gdGhlIHNhbWUgbGlzdFxuICAgICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3VwZGF0ZScsXG4gICAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc29ydCcsXG4gICAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChTb3J0YWJsZS5hY3RpdmUpIHtcbiAgICAgICAgICAvKiBqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgICAgICAgICBpZiAobmV3SW5kZXggPT0gbnVsbCB8fCBuZXdJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5ld0luZGV4ID0gb2xkSW5kZXg7XG4gICAgICAgICAgICBuZXdEcmFnZ2FibGVJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgbmFtZTogJ2VuZCcsXG4gICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgIH0pOyAvLyBTYXZlIHNvcnRpbmdcblxuXG4gICAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9udWxsaW5nKCk7XG4gIH0sXG4gIF9udWxsaW5nOiBmdW5jdGlvbiBfbnVsbGluZygpIHtcbiAgICBwbHVnaW5FdmVudCgnbnVsbGluZycsIHRoaXMpO1xuICAgIHJvb3RFbCA9IGRyYWdFbCA9IHBhcmVudEVsID0gZ2hvc3RFbCA9IG5leHRFbCA9IGNsb25lRWwgPSBsYXN0RG93bkVsID0gY2xvbmVIaWRkZW4gPSB0YXBFdnQgPSB0b3VjaEV2dCA9IG1vdmVkID0gbmV3SW5kZXggPSBuZXdEcmFnZ2FibGVJbmRleCA9IG9sZEluZGV4ID0gb2xkRHJhZ2dhYmxlSW5kZXggPSBsYXN0VGFyZ2V0ID0gbGFzdERpcmVjdGlvbiA9IHB1dFNvcnRhYmxlID0gYWN0aXZlR3JvdXAgPSBTb3J0YWJsZS5kcmFnZ2VkID0gU29ydGFibGUuZ2hvc3QgPSBTb3J0YWJsZS5jbG9uZSA9IFNvcnRhYmxlLmFjdGl2ZSA9IG51bGw7XG4gICAgc2F2ZWRJbnB1dENoZWNrZWQuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGVsLmNoZWNrZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHNhdmVkSW5wdXRDaGVja2VkLmxlbmd0aCA9IGxhc3REeCA9IGxhc3REeSA9IDA7XG4gIH0sXG4gIGhhbmRsZUV2ZW50OiBmdW5jdGlvbiBoYW5kbGVFdmVudChcbiAgLyoqRXZlbnQqL1xuICBldnQpIHtcbiAgICBzd2l0Y2ggKGV2dC50eXBlKSB7XG4gICAgICBjYXNlICdkcm9wJzpcbiAgICAgIGNhc2UgJ2RyYWdlbmQnOlxuICAgICAgICB0aGlzLl9vbkRyb3AoZXZ0KTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZHJhZ2VudGVyJzpcbiAgICAgIGNhc2UgJ2RyYWdvdmVyJzpcbiAgICAgICAgaWYgKGRyYWdFbCkge1xuICAgICAgICAgIHRoaXMuX29uRHJhZ092ZXIoZXZ0KTtcblxuICAgICAgICAgIF9nbG9iYWxEcmFnT3ZlcihldnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3NlbGVjdHN0YXJ0JzpcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBTZXJpYWxpemVzIHRoZSBpdGVtIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5nLlxyXG4gICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cclxuICAgKi9cbiAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICB2YXIgb3JkZXIgPSBbXSxcbiAgICAgICAgZWwsXG4gICAgICAgIGNoaWxkcmVuID0gdGhpcy5lbC5jaGlsZHJlbixcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIG4gPSBjaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgZWwgPSBjaGlsZHJlbltpXTtcblxuICAgICAgaWYgKGNsb3Nlc3QoZWwsIG9wdGlvbnMuZHJhZ2dhYmxlLCB0aGlzLmVsLCBmYWxzZSkpIHtcbiAgICAgICAgb3JkZXIucHVzaChlbC5nZXRBdHRyaWJ1dGUob3B0aW9ucy5kYXRhSWRBdHRyKSB8fCBfZ2VuZXJhdGVJZChlbCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcmRlcjtcbiAgfSxcblxuICAvKipcclxuICAgKiBTb3J0cyB0aGUgZWxlbWVudHMgYWNjb3JkaW5nIHRvIHRoZSBhcnJheS5cclxuICAgKiBAcGFyYW0gIHtTdHJpbmdbXX0gIG9yZGVyICBvcmRlciBvZiB0aGUgaXRlbXNcclxuICAgKi9cbiAgc29ydDogZnVuY3Rpb24gc29ydChvcmRlciwgdXNlQW5pbWF0aW9uKSB7XG4gICAgdmFyIGl0ZW1zID0ge30sXG4gICAgICAgIHJvb3RFbCA9IHRoaXMuZWw7XG4gICAgdGhpcy50b0FycmF5KCkuZm9yRWFjaChmdW5jdGlvbiAoaWQsIGkpIHtcbiAgICAgIHZhciBlbCA9IHJvb3RFbC5jaGlsZHJlbltpXTtcblxuICAgICAgaWYgKGNsb3Nlc3QoZWwsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUsIHJvb3RFbCwgZmFsc2UpKSB7XG4gICAgICAgIGl0ZW1zW2lkXSA9IGVsO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHVzZUFuaW1hdGlvbiAmJiB0aGlzLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgIG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICBpZiAoaXRlbXNbaWRdKSB7XG4gICAgICAgIHJvb3RFbC5yZW1vdmVDaGlsZChpdGVtc1tpZF0pO1xuICAgICAgICByb290RWwuYXBwZW5kQ2hpbGQoaXRlbXNbaWRdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1c2VBbmltYXRpb24gJiYgdGhpcy5hbmltYXRlQWxsKCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogU2F2ZSB0aGUgY3VycmVudCBzb3J0aW5nXHJcbiAgICovXG4gIHNhdmU6IGZ1bmN0aW9uIHNhdmUoKSB7XG4gICAgdmFyIHN0b3JlID0gdGhpcy5vcHRpb25zLnN0b3JlO1xuICAgIHN0b3JlICYmIHN0b3JlLnNldCAmJiBzdG9yZS5zZXQodGhpcyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LCBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3RvciBieSB0ZXN0aW5nIHRoZSBlbGVtZW50IGl0c2VsZiBhbmQgdHJhdmVyc2luZyB1cCB0aHJvdWdoIGl0cyBhbmNlc3RvcnMgaW4gdGhlIERPTSB0cmVlLlxyXG4gICAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gIGVsXHJcbiAgICogQHBhcmFtICAge1N0cmluZ30gICAgICAgW3NlbGVjdG9yXSAgZGVmYXVsdDogYG9wdGlvbnMuZHJhZ2dhYmxlYFxyXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudHxudWxsfVxyXG4gICAqL1xuICBjbG9zZXN0OiBmdW5jdGlvbiBjbG9zZXN0JDEoZWwsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGNsb3Nlc3QoZWwsIHNlbGVjdG9yIHx8IHRoaXMub3B0aW9ucy5kcmFnZ2FibGUsIHRoaXMuZWwsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTZXQvZ2V0IG9wdGlvblxyXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWVcclxuICAgKiBAcGFyYW0gICB7Kn0gICAgICBbdmFsdWVdXHJcbiAgICogQHJldHVybnMgeyp9XHJcbiAgICovXG4gIG9wdGlvbjogZnVuY3Rpb24gb3B0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnNbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtb2RpZmllZFZhbHVlID0gUGx1Z2luTWFuYWdlci5tb2RpZnlPcHRpb24odGhpcywgbmFtZSwgdmFsdWUpO1xuXG4gICAgICBpZiAodHlwZW9mIG1vZGlmaWVkVmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdGlvbnNbbmFtZV0gPSBtb2RpZmllZFZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9uc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICBfcHJlcGFyZUdyb3VwKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBEZXN0cm95XHJcbiAgICovXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgcGx1Z2luRXZlbnQoJ2Rlc3Ryb3knLCB0aGlzKTtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIGVsW2V4cGFuZG9dID0gbnVsbDtcbiAgICBvZmYoZWwsICdtb3VzZWRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgICBvZmYoZWwsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25UYXBTdGFydCk7XG4gICAgb2ZmKGVsLCAncG9pbnRlcmRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcblxuICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgb2ZmKGVsLCAnZHJhZ292ZXInLCB0aGlzKTtcbiAgICAgIG9mZihlbCwgJ2RyYWdlbnRlcicsIHRoaXMpO1xuICAgIH0gLy8gUmVtb3ZlIGRyYWdnYWJsZSBhdHRyaWJ1dGVzXG5cblxuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZWwucXVlcnlTZWxlY3RvckFsbCgnW2RyYWdnYWJsZV0nKSwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RyYWdnYWJsZScpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fb25Ecm9wKCk7XG5cbiAgICB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMoKTtcblxuICAgIHNvcnRhYmxlcy5zcGxpY2Uoc29ydGFibGVzLmluZGV4T2YodGhpcy5lbCksIDEpO1xuICAgIHRoaXMuZWwgPSBlbCA9IG51bGw7XG4gIH0sXG4gIF9oaWRlQ2xvbmU6IGZ1bmN0aW9uIF9oaWRlQ2xvbmUoKSB7XG4gICAgaWYgKCFjbG9uZUhpZGRlbikge1xuICAgICAgcGx1Z2luRXZlbnQoJ2hpZGVDbG9uZScsIHRoaXMpO1xuICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybjtcbiAgICAgIGNzcyhjbG9uZUVsLCAnZGlzcGxheScsICdub25lJyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUgJiYgY2xvbmVFbC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNsb25lRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZUVsKTtcbiAgICAgIH1cblxuICAgICAgY2xvbmVIaWRkZW4gPSB0cnVlO1xuICAgIH1cbiAgfSxcbiAgX3Nob3dDbG9uZTogZnVuY3Rpb24gX3Nob3dDbG9uZShwdXRTb3J0YWJsZSkge1xuICAgIGlmIChwdXRTb3J0YWJsZS5sYXN0UHV0TW9kZSAhPT0gJ2Nsb25lJykge1xuICAgICAgdGhpcy5faGlkZUNsb25lKCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2xvbmVIaWRkZW4pIHtcbiAgICAgIHBsdWdpbkV2ZW50KCdzaG93Q2xvbmUnLCB0aGlzKTtcbiAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm47IC8vIHNob3cgY2xvbmUgYXQgZHJhZ0VsIG9yIG9yaWdpbmFsIHBvc2l0aW9uXG5cbiAgICAgIGlmIChkcmFnRWwucGFyZW50Tm9kZSA9PSByb290RWwgJiYgIXRoaXMub3B0aW9ucy5ncm91cC5yZXZlcnRDbG9uZSkge1xuICAgICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGNsb25lRWwsIGRyYWdFbCk7XG4gICAgICB9IGVsc2UgaWYgKG5leHRFbCkge1xuICAgICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGNsb25lRWwsIG5leHRFbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290RWwuYXBwZW5kQ2hpbGQoY2xvbmVFbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3JvdXAucmV2ZXJ0Q2xvbmUpIHtcbiAgICAgICAgdGhpcy5hbmltYXRlKGRyYWdFbCwgY2xvbmVFbCk7XG4gICAgICB9XG5cbiAgICAgIGNzcyhjbG9uZUVsLCAnZGlzcGxheScsICcnKTtcbiAgICAgIGNsb25lSGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfZ2xvYmFsRHJhZ092ZXIoXG4vKipFdmVudCovXG5ldnQpIHtcbiAgaWYgKGV2dC5kYXRhVHJhbnNmZXIpIHtcbiAgICBldnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnbW92ZSc7XG4gIH1cblxuICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuZnVuY3Rpb24gX29uTW92ZShmcm9tRWwsIHRvRWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldEVsLCB0YXJnZXRSZWN0LCBvcmlnaW5hbEV2ZW50LCB3aWxsSW5zZXJ0QWZ0ZXIpIHtcbiAgdmFyIGV2dCxcbiAgICAgIHNvcnRhYmxlID0gZnJvbUVsW2V4cGFuZG9dLFxuICAgICAgb25Nb3ZlRm4gPSBzb3J0YWJsZS5vcHRpb25zLm9uTW92ZSxcbiAgICAgIHJldFZhbDsgLy8gU3VwcG9ydCBmb3IgbmV3IEN1c3RvbUV2ZW50IGZlYXR1cmVcblxuICBpZiAod2luZG93LkN1c3RvbUV2ZW50ICYmICFJRTExT3JMZXNzICYmICFFZGdlKSB7XG4gICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KCdtb3ZlJywge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldnQuaW5pdEV2ZW50KCdtb3ZlJywgdHJ1ZSwgdHJ1ZSk7XG4gIH1cblxuICBldnQudG8gPSB0b0VsO1xuICBldnQuZnJvbSA9IGZyb21FbDtcbiAgZXZ0LmRyYWdnZWQgPSBkcmFnRWw7XG4gIGV2dC5kcmFnZ2VkUmVjdCA9IGRyYWdSZWN0O1xuICBldnQucmVsYXRlZCA9IHRhcmdldEVsIHx8IHRvRWw7XG4gIGV2dC5yZWxhdGVkUmVjdCA9IHRhcmdldFJlY3QgfHwgZ2V0UmVjdCh0b0VsKTtcbiAgZXZ0LndpbGxJbnNlcnRBZnRlciA9IHdpbGxJbnNlcnRBZnRlcjtcbiAgZXZ0Lm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuICBmcm9tRWwuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gIGlmIChvbk1vdmVGbikge1xuICAgIHJldFZhbCA9IG9uTW92ZUZuLmNhbGwoc29ydGFibGUsIGV2dCwgb3JpZ2luYWxFdmVudCk7XG4gIH1cblxuICByZXR1cm4gcmV0VmFsO1xufVxuXG5mdW5jdGlvbiBfZGlzYWJsZURyYWdnYWJsZShlbCkge1xuICBlbC5kcmFnZ2FibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3Vuc2lsZW50KCkge1xuICBfc2lsZW50ID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF9naG9zdElzRmlyc3QoZXZ0LCB2ZXJ0aWNhbCwgc29ydGFibGUpIHtcbiAgdmFyIHJlY3QgPSBnZXRSZWN0KGdldENoaWxkKHNvcnRhYmxlLmVsLCAwLCBzb3J0YWJsZS5vcHRpb25zLCB0cnVlKSk7XG4gIHZhciBzcGFjZXIgPSAxMDtcbiAgcmV0dXJuIHZlcnRpY2FsID8gZXZ0LmNsaWVudFggPCByZWN0LmxlZnQgLSBzcGFjZXIgfHwgZXZ0LmNsaWVudFkgPCByZWN0LnRvcCAmJiBldnQuY2xpZW50WCA8IHJlY3QucmlnaHQgOiBldnQuY2xpZW50WSA8IHJlY3QudG9wIC0gc3BhY2VyIHx8IGV2dC5jbGllbnRZIDwgcmVjdC5ib3R0b20gJiYgZXZ0LmNsaWVudFggPCByZWN0LmxlZnQ7XG59XG5cbmZ1bmN0aW9uIF9naG9zdElzTGFzdChldnQsIHZlcnRpY2FsLCBzb3J0YWJsZSkge1xuICB2YXIgcmVjdCA9IGdldFJlY3QobGFzdENoaWxkKHNvcnRhYmxlLmVsLCBzb3J0YWJsZS5vcHRpb25zLmRyYWdnYWJsZSkpO1xuICB2YXIgc3BhY2VyID0gMTA7XG4gIHJldHVybiB2ZXJ0aWNhbCA/IGV2dC5jbGllbnRYID4gcmVjdC5yaWdodCArIHNwYWNlciB8fCBldnQuY2xpZW50WCA8PSByZWN0LnJpZ2h0ICYmIGV2dC5jbGllbnRZID4gcmVjdC5ib3R0b20gJiYgZXZ0LmNsaWVudFggPj0gcmVjdC5sZWZ0IDogZXZ0LmNsaWVudFggPiByZWN0LnJpZ2h0ICYmIGV2dC5jbGllbnRZID4gcmVjdC50b3AgfHwgZXZ0LmNsaWVudFggPD0gcmVjdC5yaWdodCAmJiBldnQuY2xpZW50WSA+IHJlY3QuYm90dG9tICsgc3BhY2VyO1xufVxuXG5mdW5jdGlvbiBfZ2V0U3dhcERpcmVjdGlvbihldnQsIHRhcmdldCwgdGFyZ2V0UmVjdCwgdmVydGljYWwsIHN3YXBUaHJlc2hvbGQsIGludmVydGVkU3dhcFRocmVzaG9sZCwgaW52ZXJ0U3dhcCwgaXNMYXN0VGFyZ2V0KSB7XG4gIHZhciBtb3VzZU9uQXhpcyA9IHZlcnRpY2FsID8gZXZ0LmNsaWVudFkgOiBldnQuY2xpZW50WCxcbiAgICAgIHRhcmdldExlbmd0aCA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC5oZWlnaHQgOiB0YXJnZXRSZWN0LndpZHRoLFxuICAgICAgdGFyZ2V0UzEgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QudG9wIDogdGFyZ2V0UmVjdC5sZWZ0LFxuICAgICAgdGFyZ2V0UzIgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QuYm90dG9tIDogdGFyZ2V0UmVjdC5yaWdodCxcbiAgICAgIGludmVydCA9IGZhbHNlO1xuXG4gIGlmICghaW52ZXJ0U3dhcCkge1xuICAgIC8vIE5ldmVyIGludmVydCBvciBjcmVhdGUgZHJhZ0VsIHNoYWRvdyB3aGVuIHRhcmdldCBtb3ZlbWVuZXQgY2F1c2VzIG1vdXNlIHRvIG1vdmUgcGFzdCB0aGUgZW5kIG9mIHJlZ3VsYXIgc3dhcFRocmVzaG9sZFxuICAgIGlmIChpc0xhc3RUYXJnZXQgJiYgdGFyZ2V0TW92ZURpc3RhbmNlIDwgdGFyZ2V0TGVuZ3RoICogc3dhcFRocmVzaG9sZCkge1xuICAgICAgLy8gbXVsdGlwbGllZCBvbmx5IGJ5IHN3YXBUaHJlc2hvbGQgYmVjYXVzZSBtb3VzZSB3aWxsIGFscmVhZHkgYmUgaW5zaWRlIHRhcmdldCBieSAoMSAtIHRocmVzaG9sZCkgKiB0YXJnZXRMZW5ndGggLyAyXG4gICAgICAvLyBjaGVjayBpZiBwYXN0IGZpcnN0IGludmVydCB0aHJlc2hvbGQgb24gc2lkZSBvcHBvc2l0ZSBvZiBsYXN0RGlyZWN0aW9uXG4gICAgICBpZiAoIXBhc3RGaXJzdEludmVydFRocmVzaCAmJiAobGFzdERpcmVjdGlvbiA9PT0gMSA/IG1vdXNlT25BeGlzID4gdGFyZ2V0UzEgKyB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyIDogbW91c2VPbkF4aXMgPCB0YXJnZXRTMiAtIHRhcmdldExlbmd0aCAqIGludmVydGVkU3dhcFRocmVzaG9sZCAvIDIpKSB7XG4gICAgICAgIC8vIHBhc3QgZmlyc3QgaW52ZXJ0IHRocmVzaG9sZCwgZG8gbm90IHJlc3RyaWN0IGludmVydGVkIHRocmVzaG9sZCB0byBkcmFnRWwgc2hhZG93XG4gICAgICAgIHBhc3RGaXJzdEludmVydFRocmVzaCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFzdEZpcnN0SW52ZXJ0VGhyZXNoKSB7XG4gICAgICAgIC8vIGRyYWdFbCBzaGFkb3cgKHRhcmdldCBtb3ZlIGRpc3RhbmNlIHNoYWRvdylcbiAgICAgICAgaWYgKGxhc3REaXJlY3Rpb24gPT09IDEgPyBtb3VzZU9uQXhpcyA8IHRhcmdldFMxICsgdGFyZ2V0TW92ZURpc3RhbmNlIC8vIG92ZXIgZHJhZ0VsIHNoYWRvd1xuICAgICAgICA6IG1vdXNlT25BeGlzID4gdGFyZ2V0UzIgLSB0YXJnZXRNb3ZlRGlzdGFuY2UpIHtcbiAgICAgICAgICByZXR1cm4gLWxhc3REaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmVydCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlZ3VsYXJcbiAgICAgIGlmIChtb3VzZU9uQXhpcyA+IHRhcmdldFMxICsgdGFyZ2V0TGVuZ3RoICogKDEgLSBzd2FwVGhyZXNob2xkKSAvIDIgJiYgbW91c2VPbkF4aXMgPCB0YXJnZXRTMiAtIHRhcmdldExlbmd0aCAqICgxIC0gc3dhcFRocmVzaG9sZCkgLyAyKSB7XG4gICAgICAgIHJldHVybiBfZ2V0SW5zZXJ0RGlyZWN0aW9uKHRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW52ZXJ0ID0gaW52ZXJ0IHx8IGludmVydFN3YXA7XG5cbiAgaWYgKGludmVydCkge1xuICAgIC8vIEludmVydCBvZiByZWd1bGFyXG4gICAgaWYgKG1vdXNlT25BeGlzIDwgdGFyZ2V0UzEgKyB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyIHx8IG1vdXNlT25BeGlzID4gdGFyZ2V0UzIgLSB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyKSB7XG4gICAgICByZXR1cm4gbW91c2VPbkF4aXMgPiB0YXJnZXRTMSArIHRhcmdldExlbmd0aCAvIDIgPyAxIDogLTE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG4vKipcclxuICogR2V0cyB0aGUgZGlyZWN0aW9uIGRyYWdFbCBtdXN0IGJlIHN3YXBwZWQgcmVsYXRpdmUgdG8gdGFyZ2V0IGluIG9yZGVyIHRvIG1ha2UgaXRcclxuICogc2VlbSB0aGF0IGRyYWdFbCBoYXMgYmVlbiBcImluc2VydGVkXCIgaW50byB0aGF0IGVsZW1lbnQncyBwb3NpdGlvblxyXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gdGFyZ2V0ICAgICAgIFRoZSB0YXJnZXQgd2hvc2UgcG9zaXRpb24gZHJhZ0VsIGlzIGJlaW5nIGluc2VydGVkIGF0XHJcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgRGlyZWN0aW9uIGRyYWdFbCBtdXN0IGJlIHN3YXBwZWRcclxuICovXG5cblxuZnVuY3Rpb24gX2dldEluc2VydERpcmVjdGlvbih0YXJnZXQpIHtcbiAgaWYgKGluZGV4KGRyYWdFbCkgPCBpbmRleCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59XG4vKipcclxuICogR2VuZXJhdGUgaWRcclxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBlbFxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cblxuXG5mdW5jdGlvbiBfZ2VuZXJhdGVJZChlbCkge1xuICB2YXIgc3RyID0gZWwudGFnTmFtZSArIGVsLmNsYXNzTmFtZSArIGVsLnNyYyArIGVsLmhyZWYgKyBlbC50ZXh0Q29udGVudCxcbiAgICAgIGkgPSBzdHIubGVuZ3RoLFxuICAgICAgc3VtID0gMDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgc3VtICs9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG5cbiAgcmV0dXJuIHN1bS50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIF9zYXZlSW5wdXRDaGVja2VkU3RhdGUocm9vdCkge1xuICBzYXZlZElucHV0Q2hlY2tlZC5sZW5ndGggPSAwO1xuICB2YXIgaW5wdXRzID0gcm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5wdXQnKTtcbiAgdmFyIGlkeCA9IGlucHV0cy5sZW5ndGg7XG5cbiAgd2hpbGUgKGlkeC0tKSB7XG4gICAgdmFyIGVsID0gaW5wdXRzW2lkeF07XG4gICAgZWwuY2hlY2tlZCAmJiBzYXZlZElucHV0Q2hlY2tlZC5wdXNoKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfbmV4dFRpY2soZm4pIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoZm4sIDApO1xufVxuXG5mdW5jdGlvbiBfY2FuY2VsTmV4dFRpY2soaWQpIHtcbiAgcmV0dXJuIGNsZWFyVGltZW91dChpZCk7XG59IC8vIEZpeGVkICM5NzM6XG5cblxuaWYgKGRvY3VtZW50RXhpc3RzKSB7XG4gIG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgZnVuY3Rpb24gKGV2dCkge1xuICAgIGlmICgoU29ydGFibGUuYWN0aXZlIHx8IGF3YWl0aW5nRHJhZ1N0YXJ0ZWQpICYmIGV2dC5jYW5jZWxhYmxlKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0pO1xufSAvLyBFeHBvcnQgdXRpbHNcblxuXG5Tb3J0YWJsZS51dGlscyA9IHtcbiAgb246IG9uLFxuICBvZmY6IG9mZixcbiAgY3NzOiBjc3MsXG4gIGZpbmQ6IGZpbmQsXG4gIGlzOiBmdW5jdGlvbiBpcyhlbCwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gISFjbG9zZXN0KGVsLCBzZWxlY3RvciwgZWwsIGZhbHNlKTtcbiAgfSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRocm90dGxlOiB0aHJvdHRsZSxcbiAgY2xvc2VzdDogY2xvc2VzdCxcbiAgdG9nZ2xlQ2xhc3M6IHRvZ2dsZUNsYXNzLFxuICBjbG9uZTogY2xvbmUsXG4gIGluZGV4OiBpbmRleCxcbiAgbmV4dFRpY2s6IF9uZXh0VGljayxcbiAgY2FuY2VsTmV4dFRpY2s6IF9jYW5jZWxOZXh0VGljayxcbiAgZGV0ZWN0RGlyZWN0aW9uOiBfZGV0ZWN0RGlyZWN0aW9uLFxuICBnZXRDaGlsZDogZ2V0Q2hpbGRcbn07XG4vKipcclxuICogR2V0IHRoZSBTb3J0YWJsZSBpbnN0YW5jZSBvZiBhbiBlbGVtZW50XHJcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50XHJcbiAqIEByZXR1cm4ge1NvcnRhYmxlfHVuZGVmaW5lZH0gICAgICAgICBUaGUgaW5zdGFuY2Ugb2YgU29ydGFibGVcclxuICovXG5cblNvcnRhYmxlLmdldCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50W2V4cGFuZG9dO1xufTtcbi8qKlxyXG4gKiBNb3VudCBhIHBsdWdpbiB0byBTb3J0YWJsZVxyXG4gKiBAcGFyYW0gIHsuLi5Tb3J0YWJsZVBsdWdpbnxTb3J0YWJsZVBsdWdpbltdfSBwbHVnaW5zICAgICAgIFBsdWdpbnMgYmVpbmcgbW91bnRlZFxyXG4gKi9cblxuXG5Tb3J0YWJsZS5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBsdWdpbnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcGx1Z2luc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChwbHVnaW5zWzBdLmNvbnN0cnVjdG9yID09PSBBcnJheSkgcGx1Z2lucyA9IHBsdWdpbnNbMF07XG4gIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgaWYgKCFwbHVnaW4ucHJvdG90eXBlIHx8ICFwbHVnaW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBcIlNvcnRhYmxlOiBNb3VudGVkIHBsdWdpbiBtdXN0IGJlIGEgY29uc3RydWN0b3IgZnVuY3Rpb24sIG5vdCBcIi5jb25jYXQoe30udG9TdHJpbmcuY2FsbChwbHVnaW4pKTtcbiAgICB9XG5cbiAgICBpZiAocGx1Z2luLnV0aWxzKSBTb3J0YWJsZS51dGlscyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBTb3J0YWJsZS51dGlscyksIHBsdWdpbi51dGlscyk7XG4gICAgUGx1Z2luTWFuYWdlci5tb3VudChwbHVnaW4pO1xuICB9KTtcbn07XG4vKipcclxuICogQ3JlYXRlIHNvcnRhYmxlIGluc3RhbmNlXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICBlbFxyXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICBbb3B0aW9uc11cclxuICovXG5cblxuU29ydGFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgU29ydGFibGUoZWwsIG9wdGlvbnMpO1xufTsgLy8gRXhwb3J0XG5cblxuU29ydGFibGUudmVyc2lvbiA9IHZlcnNpb247XG5cbnZhciBhdXRvU2Nyb2xscyA9IFtdLFxuICAgIHNjcm9sbEVsLFxuICAgIHNjcm9sbFJvb3RFbCxcbiAgICBzY3JvbGxpbmcgPSBmYWxzZSxcbiAgICBsYXN0QXV0b1Njcm9sbFgsXG4gICAgbGFzdEF1dG9TY3JvbGxZLFxuICAgIHRvdWNoRXZ0JDEsXG4gICAgcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWw7XG5cbmZ1bmN0aW9uIEF1dG9TY3JvbGxQbHVnaW4oKSB7XG4gIGZ1bmN0aW9uIEF1dG9TY3JvbGwoKSB7XG4gICAgdGhpcy5kZWZhdWx0cyA9IHtcbiAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgIGZvcmNlQXV0b1Njcm9sbEZhbGxiYWNrOiBmYWxzZSxcbiAgICAgIHNjcm9sbFNlbnNpdGl2aXR5OiAzMCxcbiAgICAgIHNjcm9sbFNwZWVkOiAxMCxcbiAgICAgIGJ1YmJsZVNjcm9sbDogdHJ1ZVxuICAgIH07IC8vIEJpbmQgYWxsIHByaXZhdGUgbWV0aG9kc1xuXG4gICAgZm9yICh2YXIgZm4gaW4gdGhpcykge1xuICAgICAgaWYgKGZuLmNoYXJBdCgwKSA9PT0gJ18nICYmIHR5cGVvZiB0aGlzW2ZuXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzW2ZuXSA9IHRoaXNbZm5dLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgQXV0b1Njcm9sbC5wcm90b3R5cGUgPSB7XG4gICAgZHJhZ1N0YXJ0ZWQ6IGZ1bmN0aW9uIGRyYWdTdGFydGVkKF9yZWYpIHtcbiAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gX3JlZi5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICBpZiAodGhpcy5zb3J0YWJsZS5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdkcmFnb3ZlcicsIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgICAgICAgIG9uKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsRXZlbnQudG91Y2hlcykge1xuICAgICAgICAgIG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdPdmVyQ29tcGxldGVkOiBmdW5jdGlvbiBkcmFnT3ZlckNvbXBsZXRlZChfcmVmMikge1xuICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBfcmVmMi5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICAvLyBGb3Igd2hlbiBidWJibGluZyBpcyBjYW5jZWxlZCBhbmQgdXNpbmcgZmFsbGJhY2sgKGZhbGxiYWNrICd0b3VjaG1vdmUnIGFsd2F5cyByZWFjaGVkKVxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZHJhZ092ZXJCdWJibGUgJiYgIW9yaWdpbmFsRXZlbnQucm9vdEVsKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwob3JpZ2luYWxFdmVudCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcm9wOiBmdW5jdGlvbiBkcm9wKCkge1xuICAgICAgaWYgKHRoaXMuc29ydGFibGUubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ2RyYWdvdmVyJywgdGhpcy5faGFuZGxlQXV0b1Njcm9sbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmYoZG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICB9XG5cbiAgICAgIGNsZWFyUG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwoKTtcbiAgICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICAgIGNhbmNlbFRocm90dGxlKCk7XG4gICAgfSxcbiAgICBudWxsaW5nOiBmdW5jdGlvbiBudWxsaW5nKCkge1xuICAgICAgdG91Y2hFdnQkMSA9IHNjcm9sbFJvb3RFbCA9IHNjcm9sbEVsID0gc2Nyb2xsaW5nID0gcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgPSBsYXN0QXV0b1Njcm9sbFggPSBsYXN0QXV0b1Njcm9sbFkgPSBudWxsO1xuICAgICAgYXV0b1Njcm9sbHMubGVuZ3RoID0gMDtcbiAgICB9LFxuICAgIF9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGw6IGZ1bmN0aW9uIF9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwoZXZ0KSB7XG4gICAgICB0aGlzLl9oYW5kbGVBdXRvU2Nyb2xsKGV2dCwgdHJ1ZSk7XG4gICAgfSxcbiAgICBfaGFuZGxlQXV0b1Njcm9sbDogZnVuY3Rpb24gX2hhbmRsZUF1dG9TY3JvbGwoZXZ0LCBmYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHggPSAoZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCkuY2xpZW50WCxcbiAgICAgICAgICB5ID0gKGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpLmNsaWVudFksXG4gICAgICAgICAgZWxlbSA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICB0b3VjaEV2dCQxID0gZXZ0OyAvLyBJRSBkb2VzIG5vdCBzZWVtIHRvIGhhdmUgbmF0aXZlIGF1dG9zY3JvbGwsXG4gICAgICAvLyBFZGdlJ3MgYXV0b3Njcm9sbCBzZWVtcyB0b28gY29uZGl0aW9uYWwsXG4gICAgICAvLyBNQUNPUyBTYWZhcmkgZG9lcyBub3QgaGF2ZSBhdXRvc2Nyb2xsLFxuICAgICAgLy8gRmlyZWZveCBhbmQgQ2hyb21lIGFyZSBnb29kXG5cbiAgICAgIGlmIChmYWxsYmFjayB8fCB0aGlzLm9wdGlvbnMuZm9yY2VBdXRvU2Nyb2xsRmFsbGJhY2sgfHwgRWRnZSB8fCBJRTExT3JMZXNzIHx8IFNhZmFyaSkge1xuICAgICAgICBhdXRvU2Nyb2xsKGV2dCwgdGhpcy5vcHRpb25zLCBlbGVtLCBmYWxsYmFjayk7IC8vIExpc3RlbmVyIGZvciBwb2ludGVyIGVsZW1lbnQgY2hhbmdlXG5cbiAgICAgICAgdmFyIG9nRWxlbVNjcm9sbGVyID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWxlbSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHNjcm9sbGluZyAmJiAoIXBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsIHx8IHggIT09IGxhc3RBdXRvU2Nyb2xsWCB8fCB5ICE9PSBsYXN0QXV0b1Njcm9sbFkpKSB7XG4gICAgICAgICAgcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgJiYgY2xlYXJQb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCgpOyAvLyBEZXRlY3QgZm9yIHBvaW50ZXIgZWxlbSBjaGFuZ2UsIGVtdWxhdGluZyBuYXRpdmUgRG5EIGJlaGF2aW91clxuXG4gICAgICAgICAgcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV3RWxlbSA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSksIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAobmV3RWxlbSAhPT0gb2dFbGVtU2Nyb2xsZXIpIHtcbiAgICAgICAgICAgICAgb2dFbGVtU2Nyb2xsZXIgPSBuZXdFbGVtO1xuICAgICAgICAgICAgICBjbGVhckF1dG9TY3JvbGxzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF1dG9TY3JvbGwoZXZ0LCBfdGhpcy5vcHRpb25zLCBuZXdFbGVtLCBmYWxsYmFjayk7XG4gICAgICAgICAgfSwgMTApO1xuICAgICAgICAgIGxhc3RBdXRvU2Nyb2xsWCA9IHg7XG4gICAgICAgICAgbGFzdEF1dG9TY3JvbGxZID0geTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgRG5EIGlzIGVuYWJsZWQgKGFuZCBicm93c2VyIGhhcyBnb29kIGF1dG9zY3JvbGxpbmcpLCBmaXJzdCBhdXRvc2Nyb2xsIHdpbGwgYWxyZWFkeSBzY3JvbGwsIHNvIGdldCBwYXJlbnQgYXV0b3Njcm9sbCBvZiBmaXJzdCBhdXRvc2Nyb2xsXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmJ1YmJsZVNjcm9sbCB8fCBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbGVtLCB0cnVlKSA9PT0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpKSB7XG4gICAgICAgICAgY2xlYXJBdXRvU2Nyb2xscygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF1dG9TY3JvbGwoZXZ0LCB0aGlzLm9wdGlvbnMsIGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsZW0sIGZhbHNlKSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzKEF1dG9TY3JvbGwsIHtcbiAgICBwbHVnaW5OYW1lOiAnc2Nyb2xsJyxcbiAgICBpbml0aWFsaXplQnlEZWZhdWx0OiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjbGVhckF1dG9TY3JvbGxzKCkge1xuICBhdXRvU2Nyb2xscy5mb3JFYWNoKGZ1bmN0aW9uIChhdXRvU2Nyb2xsKSB7XG4gICAgY2xlYXJJbnRlcnZhbChhdXRvU2Nyb2xsLnBpZCk7XG4gIH0pO1xuICBhdXRvU2Nyb2xscyA9IFtdO1xufVxuXG5mdW5jdGlvbiBjbGVhclBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKCkge1xuICBjbGVhckludGVydmFsKHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKTtcbn1cblxudmFyIGF1dG9TY3JvbGwgPSB0aHJvdHRsZShmdW5jdGlvbiAoZXZ0LCBvcHRpb25zLCByb290RWwsIGlzRmFsbGJhY2spIHtcbiAgLy8gQnVnOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01MDU1MjFcbiAgaWYgKCFvcHRpb25zLnNjcm9sbCkgcmV0dXJuO1xuICB2YXIgeCA9IChldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0KS5jbGllbnRYLFxuICAgICAgeSA9IChldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0KS5jbGllbnRZLFxuICAgICAgc2VucyA9IG9wdGlvbnMuc2Nyb2xsU2Vuc2l0aXZpdHksXG4gICAgICBzcGVlZCA9IG9wdGlvbnMuc2Nyb2xsU3BlZWQsXG4gICAgICB3aW5TY3JvbGxlciA9IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgdmFyIHNjcm9sbFRoaXNJbnN0YW5jZSA9IGZhbHNlLFxuICAgICAgc2Nyb2xsQ3VzdG9tRm47IC8vIE5ldyBzY3JvbGwgcm9vdCwgc2V0IHNjcm9sbEVsXG5cbiAgaWYgKHNjcm9sbFJvb3RFbCAhPT0gcm9vdEVsKSB7XG4gICAgc2Nyb2xsUm9vdEVsID0gcm9vdEVsO1xuICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICBzY3JvbGxFbCA9IG9wdGlvbnMuc2Nyb2xsO1xuICAgIHNjcm9sbEN1c3RvbUZuID0gb3B0aW9ucy5zY3JvbGxGbjtcblxuICAgIGlmIChzY3JvbGxFbCA9PT0gdHJ1ZSkge1xuICAgICAgc2Nyb2xsRWwgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChyb290RWwsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsYXllcnNPdXQgPSAwO1xuICB2YXIgY3VycmVudFBhcmVudCA9IHNjcm9sbEVsO1xuXG4gIGRvIHtcbiAgICB2YXIgZWwgPSBjdXJyZW50UGFyZW50LFxuICAgICAgICByZWN0ID0gZ2V0UmVjdChlbCksXG4gICAgICAgIHRvcCA9IHJlY3QudG9wLFxuICAgICAgICBib3R0b20gPSByZWN0LmJvdHRvbSxcbiAgICAgICAgbGVmdCA9IHJlY3QubGVmdCxcbiAgICAgICAgcmlnaHQgPSByZWN0LnJpZ2h0LFxuICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0LFxuICAgICAgICBjYW5TY3JvbGxYID0gdm9pZCAwLFxuICAgICAgICBjYW5TY3JvbGxZID0gdm9pZCAwLFxuICAgICAgICBzY3JvbGxXaWR0aCA9IGVsLnNjcm9sbFdpZHRoLFxuICAgICAgICBzY3JvbGxIZWlnaHQgPSBlbC5zY3JvbGxIZWlnaHQsXG4gICAgICAgIGVsQ1NTID0gY3NzKGVsKSxcbiAgICAgICAgc2Nyb2xsUG9zWCA9IGVsLnNjcm9sbExlZnQsXG4gICAgICAgIHNjcm9sbFBvc1kgPSBlbC5zY3JvbGxUb3A7XG5cbiAgICBpZiAoZWwgPT09IHdpblNjcm9sbGVyKSB7XG4gICAgICBjYW5TY3JvbGxYID0gd2lkdGggPCBzY3JvbGxXaWR0aCAmJiAoZWxDU1Mub3ZlcmZsb3dYID09PSAnYXV0bycgfHwgZWxDU1Mub3ZlcmZsb3dYID09PSAnc2Nyb2xsJyB8fCBlbENTUy5vdmVyZmxvd1ggPT09ICd2aXNpYmxlJyk7XG4gICAgICBjYW5TY3JvbGxZID0gaGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0ICYmIChlbENTUy5vdmVyZmxvd1kgPT09ICdhdXRvJyB8fCBlbENTUy5vdmVyZmxvd1kgPT09ICdzY3JvbGwnIHx8IGVsQ1NTLm92ZXJmbG93WSA9PT0gJ3Zpc2libGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FuU2Nyb2xsWCA9IHdpZHRoIDwgc2Nyb2xsV2lkdGggJiYgKGVsQ1NTLm92ZXJmbG93WCA9PT0gJ2F1dG8nIHx8IGVsQ1NTLm92ZXJmbG93WCA9PT0gJ3Njcm9sbCcpO1xuICAgICAgY2FuU2Nyb2xsWSA9IGhlaWdodCA8IHNjcm9sbEhlaWdodCAmJiAoZWxDU1Mub3ZlcmZsb3dZID09PSAnYXV0bycgfHwgZWxDU1Mub3ZlcmZsb3dZID09PSAnc2Nyb2xsJyk7XG4gICAgfVxuXG4gICAgdmFyIHZ4ID0gY2FuU2Nyb2xsWCAmJiAoTWF0aC5hYnMocmlnaHQgLSB4KSA8PSBzZW5zICYmIHNjcm9sbFBvc1ggKyB3aWR0aCA8IHNjcm9sbFdpZHRoKSAtIChNYXRoLmFicyhsZWZ0IC0geCkgPD0gc2VucyAmJiAhIXNjcm9sbFBvc1gpO1xuICAgIHZhciB2eSA9IGNhblNjcm9sbFkgJiYgKE1hdGguYWJzKGJvdHRvbSAtIHkpIDw9IHNlbnMgJiYgc2Nyb2xsUG9zWSArIGhlaWdodCA8IHNjcm9sbEhlaWdodCkgLSAoTWF0aC5hYnModG9wIC0geSkgPD0gc2VucyAmJiAhIXNjcm9sbFBvc1kpO1xuXG4gICAgaWYgKCFhdXRvU2Nyb2xsc1tsYXllcnNPdXRdKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBsYXllcnNPdXQ7IGkrKykge1xuICAgICAgICBpZiAoIWF1dG9TY3JvbGxzW2ldKSB7XG4gICAgICAgICAgYXV0b1Njcm9sbHNbaV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnZ4ICE9IHZ4IHx8IGF1dG9TY3JvbGxzW2xheWVyc091dF0udnkgIT0gdnkgfHwgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5lbCAhPT0gZWwpIHtcbiAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0uZWwgPSBlbDtcbiAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0udnggPSB2eDtcbiAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0udnkgPSB2eTtcbiAgICAgIGNsZWFySW50ZXJ2YWwoYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5waWQpO1xuXG4gICAgICBpZiAodnggIT0gMCB8fCB2eSAhPSAwKSB7XG4gICAgICAgIHNjcm9sbFRoaXNJbnN0YW5jZSA9IHRydWU7XG4gICAgICAgIC8qIGpzaGludCBsb29wZnVuYzp0cnVlICovXG5cbiAgICAgICAgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5waWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gZW11bGF0ZSBkcmFnIG92ZXIgZHVyaW5nIGF1dG9zY3JvbGwgKGZhbGxiYWNrKSwgZW11bGF0aW5nIG5hdGl2ZSBEbkQgYmVoYXZpb3VyXG4gICAgICAgICAgaWYgKGlzRmFsbGJhY2sgJiYgdGhpcy5sYXllciA9PT0gMCkge1xuICAgICAgICAgICAgU29ydGFibGUuYWN0aXZlLl9vblRvdWNoTW92ZSh0b3VjaEV2dCQxKTsgLy8gVG8gbW92ZSBnaG9zdCBpZiBpdCBpcyBwb3NpdGlvbmVkIGFic29sdXRlbHlcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzY3JvbGxPZmZzZXRZID0gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnkgPyBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS52eSAqIHNwZWVkIDogMDtcbiAgICAgICAgICB2YXIgc2Nyb2xsT2Zmc2V0WCA9IGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLnZ4ID8gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnggKiBzcGVlZCA6IDA7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHNjcm9sbEN1c3RvbUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsQ3VzdG9tRm4uY2FsbChTb3J0YWJsZS5kcmFnZ2VkLnBhcmVudE5vZGVbZXhwYW5kb10sIHNjcm9sbE9mZnNldFgsIHNjcm9sbE9mZnNldFksIGV2dCwgdG91Y2hFdnQkMSwgYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0uZWwpICE9PSAnY29udGludWUnKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY3JvbGxCeShhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS5lbCwgc2Nyb2xsT2Zmc2V0WCwgc2Nyb2xsT2Zmc2V0WSk7XG4gICAgICAgIH0uYmluZCh7XG4gICAgICAgICAgbGF5ZXI6IGxheWVyc091dFxuICAgICAgICB9KSwgMjQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxheWVyc091dCsrO1xuICB9IHdoaWxlIChvcHRpb25zLmJ1YmJsZVNjcm9sbCAmJiBjdXJyZW50UGFyZW50ICE9PSB3aW5TY3JvbGxlciAmJiAoY3VycmVudFBhcmVudCA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGN1cnJlbnRQYXJlbnQsIGZhbHNlKSkpO1xuXG4gIHNjcm9sbGluZyA9IHNjcm9sbFRoaXNJbnN0YW5jZTsgLy8gaW4gY2FzZSBhbm90aGVyIGZ1bmN0aW9uIGNhdGNoZXMgc2Nyb2xsaW5nIGFzIGZhbHNlIGluIGJldHdlZW4gd2hlbiBpdCBpcyBub3Rcbn0sIDMwKTtcblxudmFyIGRyb3AgPSBmdW5jdGlvbiBkcm9wKF9yZWYpIHtcbiAgdmFyIG9yaWdpbmFsRXZlbnQgPSBfcmVmLm9yaWdpbmFsRXZlbnQsXG4gICAgICBwdXRTb3J0YWJsZSA9IF9yZWYucHV0U29ydGFibGUsXG4gICAgICBkcmFnRWwgPSBfcmVmLmRyYWdFbCxcbiAgICAgIGFjdGl2ZVNvcnRhYmxlID0gX3JlZi5hY3RpdmVTb3J0YWJsZSxcbiAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCA9IF9yZWYuZGlzcGF0Y2hTb3J0YWJsZUV2ZW50LFxuICAgICAgaGlkZUdob3N0Rm9yVGFyZ2V0ID0gX3JlZi5oaWRlR2hvc3RGb3JUYXJnZXQsXG4gICAgICB1bmhpZGVHaG9zdEZvclRhcmdldCA9IF9yZWYudW5oaWRlR2hvc3RGb3JUYXJnZXQ7XG4gIGlmICghb3JpZ2luYWxFdmVudCkgcmV0dXJuO1xuICB2YXIgdG9Tb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IGFjdGl2ZVNvcnRhYmxlO1xuICBoaWRlR2hvc3RGb3JUYXJnZXQoKTtcbiAgdmFyIHRvdWNoID0gb3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBvcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA/IG9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBvcmlnaW5hbEV2ZW50O1xuICB2YXIgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKTtcbiAgdW5oaWRlR2hvc3RGb3JUYXJnZXQoKTtcblxuICBpZiAodG9Tb3J0YWJsZSAmJiAhdG9Tb3J0YWJsZS5lbC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50KCdzcGlsbCcpO1xuICAgIHRoaXMub25TcGlsbCh7XG4gICAgICBkcmFnRWw6IGRyYWdFbCxcbiAgICAgIHB1dFNvcnRhYmxlOiBwdXRTb3J0YWJsZVxuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBSZXZlcnQoKSB7fVxuXG5SZXZlcnQucHJvdG90eXBlID0ge1xuICBzdGFydEluZGV4OiBudWxsLFxuICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIGRyYWdTdGFydChfcmVmMikge1xuICAgIHZhciBvbGREcmFnZ2FibGVJbmRleCA9IF9yZWYyLm9sZERyYWdnYWJsZUluZGV4O1xuICAgIHRoaXMuc3RhcnRJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4O1xuICB9LFxuICBvblNwaWxsOiBmdW5jdGlvbiBvblNwaWxsKF9yZWYzKSB7XG4gICAgdmFyIGRyYWdFbCA9IF9yZWYzLmRyYWdFbCxcbiAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmMy5wdXRTb3J0YWJsZTtcbiAgICB0aGlzLnNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuXG4gICAgaWYgKHB1dFNvcnRhYmxlKSB7XG4gICAgICBwdXRTb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFNpYmxpbmcgPSBnZXRDaGlsZCh0aGlzLnNvcnRhYmxlLmVsLCB0aGlzLnN0YXJ0SW5kZXgsIHRoaXMub3B0aW9ucyk7XG5cbiAgICBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgIHRoaXMuc29ydGFibGUuZWwuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgbmV4dFNpYmxpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNvcnRhYmxlLmVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG4gICAgfVxuXG4gICAgdGhpcy5zb3J0YWJsZS5hbmltYXRlQWxsKCk7XG5cbiAgICBpZiAocHV0U29ydGFibGUpIHtcbiAgICAgIHB1dFNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICB9XG4gIH0sXG4gIGRyb3A6IGRyb3Bcbn07XG5cbl9leHRlbmRzKFJldmVydCwge1xuICBwbHVnaW5OYW1lOiAncmV2ZXJ0T25TcGlsbCdcbn0pO1xuXG5mdW5jdGlvbiBSZW1vdmUoKSB7fVxuXG5SZW1vdmUucHJvdG90eXBlID0ge1xuICBvblNwaWxsOiBmdW5jdGlvbiBvblNwaWxsKF9yZWY0KSB7XG4gICAgdmFyIGRyYWdFbCA9IF9yZWY0LmRyYWdFbCxcbiAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmNC5wdXRTb3J0YWJsZTtcbiAgICB2YXIgcGFyZW50U29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCB0aGlzLnNvcnRhYmxlO1xuICAgIHBhcmVudFNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgIGRyYWdFbC5wYXJlbnROb2RlICYmIGRyYWdFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRyYWdFbCk7XG4gICAgcGFyZW50U29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICB9LFxuICBkcm9wOiBkcm9wXG59O1xuXG5fZXh0ZW5kcyhSZW1vdmUsIHtcbiAgcGx1Z2luTmFtZTogJ3JlbW92ZU9uU3BpbGwnXG59KTtcblxudmFyIGxhc3RTd2FwRWw7XG5cbmZ1bmN0aW9uIFN3YXBQbHVnaW4oKSB7XG4gIGZ1bmN0aW9uIFN3YXAoKSB7XG4gICAgdGhpcy5kZWZhdWx0cyA9IHtcbiAgICAgIHN3YXBDbGFzczogJ3NvcnRhYmxlLXN3YXAtaGlnaGxpZ2h0J1xuICAgIH07XG4gIH1cblxuICBTd2FwLnByb3RvdHlwZSA9IHtcbiAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIGRyYWdTdGFydChfcmVmKSB7XG4gICAgICB2YXIgZHJhZ0VsID0gX3JlZi5kcmFnRWw7XG4gICAgICBsYXN0U3dhcEVsID0gZHJhZ0VsO1xuICAgIH0sXG4gICAgZHJhZ092ZXJWYWxpZDogZnVuY3Rpb24gZHJhZ092ZXJWYWxpZChfcmVmMikge1xuICAgICAgdmFyIGNvbXBsZXRlZCA9IF9yZWYyLmNvbXBsZXRlZCxcbiAgICAgICAgICB0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICAgICAgb25Nb3ZlID0gX3JlZjIub25Nb3ZlLFxuICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlID0gX3JlZjIuYWN0aXZlU29ydGFibGUsXG4gICAgICAgICAgY2hhbmdlZCA9IF9yZWYyLmNoYW5nZWQsXG4gICAgICAgICAgY2FuY2VsID0gX3JlZjIuY2FuY2VsO1xuICAgICAgaWYgKCFhY3RpdmVTb3J0YWJsZS5vcHRpb25zLnN3YXApIHJldHVybjtcbiAgICAgIHZhciBlbCA9IHRoaXMuc29ydGFibGUuZWwsXG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQgIT09IGVsKSB7XG4gICAgICAgIHZhciBwcmV2U3dhcEVsID0gbGFzdFN3YXBFbDtcblxuICAgICAgICBpZiAob25Nb3ZlKHRhcmdldCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3ModGFyZ2V0LCBvcHRpb25zLnN3YXBDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgbGFzdFN3YXBFbCA9IHRhcmdldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0U3dhcEVsID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2U3dhcEVsICYmIHByZXZTd2FwRWwgIT09IGxhc3RTd2FwRWwpIHtcbiAgICAgICAgICB0b2dnbGVDbGFzcyhwcmV2U3dhcEVsLCBvcHRpb25zLnN3YXBDbGFzcywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoYW5nZWQoKTtcbiAgICAgIGNvbXBsZXRlZCh0cnVlKTtcbiAgICAgIGNhbmNlbCgpO1xuICAgIH0sXG4gICAgZHJvcDogZnVuY3Rpb24gZHJvcChfcmVmMykge1xuICAgICAgdmFyIGFjdGl2ZVNvcnRhYmxlID0gX3JlZjMuYWN0aXZlU29ydGFibGUsXG4gICAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmMy5wdXRTb3J0YWJsZSxcbiAgICAgICAgICBkcmFnRWwgPSBfcmVmMy5kcmFnRWw7XG4gICAgICB2YXIgdG9Tb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IHRoaXMuc29ydGFibGU7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGxhc3RTd2FwRWwgJiYgdG9nZ2xlQ2xhc3MobGFzdFN3YXBFbCwgb3B0aW9ucy5zd2FwQ2xhc3MsIGZhbHNlKTtcblxuICAgICAgaWYgKGxhc3RTd2FwRWwgJiYgKG9wdGlvbnMuc3dhcCB8fCBwdXRTb3J0YWJsZSAmJiBwdXRTb3J0YWJsZS5vcHRpb25zLnN3YXApKSB7XG4gICAgICAgIGlmIChkcmFnRWwgIT09IGxhc3RTd2FwRWwpIHtcbiAgICAgICAgICB0b1NvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIGlmICh0b1NvcnRhYmxlICE9PSBhY3RpdmVTb3J0YWJsZSkgYWN0aXZlU29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG4gICAgICAgICAgc3dhcE5vZGVzKGRyYWdFbCwgbGFzdFN3YXBFbCk7XG4gICAgICAgICAgdG9Tb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gICAgICAgICAgaWYgKHRvU29ydGFibGUgIT09IGFjdGl2ZVNvcnRhYmxlKSBhY3RpdmVTb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG51bGxpbmc6IGZ1bmN0aW9uIG51bGxpbmcoKSB7XG4gICAgICBsYXN0U3dhcEVsID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcyhTd2FwLCB7XG4gICAgcGx1Z2luTmFtZTogJ3N3YXAnLFxuICAgIGV2ZW50UHJvcGVydGllczogZnVuY3Rpb24gZXZlbnRQcm9wZXJ0aWVzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3dhcEl0ZW06IGxhc3RTd2FwRWxcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc3dhcE5vZGVzKG4xLCBuMikge1xuICB2YXIgcDEgPSBuMS5wYXJlbnROb2RlLFxuICAgICAgcDIgPSBuMi5wYXJlbnROb2RlLFxuICAgICAgaTEsXG4gICAgICBpMjtcbiAgaWYgKCFwMSB8fCAhcDIgfHwgcDEuaXNFcXVhbE5vZGUobjIpIHx8IHAyLmlzRXF1YWxOb2RlKG4xKSkgcmV0dXJuO1xuICBpMSA9IGluZGV4KG4xKTtcbiAgaTIgPSBpbmRleChuMik7XG5cbiAgaWYgKHAxLmlzRXF1YWxOb2RlKHAyKSAmJiBpMSA8IGkyKSB7XG4gICAgaTIrKztcbiAgfVxuXG4gIHAxLmluc2VydEJlZm9yZShuMiwgcDEuY2hpbGRyZW5baTFdKTtcbiAgcDIuaW5zZXJ0QmVmb3JlKG4xLCBwMi5jaGlsZHJlbltpMl0pO1xufVxuXG52YXIgbXVsdGlEcmFnRWxlbWVudHMgPSBbXSxcbiAgICBtdWx0aURyYWdDbG9uZXMgPSBbXSxcbiAgICBsYXN0TXVsdGlEcmFnU2VsZWN0LFxuICAgIC8vIGZvciBzZWxlY3Rpb24gd2l0aCBtb2RpZmllciBrZXkgZG93biAoU0hJRlQpXG5tdWx0aURyYWdTb3J0YWJsZSxcbiAgICBpbml0aWFsRm9sZGluZyA9IGZhbHNlLFxuICAgIC8vIEluaXRpYWwgbXVsdGktZHJhZyBmb2xkIHdoZW4gZHJhZyBzdGFydGVkXG5mb2xkaW5nID0gZmFsc2UsXG4gICAgLy8gRm9sZGluZyBhbnkgb3RoZXIgdGltZVxuZHJhZ1N0YXJ0ZWQgPSBmYWxzZSxcbiAgICBkcmFnRWwkMSxcbiAgICBjbG9uZXNGcm9tUmVjdCxcbiAgICBjbG9uZXNIaWRkZW47XG5cbmZ1bmN0aW9uIE11bHRpRHJhZ1BsdWdpbigpIHtcbiAgZnVuY3Rpb24gTXVsdGlEcmFnKHNvcnRhYmxlKSB7XG4gICAgLy8gQmluZCBhbGwgcHJpdmF0ZSBtZXRob2RzXG4gICAgZm9yICh2YXIgZm4gaW4gdGhpcykge1xuICAgICAgaWYgKGZuLmNoYXJBdCgwKSA9PT0gJ18nICYmIHR5cGVvZiB0aGlzW2ZuXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzW2ZuXSA9IHRoaXNbZm5dLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzb3J0YWJsZS5vcHRpb25zLmF2b2lkSW1wbGljaXREZXNlbGVjdCkge1xuICAgICAgaWYgKHNvcnRhYmxlLm9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdwb2ludGVydXAnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbihkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICAgIG9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fY2hlY2tLZXlEb3duKTtcbiAgICBvbihkb2N1bWVudCwgJ2tleXVwJywgdGhpcy5fY2hlY2tLZXlVcCk7XG4gICAgdGhpcy5kZWZhdWx0cyA9IHtcbiAgICAgIHNlbGVjdGVkQ2xhc3M6ICdzb3J0YWJsZS1zZWxlY3RlZCcsXG4gICAgICBtdWx0aURyYWdLZXk6IG51bGwsXG4gICAgICBhdm9pZEltcGxpY2l0RGVzZWxlY3Q6IGZhbHNlLFxuICAgICAgc2V0RGF0YTogZnVuY3Rpb24gc2V0RGF0YShkYXRhVHJhbnNmZXIsIGRyYWdFbCkge1xuICAgICAgICB2YXIgZGF0YSA9ICcnO1xuXG4gICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggJiYgbXVsdGlEcmFnU29ydGFibGUgPT09IHNvcnRhYmxlKSB7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCwgaSkge1xuICAgICAgICAgICAgZGF0YSArPSAoIWkgPyAnJyA6ICcsICcpICsgbXVsdGlEcmFnRWxlbWVudC50ZXh0Q29udGVudDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhID0gZHJhZ0VsLnRleHRDb250ZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVRyYW5zZmVyLnNldERhdGEoJ1RleHQnLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgTXVsdGlEcmFnLnByb3RvdHlwZSA9IHtcbiAgICBtdWx0aURyYWdLZXlEb3duOiBmYWxzZSxcbiAgICBpc011bHRpRHJhZzogZmFsc2UsXG4gICAgZGVsYXlTdGFydEdsb2JhbDogZnVuY3Rpb24gZGVsYXlTdGFydEdsb2JhbChfcmVmKSB7XG4gICAgICB2YXIgZHJhZ2dlZCA9IF9yZWYuZHJhZ0VsO1xuICAgICAgZHJhZ0VsJDEgPSBkcmFnZ2VkO1xuICAgIH0sXG4gICAgZGVsYXlFbmRlZDogZnVuY3Rpb24gZGVsYXlFbmRlZCgpIHtcbiAgICAgIHRoaXMuaXNNdWx0aURyYWcgPSB+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihkcmFnRWwkMSk7XG4gICAgfSxcbiAgICBzZXR1cENsb25lOiBmdW5jdGlvbiBzZXR1cENsb25lKF9yZWYyKSB7XG4gICAgICB2YXIgc29ydGFibGUgPSBfcmVmMi5zb3J0YWJsZSxcbiAgICAgICAgICBjYW5jZWwgPSBfcmVmMi5jYW5jZWw7XG4gICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdWx0aURyYWdFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtdWx0aURyYWdDbG9uZXMucHVzaChjbG9uZShtdWx0aURyYWdFbGVtZW50c1tpXSkpO1xuICAgICAgICBtdWx0aURyYWdDbG9uZXNbaV0uc29ydGFibGVJbmRleCA9IG11bHRpRHJhZ0VsZW1lbnRzW2ldLnNvcnRhYmxlSW5kZXg7XG4gICAgICAgIG11bHRpRHJhZ0Nsb25lc1tpXS5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgbXVsdGlEcmFnQ2xvbmVzW2ldLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJyc7XG4gICAgICAgIHRvZ2dsZUNsYXNzKG11bHRpRHJhZ0Nsb25lc1tpXSwgdGhpcy5vcHRpb25zLnNlbGVjdGVkQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudHNbaV0gPT09IGRyYWdFbCQxICYmIHRvZ2dsZUNsYXNzKG11bHRpRHJhZ0Nsb25lc1tpXSwgdGhpcy5vcHRpb25zLmNob3NlbkNsYXNzLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHNvcnRhYmxlLl9oaWRlQ2xvbmUoKTtcblxuICAgICAgY2FuY2VsKCk7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoX3JlZjMpIHtcbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWYzLnNvcnRhYmxlLFxuICAgICAgICAgIHJvb3RFbCA9IF9yZWYzLnJvb3RFbCxcbiAgICAgICAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQgPSBfcmVmMy5kaXNwYXRjaFNvcnRhYmxlRXZlbnQsXG4gICAgICAgICAgY2FuY2VsID0gX3JlZjMuY2FuY2VsO1xuICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnKSByZXR1cm47XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlKSB7XG4gICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggJiYgbXVsdGlEcmFnU29ydGFibGUgPT09IHNvcnRhYmxlKSB7XG4gICAgICAgICAgaW5zZXJ0TXVsdGlEcmFnQ2xvbmVzKHRydWUsIHJvb3RFbCk7XG4gICAgICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50KCdjbG9uZScpO1xuICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzaG93Q2xvbmU6IGZ1bmN0aW9uIHNob3dDbG9uZShfcmVmNCkge1xuICAgICAgdmFyIGNsb25lTm93U2hvd24gPSBfcmVmNC5jbG9uZU5vd1Nob3duLFxuICAgICAgICAgIHJvb3RFbCA9IF9yZWY0LnJvb3RFbCxcbiAgICAgICAgICBjYW5jZWwgPSBfcmVmNC5jYW5jZWw7XG4gICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcbiAgICAgIGluc2VydE11bHRpRHJhZ0Nsb25lcyhmYWxzZSwgcm9vdEVsKTtcbiAgICAgIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICBjc3MoY2xvbmUsICdkaXNwbGF5JywgJycpO1xuICAgICAgfSk7XG4gICAgICBjbG9uZU5vd1Nob3duKCk7XG4gICAgICBjbG9uZXNIaWRkZW4gPSBmYWxzZTtcbiAgICAgIGNhbmNlbCgpO1xuICAgIH0sXG4gICAgaGlkZUNsb25lOiBmdW5jdGlvbiBoaWRlQ2xvbmUoX3JlZjUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWY1LnNvcnRhYmxlLFxuICAgICAgICAgIGNsb25lTm93SGlkZGVuID0gX3JlZjUuY2xvbmVOb3dIaWRkZW4sXG4gICAgICAgICAgY2FuY2VsID0gX3JlZjUuY2FuY2VsO1xuICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnKSByZXR1cm47XG4gICAgICBtdWx0aURyYWdDbG9uZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgY3NzKGNsb25lLCAnZGlzcGxheScsICdub25lJyk7XG5cbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUgJiYgY2xvbmUucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNsb25lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNsb25lTm93SGlkZGVuKCk7XG4gICAgICBjbG9uZXNIaWRkZW4gPSB0cnVlO1xuICAgICAgY2FuY2VsKCk7XG4gICAgfSxcbiAgICBkcmFnU3RhcnRHbG9iYWw6IGZ1bmN0aW9uIGRyYWdTdGFydEdsb2JhbChfcmVmNikge1xuICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjYuc29ydGFibGU7XG5cbiAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZyAmJiBtdWx0aURyYWdTb3J0YWJsZSkge1xuICAgICAgICBtdWx0aURyYWdTb3J0YWJsZS5tdWx0aURyYWcuX2Rlc2VsZWN0TXVsdGlEcmFnKCk7XG4gICAgICB9XG5cbiAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudC5zb3J0YWJsZUluZGV4ID0gaW5kZXgobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICB9KTsgLy8gU29ydCBtdWx0aS1kcmFnIGVsZW1lbnRzXG5cbiAgICAgIG11bHRpRHJhZ0VsZW1lbnRzID0gbXVsdGlEcmFnRWxlbWVudHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5zb3J0YWJsZUluZGV4IC0gYi5zb3J0YWJsZUluZGV4O1xuICAgICAgfSk7XG4gICAgICBkcmFnU3RhcnRlZCA9IHRydWU7XG4gICAgfSxcbiAgICBkcmFnU3RhcnRlZDogZnVuY3Rpb24gZHJhZ1N0YXJ0ZWQoX3JlZjcpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgc29ydGFibGUgPSBfcmVmNy5zb3J0YWJsZTtcbiAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZykgcmV0dXJuO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNvcnQpIHtcbiAgICAgICAgLy8gQ2FwdHVyZSByZWN0cyxcbiAgICAgICAgLy8gaGlkZSBtdWx0aSBkcmFnIGVsZW1lbnRzIChieSBwb3NpdGlvbmluZyB0aGVtIGFic29sdXRlKSxcbiAgICAgICAgLy8gc2V0IG11bHRpIGRyYWcgZWxlbWVudHMgcmVjdHMgdG8gZHJhZ1JlY3QsXG4gICAgICAgIC8vIHNob3cgbXVsdGkgZHJhZyBlbGVtZW50cyxcbiAgICAgICAgLy8gYW5pbWF0ZSB0byByZWN0cyxcbiAgICAgICAgLy8gdW5zZXQgcmVjdHMgJiByZW1vdmUgZnJvbSBET01cbiAgICAgICAgc29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudCA9PT0gZHJhZ0VsJDEpIHJldHVybjtcbiAgICAgICAgICAgIGNzcyhtdWx0aURyYWdFbGVtZW50LCAncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgZHJhZ1JlY3QgPSBnZXRSZWN0KGRyYWdFbCQxLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQgPT09IGRyYWdFbCQxKSByZXR1cm47XG4gICAgICAgICAgICBzZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQsIGRyYWdSZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb2xkaW5nID0gdHJ1ZTtcbiAgICAgICAgICBpbml0aWFsRm9sZGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc29ydGFibGUuYW5pbWF0ZUFsbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvbGRpbmcgPSBmYWxzZTtcbiAgICAgICAgaW5pdGlhbEZvbGRpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAoX3RoaXMyLm9wdGlvbnMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgdW5zZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIFJlbW92ZSBhbGwgYXV4aWxpYXJ5IG11bHRpZHJhZyBpdGVtcyBmcm9tIGVsLCBpZiBzb3J0aW5nIGVuYWJsZWRcblxuXG4gICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5zb3J0KSB7XG4gICAgICAgICAgcmVtb3ZlTXVsdGlEcmFnRWxlbWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBkcmFnT3ZlcjogZnVuY3Rpb24gZHJhZ092ZXIoX3JlZjgpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBfcmVmOC50YXJnZXQsXG4gICAgICAgICAgY29tcGxldGVkID0gX3JlZjguY29tcGxldGVkLFxuICAgICAgICAgIGNhbmNlbCA9IF9yZWY4LmNhbmNlbDtcblxuICAgICAgaWYgKGZvbGRpbmcgJiYgfm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YodGFyZ2V0KSkge1xuICAgICAgICBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJldmVydDogZnVuY3Rpb24gcmV2ZXJ0KF9yZWY5KSB7XG4gICAgICB2YXIgZnJvbVNvcnRhYmxlID0gX3JlZjkuZnJvbVNvcnRhYmxlLFxuICAgICAgICAgIHJvb3RFbCA9IF9yZWY5LnJvb3RFbCxcbiAgICAgICAgICBzb3J0YWJsZSA9IF9yZWY5LnNvcnRhYmxlLFxuICAgICAgICAgIGRyYWdSZWN0ID0gX3JlZjkuZHJhZ1JlY3Q7XG5cbiAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIFNldHVwIHVuZm9sZCBhbmltYXRpb25cbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgIHNvcnRhYmxlLmFkZEFuaW1hdGlvblN0YXRlKHtcbiAgICAgICAgICAgIHRhcmdldDogbXVsdGlEcmFnRWxlbWVudCxcbiAgICAgICAgICAgIHJlY3Q6IGZvbGRpbmcgPyBnZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQpIDogZHJhZ1JlY3RcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB1bnNldFJlY3QobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudC5mcm9tUmVjdCA9IGRyYWdSZWN0O1xuICAgICAgICAgIGZyb21Tb3J0YWJsZS5yZW1vdmVBbmltYXRpb25TdGF0ZShtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvbGRpbmcgPSBmYWxzZTtcbiAgICAgICAgaW5zZXJ0TXVsdGlEcmFnRWxlbWVudHMoIXRoaXMub3B0aW9ucy5yZW1vdmVDbG9uZU9uSGlkZSwgcm9vdEVsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdPdmVyQ29tcGxldGVkOiBmdW5jdGlvbiBkcmFnT3ZlckNvbXBsZXRlZChfcmVmMTApIHtcbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWYxMC5zb3J0YWJsZSxcbiAgICAgICAgICBpc093bmVyID0gX3JlZjEwLmlzT3duZXIsXG4gICAgICAgICAgaW5zZXJ0aW9uID0gX3JlZjEwLmluc2VydGlvbixcbiAgICAgICAgICBhY3RpdmVTb3J0YWJsZSA9IF9yZWYxMC5hY3RpdmVTb3J0YWJsZSxcbiAgICAgICAgICBwYXJlbnRFbCA9IF9yZWYxMC5wYXJlbnRFbCxcbiAgICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWYxMC5wdXRTb3J0YWJsZTtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgICAgIC8vIENsb25lcyBtdXN0IGJlIGhpZGRlbiBiZWZvcmUgZm9sZGluZyBhbmltYXRpb24gdG8gY2FwdHVyZSBkcmFnUmVjdEFic29sdXRlIHByb3Blcmx5XG4gICAgICAgIGlmIChpc093bmVyKSB7XG4gICAgICAgICAgYWN0aXZlU29ydGFibGUuX2hpZGVDbG9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5pdGlhbEZvbGRpbmcgPSBmYWxzZTsgLy8gSWYgbGVhdmluZyBzb3J0OmZhbHNlIHJvb3QsIG9yIGFscmVhZHkgZm9sZGluZyAtIEZvbGQgdG8gbmV3IGxvY2F0aW9uXG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uICYmIG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCA+IDEgJiYgKGZvbGRpbmcgfHwgIWlzT3duZXIgJiYgIWFjdGl2ZVNvcnRhYmxlLm9wdGlvbnMuc29ydCAmJiAhcHV0U29ydGFibGUpKSB7XG4gICAgICAgICAgLy8gRm9sZDogU2V0IGFsbCBtdWx0aSBkcmFnIGVsZW1lbnRzJ3MgcmVjdHMgdG8gZHJhZ0VsJ3MgcmVjdCB3aGVuIG11bHRpLWRyYWcgZWxlbWVudHMgYXJlIGludmlzaWJsZVxuICAgICAgICAgIHZhciBkcmFnUmVjdEFic29sdXRlID0gZ2V0UmVjdChkcmFnRWwkMSwgZmFsc2UsIHRydWUsIHRydWUpO1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50ID09PSBkcmFnRWwkMSkgcmV0dXJuO1xuICAgICAgICAgICAgc2V0UmVjdChtdWx0aURyYWdFbGVtZW50LCBkcmFnUmVjdEFic29sdXRlKTsgLy8gTW92ZSBlbGVtZW50KHMpIHRvIGVuZCBvZiBwYXJlbnRFbCBzbyB0aGF0IGl0IGRvZXMgbm90IGludGVyZmVyZSB3aXRoIG11bHRpLWRyYWcgY2xvbmVzIGluc2VydGlvbiBpZiB0aGV5IGFyZSBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gd2hpbGUgZm9sZGluZywgYW5kIHNvIHRoYXQgd2UgY2FuIGNhcHR1cmUgdGhlbSBhZ2FpbiBiZWNhdXNlIG9sZCBzb3J0YWJsZSB3aWxsIG5vIGxvbmdlciBiZSBmcm9tU29ydGFibGVcblxuICAgICAgICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9sZGluZyA9IHRydWU7XG4gICAgICAgIH0gLy8gQ2xvbmVzIG11c3QgYmUgc2hvd24gKGFuZCBjaGVjayB0byByZW1vdmUgbXVsdGkgZHJhZ3MpIGFmdGVyIGZvbGRpbmcgd2hlbiBpbnRlcmZlcmluZyBtdWx0aURyYWdFbGVtZW50cyBhcmUgbW92ZWQgb3V0XG5cblxuICAgICAgICBpZiAoIWlzT3duZXIpIHtcbiAgICAgICAgICAvLyBPbmx5IHJlbW92ZSBpZiBub3QgZm9sZGluZyAoZm9sZGluZyB3aWxsIHJlbW92ZSB0aGVtIGFueXdheXMpXG4gICAgICAgICAgaWYgKCFmb2xkaW5nKSB7XG4gICAgICAgICAgICByZW1vdmVNdWx0aURyYWdFbGVtZW50cygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgY2xvbmVzSGlkZGVuQmVmb3JlID0gY2xvbmVzSGlkZGVuO1xuXG4gICAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5fc2hvd0Nsb25lKHNvcnRhYmxlKTsgLy8gVW5mb2xkIGFuaW1hdGlvbiBmb3IgY2xvbmVzIGlmIHNob3dpbmcgZnJvbSBoaWRkZW5cblxuXG4gICAgICAgICAgICBpZiAoYWN0aXZlU29ydGFibGUub3B0aW9ucy5hbmltYXRpb24gJiYgIWNsb25lc0hpZGRlbiAmJiBjbG9uZXNIaWRkZW5CZWZvcmUpIHtcbiAgICAgICAgICAgICAgbXVsdGlEcmFnQ2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlU29ydGFibGUuYWRkQW5pbWF0aW9uU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBjbG9uZSxcbiAgICAgICAgICAgICAgICAgIHJlY3Q6IGNsb25lc0Zyb21SZWN0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2xvbmUuZnJvbVJlY3QgPSBjbG9uZXNGcm9tUmVjdDtcbiAgICAgICAgICAgICAgICBjbG9uZS50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlU29ydGFibGUuX3Nob3dDbG9uZShzb3J0YWJsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkcmFnT3ZlckFuaW1hdGlvbkNhcHR1cmU6IGZ1bmN0aW9uIGRyYWdPdmVyQW5pbWF0aW9uQ2FwdHVyZShfcmVmMTEpIHtcbiAgICAgIHZhciBkcmFnUmVjdCA9IF9yZWYxMS5kcmFnUmVjdCxcbiAgICAgICAgICBpc093bmVyID0gX3JlZjExLmlzT3duZXIsXG4gICAgICAgICAgYWN0aXZlU29ydGFibGUgPSBfcmVmMTEuYWN0aXZlU29ydGFibGU7XG4gICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgIG11bHRpRHJhZ0VsZW1lbnQudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gbnVsbDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoYWN0aXZlU29ydGFibGUub3B0aW9ucy5hbmltYXRpb24gJiYgIWlzT3duZXIgJiYgYWN0aXZlU29ydGFibGUubXVsdGlEcmFnLmlzTXVsdGlEcmFnKSB7XG4gICAgICAgIGNsb25lc0Zyb21SZWN0ID0gX2V4dGVuZHMoe30sIGRyYWdSZWN0KTtcbiAgICAgICAgdmFyIGRyYWdNYXRyaXggPSBtYXRyaXgoZHJhZ0VsJDEsIHRydWUpO1xuICAgICAgICBjbG9uZXNGcm9tUmVjdC50b3AgLT0gZHJhZ01hdHJpeC5mO1xuICAgICAgICBjbG9uZXNGcm9tUmVjdC5sZWZ0IC09IGRyYWdNYXRyaXguZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdPdmVyQW5pbWF0aW9uQ29tcGxldGU6IGZ1bmN0aW9uIGRyYWdPdmVyQW5pbWF0aW9uQ29tcGxldGUoKSB7XG4gICAgICBpZiAoZm9sZGluZykge1xuICAgICAgICBmb2xkaW5nID0gZmFsc2U7XG4gICAgICAgIHJlbW92ZU11bHRpRHJhZ0VsZW1lbnRzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcm9wOiBmdW5jdGlvbiBkcm9wKF9yZWYxMikge1xuICAgICAgdmFyIGV2dCA9IF9yZWYxMi5vcmlnaW5hbEV2ZW50LFxuICAgICAgICAgIHJvb3RFbCA9IF9yZWYxMi5yb290RWwsXG4gICAgICAgICAgcGFyZW50RWwgPSBfcmVmMTIucGFyZW50RWwsXG4gICAgICAgICAgc29ydGFibGUgPSBfcmVmMTIuc29ydGFibGUsXG4gICAgICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50ID0gX3JlZjEyLmRpc3BhdGNoU29ydGFibGVFdmVudCxcbiAgICAgICAgICBvbGRJbmRleCA9IF9yZWYxMi5vbGRJbmRleCxcbiAgICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWYxMi5wdXRTb3J0YWJsZTtcbiAgICAgIHZhciB0b1NvcnRhYmxlID0gcHV0U29ydGFibGUgfHwgdGhpcy5zb3J0YWJsZTtcbiAgICAgIGlmICghZXZ0KSByZXR1cm47XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBjaGlsZHJlbiA9IHBhcmVudEVsLmNoaWxkcmVuOyAvLyBNdWx0aS1kcmFnIHNlbGVjdGlvblxuXG4gICAgICBpZiAoIWRyYWdTdGFydGVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm11bHRpRHJhZ0tleSAmJiAhdGhpcy5tdWx0aURyYWdLZXlEb3duKSB7XG4gICAgICAgICAgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCQxLCBvcHRpb25zLnNlbGVjdGVkQ2xhc3MsICF+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihkcmFnRWwkMSkpO1xuXG4gICAgICAgIGlmICghfm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZHJhZ0VsJDEpKSB7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMucHVzaChkcmFnRWwkMSk7XG4gICAgICAgICAgZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGUsXG4gICAgICAgICAgICByb290RWw6IHJvb3RFbCxcbiAgICAgICAgICAgIG5hbWU6ICdzZWxlY3QnLFxuICAgICAgICAgICAgdGFyZ2V0RWw6IGRyYWdFbCQxLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgfSk7IC8vIE1vZGlmaWVyIGFjdGl2YXRlZCwgc2VsZWN0IGZyb20gbGFzdCB0byBkcmFnRWxcblxuICAgICAgICAgIGlmIChldnQuc2hpZnRLZXkgJiYgbGFzdE11bHRpRHJhZ1NlbGVjdCAmJiBzb3J0YWJsZS5lbC5jb250YWlucyhsYXN0TXVsdGlEcmFnU2VsZWN0KSkge1xuICAgICAgICAgICAgdmFyIGxhc3RJbmRleCA9IGluZGV4KGxhc3RNdWx0aURyYWdTZWxlY3QpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IGluZGV4KGRyYWdFbCQxKTtcblxuICAgICAgICAgICAgaWYgKH5sYXN0SW5kZXggJiYgfmN1cnJlbnRJbmRleCAmJiBsYXN0SW5kZXggIT09IGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgICAvLyBNdXN0IGluY2x1ZGUgbGFzdE11bHRpRHJhZ1NlbGVjdCAoc2VsZWN0IGl0KSwgaW4gY2FzZSBtb2RpZmllZCBzZWxlY3Rpb24gZnJvbSBubyBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgLy8gKGJ1dCBwcmV2aW91cyBzZWxlY3Rpb24gZXhpc3RlZClcbiAgICAgICAgICAgICAgdmFyIG4sIGk7XG5cbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgIGkgPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgbiA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpID0gY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgIG4gPSBsYXN0SW5kZXggKyAxO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAofm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoY2hpbGRyZW5baV0pKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhjaGlsZHJlbltpXSwgb3B0aW9ucy5zZWxlY3RlZENsYXNzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgICAgICAgICAgIHJvb3RFbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgICAgbmFtZTogJ3NlbGVjdCcsXG4gICAgICAgICAgICAgICAgICB0YXJnZXRFbDogY2hpbGRyZW5baV0sXG4gICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0TXVsdGlEcmFnU2VsZWN0ID0gZHJhZ0VsJDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbXVsdGlEcmFnU29ydGFibGUgPSB0b1NvcnRhYmxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLnNwbGljZShtdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGRyYWdFbCQxKSwgMSk7XG4gICAgICAgICAgbGFzdE11bHRpRHJhZ1NlbGVjdCA9IG51bGw7XG4gICAgICAgICAgZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGUsXG4gICAgICAgICAgICByb290RWw6IHJvb3RFbCxcbiAgICAgICAgICAgIG5hbWU6ICdkZXNlbGVjdCcsXG4gICAgICAgICAgICB0YXJnZXRFbDogZHJhZ0VsJDEsXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBNdWx0aS1kcmFnIGRyb3BcblxuXG4gICAgICBpZiAoZHJhZ1N0YXJ0ZWQgJiYgdGhpcy5pc011bHRpRHJhZykge1xuICAgICAgICBmb2xkaW5nID0gZmFsc2U7IC8vIERvIG5vdCBcInVuZm9sZFwiIGFmdGVyIGFyb3VuZCBkcmFnRWwgaWYgcmV2ZXJ0ZWRcblxuICAgICAgICBpZiAoKHBhcmVudEVsW2V4cGFuZG9dLm9wdGlvbnMuc29ydCB8fCBwYXJlbnRFbCAhPT0gcm9vdEVsKSAmJiBtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdmFyIGRyYWdSZWN0ID0gZ2V0UmVjdChkcmFnRWwkMSksXG4gICAgICAgICAgICAgIG11bHRpRHJhZ0luZGV4ID0gaW5kZXgoZHJhZ0VsJDEsICc6bm90KC4nICsgdGhpcy5vcHRpb25zLnNlbGVjdGVkQ2xhc3MgKyAnKScpO1xuICAgICAgICAgIGlmICghaW5pdGlhbEZvbGRpbmcgJiYgb3B0aW9ucy5hbmltYXRpb24pIGRyYWdFbCQxLnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgdG9Tb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcblxuICAgICAgICAgIGlmICghaW5pdGlhbEZvbGRpbmcpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgICBkcmFnRWwkMS5mcm9tUmVjdCA9IGRyYWdSZWN0O1xuICAgICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudC50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQgIT09IGRyYWdFbCQxKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGZvbGRpbmcgPyBnZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQpIDogZHJhZ1JlY3Q7XG4gICAgICAgICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50LmZyb21SZWN0ID0gcmVjdDsgLy8gUHJlcGFyZSB1bmZvbGQgYW5pbWF0aW9uXG5cbiAgICAgICAgICAgICAgICAgIHRvU29ydGFibGUuYWRkQW5pbWF0aW9uU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IG11bHRpRHJhZ0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHJlY3Q6IHJlY3RcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IC8vIE11bHRpIGRyYWcgZWxlbWVudHMgYXJlIG5vdCBuZWNlc3NhcmlseSByZW1vdmVkIGZyb20gdGhlIERPTSBvbiBkcm9wLCBzbyB0byByZWluc2VydFxuICAgICAgICAgICAgLy8gcHJvcGVybHkgdGhleSBtdXN0IGFsbCBiZSByZW1vdmVkXG5cblxuICAgICAgICAgICAgcmVtb3ZlTXVsdGlEcmFnRWxlbWVudHMoKTtcbiAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuW211bHRpRHJhZ0luZGV4XSkge1xuICAgICAgICAgICAgICAgIHBhcmVudEVsLmluc2VydEJlZm9yZShtdWx0aURyYWdFbGVtZW50LCBjaGlsZHJlblttdWx0aURyYWdJbmRleF0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbXVsdGlEcmFnSW5kZXgrKztcbiAgICAgICAgICAgIH0pOyAvLyBJZiBpbml0aWFsIGZvbGRpbmcgaXMgZG9uZSwgdGhlIGVsZW1lbnRzIG1heSBoYXZlIGNoYW5nZWQgcG9zaXRpb24gYmVjYXVzZSB0aGV5IGFyZSBub3dcbiAgICAgICAgICAgIC8vIHVuZm9sZGluZyBhcm91bmQgZHJhZ0VsLCBldmVuIHRob3VnaCBkcmFnRWwgbWF5IG5vdCBoYXZlIGhpcyBpbmRleCBjaGFuZ2VkLCBzbyB1cGRhdGUgZXZlbnRcbiAgICAgICAgICAgIC8vIG11c3QgYmUgZmlyZWQgaGVyZSBhcyBTb3J0YWJsZSB3aWxsIG5vdC5cblxuICAgICAgICAgICAgaWYgKG9sZEluZGV4ID09PSBpbmRleChkcmFnRWwkMSkpIHtcbiAgICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQuc29ydGFibGVJbmRleCAhPT0gaW5kZXgobXVsdGlEcmFnRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50KCd1cGRhdGUnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gTXVzdCBiZSBkb25lIGFmdGVyIGNhcHR1cmluZyBpbmRpdmlkdWFsIHJlY3RzIChzY3JvbGwgYmFyKVxuXG5cbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICB1bnNldFJlY3QobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdG9Tb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBtdWx0aURyYWdTb3J0YWJsZSA9IHRvU29ydGFibGU7XG4gICAgICB9IC8vIFJlbW92ZSBjbG9uZXMgaWYgbmVjZXNzYXJ5XG5cblxuICAgICAgaWYgKHJvb3RFbCA9PT0gcGFyZW50RWwgfHwgcHV0U29ydGFibGUgJiYgcHV0U29ydGFibGUubGFzdFB1dE1vZGUgIT09ICdjbG9uZScpIHtcbiAgICAgICAgbXVsdGlEcmFnQ2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgICAgY2xvbmUucGFyZW50Tm9kZSAmJiBjbG9uZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBudWxsaW5nR2xvYmFsOiBmdW5jdGlvbiBudWxsaW5nR2xvYmFsKCkge1xuICAgICAgdGhpcy5pc011bHRpRHJhZyA9IGRyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgICBtdWx0aURyYWdDbG9uZXMubGVuZ3RoID0gMDtcbiAgICB9LFxuICAgIGRlc3Ryb3lHbG9iYWw6IGZ1bmN0aW9uIGRlc3Ryb3lHbG9iYWwoKSB7XG4gICAgICB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZygpO1xuXG4gICAgICBvZmYoZG9jdW1lbnQsICdwb2ludGVydXAnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICBvZmYoZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgICAgb2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICBvZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fY2hlY2tLZXlEb3duKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ2tleXVwJywgdGhpcy5fY2hlY2tLZXlVcCk7XG4gICAgfSxcbiAgICBfZGVzZWxlY3RNdWx0aURyYWc6IGZ1bmN0aW9uIF9kZXNlbGVjdE11bHRpRHJhZyhldnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZHJhZ1N0YXJ0ZWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZHJhZ1N0YXJ0ZWQpIHJldHVybjsgLy8gT25seSBkZXNlbGVjdCBpZiBzZWxlY3Rpb24gaXMgaW4gdGhpcyBzb3J0YWJsZVxuXG4gICAgICBpZiAobXVsdGlEcmFnU29ydGFibGUgIT09IHRoaXMuc29ydGFibGUpIHJldHVybjsgLy8gT25seSBkZXNlbGVjdCBpZiB0YXJnZXQgaXMgbm90IGl0ZW0gaW4gdGhpcyBzb3J0YWJsZVxuXG4gICAgICBpZiAoZXZ0ICYmIGNsb3Nlc3QoZXZ0LnRhcmdldCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSwgdGhpcy5zb3J0YWJsZS5lbCwgZmFsc2UpKSByZXR1cm47IC8vIE9ubHkgZGVzZWxlY3QgaWYgbGVmdCBjbGlja1xuXG4gICAgICBpZiAoZXZ0ICYmIGV2dC5idXR0b24gIT09IDApIHJldHVybjtcblxuICAgICAgd2hpbGUgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgZWwgPSBtdWx0aURyYWdFbGVtZW50c1swXTtcbiAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHRoaXMub3B0aW9ucy5zZWxlY3RlZENsYXNzLCBmYWxzZSk7XG4gICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLnNoaWZ0KCk7XG4gICAgICAgIGRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLnNvcnRhYmxlLFxuICAgICAgICAgIHJvb3RFbDogdGhpcy5zb3J0YWJsZS5lbCxcbiAgICAgICAgICBuYW1lOiAnZGVzZWxlY3QnLFxuICAgICAgICAgIHRhcmdldEVsOiBlbCxcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfY2hlY2tLZXlEb3duOiBmdW5jdGlvbiBfY2hlY2tLZXlEb3duKGV2dCkge1xuICAgICAgaWYgKGV2dC5rZXkgPT09IHRoaXMub3B0aW9ucy5tdWx0aURyYWdLZXkpIHtcbiAgICAgICAgdGhpcy5tdWx0aURyYWdLZXlEb3duID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9jaGVja0tleVVwOiBmdW5jdGlvbiBfY2hlY2tLZXlVcChldnQpIHtcbiAgICAgIGlmIChldnQua2V5ID09PSB0aGlzLm9wdGlvbnMubXVsdGlEcmFnS2V5KSB7XG4gICAgICAgIHRoaXMubXVsdGlEcmFnS2V5RG93biA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzKE11bHRpRHJhZywge1xuICAgIC8vIFN0YXRpYyBtZXRob2RzICYgcHJvcGVydGllc1xuICAgIHBsdWdpbk5hbWU6ICdtdWx0aURyYWcnLFxuICAgIHV0aWxzOiB7XG4gICAgICAvKipcclxuICAgICAgICogU2VsZWN0cyB0aGUgcHJvdmlkZWQgbXVsdGktZHJhZyBpdGVtXHJcbiAgICAgICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICBUaGUgZWxlbWVudCB0byBiZSBzZWxlY3RlZFxyXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0KGVsKSB7XG4gICAgICAgIHZhciBzb3J0YWJsZSA9IGVsLnBhcmVudE5vZGVbZXhwYW5kb107XG4gICAgICAgIGlmICghc29ydGFibGUgfHwgIXNvcnRhYmxlLm9wdGlvbnMubXVsdGlEcmFnIHx8IH5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGVsKSkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChtdWx0aURyYWdTb3J0YWJsZSAmJiBtdWx0aURyYWdTb3J0YWJsZSAhPT0gc29ydGFibGUpIHtcbiAgICAgICAgICBtdWx0aURyYWdTb3J0YWJsZS5tdWx0aURyYWcuX2Rlc2VsZWN0TXVsdGlEcmFnKCk7XG5cbiAgICAgICAgICBtdWx0aURyYWdTb3J0YWJsZSA9IHNvcnRhYmxlO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHNvcnRhYmxlLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgdHJ1ZSk7XG4gICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLnB1c2goZWwpO1xuICAgICAgfSxcblxuICAgICAgLyoqXHJcbiAgICAgICAqIERlc2VsZWN0cyB0aGUgcHJvdmlkZWQgbXVsdGktZHJhZyBpdGVtXHJcbiAgICAgICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICBUaGUgZWxlbWVudCB0byBiZSBkZXNlbGVjdGVkXHJcbiAgICAgICAqL1xuICAgICAgZGVzZWxlY3Q6IGZ1bmN0aW9uIGRlc2VsZWN0KGVsKSB7XG4gICAgICAgIHZhciBzb3J0YWJsZSA9IGVsLnBhcmVudE5vZGVbZXhwYW5kb10sXG4gICAgICAgICAgICBpbmRleCA9IG11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZWwpO1xuICAgICAgICBpZiAoIXNvcnRhYmxlIHx8ICFzb3J0YWJsZS5vcHRpb25zLm11bHRpRHJhZyB8fCAhfmluZGV4KSByZXR1cm47XG4gICAgICAgIHRvZ2dsZUNsYXNzKGVsLCBzb3J0YWJsZS5vcHRpb25zLnNlbGVjdGVkQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV2ZW50UHJvcGVydGllczogZnVuY3Rpb24gZXZlbnRQcm9wZXJ0aWVzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBvbGRJbmRpY2llcyA9IFtdLFxuICAgICAgICAgIG5ld0luZGljaWVzID0gW107XG4gICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgIG9sZEluZGljaWVzLnB1c2goe1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnQ6IG11bHRpRHJhZ0VsZW1lbnQsXG4gICAgICAgICAgaW5kZXg6IG11bHRpRHJhZ0VsZW1lbnQuc29ydGFibGVJbmRleFxuICAgICAgICB9KTsgLy8gbXVsdGlEcmFnRWxlbWVudHMgd2lsbCBhbHJlYWR5IGJlIHNvcnRlZCBpZiBmb2xkaW5nXG5cbiAgICAgICAgdmFyIG5ld0luZGV4O1xuXG4gICAgICAgIGlmIChmb2xkaW5nICYmIG11bHRpRHJhZ0VsZW1lbnQgIT09IGRyYWdFbCQxKSB7XG4gICAgICAgICAgbmV3SW5kZXggPSAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChmb2xkaW5nKSB7XG4gICAgICAgICAgbmV3SW5kZXggPSBpbmRleChtdWx0aURyYWdFbGVtZW50LCAnOm5vdCguJyArIF90aGlzMy5vcHRpb25zLnNlbGVjdGVkQ2xhc3MgKyAnKScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0luZGV4ID0gaW5kZXgobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdJbmRpY2llcy5wdXNoKHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50OiBtdWx0aURyYWdFbGVtZW50LFxuICAgICAgICAgIGluZGV4OiBuZXdJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXRlbXM6IF90b0NvbnN1bWFibGVBcnJheShtdWx0aURyYWdFbGVtZW50cyksXG4gICAgICAgIGNsb25lczogW10uY29uY2F0KG11bHRpRHJhZ0Nsb25lcyksXG4gICAgICAgIG9sZEluZGljaWVzOiBvbGRJbmRpY2llcyxcbiAgICAgICAgbmV3SW5kaWNpZXM6IG5ld0luZGljaWVzXG4gICAgICB9O1xuICAgIH0sXG4gICAgb3B0aW9uTGlzdGVuZXJzOiB7XG4gICAgICBtdWx0aURyYWdLZXk6IGZ1bmN0aW9uIG11bHRpRHJhZ0tleShrZXkpIHtcbiAgICAgICAga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2N0cmwnKSB7XG4gICAgICAgICAga2V5ID0gJ0NvbnRyb2wnO1xuICAgICAgICB9IGVsc2UgaWYgKGtleS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAga2V5ID0ga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cigxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0TXVsdGlEcmFnRWxlbWVudHMoY2xvbmVzSW5zZXJ0ZWQsIHJvb3RFbCkge1xuICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50LCBpKSB7XG4gICAgdmFyIHRhcmdldCA9IHJvb3RFbC5jaGlsZHJlblttdWx0aURyYWdFbGVtZW50LnNvcnRhYmxlSW5kZXggKyAoY2xvbmVzSW5zZXJ0ZWQgPyBOdW1iZXIoaSkgOiAwKV07XG5cbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICByb290RWwuaW5zZXJ0QmVmb3JlKG11bHRpRHJhZ0VsZW1lbnQsIHRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChtdWx0aURyYWdFbGVtZW50KTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXHJcbiAqIEluc2VydCBtdWx0aS1kcmFnIGNsb25lc1xyXG4gKiBAcGFyYW0gIHtbQm9vbGVhbl19IGVsZW1lbnRzSW5zZXJ0ZWQgIFdoZXRoZXIgdGhlIG11bHRpLWRyYWcgZWxlbWVudHMgYXJlIGluc2VydGVkXHJcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSByb290RWxcclxuICovXG5cblxuZnVuY3Rpb24gaW5zZXJ0TXVsdGlEcmFnQ2xvbmVzKGVsZW1lbnRzSW5zZXJ0ZWQsIHJvb3RFbCkge1xuICBtdWx0aURyYWdDbG9uZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xvbmUsIGkpIHtcbiAgICB2YXIgdGFyZ2V0ID0gcm9vdEVsLmNoaWxkcmVuW2Nsb25lLnNvcnRhYmxlSW5kZXggKyAoZWxlbWVudHNJbnNlcnRlZCA/IE51bWJlcihpKSA6IDApXTtcblxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmUsIHRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTXVsdGlEcmFnRWxlbWVudHMoKSB7XG4gIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICBpZiAobXVsdGlEcmFnRWxlbWVudCA9PT0gZHJhZ0VsJDEpIHJldHVybjtcbiAgICBtdWx0aURyYWdFbGVtZW50LnBhcmVudE5vZGUgJiYgbXVsdGlEcmFnRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG11bHRpRHJhZ0VsZW1lbnQpO1xuICB9KTtcbn1cblxuU29ydGFibGUubW91bnQobmV3IEF1dG9TY3JvbGxQbHVnaW4oKSk7XG5Tb3J0YWJsZS5tb3VudChSZW1vdmUsIFJldmVydCk7XG5cbmV4cG9ydCBkZWZhdWx0IFNvcnRhYmxlO1xuZXhwb3J0IHsgTXVsdGlEcmFnUGx1Z2luIGFzIE11bHRpRHJhZywgU29ydGFibGUsIFN3YXBQbHVnaW4gYXMgU3dhcCB9O1xuIiwiaW1wb3J0IFNvcnRhYmxlIGZyb20gJ3NvcnRhYmxlanMnXHJcbmltcG9ydCB7JCwgcG9wdXAsIHBvc3R9IGZyb20gJy4uL2NvbW1vbidcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNvcnRhYmxlKGNvbnRhaW5lclNlbGVjdG9yLCBlbFNlbGVjdG9yLCBtb2RlbCkge1xyXG5cclxuICBsZXQgY29udGFpbmVyID0gJChjb250YWluZXJTZWxlY3RvcilbMF07XHJcbiAgaWYgKGNvbnRhaW5lcikge1xyXG5cclxuICAgIGxldCBzb3J0YWJsZSA9IFNvcnRhYmxlLmNyZWF0ZShjb250YWluZXIsIHtcclxuICAgICAgYW5pbWF0aW9uOiAxNTAsXHJcbiAgICAgIG9uRW5kOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgbGV0IG9sZEkgPSBldnQub2xkSW5kZXhcclxuICAgICAgICBsZXQgbmV3SSA9IGV2dC5uZXdJbmRleFxyXG4gICAgICAgIGlmIChvbGRJID4gbmV3SSkge1xyXG4gICAgICAgICAgc29ydChvbGRJKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzb3J0KG5ld0kpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhc3luYyBmdW5jdGlvbiBzb3J0KHVwVG9RZXN0aW9uTnVtYmVyKSB7XHJcbiAgICAgICAgICBsZXQgZWxzID0gJChlbFNlbGVjdG9yKTtcclxuICAgICAgICAgIGxldCBxdWVzdGlvbnNFbHMgPSBbXS5tYXAuY2FsbChlbHMsIGZ1bmN0aW9uIChlbCwgaSkge1xyXG4gICAgICAgICAgICAgIGlmIChpIC0gMSA8IHVwVG9RZXN0aW9uTnVtYmVyKSByZXR1cm4gZWxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgKVxyXG5cclxuICAgICAgICAgIGxldCB0b0NoYW5nZSA9IHF1ZXN0aW9uc0Vscy5tYXAoKGVsKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbC5pZFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KGAvYWRtaW5zYy8ke21vZGVsfS9zb3J0YCwge3RvQ2hhbmdlfSlcclxuICAgICAgICAgIHF1ZXN0aW9uc0Vscy5tYXAoKGVsLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICQoZWwpLmZpbmQoJy5zb3J0JykuaW5uZXJUZXh0ID0gaSArIDFcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgfSlcclxuXHJcbiAgfVxyXG59IiwiaW1wb3J0IHskLCBwb3B1cCwgcG9zdH0gZnJvbSAnLi4vLi4vLi4vY29tbW9uJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgX3Rlc3Qge1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMubW9kZWwgPSAnb3BlbnRlc3QnXHJcbiAgfVxyXG5cclxuICBhc3luYyBjcmVhdGUoKSB7XHJcbiAgICBsZXQgdGVzdCA9IF90ZXN0LnNlcnZlck1vZGVsKClcclxuICAgIHRlc3QuaWQgPSAwXHJcbiAgICB0ZXN0LmlzVGVzdCA9IDFcclxuICAgIGRlYnVnZ2VyXHJcbiAgICBsZXQgdXJsID0gYC8ke3RoaXMubW9kZWx9L3VwZGF0ZU9yQ3JlYXRlYFxyXG4gICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QodXJsLCB0ZXN0KVxyXG4gICAgaWYgKHJlcykge1xyXG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGAvYWRtaW5zYy8ke21vZGVsfS9lZGl0LyR7cmVzLmlkfWBcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGN1cnJlbnRRKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaWQ6ICQoJy5uYXYtYWN0aXZlJylbMF0uaW5uZXJUZXh0IC0gMSxcclxuICAgICAgUUVsOiAkKCcucXVlc3Rpb24uZmxleDEnKVswXSxcclxuICAgICAgbmF2TGVuZ3RoOiAkKCdbZGF0YS1wYWdpbmF0aW9uXScpLmxlbmd0aCxcclxuICAgICAgUVByZXZjOiAkKCcucXVlc3Rpb24uZmxleDEnKVswXS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLFxyXG4gICAgICBRTmV4dEVsOiAkKCcucXVlc3Rpb24uZmxleDEnKVswXS5uZXh0RWxlbWVudFNpYmxpbmcsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgdmlld01vZGVsKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaWQ6ICt3aW5kb3cubG9jYXRpb24uaHJlZi5zcGxpdCgnLycpLnBvcCgpLFxyXG4gICAgICB0ZXN0X25hbWU6ICQoJyN0ZXN0X25hbWUnKS50ZXh0KCksXHJcbiAgICAgIGVuYWJsZTogJCgnI2VuYWJsZScpWzBdLFxyXG4gICAgICBwYXJlbnQ6ICQoJ3NlbGVjdCcpLnNlbGVjdGVkSW5kZXhWYWx1ZSgpLFxyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIGlkKCkge1xyXG4gICAgcmV0dXJuIGlkID8/ICQoJy50ZXN0LW5hbWUnKVswXS5kYXRhc2V0LnRlc3RpZFxyXG4gIH1cclxuXHJcblxyXG4gIGNoaWxkcmVuKCkge1xyXG4gICAgbGV0IGNoaWxkcmVuTGVuZ2h0ID0gJCgnLmNoaWxkcmVuJykubGVuZ3RoXHJcbiAgICBpZiAoY2hpbGRyZW5MZW5naHQpXHJcbiAgICAgIHJldHVybiBjaGlsZHJlbkxlbmdodFxyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG5cclxuXHJcbiAgYXN5bmMgcGF0aF9jcmVhdGUoKSB7XHJcbiAgICBsZXQgdGVzdF9wYXRoID0gX3Rlc3Quc2VydmVyTW9kZWwoKVxyXG4gICAgdGVzdF9wYXRoLmlkID0gMFxyXG4gICAgdGVzdF9wYXRoLmlzVGVzdCA9IDBcclxuICAgIGxldCB1cmwgPSBgL2FkbWluc2MvJHttb2RlbH0vY3JlYXRlYFxyXG4gICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QodXJsLCB0ZXN0X3BhdGgpXHJcbiAgICBpZiAocmVzKSB7XHJcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYC9hZG1pbnNjLyR7bW9kZWx9L2VkaXQvJHtyZXMuaWQgLSAxfWBcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICBuYW1lKCkge1xyXG4gICAgcmV0dXJuICQoJy50ZXN0LW5hbWUnKVswXS5pbm5lclRleHRcclxuICB9XHJcblxyXG5cclxuXHJcbiAgc2VsZWN0ZWRWYWx1ZUN1c3RvbVNlbGVjdChjbGFzc05hbWUpIHtcclxuXHJcbiAgICBsZXQgc2VsZWN0ID0gJChgW2RhdGEtZmllbGQ9JHtjbGFzc05hbWV9XWApWzBdXHJcbiAgICBsZXQgc2VsZWN0ZWQgPSBbLi4uc2VsZWN0Lm9wdGlvbnNdLmZpbHRlcigob3B0KSA9PiBvcHQuc2VsZWN0ZWQpXHJcbiAgICBpZiAoc2VsZWN0ZWQpIHtcclxuICAgICAgcmV0dXJuICtzZWxlY3RlZFswXS52YWx1ZVxyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIHNlcnZlck1vZGVsKCkge1xyXG4gICAgbGV0IG1vZGVsID0ge1xyXG4gICAgICBpZDogK3dpbmRvdy5sb2NhdGlvbi5ocmVmLnNwbGl0KCcvJykucG9wKCksXHJcbiAgICAgIHRlc3RfbmFtZTogJCgnI3Rlc3RfbmFtZScpWzBdLnZhbHVlLFxyXG4gICAgICBpc1Rlc3Q6ICskKCdbaXNUZXN0XScpWzBdLmdldEF0dHJpYnV0ZSgnaXNUZXN0JyksXHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGZpZWxkcyA9ICQoJy5jdXN0b20tc2VsZWN0Jyk7XHJcbiAgICBbXS5mb3JFYWNoLmNhbGwoZmllbGRzLCBmdW5jdGlvbiAoZmllbGQpIHtcclxuICAgICAgbW9kZWxbZmllbGQuZGF0YXNldFsnZmllbGQnXV0gPSBmaWVsZC5kYXRhc2V0WydpZCddXHJcbiAgICB9KVxyXG4gICAgcmV0dXJuIG1vZGVsXHJcbiAgfVxyXG5cclxuICBhc3luYyB1cGRhdGUoKSB7XHJcbiAgICBsZXQgbW9kZWwgPSBfdGVzdC5zZXJ2ZXJNb2RlbCgpXHJcbiAgICBsZXQgdXJsID0gYC9hZG1pbnNjLyR7bW9kZWx9L3VwZGF0ZS8ke21vZGVsLmlkfWBcclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KHVybCwgbW9kZWwpXHJcbiAgICBpZiAocmVzKSB7XHJcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYC9hZG1pbnNjLyR7bW9kZWx9L2VkaXQvJHttb2RlbC5pZH1gXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgYXN5bmMgZGVsKCkge1xyXG4gICAgaWYgKF90ZXN0LmNoaWxkcmVuKCkpIHtcclxuICAgICAgcG9wdXAuc2hvdygn0KHQvdCw0YfQsNC70LAg0YPQtNCw0LvQuNGC0LUg0LLRgdC1INGC0LXRgdGC0Ysg0LjQtyDQv9Cw0L/QutC4JylcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGlkID0gX3Rlc3QuaWQoKVxyXG4gICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9hZG1pbnNjLyR7bW9kZWx9L2RlbGV0ZScsIHtpZH0pXHJcbiAgICBpZiAocmVzLm5vdEFkbWluKSB7XHJcbiAgICAgIHBvcHVwLnNob3coJ9CS0LjQtNC40LzQvtGB0YLRjCDRgtC10YHRgtCwINGB0LrRgNGL0YLQsC4g0KfRgtC+0LHRiyDRg9C00LDQu9C40YLRjCDQv9C+0LvQvdC+0YHRgtGM0Y4gLSDQvtCx0YDQsNGC0LjRgtC10YHRjCDQuiDQk9CUJylcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uID0gYC9hZG1pbnNjLyR7bW9kZWx9L2VkaXQvNDAwYFxyXG4gICAgICB9LCA0MDAwKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd2luZG93LmxvY2F0aW9uID0gYC9hZG1pbnNjLyR7bW9kZWx9L2VkaXQvNDAwYFxyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG59IiwiaW1wb3J0IHskLCBwb3B1cCwgcG9zdH0gZnJvbSAnLi4vLi4vLi4vY29tbW9uJ1xyXG5cclxuZXhwb3J0IGxldCBfYW5zd2VyID0ge1xyXG5cclxuICBhc3luYyBjcmVhdGUoYnV0dG9uKSB7XHJcblxyXG4gICAgbGV0IHF1ZXN0aW9uID0gYnV0dG9uLmNsb3Nlc3QoJy5xdWVzdGlvbi1lZGl0JylcclxuICAgIGxldCBvcGVucXVlc3Rpb25faWQgPSBxdWVzdGlvbi5pZFxyXG4gICAgbGV0IHNvcnQgPSBxdWVzdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCcuYW5zd2VyJykubGVuZ3RoICsgMVxyXG4gICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9vcGVuYW5zd2VyL3VwZGF0ZU9yQ3JlYXRlJyxcclxuICAgICAge29wZW5xdWVzdGlvbl9pZCwgc29ydH0pXHJcbiAgICBsZXQgaWQgPSByZXMuYXJyLmlkXHJcbiAgICBpZiAoaWQpIHtcclxuICAgICAgbGV0IGh0bWwgPSByZXMuaHRtbFxyXG4gICAgICBidXR0b24uaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlYmVnaW5cIiwgaHRtbClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBvcHVwLnNob3coJ9Ch0L7RhdGA0LDQvdC10L3QvicpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgYXN5bmMgZGVsKHRhcmdldCkge1xyXG4gICAgbGV0IGRlbF9idXR0b24gPSB0YXJnZXQuY2xvc2VzdCgnLmRlbGV0ZScpXHJcbiAgICBpZiAoIWRlbF9idXR0b24pIHJldHVybiBmYWxzZVxyXG4gICAgaWYgKGNvbmZpcm0oXCLQo9C00LDQu9C40YLRjCDRjdGC0L7RgiDQvtGC0LLQtdGCP1wiKSkge1xyXG4gICAgICBsZXQgYW5zd2VyID0gZGVsX2J1dHRvbi5jbG9zZXN0KCcuYW5zd2VyJylcclxuICAgICAgbGV0IGlkID0gK2Fuc3dlci5kYXRhc2V0WydhbnN3ZXJJZCddXHJcbiAgICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KCcvb3BlbmFuc3dlci9kZWxldGUnLCB7aWR9KVxyXG5cclxuICAgICAgaWYgKHJlcy5tc2cgPT09ICdvaycpIHtcclxuICAgICAgICBhbnN3ZXIucmVtb3ZlKClcclxuICAgICAgICBwb3B1cC5zaG93KCfQntGC0LLQtdGCINGD0LTQsNC70LXQvScpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG59XHJcbiIsImltcG9ydCAnLi90ZXN0LWVkaXQuc2NzcydcclxuaW1wb3J0ICcuLi9jb21wb25lbnRzL2Zvb3Rlci9mb290ZXIuc2NzcydcclxuXHJcbmltcG9ydCAnLi90ZXN0LWVkaXQtbWVudS5zY3NzJ1xyXG5pbXBvcnQgJy4uL2NvbXBvbmVudHMvcG9wdXAuc2NzcydcclxuXHJcbmltcG9ydCAnLi90ZXN0LXVwZGF0ZSdcclxuaW1wb3J0ICcuLi9BZG1pbi9hZG1pbidcclxuXHJcbmltcG9ydCB7JCwgcG9zdCwgcG9wdXAsIGRlYm91bmNlfSBmcm9tICcuLi9jb21tb24nXHJcblxyXG5pbXBvcnQge19vcGVucXVlc3Rpb259IGZyb20gXCIuL21vZGVsL29wZW50ZXN0L29wZW5xdWVzdGlvblwiXHJcbmltcG9ydCBzb3J0YWJsZSBmcm9tIFwiLi4vY29tcG9uZW50cy9zb3J0YWJsZVwiXHJcbmltcG9ydCBfdGVzdCBmcm9tIFwiLi9tb2RlbC9vcGVudGVzdC9vcGVudGVzdFwiO1xyXG5pbXBvcnQge19hbnN3ZXJ9IGZyb20gXCIuL21vZGVsL29wZW50ZXN0L29wZW5hbnN3ZXJcIjtcclxuXHJcblxyXG5sZXQgb3BlbnRlc3RFZGl0ID0gJCgnLm9wZW50ZXN0LWVkaXQtd3JhcHBlcicpWzBdXHJcbmlmIChvcGVudGVzdEVkaXQpIHtcclxuXHJcbiAgc29ydGFibGUoJy5vcGVudGVzdC1lZGl0LXdyYXBwZXIgLnF1ZXN0aW9ucycsXHJcbiAgICAnLm9wZW50ZXN0LWVkaXQtd3JhcHBlciAucXVlc3Rpb24tZWRpdCcsXHJcbiAgICAnb3BlbnF1ZXN0aW9uJylcclxuXHJcblxyXG4gICQob3BlbnRlc3RFZGl0KS5vbignY2hhbmdlJywgaGFuZGxlQ2hhbmdlKVxyXG5cclxuICAkKG9wZW50ZXN0RWRpdCkub24oJ2NsaWNrJywgKHt0YXJnZXR9KSA9PiB7XHJcbiAgICAgIGNvbnN0IHRlc3QgPSBuZXcgX3Rlc3QoKVxyXG4gICAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygndGVzdC1wYXRoX191cGRhdGUnKSkge1xyXG4gICAgICAgIHRlc3QudXBkYXRlKClcclxuICAgICAgfSBlbHNlIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCd0ZXN0X191cGRhdGUnKSkge1xyXG4gICAgICAgIHRlc3QudXBkYXRlKClcclxuICAgICAgfSBlbHNlIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCd0ZXN0X19zYXZlJykpIHtcclxuICAgICAgICB0ZXN0LnVwZGF0ZSgpXHJcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygndGVzdF9fZGVsZXRlJykpIHtcclxuICAgICAgICB0ZXN0LmRlbGV0ZSgpXHJcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygndGVzdC1wYXRoX19jcmVhdGUnKSkge1xyXG4gICAgICAgIHRlc3QucGF0aF9jcmVhdGUoKVxyXG4gICAgICB9IGVsc2UgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3Rlc3RfX2NyZWF0ZScpKSB7XHJcbiAgICAgICAgdGVzdC5jcmVhdGUoKVxyXG4gICAgICB9IGVsc2UgaWYgKCEhdGFyZ2V0LmNsb3Nlc3QoJy5xdWVzdGlvbl9fc2hvdy1hbnN3ZXJzJykpIHtcclxuICAgICAgICBfb3BlbnF1ZXN0aW9uLnNob3dBbnN3ZXJzKHRhcmdldClcclxuICAgICAgfSBlbHNlIGlmICghIXRhcmdldC5jbG9zZXN0KCcucXVlc3Rpb25fX2RlbGV0ZScpKSB7XHJcbiAgICAgICAgX29wZW5xdWVzdGlvbi5kZWwodGFyZ2V0KVxyXG4gICAgICB9IGVsc2UgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3F1ZXN0aW9uX19jcmVhdGUtYnV0dG9uJykpIHtcclxuICAgICAgICBfb3BlbnF1ZXN0aW9uLmNyZWF0ZSh0YXJnZXQpXHJcbiAgICAgIH0gZWxzZSBpZiAoISF0YXJnZXQuY2xvc2VzdCgnLmRlbGV0ZScpKSB7XHJcbiAgICAgICAgX2Fuc3dlci5kZWwodGFyZ2V0KVxyXG4gICAgICB9IGVsc2UgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2Fuc3dlcl9fY3JlYXRlLWJ1dHRvbicpKSB7XHJcbiAgICAgICAgX2Fuc3dlci5jcmVhdGUodGFyZ2V0KVxyXG4gICAgICB9IGVsc2UgaWYgKCEhdGFyZ2V0LmNsb3Nlc3QoJy5xdWVzdGlvbi1lZGl0X19wYXJlbnQtc2VsZWN0JykpIHtcclxuICAgICAgICBfb3BlbnF1ZXN0aW9uLmNoYW5nZVBhcmVudCh0YXJnZXQpXHJcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnbGVkJykpIHtcclxuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSgnYW5pbWF0ZWQnKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgKVxyXG5cclxuICBsZXQgaGFuZGxlS2V5dXAgPSBhc3luYyBmdW5jdGlvbiAoe3RhcmdldH0pIHtcclxuXHJcbiAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygndGV4dCcpKSB7XHJcbiAgICAgIGxldCBhbnN3ZXIgPSB0YXJnZXQuY2xvc2VzdCgnLmFuc3dlcicpXHJcbiAgICAgIGlmIChhbnN3ZXIpIHtcclxuICAgICAgICBzYXZlQW5zd2VyKGFuc3dlcilcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsZXQgaWQgPSB0YXJnZXQuY2xvc2VzdCgnLnF1ZXN0aW9uLWVkaXQnKS5pZFxyXG4gICAgICAgIGxldCBxdWVzdGlvbiA9IHRhcmdldC5pbm5lclRleHRcclxuICAgICAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCgnL2FkbWluc2Mvb3BlbnF1ZXN0aW9uL3VwZGF0ZU9yQ3JlYXRlJyxcclxuICAgICAgICAgIHtpZCwgcXVlc3Rpb259KVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsZXQgZGVib3VuY2VkSW5wdXQgPSBkZWJvdW5jZShoYW5kbGVLZXl1cClcclxuICAkKG9wZW50ZXN0RWRpdCkub24oJ2tleXVwJywgZGVib3VuY2VkSW5wdXQpXHJcblxyXG59XHJcblxyXG5cclxuYXN5bmMgZnVuY3Rpb24gc2F2ZUFuc3dlcihhbnN3ZXJFbCkge1xyXG4gIGxldCBpZCA9IGFuc3dlckVsLmRhdGFzZXQuYW5zd2VySWRcclxuICBsZXQgaXNfY29ycmVjdCA9ICthbnN3ZXJFbC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpLmNoZWNrZWRcclxuICBsZXQgb3BlbnF1ZXN0aW9uX2lkID0gYW5zd2VyRWwuY2xvc2VzdCgnLnF1ZXN0aW9uLWVkaXQnKS5pZFxyXG4gIGxldCBhbnN3ZXIgPSBhbnN3ZXJFbC5xdWVyeVNlbGVjdG9yKCcudGV4dCcpLmlubmVyVGV4dFxyXG4gIGxldCByZXMgPSBhd2FpdCBwb3N0KCcvYWRtaW5zYy9vcGVuYW5zd2VyL3VwZGF0ZU9yQ3JlYXRlJyxcclxuICAgIHtpZCwgYW5zd2VyLCBvcGVucXVlc3Rpb25faWQsIGlzX2NvcnJlY3R9KVxyXG5cclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKHt0YXJnZXR9KSB7XHJcbiAgbGV0IGFuc3dlciA9IHRhcmdldC5jbG9zZXN0KCcuYW5zd2VyJylcclxuXHJcbiAgaWYgKGFuc3dlcikge1xyXG4gICAgc2F2ZUFuc3dlcihhbnN3ZXIpXHJcbiAgfVxyXG5cclxufVxyXG5cclxuXHJcblxyXG4iLCJpbXBvcnQgeyQsIHBvc3QsIHRyaW1TdHIsIHBvcHVwfSBmcm9tICcuLi8uLi9jb21tb24nXHJcblxyXG5jbGFzcyBhbnN3ZXIge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc2F2ZUFuc3dlcih0YXJnZXQpIHtcclxuICAgIGxldCBxX2lkID0gdGFyZ2V0LmNsb3Nlc3QoJy5xdWVzdGlvbi1lZGl0JykuZGF0YXNldC5pZFxyXG4gICAgbGV0IGVsID0gdGFyZ2V0LmNsb3Nlc3QoJy5hbnN3ZXInKVxyXG4gICAgbGV0IGFuc3dlciA9IHRoaXMuZ2V0QW5zd2VyTW9kZWwoZWwsIHFfaWQpXHJcbiAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCgnL2FkbWluc2MvYW5zd2VyL3VwZGF0ZU9yQ3JlYXRlJywgYW5zd2VyKVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZGVsKHRhcmdldCkge1xyXG4gICAgbGV0IGVsID0gdGFyZ2V0LmNsb3Nlc3QoJy5hbnN3ZXInKVxyXG5cclxuICAgIGxldCBpZCA9ICt0YXJnZXQuZGF0YXNldC5pZFxyXG4gICAgaWYgKGNvbmZpcm0oJ9Cj0LTQsNC70LjRgtGMPycpKSB7XHJcbiAgICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KGAvYWRtaW5zYy9hbnN3ZXIvZGVsZXRlYCwge2lkfSlcclxuICAgICAgaWYgKHJlcykge1xyXG4gICAgICAgIGVsLnJlbW92ZSgpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGFuc3dlckNyZWF0ZSh0YXJnZXQpIHtcclxuICAgIGxldCBhbnN3ZXIgPSAkKCcuYW5zd2VyX19jcmVhdGUgLmFuc3dlcicpWzBdXHJcbiAgICBsZXQgcXVlc3Rpb24gPSB0YXJnZXQuY2xvc2VzdCgnLnF1ZXN0aW9uLWVkaXQnKVxyXG4gICAgbGV0IHFfaWQgPSArcXVlc3Rpb24uaWRcclxuICAgIGxldCBjbG9uZSA9IGFuc3dlci5jbG9uZU5vZGUodHJ1ZSlcclxuICAgIGxldCBhbnN3ZXJNb2RlbCA9IHRoaXMuZ2V0QW5zd2VyTW9kZWwoY2xvbmUsIHFfaWQpXHJcbiAgICBsZXQgcmVzID0gYXdhaXQgcG9zdChgL2FkbWluc2MvYW5zd2VyL3VwZGF0ZU9yQ3JlYXRlYCwgYW5zd2VyTW9kZWwpXHJcbiAgICBpZiAocmVzKSB7XHJcbiAgICAgIGlmIChyZXMuYXJyLnBvcHVwKSBwb3B1cC5zaG93KHJlcy5hcnIucG9wdXApXHJcbiAgICAgIGlmIChyZXMuYXJyLmlkICkge1xyXG4gICAgICAgIGxldCBzb3J0ID0gcXVlc3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnLmFuc3dlcicpLmxlbmd0aCArIDFcclxuICAgICAgICBjbG9uZS5xdWVyeVNlbGVjdG9yKCcuc29ydCcpLmlubmVyVGV4dCA9IHNvcnRcclxuICAgICAgICBjbG9uZS5xdWVyeVNlbGVjdG9yKCcuZGVsZXRlJykuZGF0YXNldC5pZCA9XHJcbiAgICAgICAgICBjbG9uZS5kYXRhc2V0LmlkID0gcmVzLmFyci5pZFxyXG4gICAgICAgIHRhcmdldC5iZWZvcmUoY2xvbmUpXHJcbiAgICAgIH1cclxuXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXRBbnN3ZXJNb2RlbChlbCwgcV9pZCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaWQ6ICtlbC5kYXRhc2V0LmlkLFxyXG4gICAgICBhbnN3ZXI6IHRyaW1TdHIoJChlbCkuZmluZCgnLnRleHQnKS5pbm5lclRleHQpLFxyXG4gICAgICBxdWVzdGlvbl9pZDogcV9pZCxcclxuICAgICAgY29ycmVjdF9hbnN3ZXI6ICskKGVsKS5maW5kKCdpbnB1dCcpLmNoZWNrZWQsXHJcbiAgICAgIHBpY2E6ICcnLFxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGxldCBfYW5zd2VyID0gbmV3IGFuc3dlcigpXHJcbiIsImltcG9ydCB7JCwgcG9wdXAsIHBvc3QsIHRyaW1TdHJ9IGZyb20gXCIuLi8uLi9jb21tb25cIlxyXG5pbXBvcnQge19hbnN3ZXJ9IGZyb20gXCIuL2Fuc3dlclwiO1xyXG5cclxuY2xhc3MgcXVlc3Rpb24ge1xyXG5cclxuICBjb25zdHJ1Y3RvcihlbCkge1xyXG4gICAgdGhpcy5zb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnF1ZXN0aW9ucz4ucXVlc3Rpb24tZWRpdCcpLmxlbmd0aCsxICA/PyAwXHJcbiAgfVxyXG5cclxuICBhc3luYyBxdWVzdGlvbkNyZWF0ZSh0YXJnZXQpIHtcclxuICAgIGxldCBxdWVzdGlvbiA9ICQoJy5xdWVzdGlvbl9fY3JlYXRlIC5xdWVzdGlvbi1lZGl0JylbMF1cclxuICAgIGxldCBjbG9uZSA9IHF1ZXN0aW9uLmNsb25lTm9kZSh0cnVlKVxyXG4gICAgbGV0IHF1ZXN0aW9uTW9kZWwgPSB0aGlzLmdldFF1ZXN0aW9uTW9kZWwoY2xvbmUpXHJcbiAgICBsZXQgcmVzID0gYXdhaXQgcG9zdChgL2FkbWluc2MvcXVlc3Rpb24vdXBkYXRlT3JDcmVhdGVgLCBxdWVzdGlvbk1vZGVsKVxyXG4gICAgaWYgKHJlcykge1xyXG4gICAgICBjbG9uZS5xdWVyeVNlbGVjdG9yKCcuc29ydCcpLmlubmVyVGV4dCA9IHRoaXMuc29ydFxyXG4gICAgICBjbG9uZS5xdWVyeVNlbGVjdG9yKCcucXVlc3Rpb25fX2RlbGV0ZScpLmRhdGFzZXQuaWQgPVxyXG4gICAgICAgIGNsb25lLmRhdGFzZXQuaWQgPSByZXMuYXJyLmlkXHJcbiAgICAgIHRhcmdldC5iZWZvcmUoY2xvbmUpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXRRdWVzdGlvbk1vZGVsKGVsKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpZDogZWwuZGF0YXNldC5pZCxcclxuICAgICAgcXVzdGlvbjogdHJpbVN0cihlbC5xdWVyeVNlbGVjdG9yKCcudGV4dCcpLmlubmVyVGV4dCksXHJcbiAgICAgIHBhcmVudDogK3dpbmRvdy5sb2NhdGlvbi5ocmVmLnNwbGl0KCcvJykucG9wKCksXHJcbiAgICAgIHNvcnQ6IGVsLnF1ZXJ5U2VsZWN0b3IoJy5zb3J0JykuaW5uZXJUZXh0LFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgY2hhbmdlUGFyZW50KHRhcmdldCkge1xyXG4gICAgZGVidWdnZXJcclxuICAgIGxldCBvcHQgPSB0YXJnZXQub3B0aW9uc1t0YXJnZXQuc2VsZWN0ZWRJbmRleF1cclxuICAgIGxldCBpZCA9IHRhcmdldC5jbG9zZXN0KCcucXVlc3Rpb24tZWRpdCcpLmlkXHJcbiAgICBsZXQgdGVzdF9pZCA9IG9wdC5kYXRhc2V0WydxdWVzdGlvblBhcmVudElkJ11cclxuICAgIGxldCB0ZXN0X25hbWUgPSBvcHQudmFsdWVcclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KCcvYWRtaW5zYy9xdWVzdGlvbi9jaGFuZ2VQYXJlbnQnLCB7aWQsIHRlc3RfaWR9KVxyXG4gICAgbGV0IHF1ZXN0aW9uID0gdGFyZ2V0LmNsb3Nlc3QoJy5xdWVzdGlvbi1lZGl0JylcclxuICAgIHF1ZXN0aW9uLnJlbW92ZSgpXHJcbiAgfVxyXG5cclxuICBzaG93QW5zd2Vycyh0YXJnZXQpIHtcclxuICAgIGxldCByb3cgPSB0YXJnZXQuY2xvc2VzdCgnLnF1ZXN0aW9uLWVkaXQnKVxyXG4gICAgbGV0IGFuc3dlcnMgPSAkKHJvdykuZmluZCgnLnF1ZXN0aW9uX19hbnN3ZXJzJylcclxuICAgIGFuc3dlcnMuY2xhc3NMaXN0LnRvZ2dsZSgnaGVpZ2h0JylcclxuICAgIGFuc3dlcnMuY2xhc3NMaXN0LnRvZ2dsZSgnc2NhbGUnKVxyXG4gICAgdGFyZ2V0LmNsYXNzTGlzdC50b2dnbGUoJ3JvdGF0ZScpXHJcbiAgfVxyXG5cclxuICBhc3luYyBkZWwodGFyZ2V0KSB7XHJcbiAgICBsZXQgbW9kZWwgPSB0YXJnZXQuZGF0YXNldC5tb2RlbFxyXG4gICAgbGV0IGVsID0gbnVsbFxyXG4gICAgaWYgKG1vZGVsID09PSAnYW5zd2VyJykge1xyXG4gICAgICBlbCA9IHRhcmdldC5jbG9zZXN0KCcuYW5zd2VyJylcclxuICAgIH0gZWxzZSBpZiAobW9kZWwgPT09ICdxdWVzdGlvbicpIHtcclxuICAgICAgZWwgPSB0YXJnZXQuY2xvc2VzdCgnLnF1ZXN0aW9uLWVkaXQnKVxyXG4gICAgfVxyXG4gICAgbGV0IGlkID0gK3RhcmdldC5kYXRhc2V0LmlkXHJcbiAgICBpZiAoY29uZmlybSgn0KPQtNCw0LvQuNGC0Yw/JykpIHtcclxuICAgICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoYC9hZG1pbnNjLyR7bW9kZWx9L2RlbGV0ZWAsIHtpZH0pXHJcbiAgICAgIGlmIChyZXMpIHtcclxuICAgICAgICBlbC5yZW1vdmUoKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBzYXZlUXVlc3Rpb24odGFyZ2V0KSB7XHJcbiAgICBsZXQgZWwgPSB0YXJnZXQuY2xvc2VzdCgnLnF1ZXN0aW9uLWVkaXQnKVxyXG4gICAgbGV0IHF1ZXN0aW9uID0gX3F1ZXN0aW9uLmdldFF1ZXN0aW9uTW9kZWwoZWwpXHJcbiAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCgnL2FkbWluc2MvcXVlc3Rpb24vVXBkYXRlT3JDcmVhdGUnLCBxdWVzdGlvbilcclxuICB9XHJcblxyXG4gIC8vIGdldEFuc3dlcnMocXVlc3Rpb24pIHtcclxuICAvLyAgIGxldCBhbnN3ZXJzID0gcXVlc3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnLmFuc3dlcicpXHJcbiAgLy8gICByZXR1cm4gWy4uLmFuc3dlcnNdLm1hcCgoYSkgPT4ge1xyXG4gIC8vICAgICByZXR1cm4ge1xyXG4gIC8vICAgICAgIGlkOiArYS5kYXRhc2V0WydhbnN3ZXJJZCddLFxyXG4gIC8vICAgICAgIGFuc3dlcjogYS5xdWVyeVNlbGVjdG9yKCcudGV4dCcpLmlubmVyVGV4dCxcclxuICAvLyAgICAgICBjb3JyZWN0X2Fuc3dlcjogK2EucXVlcnlTZWxlY3RvcignW3R5cGU9XCJjaGVja2JveFwiXScpLmNoZWNrZWQsXHJcbiAgLy8gICAgICAgcXVlc3Rpb25faWQ6ICtxdWVzdGlvbi5pZCxcclxuICAvLyAgICAgICBwaWNhOiAnJyxcclxuICAvLyAgICAgfVxyXG4gIC8vICAgfSwgcXVlc3Rpb24pXHJcbiAgLy8gfVxyXG59XHJcblxyXG5leHBvcnQgbGV0IF9xdWVzdGlvbiA9IG5ldyBxdWVzdGlvblxyXG4iLCJpbXBvcnQgeyQsIHBvcHVwLCBwb3N0fSBmcm9tICcuLi8uLi9jb21tb24nXHJcblxyXG5leHBvcnQgY29uc3QgX3Rlc3QgPSB7XHJcblxyXG5cclxuICB2aWV3TW9kZWw6ICgpID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOiArd2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoJy8nKS5wb3AoKSxcclxuICAgICAgbmFtZTogJCgnI3Rlc3RfbmFtZScpLnRleHQoKSxcclxuICAgICAgZW5hYmxlOiAkKCcjZW5hYmxlJylbMF0sXHJcbiAgICAgIHBhcmVudDogJCgnc2VsZWN0Jykuc2VsZWN0ZWRJbmRleFZhbHVlKCksXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgY2hpbGRyZW46ICgpID0+IHtcclxuICAgIGxldCBjaGlsZHJlbkxlbmdodCA9ICQoJy5jaGlsZHJlbicpLmxlbmd0aFxyXG4gICAgaWYgKGNoaWxkcmVuTGVuZ2h0KVxyXG4gICAgICByZXR1cm4gY2hpbGRyZW5MZW5naHRcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH0sXHJcblxyXG4gIHBhdGhfY3JlYXRlOiBhc3luYyAoKSA9PiB7XHJcbiAgICBsZXQgdGVzdF9wYXRoID0gX3Rlc3Quc2VydmVyTW9kZWwoKVxyXG4gICAgdGVzdF9wYXRoLmlkID0gMFxyXG4gICAgdGVzdF9wYXRoLmlzVGVzdCA9IDBcclxuICAgIGxldCB1cmwgPSBgL2FkbWluc2MvdGVzdC91cGRhdGVPckNyZWF0ZWBcclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KHVybCwgdGVzdF9wYXRoKVxyXG4gICAgaWYgKHJlcykge1xyXG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGAvYWRtaW5zYy90ZXN0L2VkaXQvJHtyZXMuYXJyLmlkIH1gXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgaWQ6IChpZCkgPT4ge1xyXG4gICAgcmV0dXJuIGlkID8/ICQoJy50ZXN0LW5hbWUnKVswXS5kYXRhc2V0LnRlc3RpZFxyXG4gIH0sXHJcbiAgbmFtZTogKCkgPT4ge1xyXG4gICAgcmV0dXJuICQoJy50ZXN0LW5hbWUnKVswXS5pbm5lclRleHRcclxuICB9LFxyXG5cclxuICBjcmVhdGU6IGFzeW5jICgpID0+IHtcclxuICAgIGxldCB0ZXN0ID0gX3Rlc3Quc2VydmVyTW9kZWwoKVxyXG4gICAgdGVzdC5pZCA9IDBcclxuICAgIHRlc3QuaXNUZXN0ID0gMVxyXG4gICAgbGV0IHVybCA9IGAvdGVzdC91cGRhdGVPckNyZWF0ZWBcclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KHVybCwgdGVzdClcclxuICAgIGRlYnVnZ2VyXHJcbiAgICBpZiAocmVzKSB7XHJcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYC9hZG1pbnNjL3Rlc3QvZWRpdC8ke3Jlcy5hcnIuaWR9YFxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG5cclxuICBzZXJ2ZXJNb2RlbDogKCkgPT4ge1xyXG4gICAgbGV0IGlkID0gISErd2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoJy8nKS5wb3AoKVxyXG4gICAgaWQgPSBpZCA/IGlkIDogMFxyXG4gICAgbGV0IG1vZGVsID0ge1xyXG4gICAgICBpZCxcclxuICAgICAgbmFtZTogJCgnI25hbWUuZmllbGQnKVswXS52YWx1ZSxcclxuICAgICAgaXNUZXN0OiArJCgnW2lzVGVzdF0nKVswXS5nZXRBdHRyaWJ1dGUoJ2lzVGVzdCcpLFxyXG4gICAgfVxyXG4gICAgLy8gZGVidWdnZXJcclxuICAgIGxldCBmaWVsZHMgPSAkKCdbY3VzdG9tLXNlbGVjdF0nKTtcclxuICAgIFtdLmZvckVhY2guY2FsbChmaWVsZHMsIGZ1bmN0aW9uIChmaWVsZCkge1xyXG4gICAgICBtb2RlbFtmaWVsZC5kYXRhc2V0WydmaWVsZCddXSA9IGZpZWxkLmRhdGFzZXRbJ2lkJ11cclxuICAgIH0pXHJcbiAgICByZXR1cm4gbW9kZWxcclxuICB9LFxyXG5cclxuICB1cGRhdGU6IGFzeW5jICgpID0+IHtcclxuICAgIGxldCBtb2RlbCA9IF90ZXN0LnNlcnZlck1vZGVsKClcclxuICAgIGxldCB1cmwgPSBgL2FkbWluc2MvdGVzdC91cGRhdGUvJHttb2RlbC5pZH1gXHJcbiAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCh1cmwsIG1vZGVsKVxyXG4gICAgaWYgKHJlcykge1xyXG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGAvYWRtaW5zYy90ZXN0L2VkaXQvJHttb2RlbC5pZH1gXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZGVsZXRlOiBhc3luYyBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgaWYgKF90ZXN0LmNoaWxkcmVuKCkpIHtcclxuICAgICAgcG9wdXAuc2hvdygn0KHQvdCw0YfQsNC70LAg0YPQtNCw0LvQuNGC0LUg0LLRgdC1INGC0LXRgdGC0Ysg0LjQtyDQv9Cw0L/QutC4JylcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGlkID0gX3Rlc3QuaWQoKVxyXG4gICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9hZG1pbnNjL3Rlc3QvZGVsZXRlJywge2lkfSlcclxuICAgIGlmIChyZXMubm90QWRtaW4pIHtcclxuICAgICAgcG9wdXAuc2hvdygn0JLQuNC00LjQvNC+0YHRgtGMINGC0LXRgdGC0LAg0YHQutGA0YvRgtCwLiDQp9GC0L7QsdGLINGD0LTQsNC70LjRgtGMINC/0L7Qu9C90L7RgdGC0YzRjiAtINC+0LHRgNCw0YLQuNGC0LXRgdGMINC6INCT0JQnKVxyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24gPSAnL2FkbWluc2MvdGVzdC9lZGl0LzQwMCdcclxuICAgICAgfSwgNDAwMClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHdpbmRvdy5sb2NhdGlvbiA9ICcvYWRtaW5zYy90ZXN0L2VkaXQvNDAwJ1xyXG4gICAgfVxyXG5cclxuICB9LFxyXG4gIC8vIHNlbGVjdGVkVmFsdWVDdXN0b21TZWxlY3QoY2xhc3NOYW1lKSB7XHJcbiAgLy8gICBsZXQgc2VsZWN0ID0gJChgW2RhdGEtZmllbGQ9JHtjbGFzc05hbWV9XWApWzBdXHJcbiAgLy8gICBsZXQgc2VsZWN0ZWQgPSBbLi4uc2VsZWN0Lm9wdGlvbnNdLmZpbHRlcigob3B0KSA9PiBvcHQuc2VsZWN0ZWQpXHJcbiAgLy8gICBpZiAoc2VsZWN0ZWQpIHtcclxuICAvLyAgICAgcmV0dXJuICtzZWxlY3RlZFswXS52YWx1ZVxyXG4gIC8vICAgfVxyXG4gIC8vIH0sXHJcblxyXG59XHJcbiIsImltcG9ydCAnLi90ZXN0LWVkaXQuc2NzcydcclxuaW1wb3J0ICcuLi9jb21wb25lbnRzL2Zvb3Rlci9mb290ZXIuc2NzcydcclxuXHJcbmltcG9ydCAnLi90ZXN0LWVkaXQtbWVudS5zY3NzJ1xyXG5cclxuaW1wb3J0ICcuL3Rlc3QtdXBkYXRlJ1xyXG5cclxuaW1wb3J0IHskLCBkZWJvdW5jZX0gZnJvbSAnLi4vY29tbW9uJ1xyXG5cclxuaW1wb3J0IHtfcXVlc3Rpb259IGZyb20gXCIuL21vZGVsL3F1ZXN0aW9uXCJcclxuaW1wb3J0IHtfdGVzdH0gZnJvbSBcIi4vbW9kZWwvdGVzdFwiO1xyXG5pbXBvcnQge19hbnN3ZXJ9IGZyb20gXCIuL21vZGVsL2Fuc3dlclwiO1xyXG5cclxuaW1wb3J0IHNvcnRhYmxlIGZyb20gXCIuLi9jb21wb25lbnRzL3NvcnRhYmxlXCJcclxuaW1wb3J0IFdEU1NlbGVjdCBmcm9tIFwiLi4vY29tcG9uZW50cy9zZWxlY3QvV0RTU2VsZWN0XCJcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0ZXN0RWRpdCgpIHtcclxuXHJcbiAgbGV0IHRlc3RFZGl0ID0gJCgnLnRlc3QtZWRpdC13cmFwcGVyJylbMF1cclxuICBpZiAodGVzdEVkaXQpIHtcclxuXHJcbiAgICBzb3J0YWJsZSgnLnRlc3QtZWRpdC13cmFwcGVyIC5xdWVzdGlvbnMnLFxyXG4gICAgICAnLnF1ZXN0aW9ucz4ucXVlc3Rpb24tZWRpdCcsXHJcbiAgICAgICdxdWVzdGlvbicpXHJcbiAgICAvLyBjdXN0b21TZWxlY3QoKVxyXG5cclxuICAgICQodGVzdEVkaXQpLm9uKCdrZXl1cCcsIGRlYm91bmNlZEhhbmRsZUtleXVwKVxyXG4gICAgJCh0ZXN0RWRpdCkub24oJ2NoYW5nZScsIGhhbmRsZUNoYW5nZSlcclxuICAgICQodGVzdEVkaXQpLm9uKCdjbGljaycsIGhhbmRsZUNsaWNrKVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlQ2xpY2soe3RhcmdldH0pIHtcclxuXHJcbiAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3Rlc3QtcGF0aF9fdXBkYXRlJykpIHtcclxuICAgIF90ZXN0LnVwZGF0ZSgpXHJcbiAgfSBlbHNlIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCd0ZXN0X191cGRhdGUnKSkge1xyXG4gICAgX3Rlc3QudXBkYXRlKClcclxuICB9IGVsc2UgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3Rlc3RfX3NhdmUnKSkge1xyXG4gICAgX3Rlc3QudXBkYXRlKClcclxuICB9IGVsc2UgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3Rlc3RfX2RlbGV0ZScpKSB7XHJcbiAgICBfdGVzdC5kZWxldGUoKVxyXG4gIH0gZWxzZSBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygndGVzdC1wYXRoX19jcmVhdGUnKSkge1xyXG4gICAgX3Rlc3QucGF0aF9jcmVhdGUoKVxyXG4gIH0gZWxzZSBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygndGVzdF9fY3JlYXRlJykpIHtcclxuICAgIF90ZXN0LmNyZWF0ZSgpXHJcbiAgfSBlbHNlIGlmICghIXRhcmdldC5jbG9zZXN0KCcucXVlc3Rpb25fX3Nob3ctYW5zd2VycycpKSB7XHJcbiAgICBfcXVlc3Rpb24uc2hvd0Fuc3dlcnModGFyZ2V0KVxyXG4gIH0gZWxzZSBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygncXVlc3Rpb25fX2NyZWF0ZS1idXR0b24nKSkge1xyXG4gICAgX3F1ZXN0aW9uLnF1ZXN0aW9uQ3JlYXRlKHRhcmdldClcclxuICB9IGVsc2UgaWYgKCEhdGFyZ2V0LmNsb3Nlc3QoJy5xdWVzdGlvbl9fZGVsZXRlJykpIHtcclxuICAgIF9xdWVzdGlvbi5kZWwodGFyZ2V0KVxyXG4gIH0gZWxzZSBpZiAoISF0YXJnZXQuY2xvc2VzdCgnLmRlbGV0ZScpKSB7XHJcbiAgICBfYW5zd2VyLmRlbCh0YXJnZXQpXHJcbiAgfSBlbHNlIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhbnN3ZXJfX2NyZWF0ZS1idXR0b24nKSkge1xyXG4gICAgX2Fuc3dlci5hbnN3ZXJDcmVhdGUodGFyZ2V0KVxyXG4gIH0gZWxzZSBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnY29ycmVjdCcpKSB7XHJcbiAgICBfYW5zd2VyLnNhdmVBbnN3ZXIodGFyZ2V0KVxyXG4gIH1cclxufVxyXG5cclxubGV0IGRlYm91bmNlZEhhbmRsZUtleXVwID0gZGVib3VuY2UoaGFuZGxlS2V5dXApXHJcblxyXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVLZXl1cCh7dGFyZ2V0fSkge1xyXG4gIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCd0ZXh0JykpIHtcclxuICAgIGxldCBhbnN3ZXIgPSB0YXJnZXQuY2xvc2VzdCgnLmFuc3dlcicpXHJcbiAgICBpZiAoYW5zd2VyKSB7XHJcbiAgICAgIF9hbnN3ZXIuc2F2ZUFuc3dlcih0YXJnZXQpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBfcXVlc3Rpb24uc2F2ZVF1ZXN0aW9uKHRhcmdldClcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZUNoYW5nZSh7dGFyZ2V0fSkge1xyXG4gIGlmICghIXRhcmdldC5jbG9zZXN0KCcucXVlc3Rpb24tZWRpdF9fcGFyZW50LXNlbGVjdCcpKSB7XHJcbiAgICBfcXVlc3Rpb24uY2hhbmdlUGFyZW50KHRhcmdldClcclxuICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbiIsImltcG9ydCAnLi90ZXN0LXBhZ2luYXRpb24uc2NzcydcclxuaW1wb3J0IHskfSBmcm9tIFwiLi4vLi4vY29tbW9uXCI7XHJcblxyXG5sZXQgcGFnaW5hdGlvbiA9ICQoJy5wYWdpbmF0aW9uJylbMF1cclxuXHJcbmlmIChwYWdpbmF0aW9uKSB7XHJcbiAgbmF2SW5pdCgpXHJcbiAgJChwYWdpbmF0aW9uKS5vbignY2xpY2snLCBoYW5kbGVDbGljaylcclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlQ2xpY2soe3RhcmdldH0pIHtcclxuXHJcbiAgaWYgKCF0YXJnZXQuZGF0YXNldC5wYWdpbmF0aW9uKSByZXR1cm47XHJcblxyXG4gIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSkgcmV0dXJuXHJcblxyXG4gIGxldCBhY3RpdmVfYnRuID0gJCgnLnBhZ2luYXRpb24gLmFjdGl2ZScpWzBdXHJcbiAgYWN0aXZlX2J0bi5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKVxyXG4gIHRhcmdldC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKVxyXG5cclxuICBsZXQgaWRfdG9faGlkZSA9IGFjdGl2ZV9idG4uZGF0YXNldFsncGFnaW5hdGlvbiddXHJcbiAgJChgLnF1ZXN0aW9uW2RhdGEtaWQ9XCIke2lkX3RvX2hpZGV9XCJdYCkucmVtb3ZlQ2xhc3MoJ3Nob3cnKVxyXG5cclxuICBsZXQgaWRfdG9fc2hvdyA9IHRhcmdldC5kYXRhc2V0WydwYWdpbmF0aW9uJ11cclxuICAkKGAucXVlc3Rpb25bZGF0YS1pZD1cIiR7aWRfdG9fc2hvd31cIl1gKS5hZGRDbGFzcygnc2hvdycpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5hdkluaXQoKSB7XHJcbiAgbGV0IG5hdl9idXR0b25zID0gJCgnW2RhdGEtcGFnaW5hdGlvbl0nKVxyXG4gIGlmICghbmF2X2J1dHRvbnNbMF0pIHJldHVybiBmYWxzZVxyXG4gIEFycmF5LmZyb20obmF2X2J1dHRvbnMpLm1hcCgobmF2KSA9PiB7XHJcbiAgICBuYXYuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJylcclxuICB9KVxyXG4gIG5hdl9idXR0b25zWzBdLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpXHJcbn1cclxuXHJcbi8vIGV4cG9ydCB7bmF2SW5pdH1cclxuXHJcblxyXG4iLCJpbXBvcnQgJy4vZG8uc2NzcydcclxuaW1wb3J0ICcuL3Rlc3QtcGFnaW5hdGlvbi90ZXN0LXBhZ2luYXRpb24nXHJcblxyXG5pbXBvcnQge3Bvc3QsICQsIGNhY2hlUGFnZX0gZnJvbSAnLi4vY29tbW9uJ1xyXG5cclxubGV0IHRlc3REbyA9ICQoJy50ZXN0LWRvJylcclxuaWYgKHRlc3REbykge1xyXG4gIHNob3dGaXJzdFF1ZXN0KClcclxuICBmaW5pc2hCdG5Jbml0KClcclxuICAkKCcudGVzdC1kbycpLm9uKCdjbGljaycsIGhhbmRsZUNsaWNrKVxyXG59XHJcblxyXG5mdW5jdGlvbiBmaW5pc2hCdG5Jbml0KCkge1xyXG4gIGxldCBidXR0b24gPSAkKCcudGVzdC1kb19fZmluaXNoLWJ0bicpWzBdXHJcbiAgaWYgKGJ1dHRvbikge1xyXG4gICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS5tYXRjaCgnXi90ZXN0L3Jlc3VsdC8uPycpKSB7XHJcbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdpbmFjdGl2ZScpXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVDbGljayh7dGFyZ2V0fSkge1xyXG4gIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY2NvcmRpb24tb3BlbicpKSByZXR1cm5cclxuICBsZXQgY3VyclF1ZXN0ID0gJCgnLnF1ZXN0aW9uLnNob3cnKVswXT8/JydcclxuICBsZXQgaWQgPSArY3VyclF1ZXN0Py5kYXRhc2V0LmlkPz8nJ1xyXG4gIGxldCBuYXZzID0gJCgnW2RhdGEtcGFnaW5hdGlvbl0nKT8/JydcclxuICBsZXQgbmF2SW5kZXggPSBuYXZzLmZpbmRJbmRleChlbD0+ZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSk/PycnXHJcblxyXG4gIGlmICh0YXJnZXQudHlwZSA9PT0gXCJjaGVja2JveFwiKSB7XHJcbiAgICBsZXQgYSA9IHRhcmdldC5sYWJlbHNbMF1cclxuICAgIGEuY2xhc3NMaXN0LnRvZ2dsZSgncHVzaGVkJylcclxuICB9IGVsc2UgaWYgKHRhcmdldC5pZCA9PT0gJ3ByZXYnKSB7XHJcbiAgICBwcmV2USgpXHJcbiAgfSBlbHNlIGlmICh0YXJnZXQuaWQgPT09ICduZXh0Jykge1xyXG4gICAgbmV4dFEoKVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcHJldlEoKSB7XHJcbiAgICBpZiAobmF2SW5kZXggPCAxKSByZXR1cm4gZmFsc2VcclxuICAgIGxldCBhaW1JZCA9ICtuYXZzW25hdkluZGV4IC0gMV0uZGF0YXNldC5wYWdpbmF0aW9uXHJcbiAgICBwdXNoTmF2KGlkLCBhaW1JZClcclxuICAgIHB1c2hRKGFpbUlkKVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbmV4dFEoKSB7XHJcbiAgICBpZiAobmF2SW5kZXggPT09IG5hdnMubGVuZ3RoLTEpIHJldHVybiBmYWxzZVxyXG4gICAgbGV0IGFpbUlkID0gK25hdnNbbmF2SW5kZXggKyAxXS5kYXRhc2V0LnBhZ2luYXRpb25cclxuXHJcbiAgICBwdXNoTmF2KGlkLCBhaW1JZClcclxuICAgIHB1c2hRKGFpbUlkKVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcHVzaE5hdihjdXJyZW50SWQsIGFpbU5hdklkKSB7XHJcbiAgICBsZXQgY3Vyck5hdkVsID0gJChgW2RhdGEtcGFnaW5hdGlvbj1cIiR7Y3VycmVudElkfVwiXWApWzBdXHJcbiAgICBjdXJyTmF2RWwuY2xhc3NMaXN0LnRvZ2dsZSgnYWN0aXZlJylcclxuXHJcbiAgICBsZXQgTmF2RWwgPSAkKGBbZGF0YS1wYWdpbmF0aW9uPVwiJHthaW1OYXZJZH1cIl1gKVswXVxyXG4gICAgTmF2RWwuY2xhc3NMaXN0LnRvZ2dsZSgnYWN0aXZlJylcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHB1c2hRKGFpbUlkKSB7XHJcbiAgICBjdXJyUXVlc3QuY2xhc3NMaXN0LnRvZ2dsZSgnc2hvdycpXHJcbiAgICBsZXQgYWltUXVlc3Rpb24gPSAkKGAucXVlc3Rpb25bZGF0YS1pZD1cIiR7YWltSWR9XCJdYClbMF1cclxuICAgIGFpbVF1ZXN0aW9uLmNsYXNzTGlzdC50b2dnbGUoJ3Nob3cnKVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2hvd0ZpcnN0UXVlc3QoKSB7XHJcbiAgJCgnLnF1ZXN0aW9uJykucmVtb3ZlQ2xhc3MoXCJzaG93XCIpXHJcbiAgJCgnLnF1ZXN0aW9uOmZpcnN0LWNoaWxkJykuYWRkQ2xhc3MoXCJzaG93XCIpXHJcbn1cclxuXHJcbiQoJy50ZXN0LWRvX19maW5pc2gtYnRuJykub24oJ2NsaWNrJywgYXN5bmMgZnVuY3Rpb24gKGUpIHtcclxuXHJcbiAgbGV0IGJ1dHRvbiA9IGUudGFyZ2V0O1xyXG4gIGlmIChidXR0b24uaWQgIT09ICdidG5uJykgcmV0dXJuIGZhbHNlXHJcblxyXG4gIGlmIChidXR0b24udGV4dCA9PT0gXCLQn9Cg0J7QmdCi0Jgg0KLQldCh0KIg0JfQkNCd0J7QktCeXCIpIHtcclxuICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBidXR0b24udGV4dCA9IFwi0J/QoNCe0JnQotCYINCi0JXQodCiINCX0JDQndCe0JLQnlwiXHJcblxyXG4gIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdpbmFjdGl2ZScpXHJcblxyXG4gIGxldCBjb3JyQW5zd2VycyA9IGF3YWl0IHBvc3QoJy90ZXN0L2dldENvcnJlY3RBbnN3ZXJzJywge30pXHJcbiAgY29yckFuc3dlcnMgPSBjb3JyQW5zd2Vyc1snYXJyJ11cclxuICBsZXQgZXJyb3JDbnQgPSBjb2xvclZpZXcoY29yckFuc3dlcnMpXHJcblxyXG4gIGxldCBkYXRhID0gb2JqVG9TZXJ2ZXIoZXJyb3JDbnQpXHJcbiAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9hZG1pbnNjL3Rlc3RyZXN1bHQvY3JlYXRlJywgZGF0YSlcclxuICBpZiAocmVzKSB7XHJcbiAgICAkKFwiI2J0bm5cIilbMF0uaHJlZiA9IGxvY2F0aW9uLmhyZWZcclxuICAgICQoXCIjYnRublwiKVswXS50ZXh0ID0gXCLQn9Cg0J7QmdCi0Jgg0KLQldCh0KIg0JfQkNCd0J7QktCeXCJcclxuICB9XHJcbn0pXHJcblxyXG5cclxuZnVuY3Rpb24gb2JqVG9TZXJ2ZXIoZXJyb3JDbnQpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcXVlc3Rpb25DbnQ6ICQoJy5xdWVzdGlvbicpLmxlbmd0aCxcclxuICAgIGVycm9yQ250OiBlcnJvckNudCxcclxuICAgIGh0bWw6IGNhY2hlUGFnZSgnLnRlc3QtZG8nKSxcclxuICAgIHRlc3RpZDogJCgnW2RhdGEtdGVzdC1pZF0nKVswXS5kYXRhc2V0LnRlc3RJZCxcclxuICAgIHRlc3RuYW1lOiAkKCcudGVzdC1uYW1lJylbMF0uaW5uZXJUZXh0LFxyXG4gICAgdXNlcjogJCgnLnVzZXItbWVudSAuZmlvJylbMF0uaW5uZXJUZXh0LFxyXG4gIH1cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGNvbG9yVmlldyhjb3JyZWN0QW5zd2Vycykge1xyXG4gIGxldCBxID0gJCgnLnF1ZXN0aW9uJyk7XHJcbiAgW10ubWFwLmNhbGwocSwgZnVuY3Rpb24gKHF1ZXN0aW9uKSB7XHJcbiAgICBsZXQgYW5zd2VycyA9IHF1ZXN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hJylcclxuICAgIGxldCBlcnJvcnMgPSBbXTtcclxuICAgIFtdLm1hcC5jYWxsKGFuc3dlcnMsIGZ1bmN0aW9uIChhbnN3ZXIpIHtcclxuICAgICAgbGV0IGlucHV0ID0gJChhbnN3ZXIpLmZpbmQoJ2lucHV0JylcclxuICAgICAgbGV0IGlkID0gYW5zd2VyLmRhdGFzZXQuaWRcclxuICAgICAgY2hlY2tDb3JyZWN0QW5zd2VycyhlcnJvcnMsIGlkLCBjb3JyZWN0QW5zd2VycywgaW5wdXQsIGFuc3dlcilcclxuICAgIH0pXHJcblxyXG4gICAgbGV0IGlkID0gcXVlc3Rpb24uZGF0YXNldFsnaWQnXSAvLyBpZCBxdWVzdGlvblxyXG4gICAgbGV0IHBhZ2luSXRlbSA9ICQoYC5wYWdpbmF0aW9uIFtkYXRhLXBhZ2luYXRpb249JyR7K2lkfSddYClbMF1cclxuICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XHJcbiAgICAgICQocGFnaW5JdGVtKS5hZGRDbGFzcygncmVkU2hhZG93JylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICQocGFnaW5JdGVtKS5hZGRDbGFzcygnZ3JlZW5TaGFkb3cnKVxyXG4gICAgfVxyXG4gIH0pXHJcbiAgcmV0dXJuICQoJy5yZWRTaGFkb3cnKS5sZW5ndGhcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tDb3JyZWN0QW5zd2VycyhlcnJvcnMsIGlkLCBjb3JyZWN0QW5zd2VycywgaW5wdXQsIGFuc3dlcikge1xyXG4gIGxldCBjb3JyZWN0QW5zZXIgPSBjb3JyZWN0QW5zd2Vycy5pbmRleE9mKGlkKSAhPT0gLTFcclxuICBsZXQgY2hlY2tlZCA9IGlucHV0LmNoZWNrZWRcclxuXHJcbiAgaWYgKGNoZWNrZWQgJiYgY29ycmVjdEFuc2VyKSB7Ly8gY2hlY2tib3gg0L3QsNC20LDRgi4g0LAg0LIgY29ycmVjdCBhbnN3ZXIg0L3QtdGC0YMuINCyIGNvcnJlY3RfYW5zd2VycyDQtdGB0YLRjCwg0LXQs9C+INCy0YHQtdCz0LTQsCDQv9C+0LTRgdCy0LXRh9C40LLQsNC10Lwg0LfQtdC70LXQvdGL0LxcclxuICAgIGFuc3dlci5jbGFzc0xpc3QuYWRkKCdkb25lJyk7IC8vZ3JlZW4gY2hlY2sg0LfQtdC70LXQvdGL0Lkg0LfQvdCw0YfQtdC6XHJcbiAgfSBlbHNlIGlmIChjaGVja2VkICYmICFjb3JyZWN0QW5zZXIpIHsvLyBjaGVja2JveCDQvdCw0LbQsNGCLNC4INC10YHRgtGMINCyIGNvcnJlY3QgYW5zd2VyLiDQsiBjb3JyZWN0X2Fuc3dlcnMg0L3QtdGCLCDQutC90L7Qv9C60LAg0L3QtSDQvdCw0LbQsNGC0LBcclxuICAgIGVycm9ycy5wdXNoKHRydWUpXHJcbiAgfSBlbHNlIGlmICghY2hlY2tlZCAmJiBjb3JyZWN0QW5zZXIpIHsvLyDQutC90L7Qv9C60LAg0L3QtSDQvdCw0LbQsNGC0LAsINCyIGNvcnJlY3RfYW5zd2VycyDQtdGB0YLRjFxyXG4gICAgYW5zd2VyLmNsYXNzTGlzdC5hZGQoJ2RvbmUnKTsgLy9ncmVlbiBjaGVjayDQt9C10LvQtdC90YvQuSDQt9C90LDRh9C10LpcclxuICAgIGVycm9ycy5wdXNoKHRydWUpXHJcbiAgfSBlbHNlIGlmICghY2hlY2tlZCAmJiAhY29ycmVjdEFuc2VyKSB7Ly8g0LrQvdC+0L/QutCwINC90LUg0L3QsNC20LDRgtCwLCDQsiBjb3JyZWN0X2Fuc3dlcnMg0L3QtdGCXHJcbiAgfVxyXG59XHJcblxyXG5cclxuXHJcblxyXG4iLCJpbXBvcnQgJy4vbGlzdC5zY3NzJztcclxuaW1wb3J0IHskLCBwb3N0LCBkZWJvdW5jZX0gZnJvbSAnLi4vLi4vY29tbW9uJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxpc3QoKSB7XHJcbiAgY29uc3QgdGFibGVzID0gJCgnLmN1c3RvbS1saXN0X193cmFwcGVyJylcclxuICBpZiAodGFibGVzKSB7XHJcbiAgICBbXS5mb3JFYWNoLmNhbGwodGFibGVzLCBmdW5jdGlvbiAodGFibGUpIHtcclxuXHJcbiAgICAgIGNvbnN0IGNvbnRlbnRlZGl0YWJsZSA9ICQoJ1tjb250ZW50ZWRpdGFibGVdJylcclxuICAgICAgY29uc3QgaGVhZGVycyA9IHRhYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoJy5oZWFkJylcclxuICAgICAgY29uc3Qgc29ydGFibGVzID0gdGFibGUucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc29ydF0nKVxyXG4gICAgICBjb25zdCBpbnB1dHMgPSAkKHRhYmxlKS5maW5kQWxsKCcuaGVhZCBpbnB1dCcpXHJcbiAgICAgIGNvbnN0IGlkcyA9ICQodGFibGUpWzBdLnF1ZXJ5U2VsZWN0b3JBbGwoJy5pZDpub3QoLmhlYWQnKVxyXG4gICAgICBjb25zdCBtb2RlbE5hbWUgPSB0YWJsZS5kYXRhc2V0Wydtb2RlbCddXHJcbiAgICAgIGNvbnN0IHJvd3MgPSBbXVxyXG5cclxuICAgICAgJCh0YWJsZSkub24oJ2NsaWNrJywgaGFuZGxlQ2xpY2suYmluZCh0aGlzKSk7XHJcbiAgICAgICQodGFibGUpLm9uKCdrZXl1cCcsIGhhbmRsZUtleVVwLmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgbGV0IGRlYm91bmNlZElucHV0ID0gZGVib3VuY2UoaGFuZGxlSW5wdXQpXHJcblxyXG4gICAgICBmdW5jdGlvbiBoYW5kbGVLZXlVcCh7dGFyZ2V0fSkge1xyXG5cclxuICAgICAgICAvLyBjb250ZW50ZWRpdGFibGVcclxuICAgICAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykpIHtcclxuICAgICAgICAgIGRlYm91bmNlZElucHV0KHRhYmxlLCBjb250ZW50ZWRpdGFibGUsIHRhcmdldClcclxuXHJcbiAgICAgICAgICAvLy8gc2VhcmNoXHJcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQuY2xvc2VzdCgnLmhlYWQnKSkge1xyXG4gICAgICAgICAgbGV0IGhlYWRlciA9IHRhcmdldC5jbG9zZXN0KCcuaGVhZCcpXHJcbiAgICAgICAgICBsZXQgaW5kZXggPSBbXS5maW5kSW5kZXguY2FsbChoZWFkZXJzLCAoZWwsIGksIGlucHV0cykgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gZWwgPT09IGhlYWRlclxyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIHNlYXJjaChpbmRleCwgdGFyZ2V0KVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soe3RhcmdldH0pIHtcclxuXHJcbiAgICAgICAgLy8vIGNyZWF0ZVxyXG4gICAgICAgIGlmICh0YXJnZXQuY2xhc3NOYW1lID09PSAnYWRkLW1vZGVsJykge1xyXG4gICAgICAgICAgbW9kZWxDcmVhdGUobW9kZWxOYW1lKVxyXG5cclxuICAgICAgICAgIC8vLyBkZWxldGVcclxuICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgdGFyZ2V0LmNsYXNzTmFtZSA9PT0gJy5kZWw6bm90KC5oZWFkKScgfHxcclxuICAgICAgICAgIHRhcmdldC5jbG9zZXN0KCcuZGVsOm5vdCguaGVhZCknKSkge1xyXG4gICAgICAgICAgbW9kZWxEZWwodGFyZ2V0LmNsb3Nlc3QoJy5kZWw6bm90KC5oZWFkKScpKVxyXG5cclxuICAgICAgICAgIC8vLyBlZGl0XHJcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQuY2xhc3NOYW1lID09PSAnLmVkaXQ6bm90KC5oZWFkKScgfHxcclxuICAgICAgICAgIHRhcmdldC5jbG9zZXN0KCcuZWRpdDpub3QoLmhlYWQpJykpIHtcclxuICAgICAgICAgIGxldCBpZCA9IHRhcmdldC5jbG9zZXN0KCcuZWRpdDpub3QoLmhlYWQpJykuZGF0YXNldFsnaWQnXVxyXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uID0gYC9hZG1pbnNjLyR7bW9kZWxOYW1lfS9lZGl0LyR7aWR9YDtcclxuXHJcbiAgICAgICAgICAvLy8gc29ydFxyXG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnaGVhZCcpKSB7XHJcbiAgICAgICAgICBsZXQgaGVhZGVyID0gdGFyZ2V0LmNsb3Nlc3QoJy5oZWFkJylcclxuICAgICAgICAgIGxldCBpbmRleCA9IFtdLmZpbmRJbmRleC5jYWxsKGhlYWRlcnMsIChlbCwgaSwgaW5wdXRzKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbCA9PT0gaGVhZGVyXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgc29ydENvbHVtbihpbmRleClcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERFTEVURVxyXG4gICAgICBhc3luYyBmdW5jdGlvbiBtb2RlbERlbChlbCkge1xyXG4gICAgICAgIGlmICghY29uZmlybSgn0KPQtNCw0LvQuNGC0Yw/JykpIHJldHVyblxyXG4gICAgICAgIGxldCBpZCA9IGVsLmRhdGFzZXRbJ2lkJ11cclxuICAgICAgICBsZXQgcmVzID0gYXdhaXQgcG9zdChgL2FkbWluc2MvJHttb2RlbE5hbWV9L2RlbGV0ZWAsIHtpZH0pXHJcbiAgICAgICAgaWYgKHJlcykge1xyXG4gICAgICAgICAgZGVsVmlldyhpZClcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGRlbFZpZXcoaWQpIHtcclxuICAgICAgICBsZXQgYXJyID0gJChgW2RhdGEtaWQ9JyR7aWR9J11gKTtcclxuICAgICAgICBbXS5mb3JFYWNoLmNhbGwoYXJyLCBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgIGVsLnJlbW92ZSgpXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIC8vIENSRUFURVxyXG4gICAgICBhc3luYyBmdW5jdGlvbiBtb2RlbENyZWF0ZShtb2RlbE5hbWUsIGUpIHtcclxuICAgICAgICBsZXQgcmVzID0gYXdhaXQgcG9zdChgL2FkbWluc2MvJHttb2RlbE5hbWV9L2NyZWF0ZWAsIHt9KVxyXG4gICAgICAgIGlmIChyZXMuYXJyLmlkKSB7XHJcbiAgICAgICAgICBuZXdSb3cocmVzLmFyci5pZClcclxuICAgICAgICAgIC8vIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYC9hZG1pbnNjLyR7bW9kZWxOYW1lfS9zaG93YFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gbmV3Um93KGlkKSB7XHJcbiAgICAgICAgbGV0IFJvdyA9IFsuLi5yb3dzWzBdXTtcclxuICAgICAgICBbXS5mb3JFYWNoLmNhbGwoUm93LCBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgIGxldCBuZXdFbCA9IGVsLmNsb25lTm9kZSh0cnVlKVxyXG4gICAgICAgICAgbGV0IHRhYmxlQ29udGVudCA9ICQodGFibGUpLmZpbmQoJy5jdXN0b20tbGlzdCcpXHJcbiAgICAgICAgICB0YWJsZUNvbnRlbnQuYXBwZW5kQ2hpbGQobmV3RWwpXHJcbiAgICAgICAgICBpZiAoWydpZCddLmluY2x1ZGVzKG5ld0VsLmNsYXNzTmFtZSkpIHtcclxuICAgICAgICAgICAgbmV3RWwuaW5uZXJUZXh0ID0gaWRcclxuICAgICAgICAgIH0gZWxzZSBpZiAoIVsnZGVsJywgJ2VkaXQnLCAnc2F2ZSddLmluY2x1ZGVzKG5ld0VsLmNsYXNzTmFtZSkpIHtcclxuICAgICAgICAgICAgbmV3RWwuaW5uZXJUZXh0ID0gJydcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG5ld0VsLmRhdGFzZXRbJ2lkJ10gPSBpZFxyXG5cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8vIFNFQVJDSFxyXG4gICAgICBmdW5jdGlvbiBzaG93QWxsUm93cygpIHtcclxuICAgICAgICBbXS5mb3JFYWNoLmNhbGwocm93cywgKHJvdykgPT4ge1xyXG4gICAgICAgICAgW10uZm9yRWFjaC5jYWxsKHJvdywgZWwgPT4ge1xyXG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHNlYXJjaChpbmRleCwgaW5wdXQpIHtcclxuICAgICAgICBzaG93QWxsUm93cygpXHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpbnB1dC52YWx1ZTtcclxuXHJcbiAgICAgICAgW10uZm9yRWFjaC5jYWxsKGlucHV0cywgKGlucCkgPT4ge1xyXG4gICAgICAgICAgaWYgKGlucCAhPT0gaW5wdXQpIGlucC52YWx1ZSA9ICcnXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIFtdLmZvckVhY2guY2FsbChyb3dzLCBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgICBjb25zdCBzdHIgPSByb3dbaW5kZXhdLmlubmVyVGV4dFxyXG4gICAgICAgICAgY29uc3QgcmVnZXhwID0gbmV3IFJlZ0V4cChgJHt2YWx1ZX1gLCAnZ2knKVxyXG4gICAgICAgICAgaWYgKCFzdHIubWF0Y2gocmVnZXhwKSkge1xyXG4gICAgICAgICAgICBbXS5mb3JFYWNoLmNhbGwocm93LCBlbCA9PiB7XHJcbiAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gU09SVFxyXG4gICAgICBmdW5jdGlvbiBzb3J0Q29sdW1uKGluZGV4KSB7XHJcbiAgICAgICAgLy8g0J/QvtC70YPRh9C40YLRjCDRgtC10LrRg9GJ0LXQtSDQvdCw0L/RgNCw0LLQu9C10L3QuNC1XHJcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gZGlyZWN0aW9uc1tpbmRleF0gfHwgJ2FzYydcclxuXHJcbiAgICAgICAgLy8g0KTQsNC60YLQvtGAINC/0L4g0L3QsNC/0YDQsNCy0LvQtdC90LjRjlxyXG4gICAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSAoZGlyZWN0aW9uID09PSAnYXNjJykgPyAxIDogLTFcclxuXHJcbiAgICAgICAgY29uc3QgbmV3Um93cyA9IEFycmF5LmZyb20ocm93cylcclxuXHJcbiAgICAgICAgbmV3Um93cy5zb3J0KGZ1bmN0aW9uIChyb3dBLCByb3dCKSB7XHJcbiAgICAgICAgICBjb25zdCBjZWxsQSA9IHJvd0FbaW5kZXhdLmlubmVySFRNTFxyXG4gICAgICAgICAgY29uc3QgY2VsbEIgPSByb3dCW2luZGV4XS5pbm5lckhUTUxcclxuXHJcbiAgICAgICAgICBjb25zdCBhID0gdHJhbnNmb3JtKGluZGV4LCBjZWxsQSlcclxuICAgICAgICAgIGNvbnN0IGIgPSB0cmFuc2Zvcm0oaW5kZXgsIGNlbGxCKVxyXG5cclxuICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xyXG4gICAgICAgICAgICBjYXNlIGEgPiBiOlxyXG4gICAgICAgICAgICAgIHJldHVybiAxICogbXVsdGlwbGllclxyXG4gICAgICAgICAgICBjYXNlIGEgPCBiOlxyXG4gICAgICAgICAgICAgIHJldHVybiAtMSAqIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgY2FzZSBhID09PSBiOlxyXG4gICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyDQo9C00LDQu9C40YLRjCDRgdGC0LDRgNGL0LUg0YHRgtGA0L7QutC4XHJcbiAgICAgICAgW10uZm9yRWFjaC5jYWxsKHJvd3MsIGZ1bmN0aW9uIChub2RlTGlzdCkge1xyXG4gICAgICAgICAgW10uZm9yRWFjaC5jYWxsKG5vZGVMaXN0LCBlbCA9PiB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZSgpXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyDQn9C+0LzQtdC90Y/RgtGMINC90LDQv9GA0LDQstC70LXQvdC40LVcclxuICAgICAgICBkaXJlY3Rpb25zW2luZGV4XSA9IGRpcmVjdGlvbiA9PT0gJ2FzYycgPyAnZGVzYycgOiAnYXNjJ1xyXG5cclxuICAgICAgICAvLyDQlNC+0LHQsNCy0LjRgtGMINC90L7QstGD0Y4g0YHRgtGA0L7QutGDXHJcbiAgICAgICAgbmV3Um93cy5mb3JFYWNoKGZ1bmN0aW9uIChuZXdSb3cpIHtcclxuICAgICAgICAgIG5ld1JvdyA9IEFycmF5LmZyb20obmV3Um93KTtcclxuICAgICAgICAgIG5ld1Jvdy5yZXZlcnNlKCk7XHJcbiAgICAgICAgICBbXS5mb3JFYWNoLmNhbGwobmV3Um93LCBlbCA9PiB7XHJcbiAgICAgICAgICAgIGhlYWRlcnNbaGVhZGVycy5sZW5ndGggLSAxXS5hZnRlcihlbClcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLy8gZ2V0IHRhYmxlIHJvd3MgYXJyYXlcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgaWQgPSBpZHNbaV0uZGF0YXNldC5pZFxyXG4gICAgICAgIGxldCByb3cgPSAkKHRhYmxlKVswXS5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS1pZD0nJHtpZH0nXWApXHJcbiAgICAgICAgcm93cy5wdXNoKHJvdylcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8g0J3QsNC/0YDQsNCy0LvQtdC90LjQtSDRgdC+0YDRgtC40YDQvtCy0LrQuFxyXG4gICAgICBjb25zdCBkaXJlY3Rpb25zID0gQXJyYXkuZnJvbShzb3J0YWJsZXMpLm1hcChmdW5jdGlvbiAoc29ydGFibGUpIHtcclxuICAgICAgICByZXR1cm4gJydcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyDQn9GA0LXQvtCx0YDQsNC30L7QstCw0YLRjCDRgdC+0LTQtdGA0LbQuNC80L7QtSDQtNCw0L3QvdC+0Lkg0Y/Rh9C10LnQutC4INCyINC30LDQtNCw0L3QvdC+0Lwg0YHRgtC+0LvQsdGG0LVcclxuICAgICAgZnVuY3Rpb24gdHJhbnNmb3JtKGluZGV4LCBjb250ZW50KSB7XHJcbiAgICAgICAgLy8g0J/QvtC70YPRh9C40YLRjCDRgtC40L8g0LTQsNC90L3Ri9GFINGB0YLQvtC70LHRhtCwXHJcbiAgICAgICAgY29uc3QgdHlwZSA9IHNvcnRhYmxlc1tpbmRleF0uZ2V0QXR0cmlidXRlKCdkYXRhLXR5cGUnKVxyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoY29udGVudClcclxuICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gY29udGVudFxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vLyBJTlBVVFxyXG4gICAgICBmdW5jdGlvbiBoYW5kbGVJbnB1dCh0YWJsZSwgY29udGVudGVkaXRhYmxlLCB0YXJnZXQpIHtcclxuICAgICAgICBpZiAoIXRhcmdldC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpKSByZXR1cm4gZmFsc2VcclxuICAgICAgICBsZXQgbW9kZWwgPSBtYWtlU2VydmVyTW9kZWwodGFyZ2V0LCBtb2RlbE5hbWUpXHJcbiAgICAgICAgc2F2ZShtb2RlbClcclxuICAgICAgfVxyXG5cclxuICAgICAgYXN5bmMgZnVuY3Rpb24gc2F2ZShtb2RlbCkge1xyXG4gICAgICAgIGxldCB1cmwgPSBgL2FkbWluc2MvJHttb2RlbC5tb2RlbE5hbWV9L3VwZGF0ZU9yQ3JlYXRlYFxyXG4gICAgICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KHVybCwgbW9kZWwubW9kZWwpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIG1ha2VTZXJ2ZXJNb2RlbCh0YXJnZXQsIG1vZGVsTmFtZSkge1xyXG4gICAgICAgIGxldCBmaWVsZCA9IHRhcmdldC5kYXRhc2V0WydmaWVsZCddXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIG1vZGVsOiB7XHJcbiAgICAgICAgICAgIGlkOiB0YXJnZXQuZGF0YXNldC5pZCxcclxuICAgICAgICAgICAgW2ZpZWxkXTogdGFyZ2V0LmlubmVyVGV4dFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIG1vZGVsTmFtZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgIH0pXHJcbiAgfVxyXG4gIC8vIH0pXHJcbn1cclxuIiwiaW1wb3J0ICcuL3JpZ2h0cy5zY3NzJztcclxuaW1wb3J0IHskLCBwb3B1cCwgcG9zdH0gZnJvbSAnLi4vLi4vY29tbW9uJztcclxuaW1wb3J0IGxpc3QgZnJvbSAnQGNvbXBvbmVudHMvbGlzdC9saXN0J1xyXG4vLyBpbXBvcnQgY29udGVudGVkaXRhYmxlIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvY29udGVudGVkaXRhYmxlJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmlnaHRzKCkge1xyXG4gIC8vIGRlYnVnZ2VyXHJcbiAgLy8gY29udGVudGVkaXRhYmxlKClcclxuXHJcblxyXG5cclxuICAkKCcucmlnaHRzLXRhYmxlJykub24oJ2NsaWNrJywgaGFuZGxlKVxyXG5cclxuICBmdW5jdGlvbiBoYW5kbGUoe3RhcmdldH0pIHtcclxuICAgIGlmICh0YXJnZXQuY2xvc2VzdCgnLmRlbCcpKSBkZWwodGFyZ2V0LmNsb3Nlc3QoJy5kZWwnKSlcclxuICAgIGlmICh0YXJnZXQuY2xvc2VzdCgnLnNhdmUnKSkgc2F2ZSh0YXJnZXQuY2xvc2VzdCgnLnNhdmUnKSlcclxuXHJcbiAgICBmdW5jdGlvbiBtb2RlbChlbCkge1xyXG4gICAgICBsZXQgZGF0YUlkID0gZWwuZGF0YXNldC5pZCA/PyAnbmV3J1xyXG4gICAgICBsZXQgZmllbGRzID0gJChgW2RhdGEtaWQ9JyR7ZGF0YUlkfSddYClcclxuICAgICAgbGV0IG1vZGVsID0ge31cclxuICAgICAgbW9kZWwudG9TZXJ2ID0ge31cclxuICAgICAgbW9kZWwuZW1wdHkgPSB7fVxyXG5cclxuICAgICAgZmllbGRzLm1hcCgoZikgPT4ge1xyXG4gICAgICAgIGlmIChmLmNsYXNzTGlzdC5jb250YWlucygnaWQnKSkge1xyXG4gICAgICAgICAgbW9kZWwuaWQgPSBmXHJcbiAgICAgICAgICBtb2RlbC50b1NlcnYuaWQgPSBmLmRhdGFzZXQuaWRcclxuICAgICAgICB9IGVsc2UgaWYgKGYuY2xhc3NMaXN0LmNvbnRhaW5zKCduYW1lJykpIHtcclxuICAgICAgICAgIG1vZGVsLm5hbWUgPSBmXHJcbiAgICAgICAgICBtb2RlbC50b1NlcnYubmFtZSA9IGYuaW5uZXJUZXh0LnRyaW0oKVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZi5jbGFzc0xpc3QuY29udGFpbnMoJ2Rlc2NyaXB0aW9uJykpIHtcclxuICAgICAgICAgIG1vZGVsLmRlc2NyaXB0aW9uID0gZlxyXG4gICAgICAgICAgbW9kZWwudG9TZXJ2LmRlc2NyaXB0aW9uID0gZi5pbm5lclRleHQudHJpbSgpXHJcbiAgICAgICAgfSBlbHNlIGlmIChmLmNsYXNzTGlzdC5jb250YWlucygnc2F2ZS5zdmcnKSkge1xyXG4gICAgICAgICAgbW9kZWwuc2F2ZSA9IGZcclxuICAgICAgICB9IGVsc2UgaWYgKGYuY2xhc3NMaXN0LmNvbnRhaW5zKCdkZWwnKSkge1xyXG4gICAgICAgICAgbW9kZWwuZGVsID0gZlxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuXHJcbiAgICAgIG1vZGVsLmVtcHR5LmRlbCA9IG1vZGVsLmlkLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuY2xvbmVOb2RlKHRydWUpXHJcbiAgICAgIG1vZGVsLmVtcHR5LnNhdmUgPSBtb2RlbC5pZC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuY2xvbmVOb2RlKHRydWUpXHJcbiAgICAgIG1vZGVsLmVtcHR5LmRlc2NyaXB0aW9uID0gbW9kZWwuaWQucHJldmlvdXNFbGVtZW50U2libGluZy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuY2xvbmVOb2RlKHRydWUpXHJcbiAgICAgIG1vZGVsLmVtcHR5Lm5hbWUgPSBtb2RlbC5pZC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnByZXZpb3VzRWxlbWVudFNpYmxpbmcucHJldmlvdXNFbGVtZW50U2libGluZy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmNsb25lTm9kZSh0cnVlKVxyXG4gICAgICBtb2RlbC5lbXB0eS5pZCA9IG1vZGVsLmlkLnByZXZpb3VzRWxlbWVudFNpYmxpbmcucHJldmlvdXNFbGVtZW50U2libGluZy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnByZXZpb3VzRWxlbWVudFNpYmxpbmcucHJldmlvdXNFbGVtZW50U2libGluZy5jbG9uZU5vZGUodHJ1ZSlcclxuXHJcbiAgICAgIHJldHVybiBtb2RlbFxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBkZWwoZWwpIHtcclxuICAgICAgbGV0IG1vZCA9IG1vZGVsKGVsKVxyXG4gICAgICBpZiAobW9kLnRvU2Vydi5pZCA9PT0gJ25ldycpIHJldHVyblxyXG4gICAgICBpZiAoY29uZmlybShcItCj0LTQsNC70LjRgtGMINC/0YDQsNCy0L4/XCIpKSB7XHJcbiAgICAgICAgZGVsRG9tKG1vZClcclxuICAgICAgICBkZWxTZXJ2ZXIobW9kKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgZnVuY3Rpb24gZGVsU2VydmVyKG1vZGVsKSB7XHJcbiAgICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KCcvcmlnaHQvZGVsZXRlJywge2lkOiBtb2RlbC50b1NlcnYuaWR9KVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRlbERvbShtb2RlbCkge1xyXG4gICAgICBtb2RlbC5pZC5yZW1vdmUoKVxyXG4gICAgICBtb2RlbC5uYW1lLnJlbW92ZSgpXHJcbiAgICAgIG1vZGVsLmRlc2NyaXB0aW9uLnJlbW92ZSgpXHJcbiAgICAgIG1vZGVsLnNhdmUucmVtb3ZlKClcclxuICAgICAgbW9kZWwuZGVsLnJlbW92ZSgpXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHNhdmUoZWwpIHtcclxuICAgICAgbGV0IG1vZCA9IG1vZGVsKGVsKVxyXG4gICAgICBpZiAobW9kLnRvU2Vydi5pZCAhPT0gJ25ldycpIHtcclxuICAgICAgICB1cGRhdGUobW9kLnRvU2VydilcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoIW1vZC50b1NlcnYubmFtZSB8fCAhbW9kLnRvU2Vydi5kZXNjcmlwdGlvbikgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgY3JlYXRlKG1vZClcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZSh0b1NlcnYpIHtcclxuICAgICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9yaWdodC91cGRhdGUnLCB0b1NlcnYpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2xlYXJNb2RlbChtb2RlbCl7XHJcbiAgICAgIG1vZGVsLm5hbWUuaW5uZXJUZXh0ID0gXCJcIlxyXG4gICAgICBtb2RlbC5kZXNjcmlwdGlvbi5pbm5lclRleHQgPSBcIlwiXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlT25Eb20obW9kZWwpe1xyXG4gICAgICBsZXQgbGFzdEVsZW1lbnQgPSAkKFwiLmlkW2RhdGEtaWQ9J25ldyddXCIpWzBdXHJcbiAgICAgIGxhc3RFbGVtZW50LmJlZm9yZShtb2RlbC5lbXB0eS5pZClcclxuICAgICAgbGFzdEVsZW1lbnQuYmVmb3JlKG1vZGVsLmVtcHR5Lm5hbWUpXHJcbiAgICAgIGxhc3RFbGVtZW50LmJlZm9yZShtb2RlbC5lbXB0eS5kZXNjcmlwdGlvbilcclxuICAgICAgbGFzdEVsZW1lbnQuYmVmb3JlKG1vZGVsLmVtcHR5LnNhdmUpXHJcbiAgICAgIGxhc3RFbGVtZW50LmJlZm9yZShtb2RlbC5lbXB0eS5kZWwpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXNzaWduTmV3VmFsdWVzT25DbG9uZShtb2RlbCwgaWQpe1xyXG4gICAgICBtb2RlbC5lbXB0eS5pZC5kYXRhc2V0LmlkID0gaWRcclxuICAgICAgbW9kZWwuZW1wdHkuaWQuaW5uZXJUZXh0ID0gaWRcclxuICAgICAgbW9kZWwuZW1wdHkubmFtZS5kYXRhc2V0LmlkID0gaWRcclxuICAgICAgbW9kZWwuZW1wdHkubmFtZS5pbm5lclRleHQgPSBtb2RlbC5uYW1lLmlubmVyVGV4dC50cmltKClcclxuICAgICAgbW9kZWwuZW1wdHkuZGVzY3JpcHRpb24uZGF0YXNldC5pZCA9IGlkXHJcbiAgICAgIG1vZGVsLmVtcHR5LmRlc2NyaXB0aW9uLmlubmVyVGV4dCA9IG1vZGVsLmRlc2NyaXB0aW9uLmlubmVyVGV4dC50cmltKClcclxuICAgICAgbW9kZWwuZW1wdHkuc2F2ZS5kYXRhc2V0LmlkID0gaWRcclxuICAgICAgbW9kZWwuZW1wdHkuZGVsLmRhdGFzZXQuaWQgPSBpZFxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZShtb2RlbCkge1xyXG4gICAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCgnL3JpZ2h0L2NyZWF0ZScsIG1vZGVsLnRvU2VydilcclxuXHJcbiAgICAgIGlmIChyZXMuYXJyLmlkKSB7XHJcblxyXG4gICAgICAgIGFzc2lnbk5ld1ZhbHVlc09uQ2xvbmUobW9kZWwsIHJlcy5pZC0xKVxyXG4gICAgICAgIGNyZWF0ZU9uRG9tKG1vZGVsKVxyXG4gICAgICAgIGNsZWFyTW9kZWwobW9kZWwpXHJcblxyXG4gICAgICAgIHBvcHVwLnNob3coJ9Ch0L7RhdGA0LDQvdC10L3QvicpXHJcbiAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG5cclxuICB9XHJcbn0iLCJpbXBvcnQgeyR9IGZyb20gJy4uL2NvbW1vbidcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFNleCgpIHtcclxuICBmdW5jdGlvbiBzZXgoKSB7XHJcbiAgICBjb25zdCBzID0gJCgnW25hbWU9XCJzZXhcIl0nKVxyXG4gICAgZm9yIChsZXQgZiBvZiBzKSB7XHJcbiAgICAgIGlmIChmLmNoZWNrZWQpIHtcclxuICAgICAgICByZXR1cm4gZi52YWx1ZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJ20nXHJcbiAgfVxyXG59IiwiaW1wb3J0ICcuL3VzZXJzLnNjc3MnXHJcblxyXG5pbXBvcnQgeyQsIHBvcHVwLCBwb3N0fSBmcm9tICcuLi8uLi9jb21tb24nXHJcbmltcG9ydCBnZXRTZXggZnJvbSAnLi4vLi4vQXV0aC9nZXRTZXgnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VyKCkge1xyXG5cclxuICBsZXQgaXRlbSA9ICQoJ1tkYXRhLW1vZGVsPVwidXNlclwiXScpWzBdXHJcbiAgaWYgKGl0ZW0pIHtcclxuICAgICQoaXRlbSkub24oJ2NsaWNrJywgaGFuZGxlQ2xpY2spXHJcbiAgfVxyXG5cclxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVDbGljayh7dGFyZ2V0fSkge1xyXG4gICAgaWYgKCEhdGFyZ2V0LmNsb3Nlc3QoJyNzYXZlJykpIHtcclxuXHJcbiAgICAgIGxldCB3cmFwcGVyID0gJCgnLnVzZXItaXRlbScpWzBdXHJcbiAgICAgIGxldCBkYXRhID0gZ2V0TW9kZWwod3JhcHBlcilcclxuXHJcbiAgICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KCcvYWRtaW5zYy91c2VyL3VwZGF0ZScsIGRhdGEpXHJcblxyXG4gICAgfSBlbHNlIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdyaWdodCcpKSB7XHJcbiAgICAgIGxldCByaWdodHMgPSAkKCdpbnB1dC5yaWdodDpjaGVja2VkJylcclxuICAgICAgbGV0IHN0ciA9ICcnO1xyXG4gICAgICBbXS5tYXAuY2FsbChyaWdodHMsIGZ1bmN0aW9uIChyaWdodCkge1xyXG4gICAgICAgIGxldCBzID0gcmlnaHQucHJldmlvdXNFbGVtZW50U2libGluZy5pbm5lclRleHRcclxuICAgICAgICBzdHIrPXMrJywnXHJcbiAgICAgIH0pXHJcbiAgICAgICAgbGV0IHRhYiA9IHRhcmdldC5jbG9zZXN0KCdbdGFiXScpXHJcbiAgICAgICAgdGFiLmRhdGFzZXQudmFsdWUgPSBzdHJcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJpZ2h0cygpIHtcclxuICAgIGxldCByaWdodCA9ICQoJy5yaWdodDpjaGVja2VkJylcclxuICAgIGxldCByaWdodHMgPSAnJztcclxuICAgIFtdLm1hcC5jYWxsKHJpZ2h0LCAocikgPT4ge1xyXG4gICAgICBsZXQgc3RyID0gci5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmlubmVyVGV4dCArICcsJ1xyXG4gICAgICByaWdodHMgKz0gc3RyXHJcbiAgICB9LCByaWdodHMpXHJcbiAgICByZXR1cm4gcmlnaHRzXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb25maXJtKCkge1xyXG4gICAgY29uc3QgY29uZmlybSA9ICQoJyNjb25mIG9wdGlvbicpXHJcbiAgICBmb3IgKGxldCBmIG9mIGNvbmZpcm0pIHtcclxuICAgICAgaWYgKGYuc2VsZWN0ZWQpIHtcclxuICAgICAgICByZXR1cm4gZi52YWx1ZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJzAnXHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gZ2V0TW9kZWwodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpZDogJCh0YXJnZXQpLmZpbmQoXCIjaWRcIikuaW5uZXJUZXh0LFxyXG4gICAgICBuYW1lOiAkKHRhcmdldCkuZmluZCgnI25hbWUnKS5pbm5lclRleHQsXHJcbiAgICAgIHN1ck5hbWU6ICQodGFyZ2V0KS5maW5kKCcjcy1uYW1lJykuaW5uZXJUZXh0LFxyXG4gICAgICBtaWRkbGVOYW1lOiAkKHRhcmdldCkuZmluZCgnI20tbmFtZScpLmlubmVyVGV4dCxcclxuICAgICAgYmlydGhEYXRlOiAkKHRhcmdldCkuZmluZCgnI2JkYXknKS5pbm5lclRleHQsXHJcbiAgICAgIHBob25lOiAkKHRhcmdldCkuZmluZCgnI3Bob25lJykuaW5uZXJUZXh0LFxyXG4gICAgICBlbWFpbDogJCh0YXJnZXQpLmZpbmQoJyNlbWFpbCcpLmlubmVyVGV4dCxcclxuICAgICAgaGlyZWQ6ICQodGFyZ2V0KS5maW5kKCcjaGlyZWQnKS5pbm5lclRleHQsXHJcbiAgICAgIGZpcmVkOiAkKHRhcmdldCkuZmluZCgnI2ZpcmVkJykuaW5uZXJUZXh0LFxyXG4gICAgICBjb25maXJtOiBjb25maXJtKCksXHJcbiAgICAgIHNleDogZ2V0U2V4KCksXHJcbiAgICAgIHJpZ2h0czogcmlnaHRzKClcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4iLCJpbXBvcnQgeyR9IGZyb20gXCIuLi9jb21tb25cIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFjY29yZGlvblNob3coKSB7XHJcblxyXG4gIGxldCBjdXJyZW50VGVzdElkID0gJChgW2RhdGEtdGVzdGlkXWApWzBdXHJcbiAgaWYgKGN1cnJlbnRUZXN0SWQpIHtcclxuICAgIGN1cnJlbnRUZXN0SWQgPSArY3VycmVudFRlc3RJZC5kYXRhc2V0Wyd0ZXN0aWQnXVxyXG4gICAgbGV0IG1lbnVJdGVtQ29sbGVjdGlvbiA9ICQoJy50ZXN0LWVkaXQuYWNjb3JkaW9uIGEnKVxyXG4gICAgQXJyYXkuZnJvbShtZW51SXRlbUNvbGxlY3Rpb24pLmZpbHRlcigoYSkgPT4ge1xyXG4gICAgICBpZiAoK2EuZGF0YXNldC5pZCA9PT0gY3VycmVudFRlc3RJZCkge1xyXG4gICAgICAgIGEuY2xhc3NMaXN0LmFkZCgnY3VycmVudCcpXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgfVxyXG5cclxuXHJcbiAgbGV0IGJ1dHRvbiA9ICQoJy5hY2NvcmRpb24tb3BlbicpWzBdXHJcbiAgaWYgKGJ1dHRvbikge1xyXG4gICAgJChidXR0b24pLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgbGV0IG1lbnUgPSAkKCcuYWNjb3JkaW9uX3dyYXAnKVswXVxyXG4gICAgICBtZW51LmNsYXNzTGlzdC50b2dnbGUoJ29wZW4nKVxyXG4gICAgfSlcclxuICB9XHJcblxyXG59XHJcbiIsImltcG9ydCAnLi9vcGVuX3Rlc3Quc2NzcydcclxuaW1wb3J0IHskLCBwb3N0LCBjYWNoZVBhZ2UsIElzSnNvbn0gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5cclxuaW1wb3J0ICcuLi9jb21wb25lbnRzL2FjY29yZGlvbi1zaG93JztcclxuXHJcbmxldCBvcGVuVGVzdCA9ICQoJy5vcGVudGVzdF93cmFwJylbMF1cclxuaWYgKG9wZW5UZXN0KSB7XHJcbiAgc2hvd0ZpcnN0UXVlc3QoKVxyXG4gICQob3BlblRlc3QpLm9uKCdjbGljaycsIGhhbmRsZUNsaWNrKVxyXG5cclxuICAkKG9wZW5UZXN0KS5vbigna2V5dXAnLCBoYW5kbGVLZXl1cClcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHNob3dGaXJzdFF1ZXN0KCkge1xyXG4gIGxldCBxID0gJCgnLnF1ZXN0aW9uJylbMF0uY2xhc3NMaXN0LmFkZCgnc2hvdycpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUtleXVwKHt0YXJnZXR9KSB7XHJcbiAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3RleHRhcmVhJykpIHtcclxuICAgIGxldCBhY3RpdmVQYWdpbmF0aW9uID0gJCgnW2RhdGEtcGFnaW5hdGlvbl0uYWN0aXZlJylbMF1cclxuICAgIGlmICghdGFyZ2V0LmlubmVyVGV4dCkge1xyXG4gICAgICBhY3RpdmVQYWdpbmF0aW9uLmNsYXNzTGlzdC5yZW1vdmUoJ2ZpbGxlZCcpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhY3RpdmVQYWdpbmF0aW9uLmNsYXNzTGlzdC5hZGQoJ2ZpbGxlZCcpXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVDbGljayh7dGFyZ2V0fSkge1xyXG4gIGxldCB0ZXN0aWQgPSB0YXJnZXQuZGF0YXNldC5pZFxyXG4gIGxldCBhY3RpdmVRdWVzdGlvbiA9ICQoJy5xdWVzdGlvbi5zaG93JylbMF1cclxuICBsZXQgcGFnaW5hdGlvbnMgPSAkKCdbZGF0YS1wYWdpbmF0aW9uXScpXHJcbiAgbGV0IGFjdGl2ZVBhZ2luYXRpb24gPSAkKCdbZGF0YS1wYWdpbmF0aW9uXS5hY3RpdmUnKVswXVxyXG4gIGxldCBpID0gcGFnaW5hdGlvbnMuaW5kZXhPZihhY3RpdmVQYWdpbmF0aW9uKVxyXG5cclxuICBpZiAodGFyZ2V0LmlkID09PSAncHJldicpIHtcclxuICAgIHByZXZRdWVzdCgpXHJcbiAgfSBlbHNlIGlmICh0YXJnZXQuaWQgPT09ICduZXh0Jykge1xyXG4gICAgbmV4dFF1ZXN0KClcclxuICB9IGVsc2UgaWYgKHRhcmdldC5kYXRhc2V0LnBhZ2luYXRpb24pIHtcclxuICAgIHBhZ2luYXRlKClcclxuICB9IGVsc2UgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2xlZCcpKSB7XHJcbiAgICBibGluayh0YXJnZXQpXHJcbiAgfSBlbHNlIGlmICh0YXJnZXQuaWQgPT09ICdmaW5pc2gnKSB7XHJcbiAgICBmaW5pc2goKVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZnVuY3Rpb24gZmluaXNoKCkge1xyXG4gICAgbGV0IHF1ZXN0aW9ucyA9IGF3YWl0IGdldEFuc3dlcnModGVzdGlkKVxyXG4gICAgbGV0IGNvcnJlY3RBbnN3ZXJzID0gY29ycmVjdENvdW50KHF1ZXN0aW9ucylcclxuICAgIGxldCBvYmogPSBvYmpUb1NlcnYoY29ycmVjdEFuc3dlcnMpXHJcbiAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCgnL2FkbWluc2Mvb3BlbnRlc3RyZXN1bHQvZmluaXNoJywgb2JqKVxyXG4gICAgaWYgKHJlcy5tc2cgPT09ICdvaycpIHtcclxuICAgICAgbGV0IGNhbnYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpXHJcbiAgICAgIGNhbnYuaWQgPSAnYydcclxuXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvYmpUb1NlcnYocmlnaHRBbnN3ZXJzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0ZXN0SWQ6ICt0ZXN0aWQsXHJcbiAgICAgIHF1ZXN0aW9uQ250OiBwYWdpbmF0aW9ucy5sZW5ndGgsXHJcbiAgICAgIGh0bWw6IGNhY2hlUGFnZSgnLnRlc3QnKSxcclxuICAgICAgdGVzdG5hbWU6ICQoJy50ZXN0LW5hbWUnKVswXS5pbm5lclRleHQsXHJcbiAgICAgIHVzZXJuYW1lOiAkKCcudXNlci1tZW51X19maW8nKVswXS5pbm5lclRleHQsXHJcbiAgICAgIHJpZ2h0QW5zd2VycyxcclxuICAgICAgLy8gaHRtbDogYDwhRE9DVFlQRSAke2RvY3VtZW50LmRvY3R5cGUubmFtZX0+YCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUwsXHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHBhZ2luYXRlKCkge1xyXG4gICAgaWYgKHRhcmdldCA9PT0gYWN0aXZlUGFnaW5hdGlvbikgcmV0dXJuIGZhbHNlXHJcbiAgICBsZXQgYWltUGFnaW5hdGlvbiA9IHRhcmdldFxyXG4gICAgdG9nZ2xlUXVlc3Rpb24oYWltUGFnaW5hdGlvbiwgYWN0aXZlUXVlc3Rpb24pXHJcbiAgICB0b2dnbGVOYXYoYWltUGFnaW5hdGlvbiwgYWN0aXZlUGFnaW5hdGlvbilcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHByZXZRdWVzdCgpIHtcclxuICAgIGlmIChpIDwgMSkgcmV0dXJuIGZhbHNlXHJcbiAgICBsZXQgYWltUGFnaW5hdGlvbiA9IHBhZ2luYXRpb25zW2kgLSAxXVxyXG4gICAgdG9nZ2xlUXVlc3Rpb24oYWltUGFnaW5hdGlvbiwgYWN0aXZlUXVlc3Rpb24pXHJcbiAgICB0b2dnbGVOYXYoYWltUGFnaW5hdGlvbiwgYWN0aXZlUGFnaW5hdGlvbilcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG5leHRRdWVzdCgpIHtcclxuICAgIGlmIChpID4gcGFnaW5hdGlvbnMubGVuZ3RoIC0gMikgcmV0dXJuIGZhbHNlXHJcbiAgICBsZXQgYWltUGFnaW5hdGlvbiA9IHBhZ2luYXRpb25zW2kgKyAxXVxyXG4gICAgdG9nZ2xlUXVlc3Rpb24oYWltUGFnaW5hdGlvbiwgYWN0aXZlUXVlc3Rpb24pXHJcbiAgICB0b2dnbGVOYXYoYWltUGFnaW5hdGlvbiwgYWN0aXZlUGFnaW5hdGlvbilcclxuICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBjb3JyZWN0Q291bnQocXVlc3Rpb25zKSB7XHJcbiAgbGV0IGNvcnJlY3QgPSAwXHJcbiAgcXVlc3Rpb25zLmZvckVhY2goKHEpID0+IHtcclxuICAgIGxldCBxX2lkID0gcS5pZFxyXG4gICAgbGV0IHFfZWwgPSAkKGAucXVlc3Rpb25bZGF0YS1pZD0nJHtxX2lkfSddYClbMF1cclxuICAgIGxldCB0ZXh0YXJlYSA9ICQocV9lbCkuZmluZCgnLnRleHRhcmVhJylcclxuICAgIGlmICghcS5PcGVuYW5zd2VyKSByZXR1cm5cclxuICAgIGxldCB3b3JkID0gJydcclxuICAgIHEuT3BlbmFuc3dlci5mb3JFYWNoKChhKSA9PiB7XHJcbiAgICAgIHdvcmQgKz0gYCgke2EuYW5zd2VyfSk/YFxyXG4gICAgfSlcclxuICAgIGNvcnJlY3QgKz0gaGlnaGxpZ2h0KGAke3dvcmR9YCwgdGV4dGFyZWEsIHRydWUpXHJcbiAgfSlcclxuICByZXR1cm4gY29ycmVjdFxyXG59XHJcblxyXG5mdW5jdGlvbiBoaWxpdGVyKHdvcmQsIGVsZW1lbnQsIGFkZEV2ZW50TGlzKSB7XHJcbiAgbGV0IHRleHQgPSBlbGVtZW50LmlubmVySFRNTFxyXG4gIGxldCByZ3hwID0gbmV3IFJlZ0V4cCh3b3JkLCAnZycpO1xyXG4gIGxldCBhcnIgPSB0ZXh0Lm1hdGNoKHJneHApXHJcbiAgbGV0IGNvcnJlY3QgPSAwXHJcblxyXG4gIGFyci5mb3JFYWNoKCh3KSA9PiB7XHJcbiAgICBpZiAoIXcpIHJldHVyblxyXG4gICAgY29ycmVjdCA9IDFcclxuICAgIGxldCByID0gbmV3IFJlZ0V4cCh3LCAnZycpXHJcbiAgICBsZXQgcmVwbCA9IGA8c3BhbiBzdHlsZT0nY29sb3I6cmVkOyc+YCArIHcgKyAnPC9zcGFuPic7XHJcbiAgICBlbGVtZW50LmlubmVySFRNTCA9IGVsZW1lbnQuaW5uZXJIVE1MLnJlcGxhY2UociwgcmVwbCk7XHJcbiAgfSlcclxuICByZXR1cm4gY29ycmVjdFxyXG5cclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZ2V0QW5zd2VycyhpZCkge1xyXG4gIHJldHVybiBhd2FpdCBwb3N0KCcvYWRtaW5zYy9vcGVudGVzdHJlc3VsdC9nZXRhbnN3ZXJzJywge2lkfSlcclxufVxyXG5cclxuZnVuY3Rpb24gdG9nZ2xlTmF2KGFpbVBhZ2luYXRpb24sIGFjdGl2ZVBhZ2luYXRpb24pIHtcclxuICBhY3RpdmVQYWdpbmF0aW9uLmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScpXHJcbiAgYWltUGFnaW5hdGlvbi5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnKVxyXG59XHJcblxyXG5mdW5jdGlvbiB0b2dnbGVRdWVzdGlvbihhaW1QYWdpbmF0aW9uSWQsIGFjdGl2ZVF1ZXN0aW9uKSB7XHJcbiAgbGV0IGFpbVF1ZXN0aW9uSWQgPSBhaW1QYWdpbmF0aW9uSWQuZGF0YXNldC5wYWdpbmF0aW9uXHJcbiAgbGV0IGFpbVF1ZXN0aW9uID0gJChgLnF1ZXN0aW9uW2RhdGEtaWQ9JyR7YWltUXVlc3Rpb25JZH0nXWApWzBdXHJcbiAgYWltUXVlc3Rpb24uY2xhc3NMaXN0LnRvZ2dsZSgnc2hvdycpXHJcbiAgYWN0aXZlUXVlc3Rpb24uY2xhc3NMaXN0LnRvZ2dsZSgnc2hvdycpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhpZ2hsaWdodCh3b3JkLCBlbCwgYWRkRXZlbnRMaXMpIHtcclxuICByZXR1cm4gaGlsaXRlcih3b3JkLCBlbCwgYWRkRXZlbnRMaXMpO1xyXG59XHJcblxyXG4iLCJpbXBvcnQgJy4vcmFkaW8uc2NzcydcclxuaW1wb3J0IHskfSBmcm9tICcuLi8uLi9jb21tb24nXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByYWRpbygpe1xyXG4gIGxldCByYWRpb3MgPSAkKCdbY3VzdG9tLXJhZGlvXScpO1xyXG5cclxuICBbXS5tYXAuY2FsbChyYWRpb3MsIGZ1bmN0aW9uIChyYWRpbykge1xyXG4gICAgJChyYWRpbykub24oJ2NsaWNrJyxoYW5kbGVDbGljaylcclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVDbGljayh7dGFyZ2V0fSkge1xyXG4gICAgICBsZXQgdGFyZyA9IHRhcmdldC5jbG9zZXN0KFwibGFiZWxcIilcclxuICAgICAgcmFkaW8uZGF0YXNldC52YWx1ZSA9IHRhcmcuZGF0YXNldC52YWx1ZVxyXG4gICAgfVxyXG5cclxuICB9KVxyXG5cclxufSIsImltcG9ydCAnLi9tdWx0aXNlbGVjdC5zY3NzJ1xyXG5pbXBvcnQgeyR9IGZyb20gJy4uLy4uL2NvbW1vbidcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG11bHRpc2VsZWN0KCkge1xyXG5cclxuICBmdW5jdGlvbiBnZXRTZWxlY3RlZCgpe1xyXG4gICAgaWYgKG11bHRpKXtcclxuICAgICAgbGV0IHNlbGVjdGVkID0gW10ubWFwLmNhbGwobXVsdGksIGZ1bmN0aW9uIChzZWxlY3QpIHtcclxuICAgICAgICBsZXQgY2hpcHMgPSBzZWxlY3QucXVlcnlTZWxlY3RvckFsbCgnLmNoaXAtd3JhcCcpO1xyXG4gICAgICAgIGxldCBvYmpzID0gW10ubWFwLmNhbGwoY2hpcHMsIGZ1bmN0aW9uIChjaGlwKSB7XHJcbiAgICAgICAgICByZXR1cm4gY2hpcC5kYXRhc2V0LmlkO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgbGV0IG9iaiA9IHt9XHJcbiAgICAgICAgb2JqLmZpZWxkID0gIHNlbGVjdC5kYXRhc2V0LmZpZWxkXHJcbiAgICAgICAgb2JqLmlkcyA9IG9ianNcclxuICAgICAgICByZXR1cm4gb2JqXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgICAvLyBkZWJ1Z2dlclxyXG4gIH1cclxuXHJcbiAgbGV0IG11bHRpID0gJCgnW211bHRpLXNlbGVjdF0gJylcclxuICBpZiAobXVsdGkpIHtcclxuXHJcbiAgICBbXS5mb3JFYWNoLmNhbGwobXVsdGksIGZ1bmN0aW9uIChzZWxlY3QpIHtcclxuXHJcbiAgICAgIHNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUNsaWNrLCBmYWxzZSlcclxuICAgICAgc2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVCbHVyLCBmYWxzZSlcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUJsdXIoe3RhcmdldH0pIHtcclxuICAgICAgICBsZXQgc2hvdyA9ICQodGhpcykuZmluZCgnLnNob3cnKVxyXG4gICAgICAgIGlmIChzaG93KSB7XHJcbiAgICAgICAgICBzaG93LmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soe3RhcmdldH0pIHtcclxuICAgICAgICBsZXQgbXVsdGkgPSB0YXJnZXQuY2xvc2VzdCgnW211bHRpLXNlbGVjdF0nKVxyXG4vLyDQvtGC0LrRgNGL0YLRjCDQstGL0LHQvtGAINGN0LvQtdC80LXQvdGC0L7QslxyXG4gICAgICAgIGlmICh0YXJnZXQuY2xvc2VzdCgnLmFycm93Jyl8fFsnY2hpcC13cmFwJ10uaW5jbHVkZXModGFyZ2V0LmNsYXNzTmFtZSkpICB7XHJcbiAgICAgICAgICAvLyBsZXQgbXVsdGlzZWxlY3QgPSB0YXJnZXQuY2xvc2VzdCgnW211bHRpLXNlbGVjdF0gJylcclxuICAgICAgICAgIGxldCB1bCA9IG11bHRpLnF1ZXJ5U2VsZWN0b3IoJ3VsJylcclxuICAgICAgICAgIHVsLmNsYXNzTGlzdC50b2dnbGUoJ3Nob3cnKVxyXG5cclxuLy8g0L3QsNC20LDRgtC40LUg0L/QviDQutGA0LXRgdGC0LjQutGDINGH0LjQv9CwXHJcbiAgICAgICAgfSBlbHNlIGlmIChbJ2RlbCddLmluY2x1ZGVzKHRhcmdldC5jbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICBsZXQgaWQgPSB0YXJnZXQuY2xvc2VzdCgnLmNoaXAnKS5kYXRhc2V0LmlkXHJcbiAgICAgICAgICB0b2dnbGVCYWNrZ3JvdW5kKGlkKVxyXG4gICAgICAgICAgbGV0IGNoaXAgPSB0YXJnZXQuY2xvc2VzdCgnLmNoaXAnKVxyXG4gICAgICAgICAgY2hpcC5yZW1vdmUoKVxyXG5cclxuLy8g0LLRi9Cx0L7RgCDRjdC70LXQvNC10L3RgtCwLCDQv9GA0L7QstC10YDQutCwINGB0YPRidC10YHRgtCy0L7QstCw0L3QuNGPINGH0LjQv9CwINC4INC10LPQviDQtNC+0LHQsNCy0LvQtdC90LjQtVxyXG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2xhYmVsJykge1xyXG4gICAgICAgICAgbGV0IGlkID0gdGFyZ2V0LmRhdGFzZXQuaWQ7XHJcbiAgICAgICAgICAvLyBsZXQgbSA9IHRhcmdldC5jbG9zZXN0KCdbbXVsdGktc2VsZWN0XSAnKVxyXG4gICAgICAgICAgbGV0IGNoaXBzID0gbXVsdGkucXVlcnlTZWxlY3RvckFsbCgnLmNoaXAnKTtcclxuICAgICAgICAgIGxldCBleGlzdCA9IFtdLnNvbWUuY2FsbChjaGlwcywgKGNoaXApID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNoaXAuZGF0YXNldC5pZCA9PT0gaWRcclxuICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgbGV0IHdyYXAgPSAkKG11bHRpKS5maW5kKCcuY2hpcC13cmFwJylcclxuICAgICAgICAgIGlmICghZXhpc3QpIHtcclxuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC50b2dnbGUoJ3NlbGVjdGVkJylcclxuICAgICAgICAgICAgbGV0IGNoaXAgPSBjcmVhdGVDaGlwKGlkKVxyXG4gICAgICAgICAgICB3cmFwLmFwcGVuZChjaGlwKVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC50b2dnbGUoJ3NlbGVjdGVkJylcclxuICAgICAgICAgICAgd3JhcC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1pZD0nJHtpZH0nXWApLnJlbW92ZSgpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHRvZ2dsZUJhY2tncm91bmQoaWQpIHtcclxuICAgICAgICAgIC8vIGxldCBtdWx0aSA9IHRhcmdldC5jbG9zZXN0KCdbbXVsdGktc2VsZWN0XSAnKVxyXG4gICAgICAgICAgJChtdWx0aSkuZmluZChgbGFiZWxbZGF0YS1pZD0nJHtpZH0nXWApLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNoaXAoaWQpIHtcclxuICAgICAgICAgIGxldCBjaGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgICAgICAgIGNoaXAuY2xhc3NMaXN0LmFkZCgnY2hpcCcpXHJcbiAgICAgICAgICBjaGlwLmlubmVyVGV4dCA9IHRhcmdldC5pbm5lclRleHRcclxuICAgICAgICAgIGNoaXAuZGF0YXNldFsnaWQnXSA9IGlkXHJcblxyXG4gICAgICAgICAgbGV0IGRlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXHJcbiAgICAgICAgICBkZWwuY2xhc3NMaXN0LmFkZCgnZGVsJylcclxuICAgICAgICAgIGRlbC5pbm5lclRleHQgPSAnWCdcclxuXHJcbiAgICAgICAgICBjaGlwLmFwcGVuZChkZWwpXHJcblxyXG4gICAgICAgICAgcmV0dXJuIGNoaXBcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgfVxyXG59IiwiaW1wb3J0ICcuL2NhdGFsb2ctaXRlbS5zY3NzJztcclxuaW1wb3J0IHskLCBwb3N0LHRyaW1TdHJ9IGZyb20gJy4uLy4uL2NvbW1vbic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjYXRhbG9nSXRlbSgpIHtcclxuICBsZXQgY3VzdG9tQ2F0YWxvZ0l0ZW0gPSAkKCcuaXRlbV93cmFwJylbMF1cclxuICBpZiAoY3VzdG9tQ2F0YWxvZ0l0ZW0pIHtcclxuICAgICQoY3VzdG9tQ2F0YWxvZ0l0ZW0pLm9uKCdjbGljaycsIGhhbmRsZUNsaWNrLmJpbmQodGhpcykpXHJcbiAgfVxyXG5cclxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVDbGljayh7dGFyZ2V0fSkge1xyXG5cclxuICAgIGxldCBpdGVtID0gY3VzdG9tQ2F0YWxvZ0l0ZW1cclxuICAgIGxldCBtb2RlbE5hbWUgPSBpdGVtLmRhdGFzZXQubW9kZWxcclxuICAgIGlmICh0YXJnZXQuY2xvc2VzdCgnLnNhdmUnKSkge1xyXG4gICAgICBzYXZlKG1vZGVsTmFtZSlcclxuICAgIH0gZWxzZSBpZiAodGFyZ2V0LmNsb3Nlc3QoJy5kZWwnKVxyXG4gICAgICAmJiB0YXJnZXQuY2xvc2VzdCgnLmRlbCcpLmRhdGFzZXQubW9kZWwpIHtcclxuICAgICAgZGVsKGl0ZW0sIHRhcmdldC5jbG9zZXN0KCcuZGVsJykuZGF0YXNldC5tb2RlbClcclxuICAgIH0gZWxzZSBpZiAoKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3RhYicpKSkge1xyXG4gICAgICBoYW5kbGVUYWIodGFyZ2V0LCBtb2RlbE5hbWUpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVUYWIodGFyZ2V0KSB7XHJcbiAgICBsZXQgdmlzaWJsZVNlY3Rpb24gPSAkKGBzZWN0aW9uLnNob3dgKVswXVxyXG4gICAgdmlzaWJsZVNlY3Rpb24uY2xhc3NMaXN0LnRvZ2dsZSgnc2hvdycpXHJcbiAgICBsZXQgc2VjdGlvbiA9ICQoYHNlY3Rpb25bZGF0YS1pZD0nJHt0YXJnZXQuZGF0YXNldC5pZH0nXWApWzBdXHJcbiAgICBzZWN0aW9uLmNsYXNzTGlzdC50b2dnbGUoJ3Nob3cnKVxyXG4gICAgbGV0IGFjdGl2ZVRhYiA9ICQoYC50YWIuYWN0aXZlYClbMF1cclxuICAgIGFjdGl2ZVRhYi5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnKVxyXG4gICAgdGFyZ2V0LmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScpXHJcbiAgfVxyXG5cclxuICBhc3luYyBmdW5jdGlvbiBkZWwoaXRlbSwgbW9kZWxOYW1lKSB7XHJcbiAgICBsZXQgaWQgPSBpdGVtLmRhdGFzZXQuaWRcclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KGAvYWRtaW5zYy8ke21vZGVsTmFtZX0vZGVsZXRlYCwge2lkfSlcclxuICAgIGlmIChyZXMpIHtcclxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBgL2FkbWluc2MvJHttb2RlbE5hbWV9L2VkaXRgXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBmdW5jdGlvbiBzYXZlKG1vZGVsTmFtZSkge1xyXG4gICAgaWYgKGNoZWNrUmVxdWlyZWQoKSkgcmV0dXJuIGZhbHNlXHJcbiAgICBsZXQgbW9kZWwgPSBnZXRNb2RlbCgpXHJcbiAgICBsZXQgcmVzID0gYXdhaXQgcG9zdChgL2FkbWluc2MvJHttb2RlbE5hbWV9L3VwZGF0ZW9yY3JlYXRlYCwgey4uLm1vZGVsfSlcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWQoKSB7XHJcbiAgICBsZXQgcmVxdWlyZWQgPSAkKCdbcmVxdWlyZWRdJyk7XHJcbiAgICBsZXQgZXJyQ291bnQgPSAwO1xyXG4gICAgW10uZm9yRWFjaC5jYWxsKHJlcXVpcmVkLCBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgaWYgKCFlbC5pbm5lclRleHQpIHtcclxuICAgICAgICBlbC5zdHlsZS5ib3JkZXJDb2xvciA9ICdyZWQnXHJcbiAgICAgICAgaWYgKCQoZWwpLmZpbmQoJy5lcnJvcicpKSByZXR1cm5cclxuICAgICAgICBsZXQgZXJyb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxyXG4gICAgICAgIGVycm9yLmlubmVyVGV4dCA9ICfQl9Cw0L/QvtC70L3QuNGC0LUg0L/QvtC70LUnXHJcbiAgICAgICAgZXJyb3IuY2xhc3NMaXN0LmFkZCgnZXJyb3InKVxyXG4gICAgICAgIGVsLmNsb3Nlc3QoJy52YWx1ZScpLmFwcGVuZENoaWxkKGVycm9yKVxyXG4gICAgICAgIGVyckNvdW50KytcclxuICAgICAgfVxyXG4gICAgfSlcclxuICAgIHJldHVybiBlcnJDb3VudFxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0TW9kZWwoKSB7XHJcbiAgICBsZXQgZmllbGRzID0gJCgnW2RhdGEtZmllbGRdJyk7XHJcbiAgICBsZXQgb2JqID0ge307XHJcblxyXG4gICAgZnVuY3Rpb24gcihzdHIpIHtcclxuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eICt8ICskfCggKSArL2csIFwiJDFcIilcclxuICAgIH1cclxuXHJcbiAgICAvLyBkZWJ1Z2dlcjtcclxuICAgIFtdLm1hcC5jYWxsKGZpZWxkcywgKGZpZWxkKSA9PiB7XHJcbiAgICAgIGlmIChmaWVsZC5oYXNBdHRyaWJ1dGUoJ211bHRpLXNlbGVjdCcpKSB7XHJcbiAgICAgICAgbGV0IGNoaXBzID0gZmllbGQucXVlcnlTZWxlY3RvckFsbCgnLmNoaXAnKTtcclxuICAgICAgICBsZXQgaWRzID0gW10ubWFwLmNhbGwoY2hpcHMsIChjaGlwKSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gY2hpcC5kYXRhc2V0LmlkXHJcbiAgICAgICAgfSlcclxuICAgICAgICBvYmpbZmllbGQuZGF0YXNldC5maWVsZF0gPSBpZHMudG9TdHJpbmcoKVxyXG4gICAgICB9IGVsc2UgaWYgKGZpZWxkLmhhc0F0dHJpYnV0ZSgnY3VzdG9tLXNlbGVjdCcpKSB7XHJcbiAgICAgICAgb2JqW2ZpZWxkLmRhdGFzZXQuZmllbGRdID0gZmllbGQuZGF0YXNldC52YWx1ZVxyXG4gICAgICB9IGVsc2UgaWYgKGZpZWxkLmRhdGFzZXQudHlwZSA9PT0gJ2lucHV0cycpIHtcclxuICAgICAgICBvYmpbZmllbGQuZGF0YXNldC5maWVsZF0gPSBnZXRJbnB1dHMoZmllbGQpXHJcbiAgICAgIH0gZWxzZSBpZiAoZmllbGQuaGFzQXR0cmlidXRlKCdjdXN0b20tcmFkaW8nKSkge1xyXG4gICAgICAgIG9ialtmaWVsZC5kYXRhc2V0LmZpZWxkXSA9IGZpZWxkLmRhdGFzZXQudmFsdWVcclxuICAgICAgfSBlbHNlIGlmIChmaWVsZC5oYXNBdHRyaWJ1dGUoJ3RhYicpKSB7XHJcbiAgICAgICAgb2JqW2ZpZWxkLmRhdGFzZXQuZmllbGRdID0gZmllbGQuZGF0YXNldC52YWx1ZVxyXG4gICAgICB9IGVsc2UgaWYgKGZpZWxkLnR5cGUgPT09ICdkYXRlJykge1xyXG4gICAgICAgIG9ialtmaWVsZC5kYXRhc2V0LmZpZWxkXSA9IGZpZWxkLnZhbHVlXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgb2JqW2ZpZWxkLmRhdGFzZXQuZmllbGRdID0gcih0cmltU3RyKGZpZWxkLmlubmVyVGV4dCkpXHJcbiAgICAgIH1cclxuICAgIH0sIG9iailcclxuICAgIGxldCBpc1Rlc3QgPSAkKCdbZGF0YS1pc1Rlc3RdJylbMF1cclxuICAgIGlmIChpc1Rlc3QpIHtcclxuICAgICAgb2JqLmlzVGVzdCA9ICtpc1Rlc3QuZGF0YXNldC5pc3Rlc3RcclxuICAgIH1cclxuICAgIHJldHVybiBvYmpcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldElucHV0cyhmaWVsZCkge1xyXG4gICAgbGV0IGlucHV0cyA9IGZpZWxkLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0JylcclxuICAgIGxldCBuYW1lcyA9IFtdXHJcbiAgICBpbnB1dHMuZm9yRWFjaCgoaW5wKSA9PiB7XHJcbiAgICAgIGlmICghaW5wLmNoZWNrZWQpIHJldHVyblxyXG4gICAgICBsZXQgbmFtZSA9IGlucC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3IoJy5uYW1lJykuaW5uZXJUZXh0XHJcbiAgICAgIGlmICghbmFtZSkgcmV0dXJuXHJcbiAgICAgIG5hbWVzLnB1c2gobmFtZSlcclxuICAgIH0pXHJcbiAgICByZXR1cm4gbmFtZXMuam9pbignLCcpXHJcblxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgJy4vdG9vbHRpcC5zY3NzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9vbHRpcHMoKSB7XHJcblxyXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBzaG93VGlwLCB0cnVlKVxyXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBoaWRlVGlwLCB0cnVlKVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gc2hvd1RpcCh7dGFyZ2V0fSkge1xyXG4vLyBkZWJ1Z2dlclxyXG4gICAgLy8g0LXRgdC70Lgg0YMg0L3QsNGBINC10YHRgtGMINC/0L7QtNGB0LrQsNC30LrQsC4uLlxyXG4gICAgaWYgKCF0YXJnZXQuZGF0YXNldHx8IXRhcmdldC5kYXRhc2V0LnRvb2x0aXApIHJldHVybjtcclxuXHJcbiAgICBsZXQgdG9vbHRpcEh0bWwgPSB0YXJnZXQuZGF0YXNldC50b29sdGlwXHJcbiAgICAvLyAuLi7RgdC+0LfQtNCw0LTQuNC8INGN0LvQtdC80LXQvdGCINC00LvRjyDQv9C+0LTRgdC60LDQt9C60LhcclxuICAgIGxldCB0b29sdGlwRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgdG9vbHRpcEVsZW0uY2xhc3NOYW1lID0gJ3Rvb2x0aXAnO1xyXG4gICAgdG9vbHRpcEVsZW0uaW5uZXJIVE1MID0gdG9vbHRpcEh0bWw7XHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZCh0b29sdGlwRWxlbSk7XHJcblxyXG4gICAgLy8g0YHQv9C+0LfQuNGG0LjQvtC90LjRgNGD0LXQvCDQtdCz0L4g0YHQstC10YDRhdGDINC+0YIg0LDQvdC90L7RgtC40YDRg9C10LzQvtCz0L4g0Y3Qu9C10LzQtdC90YLQsCAodG9wLWNlbnRlcilcclxuICAgIGxldCBjb29yZHMgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG4gICAgbGV0IGxlZnQgPSBjb29yZHMubGVmdCArICh0YXJnZXQub2Zmc2V0V2lkdGggLSB0b29sdGlwRWxlbS5vZmZzZXRXaWR0aCkgLyAyO1xyXG4gICAgaWYgKGxlZnQgPCAwKSBsZWZ0ID0gMDsgLy8g0L3QtSDQt9Cw0LXQt9C20LDRgtGMINC30LAg0LvQtdCy0YvQuSDQutGA0LDQuSDQvtC60L3QsFxyXG5cclxuICAgIGxldCB0b3AgPSBjb29yZHMudG9wIC0gdG9vbHRpcEVsZW0ub2Zmc2V0SGVpZ2h0IC0gNTtcclxuICAgIGlmICh0b3AgPCAwKSB7IC8vINC10YHQu9C4INC/0L7QtNGB0LrQsNC30LrQsCDQvdC1INC/0L7QvNC10YnQsNC10YLRgdGPINGB0LLQtdGA0YXRgywg0YLQviDQvtGC0L7QsdGA0LDQttCw0YLRjCDQtdGRINGB0L3QuNC30YNcclxuICAgICAgdG9wID0gY29vcmRzLnRvcCArIHRhcmdldC5vZmZzZXRIZWlnaHQgKyA1O1xyXG4gICAgfVxyXG5cclxuICAgIHRvb2x0aXBFbGVtLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcclxuICAgIHRvb2x0aXBFbGVtLnN0eWxlLnRvcCA9IHRvcCArICdweCc7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gaGlkZVRpcCgpIHtcclxuICAgIGxldCB0b29sdGlwcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy50b29sdGlwJylcclxuICAgIGlmICh0b29sdGlwcykge1xyXG4gICAgICBbXS5mb3JFYWNoLmNhbGwodG9vbHRpcHMsICh0aXApID0+IHtcclxuICAgICAgICAgIHRpcC5yZW1vdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIClcclxuICAgIH1cclxuICB9O1xyXG59XHJcbiIsImltcG9ydCAnLi9hZG1pbi5zY3NzJ1xyXG5cclxuaW1wb3J0ICcuLi9jb21wb25lbnRzL2hlYWRlci9oZWFkZXItYWRtJ1xyXG5pbXBvcnQgJy4uL2NvbXBvbmVudHMvYWNjb3JkaW9uL2FjY29yZGlvbidcclxuaW1wb3J0ICcuLi9jb21wb25lbnRzL2FkbWluX3NpZGViYXInXHJcbmltcG9ydCBcIi4vbW9kZWwvY2FjaGVcIjtcclxuaW1wb3J0IHskfSBmcm9tIFwiLi4vY29tbW9uXCI7XHJcblxyXG5pbXBvcnQgJy4uL1Rlc3QvdGVzdF9yZXN1bHRzL3Rlc3RfcmVzdWx0cydcclxuaW1wb3J0ICcuLi9UZXN0L29wZW50ZXN0LWVkaXQnXHJcbmltcG9ydCB0ZXN0RWRpdCBmcm9tICcuLi9UZXN0L3Rlc3QtZWRpdCdcclxuaW1wb3J0ICcuLi9UZXN0L2RvJ1xyXG5pbXBvcnQgJy4vU2V0dGluZ3Mvc2V0dGluZ3MnXHJcbmltcG9ydCByaWdodHMgZnJvbSAnLi9SaWdodHMvcmlnaHRzJ1xyXG5pbXBvcnQgJy4vUGxhbm5pbmcvcGxhbm5pbmcnXHJcbmltcG9ydCB1c2VyIGZyb20gJy4vdXNlci91c2VyJ1xyXG5pbXBvcnQgJy4uL1Rlc3Qvb3Blbl90ZXN0J1xyXG5cclxuaW1wb3J0IHJhZGlvIGZyb20gJ0Bjb21wb25lbnRzL3JhZGlvL3JhZGlvJ1xyXG5pbXBvcnQgbGlzdCBmcm9tICdAY29tcG9uZW50cy9saXN0L2xpc3QnXHJcbmltcG9ydCBtdWx0aXNlbGVjdCBmcm9tICdAY29tcG9uZW50cy9tdWx0aXNlbGVjdC9tdWx0aXNlbGVjdCdcclxuaW1wb3J0IGNhdGFsb2dJdGVtIGZyb20gJ0Bjb21wb25lbnRzL2NhdGFsb2ctaXRlbS9jYXRhbG9nLWl0ZW0nXHJcbmltcG9ydCBjYXRhbG9nRGF0ZSBmcm9tICdAY29tcG9uZW50cy9kYXRlL2RhdGUnXHJcbmltcG9ydCB0b29sdGlwcyBmcm9tIFwiLi4vY29tcG9uZW50cy90b29sdGlwL3Rvb2x0aXBcIjtcclxuaW1wb3J0IGFjY29yZGlvblNob3cgZnJvbSBcIi4uL2NvbXBvbmVudHMvYWNjb3JkaW9uLXNob3dcIjtcclxuXHJcbiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgbmF2aWdhdGUod2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKVxyXG4gIHJhZGlvKClcclxuICBsaXN0KClcclxuICBtdWx0aXNlbGVjdCgpXHJcbiAgY2F0YWxvZ0l0ZW0oKVxyXG4gIHRvb2x0aXBzKClcclxuXHJcbiAgYWNjb3JkaW9uU2hvdygpXHJcblxyXG4gIHRlc3RFZGl0KClcclxuXHJcbiAgZnVuY3Rpb24gbmF2aWdhdGUoc3RyKSB7XHJcbiAgICBpZiAoL1xcL2FkbWluc2NcXC9zZXR0aW5ncy8udGVzdChzdHIpXHJcbiAgICAgIHx8IC9cXC9hZG1pbnNjXFwvcmlnaHRcXC9saXN0Ly50ZXN0KHN0cilcclxuICAgICAgfHwgL1xcL2FkbWluc2NcXC9wb3N0XFwvbGlzdC8udGVzdChzdHIpIHx8XHJcbiAgICAgIC9cXC9hZG1pbnNjXFwvdG9kb1xcL2xpc3QvLnRlc3Qoc3RyKSkge1xyXG4gICAgICByaWdodHMoKVxyXG4gICAgICAkKFwiW2hyZWY9Jy9hZG1pbnNjL3NldHRpbmdzJ11cIikuYWRkQ2xhc3MoJ2N1cnJlbnQnKVxyXG4gICAgfSBlbHNlIGlmICgvXFwvYWRtaW5zY1xcL3Rlc3RyZXN1bHRcXC9yZXN1bHRzLy50ZXN0KHN0cikpIHtcclxuICAgICAgJChcIltocmVmPScvYWRtaW5zYy90ZXN0L3Jlc3VsdHMnXVwiKS5hZGRDbGFzcygnY3VycmVudCcpXHJcbiAgICB9IGVsc2UgaWYgKC9cXC9hZG1pbnNjXFwvdGVzdHJlc3VsdFxcL3Jlc3VsdHMvLnRlc3Qoc3RyKSkge1xyXG4gICAgICAkKFwiW2hyZWY9Jy9hZG1pbnNjL3Rlc3QvcmVzdWx0cyddXCIpLmFkZENsYXNzKCdjdXJyZW50JylcclxuICAgIH0gZWxzZSBpZiAoL1xcL2F1dGhcXC9wcm9maWxlLy50ZXN0KHN0cikpIHtcclxuICAgICAgdXNlcigpXHJcbiAgICB9IGVsc2UgaWYgKC9cXC9hZG1pbnNjXFwvY3JtLy50ZXN0KHN0cikpIHtcclxuICAgICAgJChcIltocmVmPScvYWRtaW5zYy9jcm0nXVwiKS5hZGRDbGFzcygnY3VycmVudCcpXHJcbiAgICB9IGVsc2UgaWYgKC9cXC9hZG1pbnNjXFwvY2F0YWxvZy8udGVzdChzdHIpKSB7XHJcbiAgICAgICQoXCJbaHJlZj0nL2FkbWluc2MvY2F0YWxvZyddXCIpLmFkZENsYXNzKCdjdXJyZW50JylcclxuICAgIH0gZWxzZSBpZiAoL1xcL2FkbWluc2NcXC9wbGFubmluZy8udGVzdChzdHIpKSB7XHJcbiAgICAgICQoXCJbaHJlZj0nL2FkbWluc2MvcGxhbm5pbmcnXVwiKS5hZGRDbGFzcygnY3VycmVudCcpXHJcbiAgICB9IGVsc2UgaWYgKC9cXC9hZG1pbnNjXFwvdGVzdFxcL3BhdGhzaG93Ly50ZXN0KHN0cilcclxuICAgICAgfHwgL1xcL2FkbWluc2NcXC90ZXN0XFwvZWRpdC8udGVzdChzdHIpKSB7XHJcbiAgICAgICQoXCJbaHJlZj0nL2FkbWluc2MvdGVzdC9lZGl0J11cIikuYWRkQ2xhc3MoJ2N1cnJlbnQnKVxyXG4gICAgfSBlbHNlIGlmICgvXFwvdGVzdC8udGVzdChzdHIpIHx8IC9cXC90ZXN0XFwvcmVzdWx0Ly50ZXN0KHN0cikpIHtcclxuICAgICAgJChcIltocmVmPScvdGVzdC9kbyddXCIpLmFkZENsYXNzKCdjdXJyZW50JylcclxuICAgIH0gZWxzZSBpZiAoL1xcL2FkbWluc2NcXC9TaXRlbWFwLy50ZXN0KHN0cikpIHtcclxuICAgICAgJChcIltocmVmPScvYWRtaW5zYy9zZXR0aW5ncyddXCIpLmFkZENsYXNzKCdjdXJyZW50JylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICQoXCJbaHJlZj0nL2FkbWluc2MnXVwiKS5hZGRDbGFzcygnY3VycmVudCcpXHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbn0pXHJcblxyXG5cclxuXHJcbiJdLCJuYW1lcyI6WyJkZWJvdW5jZSIsImZuIiwidGltZSIsInRpbWVvdXQiLCJmdW5jdGlvbkNhbGwiLCJhcHBseSIsImFyZ3VtZW50cyIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJJc0pzb24iLCJzdHIiLCJKU09OIiwicGFyc2UiLCJlIiwicmVwbGFjZU5ic3BzIiwicmUiLCJSZWdFeHAiLCJyZXBsYWNlIiwicmVwbGFjZU5zIiwicmVwbGFjZVRzIiwiY2FjaGVQYWdlIiwiY2xhc3NOYW1lIiwiaHRtbCIsIiQiLCJvdXRlckhUTUwiLCJ0cmltU3RyIiwiZHJvcERvd24iLCJlbGVtZW50SWQiLCJkcm9wZG93biIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJzaG93RHJvcGRvd24iLCJlbGVtZW50IiwiZXZlbnQiLCJjcmVhdGVFdmVudCIsImluaXRNb3VzZUV2ZW50Iiwid2luZG93IiwiZGlzcGF0Y2hFdmVudCIsInZhbGlkYXRlIiwic29ydCIsImVycm9yIiwibmV4dEVsZW1lbnRTaWJsaW5nIiwiYXIiLCJ2YWx1ZSIsIm1hdGNoIiwiaW5uZXJUZXh0Iiwic3R5bGUiLCJvcGFjaXR5IiwiZW1haWwiLCJ0ZXh0IiwicmVzIiwidGVzdCIsIlN0cmluZyIsInRvTG93ZXJDYXNlIiwicGFzc3dvcmQiLCJwb3B1cCIsInNob3ciLCJ0eHQiLCJjYWxsYmFjayIsImNsb3NlIiwiZWwiLCJwb3B1cF9faXRlbSIsImFwcGVuZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJib2R5IiwiaGlkZURlbGF5IiwiY2xhc3NMaXN0IiwicmVtb3ZlIiwiYWRkIiwicmVtb3ZlRGVsYXkiLCJ0YXJnZXQiLCJjb250YWlucyIsImNsb3Nlc3QiLCJ0YWdOYW1lIiwiY3JlYXRlRWxlbWVudCIsInVuaXEiLCJhcnJheSIsIkFycmF5IiwiZnJvbSIsIlNldCIsImdldCIsImtleSIsInAiLCJsb2NhdGlvbiIsInNlYXJjaCIsInBvc3QiLCJ1cmwiLCJkYXRhIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ0b2tlbiIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRBdHRyaWJ1dGUiLCJyZXEiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJzZXRSZXF1ZXN0SGVhZGVyIiwiRm9ybURhdGEiLCJzZW5kIiwic3RyaW5naWZ5Iiwib25lcnJvciIsIkVycm9yIiwib25sb2FkIiwicmVzcG9uc2UiLCJtc2ciLCJpbm5lckhUTUwiLCJyZW1vdmVDbGFzcyIsInN1Y2Nlc3MiLCJhZGRDbGFzcyIsIkVsZW1lbnRDb2xsZWN0aW9uIiwiYXR0ck5hbWUiLCJhdHRyVmFsIiwic2V0QXR0cmlidXRlIiwibGVuZ3RoIiwic2VsZWN0ZWRPcHRpb25zIiwib3B0aW9ucyIsImNoZWNrZWQiLCJhdHRyIiwidmFsIiwiYXJyIiwiZm9yRWFjaCIsInMiLCJwdXNoIiwiYXBwZW5kQ2hpbGQiLCJpdGVtIiwiZmlsdGVyZWQiLCJmaWx0ZXIiLCJxdWVyeVNlbGVjdG9yQWxsIiwib24iLCJjYk9yU2VsZWN0b3IiLCJjYiIsImVsZW0iLCJyZWFkeSIsImlzUmVhZHkiLCJzb21lIiwicmVhZHlTdGF0ZSIsInNlbGVjdG9yIiwiYWRkVG9vbHRpcCIsImFyZ3MiLCJjYWxsIiwib25tb3VzZWVudGVyIiwidGlwIiwibWVzc2FnZSIsImJpbmQiLCJvbm1vdXNlbGVhdmUiLCJhY2NvcmRpb25zIiwiY2hlY2tib3hlcyIsImNoIiwiaGFuZGxlIiwibGkiLCJ1bCIsImZpbmQiLCJyb3RhdGVBcnJvdyIsInNsaWRlVXAiLCJwYXJlbnQiLCJjbG9zZVNpYmxpbmdzIiwic2xpZGVEb3duIiwibWF4SGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0IiwidG9nZ2xlIiwiaW5jcmVhc2VQYXJlbnQiLCJ1bEhlaWdodCIsInBhcmVudEhlaWdodCIsInBhcnNlSW50Iiwic2lkZWJhciIsImFjY29yZGlvbiIsIl9jYWNoZSIsImNsZWFyQ2FjaGUiLCJjYWNoZSIsIl90ZXN0UmVzdWx0IiwiZGVsU2VydmVyIiwiaWQiLCJkZWxEb20iLCJtYXAiLCJpIiwiZGVsZXRlIiwiY29uZmlybSIsInRlc3RSZXN1bHRzIiwiaGFuZGxlQ2xpY2siLCJkYXRhc2V0Iiwicm93IiwidGVzdFJlc3VsdCIsIm9wZW5xdWVzdGlvbiIsInRlc3RJZCIsImNyZWF0ZSIsIm9wZW50ZXN0X2lkIiwicXVlc3Rpb25DbnQiLCJtb2RlbCIsImNsb25lIiwiY2xvbmVFbXB0eU1vZGVsIiwiYWRkQnRuIiwiYmVmb3JlIiwicXVlc3Rpb24iLCJxIiwiY2xvbmVOb2RlIiwiYW5zIiwiYW5zd2VyIiwidXBUb1Flc3Rpb25OdW1iZXIiLCJxdWVzdGlvbnNFbHMiLCJxdWVzdGlvbnMiLCJ0b0NoYW5nZSIsImNoYW5nZVBhcmVudCIsInRlc3RfaWQiLCJ0ZXN0X25hbWUiLCJzaG93QW5zd2VycyIsImFuc3dlcnMiLCJkZWwiLCJfb3BlbnF1ZXN0aW9uIiwiU29ydGFibGUiLCJzb3J0YWJsZSIsImNvbnRhaW5lclNlbGVjdG9yIiwiZWxTZWxlY3RvciIsImNvbnRhaW5lciIsImFuaW1hdGlvbiIsIm9uRW5kIiwiZXZ0Iiwib2xkSSIsIm9sZEluZGV4IiwibmV3SSIsIm5ld0luZGV4IiwiZWxzIiwiX3Rlc3QiLCJjb25zdHJ1Y3RvciIsInNlcnZlck1vZGVsIiwiaXNUZXN0IiwiaHJlZiIsImN1cnJlbnRRIiwiUUVsIiwibmF2TGVuZ3RoIiwiUVByZXZjIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsIlFOZXh0RWwiLCJ2aWV3TW9kZWwiLCJzcGxpdCIsInBvcCIsImVuYWJsZSIsInNlbGVjdGVkSW5kZXhWYWx1ZSIsInRlc3RpZCIsImNoaWxkcmVuIiwiY2hpbGRyZW5MZW5naHQiLCJwYXRoX2NyZWF0ZSIsInRlc3RfcGF0aCIsIm5hbWUiLCJzZWxlY3RlZFZhbHVlQ3VzdG9tU2VsZWN0Iiwic2VsZWN0Iiwic2VsZWN0ZWQiLCJvcHQiLCJmaWVsZHMiLCJmaWVsZCIsInVwZGF0ZSIsIm5vdEFkbWluIiwiX2Fuc3dlciIsImJ1dHRvbiIsIm9wZW5xdWVzdGlvbl9pZCIsImluc2VydEFkamFjZW50SFRNTCIsImRlbF9idXR0b24iLCJvcGVudGVzdEVkaXQiLCJoYW5kbGVDaGFuZ2UiLCJoYW5kbGVLZXl1cCIsInNhdmVBbnN3ZXIiLCJkZWJvdW5jZWRJbnB1dCIsImFuc3dlckVsIiwiYW5zd2VySWQiLCJpc19jb3JyZWN0IiwicV9pZCIsImdldEFuc3dlck1vZGVsIiwiYW5zd2VyQ3JlYXRlIiwiYW5zd2VyTW9kZWwiLCJxdWVzdGlvbl9pZCIsImNvcnJlY3RfYW5zd2VyIiwicGljYSIsInF1ZXN0aW9uQ3JlYXRlIiwicXVlc3Rpb25Nb2RlbCIsImdldFF1ZXN0aW9uTW9kZWwiLCJxdXN0aW9uIiwic2VsZWN0ZWRJbmRleCIsInNhdmVRdWVzdGlvbiIsIl9xdWVzdGlvbiIsIldEU1NlbGVjdCIsInRlc3RFZGl0IiwiZGVib3VuY2VkSGFuZGxlS2V5dXAiLCJwYWdpbmF0aW9uIiwibmF2SW5pdCIsImFjdGl2ZV9idG4iLCJpZF90b19oaWRlIiwiaWRfdG9fc2hvdyIsIm5hdl9idXR0b25zIiwibmF2IiwidGVzdERvIiwic2hvd0ZpcnN0UXVlc3QiLCJmaW5pc2hCdG5Jbml0IiwicGF0aG5hbWUiLCJjdXJyUXVlc3QiLCJuYXZzIiwibmF2SW5kZXgiLCJmaW5kSW5kZXgiLCJ0eXBlIiwiYSIsImxhYmVscyIsInByZXZRIiwibmV4dFEiLCJhaW1JZCIsInB1c2hOYXYiLCJwdXNoUSIsImN1cnJlbnRJZCIsImFpbU5hdklkIiwiY3Vyck5hdkVsIiwiTmF2RWwiLCJhaW1RdWVzdGlvbiIsInJlbG9hZCIsImNvcnJBbnN3ZXJzIiwiZXJyb3JDbnQiLCJjb2xvclZpZXciLCJvYmpUb1NlcnZlciIsInRlc3RuYW1lIiwidXNlciIsImNvcnJlY3RBbnN3ZXJzIiwiZXJyb3JzIiwiaW5wdXQiLCJjaGVja0NvcnJlY3RBbnN3ZXJzIiwicGFnaW5JdGVtIiwiY29ycmVjdEFuc2VyIiwiaW5kZXhPZiIsImxpc3QiLCJ0YWJsZXMiLCJ0YWJsZSIsImNvbnRlbnRlZGl0YWJsZSIsImhlYWRlcnMiLCJzb3J0YWJsZXMiLCJpbnB1dHMiLCJmaW5kQWxsIiwiaWRzIiwibW9kZWxOYW1lIiwicm93cyIsImhhbmRsZUtleVVwIiwiaGFuZGxlSW5wdXQiLCJoYXNBdHRyaWJ1dGUiLCJoZWFkZXIiLCJpbmRleCIsIm1vZGVsQ3JlYXRlIiwibW9kZWxEZWwiLCJzb3J0Q29sdW1uIiwiZGVsVmlldyIsIm5ld1JvdyIsIlJvdyIsIm5ld0VsIiwidGFibGVDb250ZW50IiwiaW5jbHVkZXMiLCJzaG93QWxsUm93cyIsImRpc3BsYXkiLCJpbnAiLCJyZWdleHAiLCJkaXJlY3Rpb24iLCJkaXJlY3Rpb25zIiwibXVsdGlwbGllciIsIm5ld1Jvd3MiLCJyb3dBIiwicm93QiIsImNlbGxBIiwiY2VsbEIiLCJ0cmFuc2Zvcm0iLCJiIiwibm9kZUxpc3QiLCJyZXZlcnNlIiwiYWZ0ZXIiLCJjb250ZW50IiwicGFyc2VGbG9hdCIsIm1ha2VTZXJ2ZXJNb2RlbCIsInNhdmUiLCJyaWdodHMiLCJkYXRhSWQiLCJ0b1NlcnYiLCJlbXB0eSIsImYiLCJ0cmltIiwiZGVzY3JpcHRpb24iLCJtb2QiLCJjbGVhck1vZGVsIiwiY3JlYXRlT25Eb20iLCJsYXN0RWxlbWVudCIsImFzc2lnbk5ld1ZhbHVlc09uQ2xvbmUiLCJnZXRTZXgiLCJzZXgiLCJ3cmFwcGVyIiwiZ2V0TW9kZWwiLCJyaWdodCIsInRhYiIsInIiLCJzdXJOYW1lIiwibWlkZGxlTmFtZSIsImJpcnRoRGF0ZSIsInBob25lIiwiaGlyZWQiLCJmaXJlZCIsImFjY29yZGlvblNob3ciLCJjdXJyZW50VGVzdElkIiwibWVudUl0ZW1Db2xsZWN0aW9uIiwibWVudSIsIm9wZW5UZXN0IiwiYWN0aXZlUGFnaW5hdGlvbiIsImFjdGl2ZVF1ZXN0aW9uIiwicGFnaW5hdGlvbnMiLCJwcmV2UXVlc3QiLCJuZXh0UXVlc3QiLCJwYWdpbmF0ZSIsImJsaW5rIiwiZmluaXNoIiwiZ2V0QW5zd2VycyIsImNvcnJlY3RDb3VudCIsIm9iaiIsIm9ialRvU2VydiIsImNhbnYiLCJyaWdodEFuc3dlcnMiLCJ1c2VybmFtZSIsImFpbVBhZ2luYXRpb24iLCJ0b2dnbGVRdWVzdGlvbiIsInRvZ2dsZU5hdiIsImNvcnJlY3QiLCJxX2VsIiwidGV4dGFyZWEiLCJPcGVuYW5zd2VyIiwid29yZCIsImhpZ2hsaWdodCIsImhpbGl0ZXIiLCJhZGRFdmVudExpcyIsInJneHAiLCJ3IiwicmVwbCIsImFpbVBhZ2luYXRpb25JZCIsImFpbVF1ZXN0aW9uSWQiLCJyYWRpbyIsInJhZGlvcyIsInRhcmciLCJtdWx0aXNlbGVjdCIsImdldFNlbGVjdGVkIiwibXVsdGkiLCJjaGlwcyIsIm9ianMiLCJjaGlwIiwiaGFuZGxlQmx1ciIsInRvZ2dsZUJhY2tncm91bmQiLCJleGlzdCIsIndyYXAiLCJjcmVhdGVDaGlwIiwiY2F0YWxvZ0l0ZW0iLCJjdXN0b21DYXRhbG9nSXRlbSIsImhhbmRsZVRhYiIsInZpc2libGVTZWN0aW9uIiwic2VjdGlvbiIsImFjdGl2ZVRhYiIsImNoZWNrUmVxdWlyZWQiLCJyZXF1aXJlZCIsImVyckNvdW50IiwiYm9yZGVyQ29sb3IiLCJ0b1N0cmluZyIsImdldElucHV0cyIsImlzdGVzdCIsIm5hbWVzIiwicGFyZW50Tm9kZSIsImpvaW4iLCJ0b29sdGlwcyIsInNob3dUaXAiLCJoaWRlVGlwIiwidG9vbHRpcCIsInRvb2x0aXBIdG1sIiwidG9vbHRpcEVsZW0iLCJjb29yZHMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJsZWZ0Iiwib2Zmc2V0V2lkdGgiLCJ0b3AiLCJvZmZzZXRIZWlnaHQiLCJjYXRhbG9nRGF0ZSIsIm5hdmlnYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///788\n")}},__webpack_exports__={};__webpack_modules__[788]()})();