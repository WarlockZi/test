(()=>{"use strict";var __webpack_modules__={99:()=>{eval("\n;// CONCATENATED MODULE: ./public/src/common.js\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nconst debounce = function (fn) {\n  let time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 700;\n  let timeout;\n  return function () {\n    const functionCall = () => fn.apply(this, arguments);\n\n    clearTimeout(timeout);\n    timeout = setTimeout(functionCall, time);\n  };\n};\n\nfunction IsJson(str) {\n  try {\n    JSON.parse(str);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction dropDown(elementId) {\n  var dropdown = document.getElementById(elementId);\n\n  try {\n    showDropdown(dropdown);\n  } catch (e) {}\n\n  return false;\n}\n\n;\n\nfunction showDropdown(element) {\n  var event;\n  event = document.createEvent('MouseEvents');\n  event.initMouseEvent('mousedown', true, true, window);\n  element.dispatchEvent(event);\n}\n\n;\nlet validate = {\n  sort: () => {\n    let error = undefined.nextElementSibling;\n    let ar = undefined.value.match(/\\D+/);\n\n    if (ar) {\n      error.innerText = 'Только цифры';\n      error.style.opacity = '1';\n    } else {\n      if (error.style.opacity === \"1\") {\n        error.style.opacity = '0';\n      }\n    }\n  },\n  email: email => {\n    if (!email) return false;\n    let text = \"Неправильный формат почты\";\n    let re = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n    let res = re.test(String(email).toLowerCase());\n    if (!res) return text;\n    return false;\n  },\n  password: password => {\n    if (!password) return false;\n    let text = \"Пароль может состоять из \\n \" + \"- Большие латинские бкувы \\n\" + \"- Маленькие латинские буквы \\n\" + \"- Цифры \\n\" + \"- Должен содержать не менее 6 символов\";\n    let res = /^[a-zA-Z\\-0-9]{6,20}$/.test(password);\n    if (!res) return text;\n    return false;\n  }\n}; // function up() {\n//    var top = Math.max(document.body.scrollTop, document.documentElement.scrollTop);\n//    if (top > 0) {\n//       window.scrollBy(0, -100);\n//       var t = setTimeout('up()', 20);\n//    }\n//    else\n//       clearTimeout(t);\n//    return false;\n// }\n\nlet popup = {\n  show: function (txt, callback) {\n    let close = this.el('div', 'popup__close');\n    close.innerText = 'X';\n    let popup__item = this.el('div', 'popup__item');\n    popup__item.innerText = txt;\n    popup__item.append(close);\n    let popup = common_$('.popup')[0];\n\n    if (!popup) {\n      popup = this.el('div', 'popup');\n    }\n\n    popup.append(popup__item);\n    popup.addEventListener('click', this.close, true);\n    document.body.append(popup);\n    let hideDelay = 5000;\n    setTimeout(() => {\n      popup__item.classList.remove('popup__item');\n      popup__item.classList.add('popup-hide');\n    }, hideDelay);\n    let removeDelay = hideDelay + 950;\n    setTimeout(() => {\n      popup__item.remove();\n\n      if (callback) {\n        callback();\n      }\n    }, removeDelay);\n  },\n  close: function (e) {\n    if (e.target.classList.contains('popup__close')) {\n      let popup = this.closest('.popup').remove();\n    }\n  },\n  el: function (tagName, className) {\n    let el = document.createElement(tagName);\n    el.classList.add(className);\n    return el;\n  }\n};\n\nconst uniq = array => Array.from(new Set(array));\n\nasync function get(key) {\n  let p = window.location.search;\n  p = p.match(new RegExp(key + '=([^&=]+)'));\n  return p ? p[1] : false;\n}\n\nasync function post(url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new Promise(async function (resolve, reject) {\n    data.token = document.querySelector('meta[name=\"token\"]').getAttribute('content');\n    let req = new XMLHttpRequest();\n    req.open('POST', url, true);\n    req.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n\n    if (data instanceof FormData) {\n      req.send(data);\n    } else {\n      req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n      req.send('param=' + JSON.stringify(data));\n    }\n\n    req.onerror = function (e) {\n      reject(Error(\"Network Error\" + e));\n    };\n\n    req.onload = function () {\n      let res = JSON.parse(req.response);\n      let msg = common_$('.message')[0];\n\n      if (res.popup) {\n        popup.show(res.popup);\n      } else if (res.msg) {\n        if (msg) {\n          msg.innerHTML = res.msg;\n          msg.innerHTML = res.msg;\n          common_$(msg).removeClass('success');\n          common_$(msg).removeClass('error');\n        }\n      } else if (res.success) {\n        if (msg) {\n          msg.innerHTML = res.msg;\n          common_$(msg).addClass('error');\n          common_$(msg).removeClass('success');\n        }\n      } else if (res.error) {\n        if (msg) {\n          msg.innerHTML = '';\n          msg.innerHTML = res.error;\n          common_$(msg).removeClass('success');\n          common_$(msg).addClass('error');\n        }\n      }\n\n      resolve(res);\n    };\n  });\n}\n\nclass ElementCollection extends Array {\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"value\", function () {\n      return this[0].getAttribute('value');\n    });\n\n    _defineProperty(this, \"attr\", function (attrName, attrVal) {\n      if (attrVal) {\n        this[0].setAttribute(attrName, attrVal);\n      }\n\n      return this[0].getAttribute(attrName);\n    });\n\n    _defineProperty(this, \"selectedIndexValue\", function () {\n      if (this.length) return this[0].selectedOptions[0].value;\n    });\n\n    _defineProperty(this, \"options\", function () {\n      if (this.length) return this[0].options;\n    });\n\n    _defineProperty(this, \"count\", function () {\n      return this.length;\n    });\n\n    _defineProperty(this, \"text\", function () {\n      if (this.length) return this[0].innerText;\n    });\n\n    _defineProperty(this, \"checked\", function () {\n      if (this.length) return this[0].checked;\n    });\n\n    _defineProperty(this, \"getWithStyle\", function (attr, val) {\n      let arr = [];\n      this.forEach(s => {\n        if (s.style[attr] === val) {\n          arr.push(s);\n        }\n      });\n      return arr;\n    });\n\n    _defineProperty(this, \"addClass\", function (className) {\n      this.forEach(s => {\n        s.classList.add(className);\n      });\n    });\n\n    _defineProperty(this, \"removeClass\", function (className) {\n      this.forEach(s => {\n        s.classList.remove(className);\n      });\n    });\n\n    _defineProperty(this, \"hasClass\", function (className) {\n      if (this.classList.contains(className)) return true;\n    });\n\n    _defineProperty(this, \"append\", function (el) {\n      this[0].appendChild(el);\n    });\n\n    _defineProperty(this, \"find\", function (item) {\n      if (typeof item === 'string') {\n        return this[0].querySelector(item);\n      } else {\n        let filtered = this[0].filter(el => {\n          return el === item;\n        });\n        return filtered[0];\n      }\n    });\n\n    _defineProperty(this, \"findAll\", function (item) {\n      if (typeof item === 'string') {\n        return this[0].querySelectorAll(item);\n      }\n    });\n\n    _defineProperty(this, \"css\", function (attr, val) {\n      if (!val) {\n        return this[0].style[attr];\n      }\n\n      this.forEach(s => {\n        s.style[attr] = val;\n      });\n    });\n  }\n\n  // el = this\n  // elType = function(){return {}.toString.call(this)}\n  on(event, cbOrSelector, cb) {\n    if (typeof cbOrSelector === 'function') {\n      this.forEach(e => e.addEventListener(event, cbOrSelector));\n    } else {\n      this.forEach(elem => {\n        elem.addEventListener(event, e => {\n          if (e.target === cbOrSelector) cb(e);\n        });\n      });\n    }\n  }\n\n  ready(cb) {\n    const isReady = this.some(e => {\n      return e.readyState != null && e.readyState != 'loading';\n    });\n\n    if (isReady) {\n      cb();\n    } else {\n      document.addEventListener('DOMContentLoaded', cb);\n    }\n  }\n\n}\n\nfunction common_$(selector) {\n  if (typeof selector === 'string' || selector instanceof String) {\n    return new ElementCollection(...document.querySelectorAll(selector));\n  } else {\n    return new ElementCollection(selector);\n  }\n}\n\nfunction addTooltip(args) {\n  [].forEach.call(args, el => {\n    el.onmouseenter = function () {\n      let tip = document.createElement('div');\n      tip.classList.add('tip');\n      tip.innerText = args.message;\n      el.append(tip);\n\n      let remove = () => tip.remove();\n\n      tip.addEventListener('mousemove', remove.bind(tip), true);\n    }.bind(args);\n\n    el.onmouseleave = () => {\n      let tip = el.querySelector('.tip');\n      tip.remove();\n    };\n  });\n}\n\n\n;// CONCATENATED MODULE: ./public/src/components/accordion/accordion.js\n\n\nlet accordions = common_$('[accordion]');\n\nif (accordions) {\n  let checkboxes = common_$(`[accordion] [type='checkbox']`);\n\n  if (checkboxes) {\n    [...checkboxes].filter(ch => {\n      ch.checked = false;\n    });\n  }\n\n  common_$('[accordion]').on('click', handle);\n}\n\nfunction handle(_ref) {\n  let {\n    target\n  } = _ref;\n  let li = target.closest('li');\n  if (!li) return; // let accordion = li.closest('[accordion]')\n\n  let ul = common_$(li).find('ul');\n\n  if (!ul) {\n    rotateArrow(li);\n  } else {\n    if (ul.classList.contains('open')) {\n      slideUp(ul, li);\n    } else {\n      // accordion.style.height = \"auto\"\n      if (!ul) return;\n      let parent = li.closest('ul');\n      closeSiblings(parent);\n      slideDown(ul, li, parent);\n    }\n  }\n}\n\nfunction closeSiblings(parent) {\n  if (!parent) return;\n  let open = common_$(parent).find('li>ul.open');\n\n  if (open) {\n    let li = open.closest('li');\n    slideUp(open, li);\n  }\n}\n\nfunction slideDown(ul, li, parent) {\n  if (parent) {\n    parent.style.maxHeight = ul.scrollHeight + parent.scrollHeight + \"px\";\n  }\n\n  ul.style.maxHeight = ul.scrollHeight + \"px\";\n  ul.classList.toggle('open');\n  li.classList.toggle('rotate');\n}\n\nfunction slideUp(ul, li) {\n  ul.style.maxHeight = 0 + \"px\";\n  ul.classList.toggle('open');\n  li.classList.toggle('rotate');\n}\n\nfunction rotateArrow(li) {\n  li.classList.toggle('rotate');\n}\n\nfunction increaseParent(parent, ulHeight) {\n  if (!parent.classList.contains('accordion')) {\n    let parentHeight = parseInt(parent.style.maxHeight) + ulHeight;\n    parent.style.maxHeight = parentHeight + \"px\";\n  }\n}\n;// CONCATENATED MODULE: ./public/src/components/admin_sidebar.js\n\nlet sidebar = common_$('.admin_sidebar')[0];\n\nif (sidebar) {\n  common_$('svg#burger').on('click', function () {\n    let accordion = common_$('.admin_sidebar [accordion]')[0];\n    accordion.classList.toggle('show');\n  });\n}\n;// CONCATENATED MODULE: ./public/src/Admin/model/cache.js\n\n\nlet _cache = {\n  clearCache: async function () {\n    let res = await post('/adminsc/clearCache', {});\n\n    if (res === 'Успешно') {\n      popup.show(res);\n    }\n  }\n};\nfunction cache() {\n  $('.clearCache').on('click', _cache.clearCache);\n}\n;// CONCATENATED MODULE: ./public/src/Test/model/_testResult.js\n\nconst _testResult = {\n  delServer: async id => {\n    let res = await post('/adminsc/testresult/delete', {\n      id\n    });\n\n    if (res) {\n      popup.show('Удалено');\n    }\n  },\n  delDom: id => {\n    [].map.call(common_$(`[data-row = \"${id}\"]`), function (i) {\n      i.remove();\n    });\n  },\n  delete: id => {\n    if (confirm(\"Удалить результат теста?\")) {\n      _testResult.delDom(id);\n\n      _testResult.delServer(id);\n    }\n  }\n};\n;// CONCATENATED MODULE: ./public/src/Test/test_results/test_results.js\n\n\n\nlet testResults = common_$('.test-results__table')[0];\n\nif (testResults) {\n  common_$(testResults).on('click', handleClick);\n}\n\nfunction handleClick(_ref) {\n  let {\n    target\n  } = _ref;\n\n  if (!!target.closest('.del-btn')) {\n    let id = target.closest('.del-btn').dataset.row;\n\n    _testResult[\"delete\"](id);\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Test/model/opentest/openquestion.js\nfunction openquestion_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nclass openquestion {\n  constructor() {\n    openquestion_defineProperty(this, \"model\", 'openquestion');\n\n    openquestion_defineProperty(this, \"questions\", common_$('.questions>.question-edit'));\n\n    openquestion_defineProperty(this, \"testId\", +common_$('.questions')[0]?.dataset.testId ?? null);\n\n    openquestion_defineProperty(this, \"questionCnt\", common_$('.questions>.question-edit').length ?? null);\n  }\n\n  async create(target) {\n    let id = 0;\n    let opentest_id = this.testId;\n    let sort = this.questionCnt + 1;\n    let res = await post(`/adminsc/${this.model}/updateOrCreate`, {\n      id,\n      opentest_id,\n      sort\n    });\n    res = await JSON.parse(res);\n\n    if (res.id) {\n      let clone = this.cloneEmptyModel();\n      let addBtn = target.closest('.question__create-button');\n      clone.querySelector('.sort').innerText = this.questionCnt + 1;\n      clone.querySelector('.text').innerText = '';\n      clone.id = res.id;\n      addBtn.before(clone);\n    }\n  }\n\n  cloneEmptyModel() {\n    let question = common_$('.questions .question-edit')[0];\n\n    if (question) {\n      let q = question.cloneNode(true);\n      let ans = q.querySelectorAll('.row .answer');\n      [].forEach.call(ans, function (answer) {\n        answer.remove();\n      });\n      return q;\n    }\n  }\n\n  async sort(upToQestionNumber) {\n    let questionsEls = this.questions.filter(function (el, i) {\n      if (i + 1 < upToQestionNumber) return el;\n    });\n    let toChange = questionsEls.map(el => {\n      return el.id;\n    });\n    let res = await post(`/${this.model}/sort`, {\n      toChange\n    }); // res = JSON.parse(res)\n    // if (res.msg) {\n    //   popup.show(res.msg)\n    // }\n\n    questionsEls.map((el, i) => {\n      common_$(el).find('.sort').innerText = i + 1;\n    });\n  }\n\n  async changeParent(target) {\n    // debugger\n    if (target.tagName.toLowerCase() !== 'li') return;\n    let id = target.closest('.question-edit').id;\n    let test_id = target.dataset['value'];\n    let test_name = target.innerText;\n    if (!+id || !+test_id || !test_name) return;\n    let res = await post(`/adminsc/${this.model}/changeParent`, {\n      id,\n      test_id\n    });\n    res = JSON.parse(res);\n    if (res.msg !== 'ok') throw e;\n    let question = target.closest('.question-edit');\n    question.remove();\n    popup.show('Перемещен в ' + test_name);\n  }\n\n  showAnswers(target) {\n    let row = target.closest('.question-edit');\n    let answers = common_$(row).find('.question__answers');\n    answers.classList.toggle('height');\n    answers.classList.toggle('scale');\n    target.classList.toggle('rotate');\n  }\n\n  async del(target) {\n    if (confirm(\"Удалить вопрос со всеми его ответами?\")) {\n      let question = target.closest('.question-edit');\n      let id = question.id;\n      let res = await post(`/adminsc/${this.model}/delete`, {\n        id\n      });\n      res = JSON.parse(res);\n\n      if (res) {\n        question.remove();\n      }\n    }\n  }\n\n}\n\nconst _openquestion = new openquestion();\n;// CONCATENATED MODULE: ./node_modules/sortablejs/modular/sortable.esm.js\n/**!\n * Sortable 1.15.0\n * @author\tRubaXa   <trash@rubaxa.org>\n * @author\towenm    <owen23355@gmail.com>\n * @license MIT\n */\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        sortable_esm_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction sortable_esm_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar version = \"1.15.0\";\n\nfunction userAgent(pattern) {\n  if (typeof window !== 'undefined' && window.navigator) {\n    return !! /*@__PURE__*/navigator.userAgent.match(pattern);\n  }\n}\n\nvar IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\\.|msie|iemobile|Windows Phone)/i);\nvar Edge = userAgent(/Edge/i);\nvar FireFox = userAgent(/firefox/i);\nvar Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);\nvar IOS = userAgent(/iP(ad|od|hone)/i);\nvar ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);\n\nvar captureMode = {\n  capture: false,\n  passive: false\n};\n\nfunction on(el, event, fn) {\n  el.addEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction off(el, event, fn) {\n  el.removeEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction matches(\n/**HTMLElement*/\nel,\n/**String*/\nselector) {\n  if (!selector) return;\n  selector[0] === '>' && (selector = selector.substring(1));\n\n  if (el) {\n    try {\n      if (el.matches) {\n        return el.matches(selector);\n      } else if (el.msMatchesSelector) {\n        return el.msMatchesSelector(selector);\n      } else if (el.webkitMatchesSelector) {\n        return el.webkitMatchesSelector(selector);\n      }\n    } catch (_) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction getParentOrHost(el) {\n  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;\n}\n\nfunction closest(\n/**HTMLElement*/\nel,\n/**String*/\nselector,\n/**HTMLElement*/\nctx, includeCTX) {\n  if (el) {\n    ctx = ctx || document;\n\n    do {\n      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {\n        return el;\n      }\n\n      if (el === ctx) break;\n      /* jshint boss:true */\n    } while (el = getParentOrHost(el));\n  }\n\n  return null;\n}\n\nvar R_SPACE = /\\s+/g;\n\nfunction toggleClass(el, name, state) {\n  if (el && name) {\n    if (el.classList) {\n      el.classList[state ? 'add' : 'remove'](name);\n    } else {\n      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');\n      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');\n    }\n  }\n}\n\nfunction css(el, prop, val) {\n  var style = el && el.style;\n\n  if (style) {\n    if (val === void 0) {\n      if (document.defaultView && document.defaultView.getComputedStyle) {\n        val = document.defaultView.getComputedStyle(el, '');\n      } else if (el.currentStyle) {\n        val = el.currentStyle;\n      }\n\n      return prop === void 0 ? val : val[prop];\n    } else {\n      if (!(prop in style) && prop.indexOf('webkit') === -1) {\n        prop = '-webkit-' + prop;\n      }\n\n      style[prop] = val + (typeof val === 'string' ? '' : 'px');\n    }\n  }\n}\n\nfunction matrix(el, selfOnly) {\n  var appliedTransforms = '';\n\n  if (typeof el === 'string') {\n    appliedTransforms = el;\n  } else {\n    do {\n      var transform = css(el, 'transform');\n\n      if (transform && transform !== 'none') {\n        appliedTransforms = transform + ' ' + appliedTransforms;\n      }\n      /* jshint boss:true */\n\n    } while (!selfOnly && (el = el.parentNode));\n  }\n\n  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;\n  /*jshint -W056 */\n\n  return matrixFn && new matrixFn(appliedTransforms);\n}\n\nfunction find(ctx, tagName, iterator) {\n  if (ctx) {\n    var list = ctx.getElementsByTagName(tagName),\n        i = 0,\n        n = list.length;\n\n    if (iterator) {\n      for (; i < n; i++) {\n        iterator(list[i], i);\n      }\n    }\n\n    return list;\n  }\n\n  return [];\n}\n\nfunction getWindowScrollingElement() {\n  var scrollingElement = document.scrollingElement;\n\n  if (scrollingElement) {\n    return scrollingElement;\n  } else {\n    return document.documentElement;\n  }\n}\n/**\n * Returns the \"bounding client rect\" of given element\n * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted\n * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container\n * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr\n * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone\n * @param  {[HTMLElement]} container              The parent the element will be placed in\n * @return {Object}                               The boundingClientRect of el, with specified adjustments\n */\n\n\nfunction getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {\n  if (!el.getBoundingClientRect && el !== window) return;\n  var elRect, top, left, bottom, right, height, width;\n\n  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {\n    elRect = el.getBoundingClientRect();\n    top = elRect.top;\n    left = elRect.left;\n    bottom = elRect.bottom;\n    right = elRect.right;\n    height = elRect.height;\n    width = elRect.width;\n  } else {\n    top = 0;\n    left = 0;\n    bottom = window.innerHeight;\n    right = window.innerWidth;\n    height = window.innerHeight;\n    width = window.innerWidth;\n  }\n\n  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {\n    // Adjust for translate()\n    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)\n    // Not needed on <= IE11\n\n    if (!IE11OrLess) {\n      do {\n        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {\n          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container\n\n          top -= containerRect.top + parseInt(css(container, 'border-top-width'));\n          left -= containerRect.left + parseInt(css(container, 'border-left-width'));\n          bottom = top + elRect.height;\n          right = left + elRect.width;\n          break;\n        }\n        /* jshint boss:true */\n\n      } while (container = container.parentNode);\n    }\n  }\n\n  if (undoScale && el !== window) {\n    // Adjust for scale()\n    var elMatrix = matrix(container || el),\n        scaleX = elMatrix && elMatrix.a,\n        scaleY = elMatrix && elMatrix.d;\n\n    if (elMatrix) {\n      top /= scaleY;\n      left /= scaleX;\n      width /= scaleX;\n      height /= scaleY;\n      bottom = top + height;\n      right = left + width;\n    }\n  }\n\n  return {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    width: width,\n    height: height\n  };\n}\n/**\n * Checks if a side of an element is scrolled past a side of its parents\n * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question\n * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')\n * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')\n * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element\n */\n\n\nfunction isScrolledPast(el, elSide, parentSide) {\n  var parent = getParentAutoScrollElement(el, true),\n      elSideVal = getRect(el)[elSide];\n  /* jshint boss:true */\n\n  while (parent) {\n    var parentSideVal = getRect(parent)[parentSide],\n        visible = void 0;\n\n    if (parentSide === 'top' || parentSide === 'left') {\n      visible = elSideVal >= parentSideVal;\n    } else {\n      visible = elSideVal <= parentSideVal;\n    }\n\n    if (!visible) return parent;\n    if (parent === getWindowScrollingElement()) break;\n    parent = getParentAutoScrollElement(parent, false);\n  }\n\n  return false;\n}\n/**\n * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\n * and non-draggable elements\n * @param  {HTMLElement} el       The parent element\n * @param  {Number} childNum      The index of the child\n * @param  {Object} options       Parent Sortable's options\n * @return {HTMLElement}          The child at index childNum, or null if not found\n */\n\n\nfunction getChild(el, childNum, options, includeDragEl) {\n  var currentChild = 0,\n      i = 0,\n      children = el.children;\n\n  while (i < children.length) {\n    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {\n      if (currentChild === childNum) {\n        return children[i];\n      }\n\n      currentChild++;\n    }\n\n    i++;\n  }\n\n  return null;\n}\n/**\n * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\n * @param  {HTMLElement} el       Parent element\n * @param  {selector} selector    Any other elements that should be ignored\n * @return {HTMLElement}          The last child, ignoring ghostEl\n */\n\n\nfunction lastChild(el, selector) {\n  var last = el.lastElementChild;\n\n  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {\n    last = last.previousElementSibling;\n  }\n\n  return last || null;\n}\n/**\n * Returns the index of an element within its parent for a selected set of\n * elements\n * @param  {HTMLElement} el\n * @param  {selector} selector\n * @return {number}\n */\n\n\nfunction index(el, selector) {\n  var index = 0;\n\n  if (!el || !el.parentNode) {\n    return -1;\n  }\n  /* jshint boss:true */\n\n\n  while (el = el.previousElementSibling) {\n    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {\n      index++;\n    }\n  }\n\n  return index;\n}\n/**\n * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\n * The value is returned in real pixels.\n * @param  {HTMLElement} el\n * @return {Array}             Offsets in the format of [left, top]\n */\n\n\nfunction getRelativeScrollOffset(el) {\n  var offsetLeft = 0,\n      offsetTop = 0,\n      winScroller = getWindowScrollingElement();\n\n  if (el) {\n    do {\n      var elMatrix = matrix(el),\n          scaleX = elMatrix.a,\n          scaleY = elMatrix.d;\n      offsetLeft += el.scrollLeft * scaleX;\n      offsetTop += el.scrollTop * scaleY;\n    } while (el !== winScroller && (el = el.parentNode));\n  }\n\n  return [offsetLeft, offsetTop];\n}\n/**\n * Returns the index of the object within the given array\n * @param  {Array} arr   Array that may or may not hold the object\n * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find\n * @return {Number}      The index of the object in the array, or -1\n */\n\n\nfunction indexOfObject(arr, obj) {\n  for (var i in arr) {\n    if (!arr.hasOwnProperty(i)) continue;\n\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);\n    }\n  }\n\n  return -1;\n}\n\nfunction getParentAutoScrollElement(el, includeSelf) {\n  // skip to window\n  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();\n  var elem = el;\n  var gotSelf = false;\n\n  do {\n    // we don't need to get elem css if it isn't even overflowing in the first place (performance)\n    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {\n      var elemCSS = css(elem);\n\n      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {\n        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();\n        if (gotSelf || includeSelf) return elem;\n        gotSelf = true;\n      }\n    }\n    /* jshint boss:true */\n\n  } while (elem = elem.parentNode);\n\n  return getWindowScrollingElement();\n}\n\nfunction extend(dst, src) {\n  if (dst && src) {\n    for (var key in src) {\n      if (src.hasOwnProperty(key)) {\n        dst[key] = src[key];\n      }\n    }\n  }\n\n  return dst;\n}\n\nfunction isRectEqual(rect1, rect2) {\n  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);\n}\n\nvar _throttleTimeout;\n\nfunction throttle(callback, ms) {\n  return function () {\n    if (!_throttleTimeout) {\n      var args = arguments,\n          _this = this;\n\n      if (args.length === 1) {\n        callback.call(_this, args[0]);\n      } else {\n        callback.apply(_this, args);\n      }\n\n      _throttleTimeout = setTimeout(function () {\n        _throttleTimeout = void 0;\n      }, ms);\n    }\n  };\n}\n\nfunction cancelThrottle() {\n  clearTimeout(_throttleTimeout);\n  _throttleTimeout = void 0;\n}\n\nfunction scrollBy(el, x, y) {\n  el.scrollLeft += x;\n  el.scrollTop += y;\n}\n\nfunction clone(el) {\n  var Polymer = window.Polymer;\n  var $ = window.jQuery || window.Zepto;\n\n  if (Polymer && Polymer.dom) {\n    return Polymer.dom(el).cloneNode(true);\n  } else if ($) {\n    return $(el).clone(true)[0];\n  } else {\n    return el.cloneNode(true);\n  }\n}\n\nfunction setRect(el, rect) {\n  css(el, 'position', 'absolute');\n  css(el, 'top', rect.top);\n  css(el, 'left', rect.left);\n  css(el, 'width', rect.width);\n  css(el, 'height', rect.height);\n}\n\nfunction unsetRect(el) {\n  css(el, 'position', '');\n  css(el, 'top', '');\n  css(el, 'left', '');\n  css(el, 'width', '');\n  css(el, 'height', '');\n}\n\nvar expando = 'Sortable' + new Date().getTime();\n\nfunction AnimationStateManager() {\n  var animationStates = [],\n      animationCallbackId;\n  return {\n    captureAnimationState: function captureAnimationState() {\n      animationStates = [];\n      if (!this.options.animation) return;\n      var children = [].slice.call(this.el.children);\n      children.forEach(function (child) {\n        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;\n        animationStates.push({\n          target: child,\n          rect: getRect(child)\n        });\n\n        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation\n\n\n        if (child.thisAnimationDuration) {\n          var childMatrix = matrix(child, true);\n\n          if (childMatrix) {\n            fromRect.top -= childMatrix.f;\n            fromRect.left -= childMatrix.e;\n          }\n        }\n\n        child.fromRect = fromRect;\n      });\n    },\n    addAnimationState: function addAnimationState(state) {\n      animationStates.push(state);\n    },\n    removeAnimationState: function removeAnimationState(target) {\n      animationStates.splice(indexOfObject(animationStates, {\n        target: target\n      }), 1);\n    },\n    animateAll: function animateAll(callback) {\n      var _this = this;\n\n      if (!this.options.animation) {\n        clearTimeout(animationCallbackId);\n        if (typeof callback === 'function') callback();\n        return;\n      }\n\n      var animating = false,\n          animationTime = 0;\n      animationStates.forEach(function (state) {\n        var time = 0,\n            target = state.target,\n            fromRect = target.fromRect,\n            toRect = getRect(target),\n            prevFromRect = target.prevFromRect,\n            prevToRect = target.prevToRect,\n            animatingRect = state.rect,\n            targetMatrix = matrix(target, true);\n\n        if (targetMatrix) {\n          // Compensate for current animation\n          toRect.top -= targetMatrix.f;\n          toRect.left -= targetMatrix.e;\n        }\n\n        target.toRect = toRect;\n\n        if (target.thisAnimationDuration) {\n          // Could also check if animatingRect is between fromRect and toRect\n          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect\n          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {\n            // If returning to same place as started from animation and on same axis\n            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);\n          }\n        } // if fromRect != toRect: animate\n\n\n        if (!isRectEqual(toRect, fromRect)) {\n          target.prevFromRect = fromRect;\n          target.prevToRect = toRect;\n\n          if (!time) {\n            time = _this.options.animation;\n          }\n\n          _this.animate(target, animatingRect, toRect, time);\n        }\n\n        if (time) {\n          animating = true;\n          animationTime = Math.max(animationTime, time);\n          clearTimeout(target.animationResetTimer);\n          target.animationResetTimer = setTimeout(function () {\n            target.animationTime = 0;\n            target.prevFromRect = null;\n            target.fromRect = null;\n            target.prevToRect = null;\n            target.thisAnimationDuration = null;\n          }, time);\n          target.thisAnimationDuration = time;\n        }\n      });\n      clearTimeout(animationCallbackId);\n\n      if (!animating) {\n        if (typeof callback === 'function') callback();\n      } else {\n        animationCallbackId = setTimeout(function () {\n          if (typeof callback === 'function') callback();\n        }, animationTime);\n      }\n\n      animationStates = [];\n    },\n    animate: function animate(target, currentRect, toRect, duration) {\n      if (duration) {\n        css(target, 'transition', '');\n        css(target, 'transform', '');\n        var elMatrix = matrix(this.el),\n            scaleX = elMatrix && elMatrix.a,\n            scaleY = elMatrix && elMatrix.d,\n            translateX = (currentRect.left - toRect.left) / (scaleX || 1),\n            translateY = (currentRect.top - toRect.top) / (scaleY || 1);\n        target.animatingX = !!translateX;\n        target.animatingY = !!translateY;\n        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');\n        this.forRepaintDummy = repaint(target); // repaint\n\n        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));\n        css(target, 'transform', 'translate3d(0,0,0)');\n        typeof target.animated === 'number' && clearTimeout(target.animated);\n        target.animated = setTimeout(function () {\n          css(target, 'transition', '');\n          css(target, 'transform', '');\n          target.animated = false;\n          target.animatingX = false;\n          target.animatingY = false;\n        }, duration);\n      }\n    }\n  };\n}\n\nfunction repaint(target) {\n  return target.offsetWidth;\n}\n\nfunction calculateRealTime(animatingRect, fromRect, toRect, options) {\n  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;\n}\n\nvar plugins = [];\nvar defaults = {\n  initializeByDefault: true\n};\nvar PluginManager = {\n  mount: function mount(plugin) {\n    // Set default static properties\n    for (var option in defaults) {\n      if (defaults.hasOwnProperty(option) && !(option in plugin)) {\n        plugin[option] = defaults[option];\n      }\n    }\n\n    plugins.forEach(function (p) {\n      if (p.pluginName === plugin.pluginName) {\n        throw \"Sortable: Cannot mount plugin \".concat(plugin.pluginName, \" more than once\");\n      }\n    });\n    plugins.push(plugin);\n  },\n  pluginEvent: function pluginEvent(eventName, sortable, evt) {\n    var _this = this;\n\n    this.eventCanceled = false;\n\n    evt.cancel = function () {\n      _this.eventCanceled = true;\n    };\n\n    var eventNameGlobal = eventName + 'Global';\n    plugins.forEach(function (plugin) {\n      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable\n\n      if (sortable[plugin.pluginName][eventNameGlobal]) {\n        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({\n          sortable: sortable\n        }, evt));\n      } // Only fire plugin event if plugin is enabled in this sortable,\n      // and plugin has event defined\n\n\n      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {\n        sortable[plugin.pluginName][eventName](_objectSpread2({\n          sortable: sortable\n        }, evt));\n      }\n    });\n  },\n  initializePlugins: function initializePlugins(sortable, el, defaults, options) {\n    plugins.forEach(function (plugin) {\n      var pluginName = plugin.pluginName;\n      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;\n      var initialized = new plugin(sortable, el, sortable.options);\n      initialized.sortable = sortable;\n      initialized.options = sortable.options;\n      sortable[pluginName] = initialized; // Add default options from plugin\n\n      _extends(defaults, initialized.defaults);\n    });\n\n    for (var option in sortable.options) {\n      if (!sortable.options.hasOwnProperty(option)) continue;\n      var modified = this.modifyOption(sortable, option, sortable.options[option]);\n\n      if (typeof modified !== 'undefined') {\n        sortable.options[option] = modified;\n      }\n    }\n  },\n  getEventProperties: function getEventProperties(name, sortable) {\n    var eventProperties = {};\n    plugins.forEach(function (plugin) {\n      if (typeof plugin.eventProperties !== 'function') return;\n\n      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));\n    });\n    return eventProperties;\n  },\n  modifyOption: function modifyOption(sortable, name, value) {\n    var modifiedValue;\n    plugins.forEach(function (plugin) {\n      // Plugin must exist on the Sortable\n      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin\n\n      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {\n        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);\n      }\n    });\n    return modifiedValue;\n  }\n};\n\nfunction dispatchEvent(_ref) {\n  var sortable = _ref.sortable,\n      rootEl = _ref.rootEl,\n      name = _ref.name,\n      targetEl = _ref.targetEl,\n      cloneEl = _ref.cloneEl,\n      toEl = _ref.toEl,\n      fromEl = _ref.fromEl,\n      oldIndex = _ref.oldIndex,\n      newIndex = _ref.newIndex,\n      oldDraggableIndex = _ref.oldDraggableIndex,\n      newDraggableIndex = _ref.newDraggableIndex,\n      originalEvent = _ref.originalEvent,\n      putSortable = _ref.putSortable,\n      extraEventProperties = _ref.extraEventProperties;\n  sortable = sortable || rootEl && rootEl[expando];\n  if (!sortable) return;\n  var evt,\n      options = sortable.options,\n      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature\n\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent(name, {\n      bubbles: true,\n      cancelable: true\n    });\n  } else {\n    evt = document.createEvent('Event');\n    evt.initEvent(name, true, true);\n  }\n\n  evt.to = toEl || rootEl;\n  evt.from = fromEl || rootEl;\n  evt.item = targetEl || rootEl;\n  evt.clone = cloneEl;\n  evt.oldIndex = oldIndex;\n  evt.newIndex = newIndex;\n  evt.oldDraggableIndex = oldDraggableIndex;\n  evt.newDraggableIndex = newDraggableIndex;\n  evt.originalEvent = originalEvent;\n  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;\n\n  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));\n\n  for (var option in allEventProperties) {\n    evt[option] = allEventProperties[option];\n  }\n\n  if (rootEl) {\n    rootEl.dispatchEvent(evt);\n  }\n\n  if (options[onName]) {\n    options[onName].call(sortable, evt);\n  }\n}\n\nvar _excluded = [\"evt\"];\n\nvar pluginEvent = function pluginEvent(eventName, sortable) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      originalEvent = _ref.evt,\n      data = _objectWithoutProperties(_ref, _excluded);\n\n  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({\n    dragEl: dragEl,\n    parentEl: parentEl,\n    ghostEl: ghostEl,\n    rootEl: rootEl,\n    nextEl: nextEl,\n    lastDownEl: lastDownEl,\n    cloneEl: cloneEl,\n    cloneHidden: cloneHidden,\n    dragStarted: moved,\n    putSortable: putSortable,\n    activeSortable: Sortable.active,\n    originalEvent: originalEvent,\n    oldIndex: oldIndex,\n    oldDraggableIndex: oldDraggableIndex,\n    newIndex: newIndex,\n    newDraggableIndex: newDraggableIndex,\n    hideGhostForTarget: _hideGhostForTarget,\n    unhideGhostForTarget: _unhideGhostForTarget,\n    cloneNowHidden: function cloneNowHidden() {\n      cloneHidden = true;\n    },\n    cloneNowShown: function cloneNowShown() {\n      cloneHidden = false;\n    },\n    dispatchSortableEvent: function dispatchSortableEvent(name) {\n      _dispatchEvent({\n        sortable: sortable,\n        name: name,\n        originalEvent: originalEvent\n      });\n    }\n  }, data));\n};\n\nfunction _dispatchEvent(info) {\n  dispatchEvent(_objectSpread2({\n    putSortable: putSortable,\n    cloneEl: cloneEl,\n    targetEl: dragEl,\n    rootEl: rootEl,\n    oldIndex: oldIndex,\n    oldDraggableIndex: oldDraggableIndex,\n    newIndex: newIndex,\n    newDraggableIndex: newDraggableIndex\n  }, info));\n}\n\nvar dragEl,\n    parentEl,\n    ghostEl,\n    rootEl,\n    nextEl,\n    lastDownEl,\n    cloneEl,\n    cloneHidden,\n    oldIndex,\n    newIndex,\n    oldDraggableIndex,\n    newDraggableIndex,\n    activeGroup,\n    putSortable,\n    awaitingDragStarted = false,\n    ignoreNextClick = false,\n    sortables = [],\n    tapEvt,\n    touchEvt,\n    lastDx,\n    lastDy,\n    tapDistanceLeft,\n    tapDistanceTop,\n    moved,\n    lastTarget,\n    lastDirection,\n    pastFirstInvertThresh = false,\n    isCircumstantialInvert = false,\n    targetMoveDistance,\n    // For positioning ghost absolutely\nghostRelativeParent,\n    ghostRelativeParentInitialScroll = [],\n    // (left, top)\n_silent = false,\n    savedInputChecked = [];\n/** @const */\n\nvar documentExists = typeof document !== 'undefined',\n    PositionGhostAbsolutely = IOS,\n    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',\n    // This will not pass for IE9, because IE9 DnD only works on anchors\nsupportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),\n    supportCssPointerEvents = function () {\n  if (!documentExists) return; // false when <= IE11\n\n  if (IE11OrLess) {\n    return false;\n  }\n\n  var el = document.createElement('x');\n  el.style.cssText = 'pointer-events:auto';\n  return el.style.pointerEvents === 'auto';\n}(),\n    _detectDirection = function _detectDirection(el, options) {\n  var elCSS = css(el),\n      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),\n      child1 = getChild(el, 0, options),\n      child2 = getChild(el, 1, options),\n      firstChildCSS = child1 && css(child1),\n      secondChildCSS = child2 && css(child2),\n      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,\n      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;\n\n  if (elCSS.display === 'flex') {\n    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';\n  }\n\n  if (elCSS.display === 'grid') {\n    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';\n  }\n\n  if (child1 && firstChildCSS[\"float\"] && firstChildCSS[\"float\"] !== 'none') {\n    var touchingSideChild2 = firstChildCSS[\"float\"] === 'left' ? 'left' : 'right';\n    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';\n  }\n\n  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';\n},\n    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {\n  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,\n      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,\n      dragElOppLength = vertical ? dragRect.width : dragRect.height,\n      targetS1Opp = vertical ? targetRect.left : targetRect.top,\n      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,\n      targetOppLength = vertical ? targetRect.width : targetRect.height;\n  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;\n},\n\n/**\r\n * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\r\n * @param  {Number} x      X position\r\n * @param  {Number} y      Y position\r\n * @return {HTMLElement}   Element of the first found nearest Sortable\r\n */\n_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {\n  var ret;\n  sortables.some(function (sortable) {\n    var threshold = sortable[expando].options.emptyInsertThreshold;\n    if (!threshold || lastChild(sortable)) return;\n    var rect = getRect(sortable),\n        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,\n        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;\n\n    if (insideHorizontally && insideVertically) {\n      return ret = sortable;\n    }\n  });\n  return ret;\n},\n    _prepareGroup = function _prepareGroup(options) {\n  function toFn(value, pull) {\n    return function (to, from, dragEl, evt) {\n      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;\n\n      if (value == null && (pull || sameGroup)) {\n        // Default pull value\n        // Default pull and put value if same group\n        return true;\n      } else if (value == null || value === false) {\n        return false;\n      } else if (pull && value === 'clone') {\n        return value;\n      } else if (typeof value === 'function') {\n        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);\n      } else {\n        var otherGroup = (pull ? to : from).options.group.name;\n        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;\n      }\n    };\n  }\n\n  var group = {};\n  var originalGroup = options.group;\n\n  if (!originalGroup || _typeof(originalGroup) != 'object') {\n    originalGroup = {\n      name: originalGroup\n    };\n  }\n\n  group.name = originalGroup.name;\n  group.checkPull = toFn(originalGroup.pull, true);\n  group.checkPut = toFn(originalGroup.put);\n  group.revertClone = originalGroup.revertClone;\n  options.group = group;\n},\n    _hideGhostForTarget = function _hideGhostForTarget() {\n  if (!supportCssPointerEvents && ghostEl) {\n    css(ghostEl, 'display', 'none');\n  }\n},\n    _unhideGhostForTarget = function _unhideGhostForTarget() {\n  if (!supportCssPointerEvents && ghostEl) {\n    css(ghostEl, 'display', '');\n  }\n}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position\n\n\nif (documentExists && !ChromeForAndroid) {\n  document.addEventListener('click', function (evt) {\n    if (ignoreNextClick) {\n      evt.preventDefault();\n      evt.stopPropagation && evt.stopPropagation();\n      evt.stopImmediatePropagation && evt.stopImmediatePropagation();\n      ignoreNextClick = false;\n      return false;\n    }\n  }, true);\n}\n\nvar nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {\n  if (dragEl) {\n    evt = evt.touches ? evt.touches[0] : evt;\n\n    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);\n\n    if (nearest) {\n      // Create imitation event\n      var event = {};\n\n      for (var i in evt) {\n        if (evt.hasOwnProperty(i)) {\n          event[i] = evt[i];\n        }\n      }\n\n      event.target = event.rootEl = nearest;\n      event.preventDefault = void 0;\n      event.stopPropagation = void 0;\n\n      nearest[expando]._onDragOver(event);\n    }\n  }\n};\n\nvar _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {\n  if (dragEl) {\n    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n  }\n};\n/**\r\n * @class  Sortable\r\n * @param  {HTMLElement}  el\r\n * @param  {Object}       [options]\r\n */\n\n\nfunction Sortable(el, options) {\n  if (!(el && el.nodeType && el.nodeType === 1)) {\n    throw \"Sortable: `el` must be an HTMLElement, not \".concat({}.toString.call(el));\n  }\n\n  this.el = el; // root element\n\n  this.options = options = _extends({}, options); // Export instance\n\n  el[expando] = this;\n  var defaults = {\n    group: null,\n    sort: true,\n    disabled: false,\n    store: null,\n    handle: null,\n    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',\n    swapThreshold: 1,\n    // percentage; 0 <= x <= 1\n    invertSwap: false,\n    // invert always\n    invertedSwapThreshold: null,\n    // will be set to same as swapThreshold if default\n    removeCloneOnHide: true,\n    direction: function direction() {\n      return _detectDirection(el, this.options);\n    },\n    ghostClass: 'sortable-ghost',\n    chosenClass: 'sortable-chosen',\n    dragClass: 'sortable-drag',\n    ignore: 'a, img',\n    filter: null,\n    preventOnFilter: true,\n    animation: 0,\n    easing: null,\n    setData: function setData(dataTransfer, dragEl) {\n      dataTransfer.setData('Text', dragEl.textContent);\n    },\n    dropBubble: false,\n    dragoverBubble: false,\n    dataIdAttr: 'data-id',\n    delay: 0,\n    delayOnTouchOnly: false,\n    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,\n    forceFallback: false,\n    fallbackClass: 'sortable-fallback',\n    fallbackOnBody: false,\n    fallbackTolerance: 0,\n    fallbackOffset: {\n      x: 0,\n      y: 0\n    },\n    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,\n    emptyInsertThreshold: 5\n  };\n  PluginManager.initializePlugins(this, el, defaults); // Set default options\n\n  for (var name in defaults) {\n    !(name in options) && (options[name] = defaults[name]);\n  }\n\n  _prepareGroup(options); // Bind all private methods\n\n\n  for (var fn in this) {\n    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n      this[fn] = this[fn].bind(this);\n    }\n  } // Setup drag mode\n\n\n  this.nativeDraggable = options.forceFallback ? false : supportDraggable;\n\n  if (this.nativeDraggable) {\n    // Touch start threshold cannot be greater than the native dragstart threshold\n    this.options.touchStartThreshold = 1;\n  } // Bind events\n\n\n  if (options.supportPointer) {\n    on(el, 'pointerdown', this._onTapStart);\n  } else {\n    on(el, 'mousedown', this._onTapStart);\n    on(el, 'touchstart', this._onTapStart);\n  }\n\n  if (this.nativeDraggable) {\n    on(el, 'dragover', this);\n    on(el, 'dragenter', this);\n  }\n\n  sortables.push(this.el); // Restore sorting\n\n  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager\n\n  _extends(this, AnimationStateManager());\n}\n\nSortable.prototype =\n/** @lends Sortable.prototype */\n{\n  constructor: Sortable,\n  _isOutsideThisEl: function _isOutsideThisEl(target) {\n    if (!this.el.contains(target) && target !== this.el) {\n      lastTarget = null;\n    }\n  },\n  _getDirection: function _getDirection(evt, target) {\n    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;\n  },\n  _onTapStart: function _onTapStart(\n  /** Event|TouchEvent */\n  evt) {\n    if (!evt.cancelable) return;\n\n    var _this = this,\n        el = this.el,\n        options = this.options,\n        preventOnFilter = options.preventOnFilter,\n        type = evt.type,\n        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,\n        target = (touch || evt).target,\n        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,\n        filter = options.filter;\n\n    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.\n\n\n    if (dragEl) {\n      return;\n    }\n\n    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {\n      return; // only left button and enabled\n    } // cancel dnd if original target is content editable\n\n\n    if (originalTarget.isContentEditable) {\n      return;\n    } // Safari ignores further event handling after mousedown\n\n\n    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {\n      return;\n    }\n\n    target = closest(target, options.draggable, el, false);\n\n    if (target && target.animated) {\n      return;\n    }\n\n    if (lastDownEl === target) {\n      // Ignoring duplicate `down`\n      return;\n    } // Get the index of the dragged element within its parent\n\n\n    oldIndex = index(target);\n    oldDraggableIndex = index(target, options.draggable); // Check filter\n\n    if (typeof filter === 'function') {\n      if (filter.call(this, evt, target, this)) {\n        _dispatchEvent({\n          sortable: _this,\n          rootEl: originalTarget,\n          name: 'filter',\n          targetEl: target,\n          toEl: el,\n          fromEl: el\n        });\n\n        pluginEvent('filter', _this, {\n          evt: evt\n        });\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    } else if (filter) {\n      filter = filter.split(',').some(function (criteria) {\n        criteria = closest(originalTarget, criteria.trim(), el, false);\n\n        if (criteria) {\n          _dispatchEvent({\n            sortable: _this,\n            rootEl: criteria,\n            name: 'filter',\n            targetEl: target,\n            fromEl: el,\n            toEl: el\n          });\n\n          pluginEvent('filter', _this, {\n            evt: evt\n          });\n          return true;\n        }\n      });\n\n      if (filter) {\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    }\n\n    if (options.handle && !closest(originalTarget, options.handle, el, false)) {\n      return;\n    } // Prepare `dragstart`\n\n\n    this._prepareDragStart(evt, touch, target);\n  },\n  _prepareDragStart: function _prepareDragStart(\n  /** Event */\n  evt,\n  /** Touch */\n  touch,\n  /** HTMLElement */\n  target) {\n    var _this = this,\n        el = _this.el,\n        options = _this.options,\n        ownerDocument = el.ownerDocument,\n        dragStartFn;\n\n    if (target && !dragEl && target.parentNode === el) {\n      var dragRect = getRect(target);\n      rootEl = el;\n      dragEl = target;\n      parentEl = dragEl.parentNode;\n      nextEl = dragEl.nextSibling;\n      lastDownEl = target;\n      activeGroup = options.group;\n      Sortable.dragged = dragEl;\n      tapEvt = {\n        target: dragEl,\n        clientX: (touch || evt).clientX,\n        clientY: (touch || evt).clientY\n      };\n      tapDistanceLeft = tapEvt.clientX - dragRect.left;\n      tapDistanceTop = tapEvt.clientY - dragRect.top;\n      this._lastX = (touch || evt).clientX;\n      this._lastY = (touch || evt).clientY;\n      dragEl.style['will-change'] = 'all';\n\n      dragStartFn = function dragStartFn() {\n        pluginEvent('delayEnded', _this, {\n          evt: evt\n        });\n\n        if (Sortable.eventCanceled) {\n          _this._onDrop();\n\n          return;\n        } // Delayed drag has been triggered\n        // we can re-enable the events: touchmove/mousemove\n\n\n        _this._disableDelayedDragEvents();\n\n        if (!FireFox && _this.nativeDraggable) {\n          dragEl.draggable = true;\n        } // Bind the events: dragstart/dragend\n\n\n        _this._triggerDragStart(evt, touch); // Drag start event\n\n\n        _dispatchEvent({\n          sortable: _this,\n          name: 'choose',\n          originalEvent: evt\n        }); // Chosen item\n\n\n        toggleClass(dragEl, options.chosenClass, true);\n      }; // Disable \"draggable\"\n\n\n      options.ignore.split(',').forEach(function (criteria) {\n        find(dragEl, criteria.trim(), _disableDraggable);\n      });\n      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'mouseup', _this._onDrop);\n      on(ownerDocument, 'touchend', _this._onDrop);\n      on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)\n\n      if (FireFox && this.nativeDraggable) {\n        this.options.touchStartThreshold = 4;\n        dragEl.draggable = true;\n      }\n\n      pluginEvent('delayStart', this, {\n        evt: evt\n      }); // Delay is impossible for native DnD in Edge or IE\n\n      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {\n        if (Sortable.eventCanceled) {\n          this._onDrop();\n\n          return;\n        } // If the user moves the pointer or let go the click or touch\n        // before the delay has been reached:\n        // disable the delayed drag\n\n\n        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);\n        on(ownerDocument, 'touchend', _this._disableDelayedDrag);\n        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);\n        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);\n        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);\n        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);\n        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);\n      } else {\n        dragStartFn();\n      }\n    }\n  },\n  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(\n  /** TouchEvent|PointerEvent **/\n  e) {\n    var touch = e.touches ? e.touches[0] : e;\n\n    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {\n      this._disableDelayedDrag();\n    }\n  },\n  _disableDelayedDrag: function _disableDelayedDrag() {\n    dragEl && _disableDraggable(dragEl);\n    clearTimeout(this._dragStartTimer);\n\n    this._disableDelayedDragEvents();\n  },\n  _disableDelayedDragEvents: function _disableDelayedDragEvents() {\n    var ownerDocument = this.el.ownerDocument;\n    off(ownerDocument, 'mouseup', this._disableDelayedDrag);\n    off(ownerDocument, 'touchend', this._disableDelayedDrag);\n    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);\n    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);\n    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);\n    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);\n  },\n  _triggerDragStart: function _triggerDragStart(\n  /** Event */\n  evt,\n  /** Touch */\n  touch) {\n    touch = touch || evt.pointerType == 'touch' && evt;\n\n    if (!this.nativeDraggable || touch) {\n      if (this.options.supportPointer) {\n        on(document, 'pointermove', this._onTouchMove);\n      } else if (touch) {\n        on(document, 'touchmove', this._onTouchMove);\n      } else {\n        on(document, 'mousemove', this._onTouchMove);\n      }\n    } else {\n      on(dragEl, 'dragend', this);\n      on(rootEl, 'dragstart', this._onDragStart);\n    }\n\n    try {\n      if (document.selection) {\n        // Timeout neccessary for IE9\n        _nextTick(function () {\n          document.selection.empty();\n        });\n      } else {\n        window.getSelection().removeAllRanges();\n      }\n    } catch (err) {}\n  },\n  _dragStarted: function _dragStarted(fallback, evt) {\n\n    awaitingDragStarted = false;\n\n    if (rootEl && dragEl) {\n      pluginEvent('dragStarted', this, {\n        evt: evt\n      });\n\n      if (this.nativeDraggable) {\n        on(document, 'dragover', _checkOutsideTargetEl);\n      }\n\n      var options = this.options; // Apply effect\n\n      !fallback && toggleClass(dragEl, options.dragClass, false);\n      toggleClass(dragEl, options.ghostClass, true);\n      Sortable.active = this;\n      fallback && this._appendGhost(); // Drag start event\n\n      _dispatchEvent({\n        sortable: this,\n        name: 'start',\n        originalEvent: evt\n      });\n    } else {\n      this._nulling();\n    }\n  },\n  _emulateDragOver: function _emulateDragOver() {\n    if (touchEvt) {\n      this._lastX = touchEvt.clientX;\n      this._lastY = touchEvt.clientY;\n\n      _hideGhostForTarget();\n\n      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n      var parent = target;\n\n      while (target && target.shadowRoot) {\n        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n        if (target === parent) break;\n        parent = target;\n      }\n\n      dragEl.parentNode[expando]._isOutsideThisEl(target);\n\n      if (parent) {\n        do {\n          if (parent[expando]) {\n            var inserted = void 0;\n            inserted = parent[expando]._onDragOver({\n              clientX: touchEvt.clientX,\n              clientY: touchEvt.clientY,\n              target: target,\n              rootEl: parent\n            });\n\n            if (inserted && !this.options.dragoverBubble) {\n              break;\n            }\n          }\n\n          target = parent; // store last element\n        }\n        /* jshint boss:true */\n        while (parent = parent.parentNode);\n      }\n\n      _unhideGhostForTarget();\n    }\n  },\n  _onTouchMove: function _onTouchMove(\n  /**TouchEvent*/\n  evt) {\n    if (tapEvt) {\n      var options = this.options,\n          fallbackTolerance = options.fallbackTolerance,\n          fallbackOffset = options.fallbackOffset,\n          touch = evt.touches ? evt.touches[0] : evt,\n          ghostMatrix = ghostEl && matrix(ghostEl, true),\n          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,\n          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,\n          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),\n          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),\n          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging\n\n      if (!Sortable.active && !awaitingDragStarted) {\n        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {\n          return;\n        }\n\n        this._onDragStart(evt, true);\n      }\n\n      if (ghostEl) {\n        if (ghostMatrix) {\n          ghostMatrix.e += dx - (lastDx || 0);\n          ghostMatrix.f += dy - (lastDy || 0);\n        } else {\n          ghostMatrix = {\n            a: 1,\n            b: 0,\n            c: 0,\n            d: 1,\n            e: dx,\n            f: dy\n          };\n        }\n\n        var cssMatrix = \"matrix(\".concat(ghostMatrix.a, \",\").concat(ghostMatrix.b, \",\").concat(ghostMatrix.c, \",\").concat(ghostMatrix.d, \",\").concat(ghostMatrix.e, \",\").concat(ghostMatrix.f, \")\");\n        css(ghostEl, 'webkitTransform', cssMatrix);\n        css(ghostEl, 'mozTransform', cssMatrix);\n        css(ghostEl, 'msTransform', cssMatrix);\n        css(ghostEl, 'transform', cssMatrix);\n        lastDx = dx;\n        lastDy = dy;\n        touchEvt = touch;\n      }\n\n      evt.cancelable && evt.preventDefault();\n    }\n  },\n  _appendGhost: function _appendGhost() {\n    // Bug if using scale(): https://stackoverflow.com/questions/2637058\n    // Not being adjusted for\n    if (!ghostEl) {\n      var container = this.options.fallbackOnBody ? document.body : rootEl,\n          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),\n          options = this.options; // Position absolutely\n\n      if (PositionGhostAbsolutely) {\n        // Get relatively positioned parent\n        ghostRelativeParent = container;\n\n        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {\n          ghostRelativeParent = ghostRelativeParent.parentNode;\n        }\n\n        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {\n          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();\n          rect.top += ghostRelativeParent.scrollTop;\n          rect.left += ghostRelativeParent.scrollLeft;\n        } else {\n          ghostRelativeParent = getWindowScrollingElement();\n        }\n\n        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);\n      }\n\n      ghostEl = dragEl.cloneNode(true);\n      toggleClass(ghostEl, options.ghostClass, false);\n      toggleClass(ghostEl, options.fallbackClass, true);\n      toggleClass(ghostEl, options.dragClass, true);\n      css(ghostEl, 'transition', '');\n      css(ghostEl, 'transform', '');\n      css(ghostEl, 'box-sizing', 'border-box');\n      css(ghostEl, 'margin', 0);\n      css(ghostEl, 'top', rect.top);\n      css(ghostEl, 'left', rect.left);\n      css(ghostEl, 'width', rect.width);\n      css(ghostEl, 'height', rect.height);\n      css(ghostEl, 'opacity', '0.8');\n      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');\n      css(ghostEl, 'zIndex', '100000');\n      css(ghostEl, 'pointerEvents', 'none');\n      Sortable.ghost = ghostEl;\n      container.appendChild(ghostEl); // Set transform-origin\n\n      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');\n    }\n  },\n  _onDragStart: function _onDragStart(\n  /**Event*/\n  evt,\n  /**boolean*/\n  fallback) {\n    var _this = this;\n\n    var dataTransfer = evt.dataTransfer;\n    var options = _this.options;\n    pluginEvent('dragStart', this, {\n      evt: evt\n    });\n\n    if (Sortable.eventCanceled) {\n      this._onDrop();\n\n      return;\n    }\n\n    pluginEvent('setupClone', this);\n\n    if (!Sortable.eventCanceled) {\n      cloneEl = clone(dragEl);\n      cloneEl.removeAttribute(\"id\");\n      cloneEl.draggable = false;\n      cloneEl.style['will-change'] = '';\n\n      this._hideClone();\n\n      toggleClass(cloneEl, this.options.chosenClass, false);\n      Sortable.clone = cloneEl;\n    } // #1143: IFrame support workaround\n\n\n    _this.cloneId = _nextTick(function () {\n      pluginEvent('clone', _this);\n      if (Sortable.eventCanceled) return;\n\n      if (!_this.options.removeCloneOnHide) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      }\n\n      _this._hideClone();\n\n      _dispatchEvent({\n        sortable: _this,\n        name: 'clone'\n      });\n    });\n    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events\n\n    if (fallback) {\n      ignoreNextClick = true;\n      _this._loopId = setInterval(_this._emulateDragOver, 50);\n    } else {\n      // Undo what was set in _prepareDragStart before drag started\n      off(document, 'mouseup', _this._onDrop);\n      off(document, 'touchend', _this._onDrop);\n      off(document, 'touchcancel', _this._onDrop);\n\n      if (dataTransfer) {\n        dataTransfer.effectAllowed = 'move';\n        options.setData && options.setData.call(_this, dataTransfer, dragEl);\n      }\n\n      on(document, 'drop', _this); // #1276 fix:\n\n      css(dragEl, 'transform', 'translateZ(0)');\n    }\n\n    awaitingDragStarted = true;\n    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));\n    on(document, 'selectstart', _this);\n    moved = true;\n\n    if (Safari) {\n      css(document.body, 'user-select', 'none');\n    }\n  },\n  // Returns true - if no further action is needed (either inserted or another condition)\n  _onDragOver: function _onDragOver(\n  /**Event*/\n  evt) {\n    var el = this.el,\n        target = evt.target,\n        dragRect,\n        targetRect,\n        revert,\n        options = this.options,\n        group = options.group,\n        activeSortable = Sortable.active,\n        isOwner = activeGroup === group,\n        canSort = options.sort,\n        fromSortable = putSortable || activeSortable,\n        vertical,\n        _this = this,\n        completedFired = false;\n\n    if (_silent) return;\n\n    function dragOverEvent(name, extra) {\n      pluginEvent(name, _this, _objectSpread2({\n        evt: evt,\n        isOwner: isOwner,\n        axis: vertical ? 'vertical' : 'horizontal',\n        revert: revert,\n        dragRect: dragRect,\n        targetRect: targetRect,\n        canSort: canSort,\n        fromSortable: fromSortable,\n        target: target,\n        completed: completed,\n        onMove: function onMove(target, after) {\n          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);\n        },\n        changed: changed\n      }, extra));\n    } // Capture animation state\n\n\n    function capture() {\n      dragOverEvent('dragOverAnimationCapture');\n\n      _this.captureAnimationState();\n\n      if (_this !== fromSortable) {\n        fromSortable.captureAnimationState();\n      }\n    } // Return invocation when dragEl is inserted (or completed)\n\n\n    function completed(insertion) {\n      dragOverEvent('dragOverCompleted', {\n        insertion: insertion\n      });\n\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        } else {\n          activeSortable._showClone(_this);\n        }\n\n        if (_this !== fromSortable) {\n          // Set ghost class to new sortable's ghost class\n          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);\n          toggleClass(dragEl, options.ghostClass, true);\n        }\n\n        if (putSortable !== _this && _this !== Sortable.active) {\n          putSortable = _this;\n        } else if (_this === Sortable.active && putSortable) {\n          putSortable = null;\n        } // Animation\n\n\n        if (fromSortable === _this) {\n          _this._ignoreWhileAnimating = target;\n        }\n\n        _this.animateAll(function () {\n          dragOverEvent('dragOverAnimationComplete');\n          _this._ignoreWhileAnimating = null;\n        });\n\n        if (_this !== fromSortable) {\n          fromSortable.animateAll();\n          fromSortable._ignoreWhileAnimating = null;\n        }\n      } // Null lastTarget if it is not inside a previously swapped element\n\n\n      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {\n        lastTarget = null;\n      } // no bubbling and not fallback\n\n\n      if (!options.dragoverBubble && !evt.rootEl && target !== document) {\n        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted\n\n\n        !insertion && nearestEmptyInsertDetectEvent(evt);\n      }\n\n      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\n      return completedFired = true;\n    } // Call when dragEl has been inserted\n\n\n    function changed() {\n      newIndex = index(dragEl);\n      newDraggableIndex = index(dragEl, options.draggable);\n\n      _dispatchEvent({\n        sortable: _this,\n        name: 'change',\n        toEl: el,\n        newIndex: newIndex,\n        newDraggableIndex: newDraggableIndex,\n        originalEvent: evt\n      });\n    }\n\n    if (evt.preventDefault !== void 0) {\n      evt.cancelable && evt.preventDefault();\n    }\n\n    target = closest(target, options.draggable, el, true);\n    dragOverEvent('dragOver');\n    if (Sortable.eventCanceled) return completedFired;\n\n    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {\n      return completed(false);\n    }\n\n    ignoreNextClick = false;\n\n    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list\n    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {\n      vertical = this._getDirection(evt, target) === 'vertical';\n      dragRect = getRect(dragEl);\n      dragOverEvent('dragOverValid');\n      if (Sortable.eventCanceled) return completedFired;\n\n      if (revert) {\n        parentEl = rootEl; // actualization\n\n        capture();\n\n        this._hideClone();\n\n        dragOverEvent('revert');\n\n        if (!Sortable.eventCanceled) {\n          if (nextEl) {\n            rootEl.insertBefore(dragEl, nextEl);\n          } else {\n            rootEl.appendChild(dragEl);\n          }\n        }\n\n        return completed(true);\n      }\n\n      var elLastChild = lastChild(el, options.draggable);\n\n      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {\n        // Insert to end of list\n        // If already at end of list: Do not insert\n        if (elLastChild === dragEl) {\n          return completed(false);\n        } // if there is a last element, it is the target\n\n\n        if (elLastChild && el === evt.target) {\n          target = elLastChild;\n        }\n\n        if (target) {\n          targetRect = getRect(target);\n        }\n\n        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {\n          capture();\n\n          if (elLastChild && elLastChild.nextSibling) {\n            // the last draggable element is not the last node\n            el.insertBefore(dragEl, elLastChild.nextSibling);\n          } else {\n            el.appendChild(dragEl);\n          }\n\n          parentEl = el; // actualization\n\n          changed();\n          return completed(true);\n        }\n      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {\n        // Insert to start of list\n        var firstChild = getChild(el, 0, options, true);\n\n        if (firstChild === dragEl) {\n          return completed(false);\n        }\n\n        target = firstChild;\n        targetRect = getRect(target);\n\n        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {\n          capture();\n          el.insertBefore(dragEl, firstChild);\n          parentEl = el; // actualization\n\n          changed();\n          return completed(true);\n        }\n      } else if (target.parentNode === el) {\n        targetRect = getRect(target);\n        var direction = 0,\n            targetBeforeFirstSwap,\n            differentLevel = dragEl.parentNode !== el,\n            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),\n            side1 = vertical ? 'top' : 'left',\n            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),\n            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\n\n        if (lastTarget !== target) {\n          targetBeforeFirstSwap = targetRect[side1];\n          pastFirstInvertThresh = false;\n          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;\n        }\n\n        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);\n        var sibling;\n\n        if (direction !== 0) {\n          // Check if target is beside dragEl in respective direction (ignoring hidden elements)\n          var dragIndex = index(dragEl);\n\n          do {\n            dragIndex -= direction;\n            sibling = parentEl.children[dragIndex];\n          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));\n        } // If dragEl is already beside target: Do not insert\n\n\n        if (direction === 0 || sibling === target) {\n          return completed(false);\n        }\n\n        lastTarget = target;\n        lastDirection = direction;\n        var nextSibling = target.nextElementSibling,\n            after = false;\n        after = direction === 1;\n\n        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);\n\n        if (moveVector !== false) {\n          if (moveVector === 1 || moveVector === -1) {\n            after = moveVector === 1;\n          }\n\n          _silent = true;\n          setTimeout(_unsilent, 30);\n          capture();\n\n          if (after && !nextSibling) {\n            el.appendChild(dragEl);\n          } else {\n            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);\n          } // Undo chrome's scroll adjustment (has no effect on other browsers)\n\n\n          if (scrolledPastTop) {\n            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);\n          }\n\n          parentEl = dragEl.parentNode; // actualization\n          // must be done before animation\n\n          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\n            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);\n          }\n\n          changed();\n          return completed(true);\n        }\n      }\n\n      if (el.contains(dragEl)) {\n        return completed(false);\n      }\n    }\n\n    return false;\n  },\n  _ignoreWhileAnimating: null,\n  _offMoveEvents: function _offMoveEvents() {\n    off(document, 'mousemove', this._onTouchMove);\n    off(document, 'touchmove', this._onTouchMove);\n    off(document, 'pointermove', this._onTouchMove);\n    off(document, 'dragover', nearestEmptyInsertDetectEvent);\n    off(document, 'mousemove', nearestEmptyInsertDetectEvent);\n    off(document, 'touchmove', nearestEmptyInsertDetectEvent);\n  },\n  _offUpEvents: function _offUpEvents() {\n    var ownerDocument = this.el.ownerDocument;\n    off(ownerDocument, 'mouseup', this._onDrop);\n    off(ownerDocument, 'touchend', this._onDrop);\n    off(ownerDocument, 'pointerup', this._onDrop);\n    off(ownerDocument, 'touchcancel', this._onDrop);\n    off(document, 'selectstart', this);\n  },\n  _onDrop: function _onDrop(\n  /**Event*/\n  evt) {\n    var el = this.el,\n        options = this.options; // Get the index of the dragged element within its parent\n\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n    pluginEvent('drop', this, {\n      evt: evt\n    });\n    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event\n\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n\n    if (Sortable.eventCanceled) {\n      this._nulling();\n\n      return;\n    }\n\n    awaitingDragStarted = false;\n    isCircumstantialInvert = false;\n    pastFirstInvertThresh = false;\n    clearInterval(this._loopId);\n    clearTimeout(this._dragStartTimer);\n\n    _cancelNextTick(this.cloneId);\n\n    _cancelNextTick(this._dragStartId); // Unbind events\n\n\n    if (this.nativeDraggable) {\n      off(document, 'drop', this);\n      off(el, 'dragstart', this._onDragStart);\n    }\n\n    this._offMoveEvents();\n\n    this._offUpEvents();\n\n    if (Safari) {\n      css(document.body, 'user-select', '');\n    }\n\n    css(dragEl, 'transform', '');\n\n    if (evt) {\n      if (moved) {\n        evt.cancelable && evt.preventDefault();\n        !options.dropBubble && evt.stopPropagation();\n      }\n\n      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);\n\n      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n        // Remove clone(s)\n        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);\n      }\n\n      if (dragEl) {\n        if (this.nativeDraggable) {\n          off(dragEl, 'dragend', this);\n        }\n\n        _disableDraggable(dragEl);\n\n        dragEl.style['will-change'] = ''; // Remove classes\n        // ghostClass is added in dragStarted\n\n        if (moved && !awaitingDragStarted) {\n          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);\n        }\n\n        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event\n\n        _dispatchEvent({\n          sortable: this,\n          name: 'unchoose',\n          toEl: parentEl,\n          newIndex: null,\n          newDraggableIndex: null,\n          originalEvent: evt\n        });\n\n        if (rootEl !== parentEl) {\n          if (newIndex >= 0) {\n            // Add event\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: 'add',\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt\n            }); // Remove event\n\n\n            _dispatchEvent({\n              sortable: this,\n              name: 'remove',\n              toEl: parentEl,\n              originalEvent: evt\n            }); // drag from one list and drop into another\n\n\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: 'sort',\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt\n            });\n\n            _dispatchEvent({\n              sortable: this,\n              name: 'sort',\n              toEl: parentEl,\n              originalEvent: evt\n            });\n          }\n\n          putSortable && putSortable.save();\n        } else {\n          if (newIndex !== oldIndex) {\n            if (newIndex >= 0) {\n              // drag & drop within the same list\n              _dispatchEvent({\n                sortable: this,\n                name: 'update',\n                toEl: parentEl,\n                originalEvent: evt\n              });\n\n              _dispatchEvent({\n                sortable: this,\n                name: 'sort',\n                toEl: parentEl,\n                originalEvent: evt\n              });\n            }\n          }\n        }\n\n        if (Sortable.active) {\n          /* jshint eqnull:true */\n          if (newIndex == null || newIndex === -1) {\n            newIndex = oldIndex;\n            newDraggableIndex = oldDraggableIndex;\n          }\n\n          _dispatchEvent({\n            sortable: this,\n            name: 'end',\n            toEl: parentEl,\n            originalEvent: evt\n          }); // Save sorting\n\n\n          this.save();\n        }\n      }\n    }\n\n    this._nulling();\n  },\n  _nulling: function _nulling() {\n    pluginEvent('nulling', this);\n    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;\n    savedInputChecked.forEach(function (el) {\n      el.checked = true;\n    });\n    savedInputChecked.length = lastDx = lastDy = 0;\n  },\n  handleEvent: function handleEvent(\n  /**Event*/\n  evt) {\n    switch (evt.type) {\n      case 'drop':\n      case 'dragend':\n        this._onDrop(evt);\n\n        break;\n\n      case 'dragenter':\n      case 'dragover':\n        if (dragEl) {\n          this._onDragOver(evt);\n\n          _globalDragOver(evt);\n        }\n\n        break;\n\n      case 'selectstart':\n        evt.preventDefault();\n        break;\n    }\n  },\n\n  /**\r\n   * Serializes the item into an array of string.\r\n   * @returns {String[]}\r\n   */\n  toArray: function toArray() {\n    var order = [],\n        el,\n        children = this.el.children,\n        i = 0,\n        n = children.length,\n        options = this.options;\n\n    for (; i < n; i++) {\n      el = children[i];\n\n      if (closest(el, options.draggable, this.el, false)) {\n        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\n      }\n    }\n\n    return order;\n  },\n\n  /**\r\n   * Sorts the elements according to the array.\r\n   * @param  {String[]}  order  order of the items\r\n   */\n  sort: function sort(order, useAnimation) {\n    var items = {},\n        rootEl = this.el;\n    this.toArray().forEach(function (id, i) {\n      var el = rootEl.children[i];\n\n      if (closest(el, this.options.draggable, rootEl, false)) {\n        items[id] = el;\n      }\n    }, this);\n    useAnimation && this.captureAnimationState();\n    order.forEach(function (id) {\n      if (items[id]) {\n        rootEl.removeChild(items[id]);\n        rootEl.appendChild(items[id]);\n      }\n    });\n    useAnimation && this.animateAll();\n  },\n\n  /**\r\n   * Save the current sorting\r\n   */\n  save: function save() {\n    var store = this.options.store;\n    store && store.set && store.set(this);\n  },\n\n  /**\r\n   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.\r\n   * @param   {HTMLElement}  el\r\n   * @param   {String}       [selector]  default: `options.draggable`\r\n   * @returns {HTMLElement|null}\r\n   */\n  closest: function closest$1(el, selector) {\n    return closest(el, selector || this.options.draggable, this.el, false);\n  },\n\n  /**\r\n   * Set/get option\r\n   * @param   {string} name\r\n   * @param   {*}      [value]\r\n   * @returns {*}\r\n   */\n  option: function option(name, value) {\n    var options = this.options;\n\n    if (value === void 0) {\n      return options[name];\n    } else {\n      var modifiedValue = PluginManager.modifyOption(this, name, value);\n\n      if (typeof modifiedValue !== 'undefined') {\n        options[name] = modifiedValue;\n      } else {\n        options[name] = value;\n      }\n\n      if (name === 'group') {\n        _prepareGroup(options);\n      }\n    }\n  },\n\n  /**\r\n   * Destroy\r\n   */\n  destroy: function destroy() {\n    pluginEvent('destroy', this);\n    var el = this.el;\n    el[expando] = null;\n    off(el, 'mousedown', this._onTapStart);\n    off(el, 'touchstart', this._onTapStart);\n    off(el, 'pointerdown', this._onTapStart);\n\n    if (this.nativeDraggable) {\n      off(el, 'dragover', this);\n      off(el, 'dragenter', this);\n    } // Remove draggable attributes\n\n\n    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {\n      el.removeAttribute('draggable');\n    });\n\n    this._onDrop();\n\n    this._disableDelayedDragEvents();\n\n    sortables.splice(sortables.indexOf(this.el), 1);\n    this.el = el = null;\n  },\n  _hideClone: function _hideClone() {\n    if (!cloneHidden) {\n      pluginEvent('hideClone', this);\n      if (Sortable.eventCanceled) return;\n      css(cloneEl, 'display', 'none');\n\n      if (this.options.removeCloneOnHide && cloneEl.parentNode) {\n        cloneEl.parentNode.removeChild(cloneEl);\n      }\n\n      cloneHidden = true;\n    }\n  },\n  _showClone: function _showClone(putSortable) {\n    if (putSortable.lastPutMode !== 'clone') {\n      this._hideClone();\n\n      return;\n    }\n\n    if (cloneHidden) {\n      pluginEvent('showClone', this);\n      if (Sortable.eventCanceled) return; // show clone at dragEl or original position\n\n      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      } else if (nextEl) {\n        rootEl.insertBefore(cloneEl, nextEl);\n      } else {\n        rootEl.appendChild(cloneEl);\n      }\n\n      if (this.options.group.revertClone) {\n        this.animate(dragEl, cloneEl);\n      }\n\n      css(cloneEl, 'display', '');\n      cloneHidden = false;\n    }\n  }\n};\n\nfunction _globalDragOver(\n/**Event*/\nevt) {\n  if (evt.dataTransfer) {\n    evt.dataTransfer.dropEffect = 'move';\n  }\n\n  evt.cancelable && evt.preventDefault();\n}\n\nfunction _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {\n  var evt,\n      sortable = fromEl[expando],\n      onMoveFn = sortable.options.onMove,\n      retVal; // Support for new CustomEvent feature\n\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent('move', {\n      bubbles: true,\n      cancelable: true\n    });\n  } else {\n    evt = document.createEvent('Event');\n    evt.initEvent('move', true, true);\n  }\n\n  evt.to = toEl;\n  evt.from = fromEl;\n  evt.dragged = dragEl;\n  evt.draggedRect = dragRect;\n  evt.related = targetEl || toEl;\n  evt.relatedRect = targetRect || getRect(toEl);\n  evt.willInsertAfter = willInsertAfter;\n  evt.originalEvent = originalEvent;\n  fromEl.dispatchEvent(evt);\n\n  if (onMoveFn) {\n    retVal = onMoveFn.call(sortable, evt, originalEvent);\n  }\n\n  return retVal;\n}\n\nfunction _disableDraggable(el) {\n  el.draggable = false;\n}\n\nfunction _unsilent() {\n  _silent = false;\n}\n\nfunction _ghostIsFirst(evt, vertical, sortable) {\n  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));\n  var spacer = 10;\n  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;\n}\n\nfunction _ghostIsLast(evt, vertical, sortable) {\n  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));\n  var spacer = 10;\n  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;\n}\n\nfunction _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {\n  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,\n      targetLength = vertical ? targetRect.height : targetRect.width,\n      targetS1 = vertical ? targetRect.top : targetRect.left,\n      targetS2 = vertical ? targetRect.bottom : targetRect.right,\n      invert = false;\n\n  if (!invertSwap) {\n    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\n    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {\n      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\n      // check if past first invert threshold on side opposite of lastDirection\n      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {\n        // past first invert threshold, do not restrict inverted threshold to dragEl shadow\n        pastFirstInvertThresh = true;\n      }\n\n      if (!pastFirstInvertThresh) {\n        // dragEl shadow (target move distance shadow)\n        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\n        : mouseOnAxis > targetS2 - targetMoveDistance) {\n          return -lastDirection;\n        }\n      } else {\n        invert = true;\n      }\n    } else {\n      // Regular\n      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {\n        return _getInsertDirection(target);\n      }\n    }\n  }\n\n  invert = invert || invertSwap;\n\n  if (invert) {\n    // Invert of regular\n    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {\n      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;\n    }\n  }\n\n  return 0;\n}\n/**\r\n * Gets the direction dragEl must be swapped relative to target in order to make it\r\n * seem that dragEl has been \"inserted\" into that element's position\r\n * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\r\n * @return {Number}                   Direction dragEl must be swapped\r\n */\n\n\nfunction _getInsertDirection(target) {\n  if (index(dragEl) < index(target)) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n/**\r\n * Generate id\r\n * @param   {HTMLElement} el\r\n * @returns {String}\r\n * @private\r\n */\n\n\nfunction _generateId(el) {\n  var str = el.tagName + el.className + el.src + el.href + el.textContent,\n      i = str.length,\n      sum = 0;\n\n  while (i--) {\n    sum += str.charCodeAt(i);\n  }\n\n  return sum.toString(36);\n}\n\nfunction _saveInputCheckedState(root) {\n  savedInputChecked.length = 0;\n  var inputs = root.getElementsByTagName('input');\n  var idx = inputs.length;\n\n  while (idx--) {\n    var el = inputs[idx];\n    el.checked && savedInputChecked.push(el);\n  }\n}\n\nfunction _nextTick(fn) {\n  return setTimeout(fn, 0);\n}\n\nfunction _cancelNextTick(id) {\n  return clearTimeout(id);\n} // Fixed #973:\n\n\nif (documentExists) {\n  on(document, 'touchmove', function (evt) {\n    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {\n      evt.preventDefault();\n    }\n  });\n} // Export utils\n\n\nSortable.utils = {\n  on: on,\n  off: off,\n  css: css,\n  find: find,\n  is: function is(el, selector) {\n    return !!closest(el, selector, el, false);\n  },\n  extend: extend,\n  throttle: throttle,\n  closest: closest,\n  toggleClass: toggleClass,\n  clone: clone,\n  index: index,\n  nextTick: _nextTick,\n  cancelNextTick: _cancelNextTick,\n  detectDirection: _detectDirection,\n  getChild: getChild\n};\n/**\r\n * Get the Sortable instance of an element\r\n * @param  {HTMLElement} element The element\r\n * @return {Sortable|undefined}         The instance of Sortable\r\n */\n\nSortable.get = function (element) {\n  return element[expando];\n};\n/**\r\n * Mount a plugin to Sortable\r\n * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted\r\n */\n\n\nSortable.mount = function () {\n  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {\n    plugins[_key] = arguments[_key];\n  }\n\n  if (plugins[0].constructor === Array) plugins = plugins[0];\n  plugins.forEach(function (plugin) {\n    if (!plugin.prototype || !plugin.prototype.constructor) {\n      throw \"Sortable: Mounted plugin must be a constructor function, not \".concat({}.toString.call(plugin));\n    }\n\n    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);\n    PluginManager.mount(plugin);\n  });\n};\n/**\r\n * Create sortable instance\r\n * @param {HTMLElement}  el\r\n * @param {Object}      [options]\r\n */\n\n\nSortable.create = function (el, options) {\n  return new Sortable(el, options);\n}; // Export\n\n\nSortable.version = version;\n\nvar autoScrolls = [],\n    scrollEl,\n    scrollRootEl,\n    scrolling = false,\n    lastAutoScrollX,\n    lastAutoScrollY,\n    touchEvt$1,\n    pointerElemChangedInterval;\n\nfunction AutoScrollPlugin() {\n  function AutoScroll() {\n    this.defaults = {\n      scroll: true,\n      forceAutoScrollFallback: false,\n      scrollSensitivity: 30,\n      scrollSpeed: 10,\n      bubbleScroll: true\n    }; // Bind all private methods\n\n    for (var fn in this) {\n      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n  }\n\n  AutoScroll.prototype = {\n    dragStarted: function dragStarted(_ref) {\n      var originalEvent = _ref.originalEvent;\n\n      if (this.sortable.nativeDraggable) {\n        on(document, 'dragover', this._handleAutoScroll);\n      } else {\n        if (this.options.supportPointer) {\n          on(document, 'pointermove', this._handleFallbackAutoScroll);\n        } else if (originalEvent.touches) {\n          on(document, 'touchmove', this._handleFallbackAutoScroll);\n        } else {\n          on(document, 'mousemove', this._handleFallbackAutoScroll);\n        }\n      }\n    },\n    dragOverCompleted: function dragOverCompleted(_ref2) {\n      var originalEvent = _ref2.originalEvent;\n\n      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)\n      if (!this.options.dragOverBubble && !originalEvent.rootEl) {\n        this._handleAutoScroll(originalEvent);\n      }\n    },\n    drop: function drop() {\n      if (this.sortable.nativeDraggable) {\n        off(document, 'dragover', this._handleAutoScroll);\n      } else {\n        off(document, 'pointermove', this._handleFallbackAutoScroll);\n        off(document, 'touchmove', this._handleFallbackAutoScroll);\n        off(document, 'mousemove', this._handleFallbackAutoScroll);\n      }\n\n      clearPointerElemChangedInterval();\n      clearAutoScrolls();\n      cancelThrottle();\n    },\n    nulling: function nulling() {\n      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;\n      autoScrolls.length = 0;\n    },\n    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {\n      this._handleAutoScroll(evt, true);\n    },\n    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {\n      var _this = this;\n\n      var x = (evt.touches ? evt.touches[0] : evt).clientX,\n          y = (evt.touches ? evt.touches[0] : evt).clientY,\n          elem = document.elementFromPoint(x, y);\n      touchEvt$1 = evt; // IE does not seem to have native autoscroll,\n      // Edge's autoscroll seems too conditional,\n      // MACOS Safari does not have autoscroll,\n      // Firefox and Chrome are good\n\n      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {\n        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change\n\n        var ogElemScroller = getParentAutoScrollElement(elem, true);\n\n        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {\n          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour\n\n          pointerElemChangedInterval = setInterval(function () {\n            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);\n\n            if (newElem !== ogElemScroller) {\n              ogElemScroller = newElem;\n              clearAutoScrolls();\n            }\n\n            autoScroll(evt, _this.options, newElem, fallback);\n          }, 10);\n          lastAutoScrollX = x;\n          lastAutoScrollY = y;\n        }\n      } else {\n        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll\n        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {\n          clearAutoScrolls();\n          return;\n        }\n\n        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);\n      }\n    }\n  };\n  return _extends(AutoScroll, {\n    pluginName: 'scroll',\n    initializeByDefault: true\n  });\n}\n\nfunction clearAutoScrolls() {\n  autoScrolls.forEach(function (autoScroll) {\n    clearInterval(autoScroll.pid);\n  });\n  autoScrolls = [];\n}\n\nfunction clearPointerElemChangedInterval() {\n  clearInterval(pointerElemChangedInterval);\n}\n\nvar autoScroll = throttle(function (evt, options, rootEl, isFallback) {\n  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521\n  if (!options.scroll) return;\n  var x = (evt.touches ? evt.touches[0] : evt).clientX,\n      y = (evt.touches ? evt.touches[0] : evt).clientY,\n      sens = options.scrollSensitivity,\n      speed = options.scrollSpeed,\n      winScroller = getWindowScrollingElement();\n  var scrollThisInstance = false,\n      scrollCustomFn; // New scroll root, set scrollEl\n\n  if (scrollRootEl !== rootEl) {\n    scrollRootEl = rootEl;\n    clearAutoScrolls();\n    scrollEl = options.scroll;\n    scrollCustomFn = options.scrollFn;\n\n    if (scrollEl === true) {\n      scrollEl = getParentAutoScrollElement(rootEl, true);\n    }\n  }\n\n  var layersOut = 0;\n  var currentParent = scrollEl;\n\n  do {\n    var el = currentParent,\n        rect = getRect(el),\n        top = rect.top,\n        bottom = rect.bottom,\n        left = rect.left,\n        right = rect.right,\n        width = rect.width,\n        height = rect.height,\n        canScrollX = void 0,\n        canScrollY = void 0,\n        scrollWidth = el.scrollWidth,\n        scrollHeight = el.scrollHeight,\n        elCSS = css(el),\n        scrollPosX = el.scrollLeft,\n        scrollPosY = el.scrollTop;\n\n    if (el === winScroller) {\n      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');\n      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');\n    } else {\n      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');\n      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');\n    }\n\n    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);\n    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);\n\n    if (!autoScrolls[layersOut]) {\n      for (var i = 0; i <= layersOut; i++) {\n        if (!autoScrolls[i]) {\n          autoScrolls[i] = {};\n        }\n      }\n    }\n\n    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {\n      autoScrolls[layersOut].el = el;\n      autoScrolls[layersOut].vx = vx;\n      autoScrolls[layersOut].vy = vy;\n      clearInterval(autoScrolls[layersOut].pid);\n\n      if (vx != 0 || vy != 0) {\n        scrollThisInstance = true;\n        /* jshint loopfunc:true */\n\n        autoScrolls[layersOut].pid = setInterval(function () {\n          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour\n          if (isFallback && this.layer === 0) {\n            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely\n\n          }\n\n          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;\n          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;\n\n          if (typeof scrollCustomFn === 'function') {\n            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {\n              return;\n            }\n          }\n\n          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);\n        }.bind({\n          layer: layersOut\n        }), 24);\n      }\n    }\n\n    layersOut++;\n  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));\n\n  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not\n}, 30);\n\nvar drop = function drop(_ref) {\n  var originalEvent = _ref.originalEvent,\n      putSortable = _ref.putSortable,\n      dragEl = _ref.dragEl,\n      activeSortable = _ref.activeSortable,\n      dispatchSortableEvent = _ref.dispatchSortableEvent,\n      hideGhostForTarget = _ref.hideGhostForTarget,\n      unhideGhostForTarget = _ref.unhideGhostForTarget;\n  if (!originalEvent) return;\n  var toSortable = putSortable || activeSortable;\n  hideGhostForTarget();\n  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;\n  var target = document.elementFromPoint(touch.clientX, touch.clientY);\n  unhideGhostForTarget();\n\n  if (toSortable && !toSortable.el.contains(target)) {\n    dispatchSortableEvent('spill');\n    this.onSpill({\n      dragEl: dragEl,\n      putSortable: putSortable\n    });\n  }\n};\n\nfunction Revert() {}\n\nRevert.prototype = {\n  startIndex: null,\n  dragStart: function dragStart(_ref2) {\n    var oldDraggableIndex = _ref2.oldDraggableIndex;\n    this.startIndex = oldDraggableIndex;\n  },\n  onSpill: function onSpill(_ref3) {\n    var dragEl = _ref3.dragEl,\n        putSortable = _ref3.putSortable;\n    this.sortable.captureAnimationState();\n\n    if (putSortable) {\n      putSortable.captureAnimationState();\n    }\n\n    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);\n\n    if (nextSibling) {\n      this.sortable.el.insertBefore(dragEl, nextSibling);\n    } else {\n      this.sortable.el.appendChild(dragEl);\n    }\n\n    this.sortable.animateAll();\n\n    if (putSortable) {\n      putSortable.animateAll();\n    }\n  },\n  drop: drop\n};\n\n_extends(Revert, {\n  pluginName: 'revertOnSpill'\n});\n\nfunction Remove() {}\n\nRemove.prototype = {\n  onSpill: function onSpill(_ref4) {\n    var dragEl = _ref4.dragEl,\n        putSortable = _ref4.putSortable;\n    var parentSortable = putSortable || this.sortable;\n    parentSortable.captureAnimationState();\n    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);\n    parentSortable.animateAll();\n  },\n  drop: drop\n};\n\n_extends(Remove, {\n  pluginName: 'removeOnSpill'\n});\n\nvar lastSwapEl;\n\nfunction SwapPlugin() {\n  function Swap() {\n    this.defaults = {\n      swapClass: 'sortable-swap-highlight'\n    };\n  }\n\n  Swap.prototype = {\n    dragStart: function dragStart(_ref) {\n      var dragEl = _ref.dragEl;\n      lastSwapEl = dragEl;\n    },\n    dragOverValid: function dragOverValid(_ref2) {\n      var completed = _ref2.completed,\n          target = _ref2.target,\n          onMove = _ref2.onMove,\n          activeSortable = _ref2.activeSortable,\n          changed = _ref2.changed,\n          cancel = _ref2.cancel;\n      if (!activeSortable.options.swap) return;\n      var el = this.sortable.el,\n          options = this.options;\n\n      if (target && target !== el) {\n        var prevSwapEl = lastSwapEl;\n\n        if (onMove(target) !== false) {\n          toggleClass(target, options.swapClass, true);\n          lastSwapEl = target;\n        } else {\n          lastSwapEl = null;\n        }\n\n        if (prevSwapEl && prevSwapEl !== lastSwapEl) {\n          toggleClass(prevSwapEl, options.swapClass, false);\n        }\n      }\n\n      changed();\n      completed(true);\n      cancel();\n    },\n    drop: function drop(_ref3) {\n      var activeSortable = _ref3.activeSortable,\n          putSortable = _ref3.putSortable,\n          dragEl = _ref3.dragEl;\n      var toSortable = putSortable || this.sortable;\n      var options = this.options;\n      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);\n\n      if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {\n        if (dragEl !== lastSwapEl) {\n          toSortable.captureAnimationState();\n          if (toSortable !== activeSortable) activeSortable.captureAnimationState();\n          swapNodes(dragEl, lastSwapEl);\n          toSortable.animateAll();\n          if (toSortable !== activeSortable) activeSortable.animateAll();\n        }\n      }\n    },\n    nulling: function nulling() {\n      lastSwapEl = null;\n    }\n  };\n  return _extends(Swap, {\n    pluginName: 'swap',\n    eventProperties: function eventProperties() {\n      return {\n        swapItem: lastSwapEl\n      };\n    }\n  });\n}\n\nfunction swapNodes(n1, n2) {\n  var p1 = n1.parentNode,\n      p2 = n2.parentNode,\n      i1,\n      i2;\n  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;\n  i1 = index(n1);\n  i2 = index(n2);\n\n  if (p1.isEqualNode(p2) && i1 < i2) {\n    i2++;\n  }\n\n  p1.insertBefore(n2, p1.children[i1]);\n  p2.insertBefore(n1, p2.children[i2]);\n}\n\nvar multiDragElements = (/* unused pure expression or super */ null && ([])),\n    multiDragClones = (/* unused pure expression or super */ null && ([])),\n    lastMultiDragSelect,\n    // for selection with modifier key down (SHIFT)\nmultiDragSortable,\n    initialFolding = false,\n    // Initial multi-drag fold when drag started\nfolding = false,\n    // Folding any other time\ndragStarted = false,\n    dragEl$1,\n    clonesFromRect,\n    clonesHidden;\n\nfunction MultiDragPlugin() {\n  function MultiDrag(sortable) {\n    // Bind all private methods\n    for (var fn in this) {\n      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n\n    if (!sortable.options.avoidImplicitDeselect) {\n      if (sortable.options.supportPointer) {\n        on(document, 'pointerup', this._deselectMultiDrag);\n      } else {\n        on(document, 'mouseup', this._deselectMultiDrag);\n        on(document, 'touchend', this._deselectMultiDrag);\n      }\n    }\n\n    on(document, 'keydown', this._checkKeyDown);\n    on(document, 'keyup', this._checkKeyUp);\n    this.defaults = {\n      selectedClass: 'sortable-selected',\n      multiDragKey: null,\n      avoidImplicitDeselect: false,\n      setData: function setData(dataTransfer, dragEl) {\n        var data = '';\n\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          multiDragElements.forEach(function (multiDragElement, i) {\n            data += (!i ? '' : ', ') + multiDragElement.textContent;\n          });\n        } else {\n          data = dragEl.textContent;\n        }\n\n        dataTransfer.setData('Text', data);\n      }\n    };\n  }\n\n  MultiDrag.prototype = {\n    multiDragKeyDown: false,\n    isMultiDrag: false,\n    delayStartGlobal: function delayStartGlobal(_ref) {\n      var dragged = _ref.dragEl;\n      dragEl$1 = dragged;\n    },\n    delayEnded: function delayEnded() {\n      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);\n    },\n    setupClone: function setupClone(_ref2) {\n      var sortable = _ref2.sortable,\n          cancel = _ref2.cancel;\n      if (!this.isMultiDrag) return;\n\n      for (var i = 0; i < multiDragElements.length; i++) {\n        multiDragClones.push(clone(multiDragElements[i]));\n        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;\n        multiDragClones[i].draggable = false;\n        multiDragClones[i].style['will-change'] = '';\n        toggleClass(multiDragClones[i], this.options.selectedClass, false);\n        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);\n      }\n\n      sortable._hideClone();\n\n      cancel();\n    },\n    clone: function clone(_ref3) {\n      var sortable = _ref3.sortable,\n          rootEl = _ref3.rootEl,\n          dispatchSortableEvent = _ref3.dispatchSortableEvent,\n          cancel = _ref3.cancel;\n      if (!this.isMultiDrag) return;\n\n      if (!this.options.removeCloneOnHide) {\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          insertMultiDragClones(true, rootEl);\n          dispatchSortableEvent('clone');\n          cancel();\n        }\n      }\n    },\n    showClone: function showClone(_ref4) {\n      var cloneNowShown = _ref4.cloneNowShown,\n          rootEl = _ref4.rootEl,\n          cancel = _ref4.cancel;\n      if (!this.isMultiDrag) return;\n      insertMultiDragClones(false, rootEl);\n      multiDragClones.forEach(function (clone) {\n        css(clone, 'display', '');\n      });\n      cloneNowShown();\n      clonesHidden = false;\n      cancel();\n    },\n    hideClone: function hideClone(_ref5) {\n      var _this = this;\n\n      var sortable = _ref5.sortable,\n          cloneNowHidden = _ref5.cloneNowHidden,\n          cancel = _ref5.cancel;\n      if (!this.isMultiDrag) return;\n      multiDragClones.forEach(function (clone) {\n        css(clone, 'display', 'none');\n\n        if (_this.options.removeCloneOnHide && clone.parentNode) {\n          clone.parentNode.removeChild(clone);\n        }\n      });\n      cloneNowHidden();\n      clonesHidden = true;\n      cancel();\n    },\n    dragStartGlobal: function dragStartGlobal(_ref6) {\n      var sortable = _ref6.sortable;\n\n      if (!this.isMultiDrag && multiDragSortable) {\n        multiDragSortable.multiDrag._deselectMultiDrag();\n      }\n\n      multiDragElements.forEach(function (multiDragElement) {\n        multiDragElement.sortableIndex = index(multiDragElement);\n      }); // Sort multi-drag elements\n\n      multiDragElements = multiDragElements.sort(function (a, b) {\n        return a.sortableIndex - b.sortableIndex;\n      });\n      dragStarted = true;\n    },\n    dragStarted: function dragStarted(_ref7) {\n      var _this2 = this;\n\n      var sortable = _ref7.sortable;\n      if (!this.isMultiDrag) return;\n\n      if (this.options.sort) {\n        // Capture rects,\n        // hide multi drag elements (by positioning them absolute),\n        // set multi drag elements rects to dragRect,\n        // show multi drag elements,\n        // animate to rects,\n        // unset rects & remove from DOM\n        sortable.captureAnimationState();\n\n        if (this.options.animation) {\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            css(multiDragElement, 'position', 'absolute');\n          });\n          var dragRect = getRect(dragEl$1, false, true, true);\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            setRect(multiDragElement, dragRect);\n          });\n          folding = true;\n          initialFolding = true;\n        }\n      }\n\n      sortable.animateAll(function () {\n        folding = false;\n        initialFolding = false;\n\n        if (_this2.options.animation) {\n          multiDragElements.forEach(function (multiDragElement) {\n            unsetRect(multiDragElement);\n          });\n        } // Remove all auxiliary multidrag items from el, if sorting enabled\n\n\n        if (_this2.options.sort) {\n          removeMultiDragElements();\n        }\n      });\n    },\n    dragOver: function dragOver(_ref8) {\n      var target = _ref8.target,\n          completed = _ref8.completed,\n          cancel = _ref8.cancel;\n\n      if (folding && ~multiDragElements.indexOf(target)) {\n        completed(false);\n        cancel();\n      }\n    },\n    revert: function revert(_ref9) {\n      var fromSortable = _ref9.fromSortable,\n          rootEl = _ref9.rootEl,\n          sortable = _ref9.sortable,\n          dragRect = _ref9.dragRect;\n\n      if (multiDragElements.length > 1) {\n        // Setup unfold animation\n        multiDragElements.forEach(function (multiDragElement) {\n          sortable.addAnimationState({\n            target: multiDragElement,\n            rect: folding ? getRect(multiDragElement) : dragRect\n          });\n          unsetRect(multiDragElement);\n          multiDragElement.fromRect = dragRect;\n          fromSortable.removeAnimationState(multiDragElement);\n        });\n        folding = false;\n        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);\n      }\n    },\n    dragOverCompleted: function dragOverCompleted(_ref10) {\n      var sortable = _ref10.sortable,\n          isOwner = _ref10.isOwner,\n          insertion = _ref10.insertion,\n          activeSortable = _ref10.activeSortable,\n          parentEl = _ref10.parentEl,\n          putSortable = _ref10.putSortable;\n      var options = this.options;\n\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        }\n\n        initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location\n\n        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {\n          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible\n          var dragRectAbsolute = getRect(dragEl$1, false, true, true);\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted\n            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable\n\n            parentEl.appendChild(multiDragElement);\n          });\n          folding = true;\n        } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out\n\n\n        if (!isOwner) {\n          // Only remove if not folding (folding will remove them anyways)\n          if (!folding) {\n            removeMultiDragElements();\n          }\n\n          if (multiDragElements.length > 1) {\n            var clonesHiddenBefore = clonesHidden;\n\n            activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden\n\n\n            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {\n              multiDragClones.forEach(function (clone) {\n                activeSortable.addAnimationState({\n                  target: clone,\n                  rect: clonesFromRect\n                });\n                clone.fromRect = clonesFromRect;\n                clone.thisAnimationDuration = null;\n              });\n            }\n          } else {\n            activeSortable._showClone(sortable);\n          }\n        }\n      }\n    },\n    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {\n      var dragRect = _ref11.dragRect,\n          isOwner = _ref11.isOwner,\n          activeSortable = _ref11.activeSortable;\n      multiDragElements.forEach(function (multiDragElement) {\n        multiDragElement.thisAnimationDuration = null;\n      });\n\n      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {\n        clonesFromRect = _extends({}, dragRect);\n        var dragMatrix = matrix(dragEl$1, true);\n        clonesFromRect.top -= dragMatrix.f;\n        clonesFromRect.left -= dragMatrix.e;\n      }\n    },\n    dragOverAnimationComplete: function dragOverAnimationComplete() {\n      if (folding) {\n        folding = false;\n        removeMultiDragElements();\n      }\n    },\n    drop: function drop(_ref12) {\n      var evt = _ref12.originalEvent,\n          rootEl = _ref12.rootEl,\n          parentEl = _ref12.parentEl,\n          sortable = _ref12.sortable,\n          dispatchSortableEvent = _ref12.dispatchSortableEvent,\n          oldIndex = _ref12.oldIndex,\n          putSortable = _ref12.putSortable;\n      var toSortable = putSortable || this.sortable;\n      if (!evt) return;\n      var options = this.options,\n          children = parentEl.children; // Multi-drag selection\n\n      if (!dragStarted) {\n        if (options.multiDragKey && !this.multiDragKeyDown) {\n          this._deselectMultiDrag();\n        }\n\n        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));\n\n        if (!~multiDragElements.indexOf(dragEl$1)) {\n          multiDragElements.push(dragEl$1);\n          dispatchEvent({\n            sortable: sortable,\n            rootEl: rootEl,\n            name: 'select',\n            targetEl: dragEl$1,\n            originalEvent: evt\n          }); // Modifier activated, select from last to dragEl\n\n          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {\n            var lastIndex = index(lastMultiDragSelect),\n                currentIndex = index(dragEl$1);\n\n            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {\n              // Must include lastMultiDragSelect (select it), in case modified selection from no selection\n              // (but previous selection existed)\n              var n, i;\n\n              if (currentIndex > lastIndex) {\n                i = lastIndex;\n                n = currentIndex;\n              } else {\n                i = currentIndex;\n                n = lastIndex + 1;\n              }\n\n              for (; i < n; i++) {\n                if (~multiDragElements.indexOf(children[i])) continue;\n                toggleClass(children[i], options.selectedClass, true);\n                multiDragElements.push(children[i]);\n                dispatchEvent({\n                  sortable: sortable,\n                  rootEl: rootEl,\n                  name: 'select',\n                  targetEl: children[i],\n                  originalEvent: evt\n                });\n              }\n            }\n          } else {\n            lastMultiDragSelect = dragEl$1;\n          }\n\n          multiDragSortable = toSortable;\n        } else {\n          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);\n          lastMultiDragSelect = null;\n          dispatchEvent({\n            sortable: sortable,\n            rootEl: rootEl,\n            name: 'deselect',\n            targetEl: dragEl$1,\n            originalEvent: evt\n          });\n        }\n      } // Multi-drag drop\n\n\n      if (dragStarted && this.isMultiDrag) {\n        folding = false; // Do not \"unfold\" after around dragEl if reverted\n\n        if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {\n          var dragRect = getRect(dragEl$1),\n              multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');\n          if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;\n          toSortable.captureAnimationState();\n\n          if (!initialFolding) {\n            if (options.animation) {\n              dragEl$1.fromRect = dragRect;\n              multiDragElements.forEach(function (multiDragElement) {\n                multiDragElement.thisAnimationDuration = null;\n\n                if (multiDragElement !== dragEl$1) {\n                  var rect = folding ? getRect(multiDragElement) : dragRect;\n                  multiDragElement.fromRect = rect; // Prepare unfold animation\n\n                  toSortable.addAnimationState({\n                    target: multiDragElement,\n                    rect: rect\n                  });\n                }\n              });\n            } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert\n            // properly they must all be removed\n\n\n            removeMultiDragElements();\n            multiDragElements.forEach(function (multiDragElement) {\n              if (children[multiDragIndex]) {\n                parentEl.insertBefore(multiDragElement, children[multiDragIndex]);\n              } else {\n                parentEl.appendChild(multiDragElement);\n              }\n\n              multiDragIndex++;\n            }); // If initial folding is done, the elements may have changed position because they are now\n            // unfolding around dragEl, even though dragEl may not have his index changed, so update event\n            // must be fired here as Sortable will not.\n\n            if (oldIndex === index(dragEl$1)) {\n              var update = false;\n              multiDragElements.forEach(function (multiDragElement) {\n                if (multiDragElement.sortableIndex !== index(multiDragElement)) {\n                  update = true;\n                  return;\n                }\n              });\n\n              if (update) {\n                dispatchSortableEvent('update');\n              }\n            }\n          } // Must be done after capturing individual rects (scroll bar)\n\n\n          multiDragElements.forEach(function (multiDragElement) {\n            unsetRect(multiDragElement);\n          });\n          toSortable.animateAll();\n        }\n\n        multiDragSortable = toSortable;\n      } // Remove clones if necessary\n\n\n      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n        multiDragClones.forEach(function (clone) {\n          clone.parentNode && clone.parentNode.removeChild(clone);\n        });\n      }\n    },\n    nullingGlobal: function nullingGlobal() {\n      this.isMultiDrag = dragStarted = false;\n      multiDragClones.length = 0;\n    },\n    destroyGlobal: function destroyGlobal() {\n      this._deselectMultiDrag();\n\n      off(document, 'pointerup', this._deselectMultiDrag);\n      off(document, 'mouseup', this._deselectMultiDrag);\n      off(document, 'touchend', this._deselectMultiDrag);\n      off(document, 'keydown', this._checkKeyDown);\n      off(document, 'keyup', this._checkKeyUp);\n    },\n    _deselectMultiDrag: function _deselectMultiDrag(evt) {\n      if (typeof dragStarted !== \"undefined\" && dragStarted) return; // Only deselect if selection is in this sortable\n\n      if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable\n\n      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click\n\n      if (evt && evt.button !== 0) return;\n\n      while (multiDragElements.length) {\n        var el = multiDragElements[0];\n        toggleClass(el, this.options.selectedClass, false);\n        multiDragElements.shift();\n        dispatchEvent({\n          sortable: this.sortable,\n          rootEl: this.sortable.el,\n          name: 'deselect',\n          targetEl: el,\n          originalEvent: evt\n        });\n      }\n    },\n    _checkKeyDown: function _checkKeyDown(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = true;\n      }\n    },\n    _checkKeyUp: function _checkKeyUp(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = false;\n      }\n    }\n  };\n  return _extends(MultiDrag, {\n    // Static methods & properties\n    pluginName: 'multiDrag',\n    utils: {\n      /**\r\n       * Selects the provided multi-drag item\r\n       * @param  {HTMLElement} el    The element to be selected\r\n       */\n      select: function select(el) {\n        var sortable = el.parentNode[expando];\n        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;\n\n        if (multiDragSortable && multiDragSortable !== sortable) {\n          multiDragSortable.multiDrag._deselectMultiDrag();\n\n          multiDragSortable = sortable;\n        }\n\n        toggleClass(el, sortable.options.selectedClass, true);\n        multiDragElements.push(el);\n      },\n\n      /**\r\n       * Deselects the provided multi-drag item\r\n       * @param  {HTMLElement} el    The element to be deselected\r\n       */\n      deselect: function deselect(el) {\n        var sortable = el.parentNode[expando],\n            index = multiDragElements.indexOf(el);\n        if (!sortable || !sortable.options.multiDrag || !~index) return;\n        toggleClass(el, sortable.options.selectedClass, false);\n        multiDragElements.splice(index, 1);\n      }\n    },\n    eventProperties: function eventProperties() {\n      var _this3 = this;\n\n      var oldIndicies = [],\n          newIndicies = [];\n      multiDragElements.forEach(function (multiDragElement) {\n        oldIndicies.push({\n          multiDragElement: multiDragElement,\n          index: multiDragElement.sortableIndex\n        }); // multiDragElements will already be sorted if folding\n\n        var newIndex;\n\n        if (folding && multiDragElement !== dragEl$1) {\n          newIndex = -1;\n        } else if (folding) {\n          newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');\n        } else {\n          newIndex = index(multiDragElement);\n        }\n\n        newIndicies.push({\n          multiDragElement: multiDragElement,\n          index: newIndex\n        });\n      });\n      return {\n        items: _toConsumableArray(multiDragElements),\n        clones: [].concat(multiDragClones),\n        oldIndicies: oldIndicies,\n        newIndicies: newIndicies\n      };\n    },\n    optionListeners: {\n      multiDragKey: function multiDragKey(key) {\n        key = key.toLowerCase();\n\n        if (key === 'ctrl') {\n          key = 'Control';\n        } else if (key.length > 1) {\n          key = key.charAt(0).toUpperCase() + key.substr(1);\n        }\n\n        return key;\n      }\n    }\n  });\n}\n\nfunction insertMultiDragElements(clonesInserted, rootEl) {\n  multiDragElements.forEach(function (multiDragElement, i) {\n    var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];\n\n    if (target) {\n      rootEl.insertBefore(multiDragElement, target);\n    } else {\n      rootEl.appendChild(multiDragElement);\n    }\n  });\n}\n/**\r\n * Insert multi-drag clones\r\n * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted\r\n * @param  {HTMLElement} rootEl\r\n */\n\n\nfunction insertMultiDragClones(elementsInserted, rootEl) {\n  multiDragClones.forEach(function (clone, i) {\n    var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];\n\n    if (target) {\n      rootEl.insertBefore(clone, target);\n    } else {\n      rootEl.appendChild(clone);\n    }\n  });\n}\n\nfunction removeMultiDragElements() {\n  multiDragElements.forEach(function (multiDragElement) {\n    if (multiDragElement === dragEl$1) return;\n    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);\n  });\n}\n\nSortable.mount(new AutoScrollPlugin());\nSortable.mount(Remove, Revert);\n\n/* harmony default export */ const sortable_esm = (Sortable);\n\n\n;// CONCATENATED MODULE: ./public/src/components/sortable.js\n\n\nfunction sortable(containerSelector, elSelector, model) {\n  let container = common_$(containerSelector)[0]; // debugger\n\n  if (container) {\n    // let els = $(elSelector);\n    let sortable = sortable_esm.create(container, {\n      animation: 150,\n      onEnd: function (evt) {\n        let oldI = evt.oldIndex;\n        let newI = evt.newIndex; // let questions = _question.questions()\n\n        if (oldI > newI) {\n          sort(oldI);\n        } else {\n          sort(newI);\n        }\n\n        async function sort(upToQestionNumber) {\n          let els = common_$(elSelector);\n          let questionsEls = [].map.call(els, function (el, i) {\n            if (i - 1 < upToQestionNumber) return el;\n          });\n          let toChange = questionsEls.map(el => {\n            return el.id;\n          });\n          let res = await post(`/adminsc/${model}/sort`, {\n            toChange\n          }); // res = JSON.parse(res)\n          // if (res.msg) {\n          //   popup.show(res.msg)\n          // }\n\n          questionsEls.map((el, i) => {\n            common_$(el).find('.sort').innerText = i + 1;\n          });\n        }\n      }\n    });\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Test/model/opentest/opentest.js\n\nclass _test {\n  constructor() {\n    this.model = 'opentest';\n  }\n\n  async create() {\n    let test = _test.serverModel();\n\n    test.id = 0;\n    test.isTest = 1;\n    debugger;\n    let url = `/${this.model}/updateOrCreate`;\n    let res = await post(url, test);\n    res = await JSON.parse(res);\n    debugger;\n\n    if (res) {\n      window.location.href = `/adminsc/${model}/edit/${res.id}`;\n    }\n  }\n\n  currentQ() {\n    return {\n      id: common_$('.nav-active')[0].innerText - 1,\n      QEl: common_$('.question.flex1')[0],\n      navLength: common_$('[data-pagination]').length,\n      QPrevc: common_$('.question.flex1')[0].previousElementSibling,\n      QNextEl: common_$('.question.flex1')[0].nextElementSibling\n    };\n  }\n\n  viewModel() {\n    return {\n      id: +window.location.href.split('/').pop(),\n      test_name: common_$('#test_name').text(),\n      enable: common_$('#enable')[0],\n      parent: common_$('select').selectedIndexValue()\n    };\n  }\n\n  id() {\n    return id ?? common_$('.test-name')[0].dataset.testid;\n  }\n\n  children() {\n    let childrenLenght = common_$('.children').length;\n    if (childrenLenght) return childrenLenght;\n    return false;\n  }\n\n  async path_create() {\n    let test_path = _test.serverModel();\n\n    test_path.id = 0;\n    test_path.isTest = 0;\n    let url = `/adminsc/${model}/create`;\n    let res = await post(url, test_path);\n    res = await JSON.parse(res);\n\n    if (res) {\n      window.location.href = `/adminsc/${model}/edit/${res.id - 1}`;\n    }\n  }\n\n  name() {\n    return common_$('.test-name')[0].innerText;\n  }\n\n  selectedValueCustomSelect(className) {\n    let select = common_$(`[data-field=${className}]`)[0];\n    let selected = [...select.options].filter(opt => opt.selected);\n\n    if (selected) {\n      return +selected[0].value;\n    }\n  }\n\n  serverModel() {\n    let model = {\n      id: +window.location.href.split('/').pop(),\n      test_name: common_$('#test_name')[0].value,\n      isTest: +common_$('[isTest]')[0].getAttribute('isTest')\n    };\n    let fields = common_$('.custom-select');\n    [].forEach.call(fields, function (field) {\n      model[field.dataset['field']] = field.dataset['id'];\n    });\n    return model;\n  }\n\n  async update() {\n    let model = _test.serverModel();\n\n    let url = `/adminsc/${model}/update/${model.id}`;\n    let res = await post(url, model);\n    res = await JSON.parse(res);\n\n    if (res) {\n      window.location.href = `/adminsc/${model}/edit/${model.id}`;\n    }\n  }\n\n  async del() {\n    if (_test.children()) {\n      popup.show('Сначала удалите все тесты из папки');\n      return false;\n    }\n\n    let id = _test.id();\n\n    let res = await post('/adminsc/${model}/delete', {\n      id\n    });\n    res = await JSON.parse(res);\n\n    if (res.notAdmin) {\n      popup.show('Видимость теста скрыта. Чтобы удалить полностью - обратитесь к ГД');\n      setTimeout(() => {\n        window.location = `/adminsc/${model}/edit/400`;\n      }, 4000);\n    } else {\n      window.location = `/adminsc/${model}/edit/400`;\n    }\n  }\n\n}\n;// CONCATENATED MODULE: ./public/src/Test/model/opentest/openanswer.js\n\nlet _answer = {\n  async create(button) {\n    let question = button.closest('.question-edit');\n    let openquestion_id = question.id;\n    let sort = question.querySelectorAll('.answer').length + 1;\n    let res = await post('/openanswer/updateOrCreate', {\n      openquestion_id,\n      sort\n    });\n    res = JSON.parse(res);\n    let id = res.id;\n\n    if (id) {\n      let html = res.html;\n      button.insertAdjacentHTML(\"beforebegin\", html);\n    } else {\n      popup.show('Сохранено');\n    }\n  },\n\n  async del(target) {\n    let del_button = target.closest('.delete');\n    if (!del_button) return false;\n\n    if (confirm(\"Удалить этот ответ?\")) {\n      let answer = del_button.closest('.answer');\n      let id = +answer.dataset['answerId'];\n      let res = await post('/openanswer/delete', {\n        id\n      });\n      res = JSON.parse(res);\n\n      if (res.msg === 'ok') {\n        answer.remove();\n        popup.show('Ответ удален');\n      }\n    }\n  }\n\n};\n;// CONCATENATED MODULE: ./public/src/Test/opentest-edit.js\n\n\n\n\n\n\n\n\n\n\n\nlet opentestEdit = common_$('.opentest-edit-wrapper')[0];\n\nif (opentestEdit) {\n  sortable('.opentest-edit-wrapper .questions', '.opentest-edit-wrapper .question-edit', 'openquestion');\n  common_$(opentestEdit).on('change', handleChange);\n  common_$(opentestEdit).on('click', _ref => {\n    let {\n      target\n    } = _ref;\n    const test = new _test();\n\n    if (target.classList.contains('test-path__update')) {\n      test.update();\n    } else if (target.classList.contains('test__update')) {\n      test.update();\n    } else if (target.classList.contains('test__save')) {\n      test.update();\n    } else if (target.classList.contains('test__delete')) {\n      test.delete();\n    } else if (target.classList.contains('test-path__create')) {\n      test.path_create();\n    } else if (target.classList.contains('test__create')) {\n      test.create();\n    } else if (!!target.closest('.question__show-answers')) {\n      _openquestion.showAnswers(target);\n    } else if (!!target.closest('.question__delete')) {\n      _openquestion.del(target);\n    } else if (target.classList.contains('question__create-button')) {\n      _openquestion.create(target);\n    } else if (!!target.closest('.delete')) {\n      _answer.del(target);\n    } else if (target.classList.contains('answer__create-button')) {\n      _answer.create(target);\n    } else if (!!target.closest('.question-edit__parent-select')) {\n      _openquestion.changeParent(target);\n    } else if (target.classList.contains('led')) {\n      target.classList.toggle('animated');\n    }\n  });\n\n  let handleKeyup = async function (_ref2) {\n    let {\n      target\n    } = _ref2;\n\n    if (target.classList.contains('text')) {\n      let answer = target.closest('.answer');\n\n      if (answer) {\n        saveAnswer(answer);\n      } else {\n        let id = target.closest('.question-edit').id;\n        let question = target.innerText;\n        let res = await post('/adminsc/openquestion/updateOrCreate', {\n          id,\n          question\n        });\n        res = await JSON.parse(res);\n      }\n    }\n  };\n\n  let debouncedInput = debounce(handleKeyup);\n  common_$(opentestEdit).on('keyup', debouncedInput);\n}\n\nasync function saveAnswer(answerEl) {\n  let id = answerEl.dataset.answerId;\n  let is_correct = +answerEl.querySelector('input').checked;\n  let openquestion_id = answerEl.closest('.question-edit').id;\n  let answer = answerEl.querySelector('.text').innerText;\n  let res = await post('/adminsc/openanswer/updateOrCreate', {\n    id,\n    answer,\n    openquestion_id,\n    is_correct\n  });\n  res = JSON.parse(res);\n\n  if (res.msg === 'ok') {\n    popup.show('Сохранен');\n  }\n}\n\nasync function handleChange(_ref3) {\n  let {\n    target\n  } = _ref3;\n  let answer = target.closest('.answer');\n\n  if (answer) {\n    saveAnswer(answer);\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Test/model/answer.js\n\nlet answer_answer = {\n  el: add_button => {\n    let answers = add_button.parentNode.querySelectorAll('.answer');\n    let prev_sort = 0;\n\n    if (answers.length) {\n      prev_sort = +common_$(answers[answers.length - 1]).find('.sort').innerText;\n    }\n\n    let el = common_$('.answer__create').find('.answer').cloneNode(true);\n    el.classList.add('answer');\n    el.classList.remove('answer__create');\n    return {\n      el: el,\n      id: 'new',\n      q_id: +add_button.closest('.question-edit').id,\n      previous_sort: prev_sort,\n      answerCnt: answers.length,\n      sort: common_$(el).find('.sort'),\n      checked: common_$(el).find('input'),\n      text: common_$(el).find('.text'),\n      delete: common_$(common_$(el).find('.delete')).on('click', function () {\n        answer_answer.del(this);\n      })\n    };\n  },\n\n  getModelForServer(el) {\n    return {\n      answer: '',\n      parent_question: el.q_id,\n      correct_answer: 0,\n      pica: ''\n    };\n  },\n\n  async create(button) {\n    // debugger\n    let a_id = await createOnServer(button);\n    show(a_id);\n\n    async function createOnServer(button) {\n      let newEl = answer_answer.getModelForServer(answer_answer.el(button));\n\n      let res = await post('/answer/create', newEl);\n      res = JSON.parse(res);\n      return res.id;\n    }\n\n    function show(a_id) {\n      let el = answer_answer.el(button);\n\n      el.checked.checked = false;\n      el.el.dataset['answerId'] = a_id;\n      el.text.innerText = '';\n      el.sort.innerText = el.answerCnt + 1;\n      el.el.style.display = 'flex';\n      button.before(el.el);\n      el.el.style.opacity = 1;\n    }\n  },\n\n  async del(target) {\n    let del_button = target.closest('.delete');\n    if (!del_button) return false;\n\n    if (confirm(\"Удалить этот ответ?\")) {\n      let res = await deleteFromServer(del_button);\n    }\n\n    async function deleteFromServer(del_button) {\n      let a_id = +del_button.closest('.answer').dataset['answerId'];\n      let res = await post('/answer/delete', {\n        a_id\n      });\n      res = JSON.parse(res);\n\n      if (res.msg === 'ok') {\n        del_button.closest('.answer').remove();\n        popup.show('Ответ удален');\n      }\n    }\n  }\n\n};\n;// CONCATENATED MODULE: ./public/src/Test/model/question.js\n\n\nlet _question = {\n  changeParent: async function (target) {\n    debugger;\n    let opt = target.options[target.selectedIndex];\n    let id = target.closest('.question-edit').id;\n    let test_id = opt.dataset['questionParentId'];\n    let test_name = opt.value;\n    let res = await post('/adminsc/question/changeParent', {\n      id,\n      test_id\n    });\n    res = JSON.parse(res);\n    if (res.msg !== 'ok') throw e;\n    let question = target.closest('.question-edit');\n    question.remove();\n    popup.show('Перемещен в ' + test_name); // debugger\n  },\n  showTip: (action, event) => {\n    let el = event.target;\n    let tip = document.createElement(\"div\");\n\n    if (action === 'save.svg') {\n      addTooltip(el, 'сохранить');\n    }\n  },\n  // showFirst: () => {\n  //   let question = _question.cloneEmptyModel()\n  //   if (!question) return\n  //\n  //   let model = _question.viewModel(question)\n  //   model.sort.innerText = '1'\n  //   $(model.save).on('click', _question.save)\n  //   $(model.del).on('click', _question.delete)\n  //\n  //   $(question).addClass('question-edit')\n  //   $(question).removeClass('question__create')\n  //\n  //   let questions = $('.questions')[0]\n  //   questions.prepend(question)\n  // },\n  cloneEmptyModel: () => {\n    let question = common_$('.questions .question__create .question-edit')[0];\n    if (question) return question.cloneNode(true);\n  },\n  showAnswers: target => {\n    let row = target.closest('.question-edit');\n    let answers = common_$(row).find('.question__answers');\n    answers.classList.toggle('height');\n    answers.classList.toggle('scale');\n    target.classList.toggle('rotate');\n  },\n  viewModel: el => {\n    return {\n      id: +el.id,\n      el: el,\n      sort: el.querySelector('.sort'),\n      save: el.querySelector('.question__save'),\n      text: el.querySelector('.question__text'),\n      del: el.querySelector('.question__delete'),\n      createAnswerButton: el.querySelector('.answer__create-button'),\n      addButton: common_$(common_$('.questions')[0]).find('.question__create-button')\n    };\n  },\n  serverModel: () => {\n    return {\n      question: {\n        id: null,\n        qustion: '',\n        parent: +window.location.href.split('/').pop(),\n        sort: _question.lastSort()\n      }\n    };\n  },\n  questions: () => {\n    return common_$('.questions>.question-edit'); // return $('.questions>.question-edit').el\n  },\n  questionsCount: () => {\n    return common_$('.questions>.question-edit').el.length;\n  },\n  lastSort: () => {\n    let qs = _question.questions();\n\n    let length = qs.length - 1;\n    let last = +_question.viewModel(qs[length]).sort.innerText;\n    return last + 1;\n  },\n  create: async e => {\n    let q_id = await _question.createOnServer(e);\n\n    if (q_id) {\n      _question.createOnView(q_id);\n    }\n  },\n  createOnServer: async () => {\n    let question = _question.serverModel();\n\n    let res = await post('/question/updateOrCreate', {\n      question: question.question,\n      answers: {}\n    });\n    res = await JSON.parse(res);\n    return res.id;\n  },\n  createOnView: q_id => {\n    let clone = _question.cloneEmptyModel();\n\n    let model = _question.viewModel(clone);\n\n    model.sort.innerText = _question.lastSort();\n    model.text.innerText = '';\n    model.el.id = q_id;\n    model.addButton.before(clone);\n  },\n  save: async target => {\n    let question = target.closest('.question-edit');\n    let res = await post('/question/UpdateOrCreate', {\n      question: _question.getModelForServer(question),\n      answers: _question.getAnswers(question)\n    });\n    res = await JSON.parse(res); // popup.show(res.msg)\n  },\n  delete: async target => {\n    if (confirm(\"Удалить вопрос со всеми его ответами?\")) {\n      let viewModel = _question.viewModel(target.closest('.question-edit'));\n\n      let id = viewModel.id;\n      let deleted = await _question.deleteFromServer(id);\n\n      if (deleted) {\n        _question.deleteFromView(viewModel); // popup.show(deleted.msg)\n\n      }\n    }\n  },\n  deleteFromView: async viewModel => {\n    viewModel.el.remove();\n  },\n  deleteFromServer: async q_id => {\n    let res = await post('/question/delete', {\n      q_id\n    });\n    return JSON.parse(res);\n  },\n  getModelForServer: question => {\n    return {\n      id: +question.id,\n      parent: +common_$('.questions')[0].dataset.testId,\n      picq: '',\n      qustion: common_$(question).find('.question__text').innerText,\n      sort: +common_$(question).find('.sort').innerText\n    };\n  },\n  getAnswers: question => {\n    let answerBlocks = question.querySelectorAll('.answer');\n    return [...answerBlocks].map(a => {\n      return {\n        id: +a.dataset['answerId'],\n        answer: a.querySelector('.text').innerText,\n        correct_answer: +a.querySelector('[type=\"checkbox\"]').checked,\n        parent_question: +question.id,\n        pica: ''\n      };\n    }, question);\n  }\n};\n;// CONCATENATED MODULE: ./public/src/components/select/WDSSelect.js\n\n\nclass WDSSelect {\n  constructor(el) {\n    if (!el) return false;\n    if (el.multiple) return false;\n    this.title = el.title ?? '';\n    this.field = el.dataset['field'];\n    this.options = getFormattedOptions(el.querySelectorAll(\"option\"));\n    this.sel = document.createElement(\"div\");\n    if (el.className) this.sel.classList.add(el.className);\n    this.label = document.createElement(\"span\");\n    this.arrow = document.createElement(\"div\");\n    this.space = document.createElement(\"div\");\n    this.ul = document.createElement(\"ul\");\n    setup(this);\n    el.after(this.sel); // el.style.display = \"none\"\n\n    el.remove();\n  }\n\n  get selectedOption() {\n    return this.options.find(option => option.selected);\n  }\n\n  get selectedOptionIndex() {\n    return this.options.indexOf(this.selectedOption);\n  }\n\n  selectValue(value) {\n    const next = this.options.find(option => {\n      return option.value === value;\n    });\n    const prev = this.selectedOption;\n    prev.selected = false; // prev.element.selected = false\n\n    next.selected = true; // next.element.selected = true\n\n    this.space.innerText = next.label;\n    this.label.closest('[custom-select]').dataset['id'] = next.value;\n    this.label.closest('[custom-select]').dataset['value'] = next.value;\n    this.ul.querySelector(`[data-value=\"${prev.value}\"]`).classList.remove(\"selected\");\n    const newCustomElement = this.ul.querySelector(`[data-value=\"${next.value}\"]`);\n    newCustomElement.classList.add(\"selected\");\n    newCustomElement.scrollIntoView({\n      block: \"nearest\"\n    });\n  }\n\n}\n\nfunction setup(select) {\n  if (select.title) {\n    select.titleElement = document.createElement(\"div\");\n    select.titleElement.classList.add(\"title\");\n    select.titleElement.innerText = select.title;\n    select.sel.append(select.titleElement);\n  } // select.sel.classList.add(\"custom-select\")\n\n\n  select.sel.setAttribute(\"custom-select\", '');\n  if (select.field) select.sel.dataset['field'] = select.field;\n  select.sel.dataset['id'] = select.selectedOption.value;\n  select.sel.dataset['value'] = select.selectedOption.value;\n  select.sel.tabIndex = 0; // select.label.classList.add(\"value\")\n\n  select.sel.append(select.label);\n  select.space.classList.add(\"space\");\n  select.space.innerText = select.selectedOption.label;\n  select.label.append(select.space);\n  select.arrow.classList.add(\"arrow\");\n  select.label.append(select.arrow);\n  select.ul.classList.add(\"options\");\n  select.options.forEach(option => {\n    setOption(option);\n  });\n\n  function setOption(option) {\n    const li = document.createElement(\"li\");\n    li.innerText = option.label;\n    li.dataset.value = option.value;\n    li.classList.toggle(\"selected\", option.selected);\n    li.addEventListener(\"click\", () => {\n      select.selectValue(option.value);\n      select.ul.classList.remove(\"show\");\n    });\n    select.ul.append(li);\n  }\n\n  select.sel.append(select.ul);\n  select.label.addEventListener(\"click\", () => {\n    select.ul.classList.toggle(\"show\");\n  });\n  select.sel.addEventListener(\"blur\", () => {\n    select.ul.classList.remove(\"show\");\n  });\n  let debounceTimeout;\n  let searchTerm = \"\";\n  select.sel.addEventListener(\"keydown\", e => {\n    switch (e.code) {\n      case \"Space\":\n        select.ul.classList.toggle(\"show\");\n        break;\n\n      case \"ArrowUp\":\n        {\n          const prevOption = select.options[select.selectedOptionIndex - 1];\n\n          if (prevOption) {\n            select.selectValue(prevOption.value);\n          }\n\n          break;\n        }\n\n      case \"ArrowDown\":\n        {\n          const nextOption = select.options[select.selectedOptionIndex + 1];\n\n          if (nextOption) {\n            select.selectValue(nextOption.value);\n          }\n\n          break;\n        }\n\n      case \"Enter\":\n      case \"Escape\":\n        select.ul.classList.remove(\"show\");\n        break;\n\n      default:\n        {\n          clearTimeout(debounceTimeout);\n          searchTerm += e.key;\n          debounceTimeout = setTimeout(() => {\n            searchTerm = \"\";\n          }, 500);\n          const searchedOption = select.options.find(option => {\n            return option.label.toLowerCase().startsWith(searchTerm);\n          });\n\n          if (searchedOption) {\n            select.selectValue(searchedOption.value);\n          }\n        }\n    }\n  });\n}\n\nfunction getFormattedOptions(options) {\n  return [...options].map(option => {\n    return {\n      value: option.value,\n      label: option.label,\n      selected: option.selected,\n      element: option\n    };\n  });\n}\n;// CONCATENATED MODULE: ./public/src/components/accordion-show.js\n\nfunction accordionShow() {\n  let currentTestId = common_$(`[data-testid]`)[0];\n\n  if (currentTestId) {\n    currentTestId = +currentTestId.dataset['testid'];\n    let menuItemCollection = common_$('.test-edit.accordion a');\n    Array.from(menuItemCollection).filter(a => {\n      if (+a.dataset.id === currentTestId) {\n        a.classList.add('current');\n      }\n    });\n  }\n\n  let button = common_$('.accordion-open')[0];\n\n  if (button) {\n    common_$(button).on('click', function () {\n      let menu = common_$('.accordion_wrap')[0];\n      menu.classList.toggle('open');\n    });\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Test/model/test.js\n\nconst test_test = {\n  nextQ: () => {\n    let current = test_test.currentQ();\n\n    if (current.id > current.navLength - 2) return false;\n\n    let aimNavId = test_test.aimNavIdFunction(current.id, 'next');\n\n    let aimQEl = test_test.aimQElFunction(current, 'next');\n\n    test_test.pushNav(current.id, aimNavId);\n\n    test_test.pushQ(current.QEl, aimQEl);\n  },\n  prevQ: () => {\n    let current = test_test.currentQ();\n\n    if (current.id < 1) return false;\n\n    let aimNavId = test_test.aimNavIdFunction(current.id, 'back');\n\n    let aimQEl = test_test.aimQElFunction(current, 'back');\n\n    test_test.pushNav(current.id, aimNavId);\n\n    test_test.pushQ(current.QEl, aimQEl);\n  },\n  pushNav: (currentId, aimNavId) => {\n    let currNavEl = common_$('[data-pagination]')[currentId];\n    currNavEl.classList.toggle('active');\n    let NavEl = common_$('[data-pagination]')[aimNavId];\n    NavEl.classList.toggle('active');\n  },\n  pushQ: (currentEl, aimQEl) => {\n    currentEl.classList.toggle('show');\n    aimQEl.classList.toggle('show');\n  },\n  aimNavIdFunction: (currentId, direction) => {\n    let dir = currentId;\n\n    switch (true) {\n      case direction === 'next':\n        return dir += 1;\n        break;\n\n      case direction === 'back':\n        return dir -= 1;\n        break;\n    }\n  },\n  aimQElFunction: (current, direction) => {\n    switch (true) {\n      case direction === 'next':\n        return current.QNextEl;\n        break;\n\n      case direction === 'back':\n        return current.QPrevEl;\n        break;\n    }\n  },\n  currentQ: () => {\n    return {\n      id: common_$('.active')[0].innerText - 1,\n      QEl: common_$('.question.show')[0],\n      navLength: common_$('[data-pagination]').length,\n      QPrevEl: common_$('.question.show')[0].previousElementSibling,\n      QNextEl: common_$('.question.show')[0].nextElementSibling\n    };\n  },\n  viewModel: () => {\n    return {\n      id: +window.location.href.split('/').pop(),\n      test_name: common_$('#test_name').text(),\n      enable: common_$('#enable')[0],\n      parent: common_$('select').selectedIndexValue()\n    };\n  },\n  id: id => {\n    return id ?? common_$('.test-name')[0].dataset.testid;\n  },\n  children: () => {\n    let childrenLenght = common_$('.children').length;\n    if (childrenLenght) return childrenLenght;\n    return false;\n  },\n  path_create: async () => {\n    let test_path = test_test.serverModel();\n\n    test_path.id = 0;\n    test_path.isTest = 0;\n    let url = `/test/create`;\n    let res = await post(url, test_path);\n    res = await JSON.parse(res);\n\n    if (res) {\n      window.location.href = `/adminsc/test/edit/${res.id - 1}`;\n    }\n  },\n  name: () => {\n    return common_$('.test-name')[0].innerText;\n  },\n  create: async () => {\n    let test = test_test.serverModel();\n\n    test.id = 0;\n    test.isTest = 1;\n    let url = `/test/updateOrCreate`;\n    let res = await post(url, test);\n    res = await JSON.parse(res);\n    debugger;\n\n    if (res) {\n      window.location.href = `/adminsc/test/edit/${res.id}`;\n    }\n  },\n\n  selectedValueCustomSelect(className) {\n    let select = common_$(`[data-field=${className}]`)[0];\n    let selected = [...select.options].filter(opt => opt.selected);\n\n    if (selected) {\n      return +selected[0].value;\n    }\n  },\n\n  serverModel: () => {\n    let model = {\n      id: +window.location.href.split('/').pop(),\n      test_name: common_$('#test_name')[0].value,\n      isTest: +common_$('[isTest]')[0].getAttribute('isTest') // enable: _test.selectedValueCustomSelect('enable'),\n      // parent: _test.selectedValueCustomSelect('parent'),\n\n    }; // debugger\n\n    let fields = common_$('.custom-select');\n    [].forEach.call(fields, function (field) {\n      model[field.dataset['field']] = field.dataset['id'];\n    });\n    return model;\n  },\n  update: async () => {\n    let model = test_test.serverModel();\n\n    let url = `/adminsc/test/update/${model.id}`;\n    let res = await post(url, model);\n    res = await JSON.parse(res);\n\n    if (res) {\n      window.location.href = `/adminsc/test/edit/${model.id}`;\n    }\n  },\n  delete: async function () {\n    if (test_test.children()) {\n      popup.show('Сначала удалите все тесты из папки');\n      return false;\n    }\n\n    let id = test_test.id();\n\n    let res = await post('/adminsc/test/delete', {\n      id\n    });\n    res = await JSON.parse(res);\n\n    if (res.notAdmin) {\n      popup.show('Видимость теста скрыта. Чтобы удалить полностью - обратитесь к ГД');\n      setTimeout(() => {\n        window.location = '/adminsc/test/edit/400';\n      }, 4000);\n    } else {\n      window.location = '/adminsc/test/edit/400';\n    }\n  }\n};\n;// CONCATENATED MODULE: ./public/src/Test/test-edit.js\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction testEdit() {\n  let testEdit = common_$('.test-edit-wrapper')[0];\n\n  if (testEdit) {\n    sortable('.test-edit-wrapper.questions');\n    customSelect();\n    common_$(testEdit).on('change', handleKeyup);\n    common_$(testEdit).on('click', test_edit_handleClick);\n  }\n}\n\nfunction customSelect() {\n  let customSelects = common_$('[custom-select]');\n  [].forEach.call(customSelects, function (select) {\n    new WDSSelect(select);\n  });\n}\n\nfunction test_edit_handleClick(_ref) {\n  let {\n    target\n  } = _ref;\n\n  if (target.classList.contains('test-path__update')) {\n    test_test.update();\n  } else if (target.classList.contains('test__update')) {\n    test_test.update();\n  } else if (target.classList.contains('test__save')) {\n    test_test.update();\n  } else if (target.classList.contains('test__delete')) {\n    test_test[\"delete\"]();\n  } else if (target.classList.contains('test-path__create')) {\n    test_test.path_create();\n  } else if (target.classList.contains('test__create')) {\n    test_test.create();\n  } else if (!!target.closest('.question__save')) {\n    _question.save(target);\n  } else if (!!target.closest('.question__show-answers')) {\n    _question.showAnswers(target);\n  } else if (!!target.closest('.question__delete')) {\n    _question[\"delete\"](target);\n  } else if (target.classList.contains('question__create-button')) {\n    _question.create();\n  } else if (!!target.closest('.delete')) {\n    answer_answer.del(target);\n  } else if (target.classList.contains('answer__create-button')) {\n    answer_answer.create(target);\n  }\n}\n\nfunction handleKeyup(_ref2) {\n  let {\n    target\n  } = _ref2;\n\n  if (!!target.closest('.question-edit__parent-select')) {\n    _question.changeParent(target);\n  }\n}\n;// CONCATENATED MODULE: ./public/src/components/test-pagination/test-pagination.js\n\n\nlet pagination = common_$('.pagination')[0];\n\nif (pagination) {\n  common_$(pagination).on('click', test_pagination_handleClick);\n}\n\nfunction test_pagination_handleClick(_ref) {\n  let {\n    target\n  } = _ref;\n  // debugger\n  if (!target.dataset.pagination) return; /// get clicked button Return if clicked is active\n\n  if (target.classList.contains('active')) return;\n  let active_btn = common_$('.pagination .active')[0]; //// change active button\n\n  active_btn.classList.remove('active');\n  target.classList.add('active');\n  let id_to_hide = active_btn.dataset['pagination'];\n  common_$(`.question[data-id=\"${id_to_hide}\"]`).removeClass('show');\n  let id_to_show = target.dataset['pagination'];\n  common_$(`.question[data-id=\"${id_to_show}\"]`).addClass('show');\n}\n\nfunction navInit() {\n  let nav_buttons = common_$('[data-pagination]');\n  if (!nav_buttons[0]) return false;\n  Array.from(nav_buttons).map(nav => {\n    nav.classList.remove('active');\n  });\n  nav_buttons[0].classList.add('active');\n}\n\n\n;// CONCATENATED MODULE: ./public/src/Test/do.js\n\n\n\n\nfunction testDo() {\n  //Скрыть все вопросы\n  common_$('.question').removeClass(\"show\"); //Показть первый вопрос\n\n  common_$('.question:first-child').addClass(\"show\"); // Нажать первуюкнопку navigation\n\n  navInit();\n  common_$('.test-do [type=\"checkbox\"]').on('click', function (e) {\n    let a = e.target.labels[0];\n    a.classList.toggle('pushed');\n  });\n  common_$('#prev').on('click', test_test.prevQ);\n  common_$('#next').on('click', test_test.nextQ); /////////////////////////////////////////////////////////////////////////////\n  ///////////  RESULTS  TEST  Закончить тест/////////////////////////////\n  /////////////////////////////////////////////////////////////////////////////\n  // если это результат теста, деактивирукм кнопку Закончить тест\n\n  let button = common_$('.test-do__finish-btn')[0];\n\n  if (button) {\n    if (window.location.pathname.match('^/test/result/.?')) {\n      button.classList.add('inactive');\n    }\n  }\n\n  common_$('.test-do__finish-btn').on('click', async function (e) {\n    let button = e.target;\n    if (button.classList.contains('inactive')) return false;\n    if (button.id !== 'btnn') return false;\n    button.classList.add('inactive');\n\n    if (button.text == \"ПРОЙТИ ТЕСТ ЗАНОВО\") {\n      location.reload();\n      return;\n    }\n\n    let corrAnswers = await post('/test/getCorrectAnswers', {});\n    let errorCnt = colorView(corrAnswers);\n    let data = objToServer(errorCnt);\n    let res = await post('/adminsc/testresult/cachePageSendEmail', { ...data\n    });\n\n    if (res === 'ok') {\n      common_$(\"#btnn\")[0].href = location.href;\n      common_$(\"#btnn\")[0].text = \"ПРОЙТИ ТЕСТ ЗАНОВО\";\n    }\n  });\n\n  function replaceNbsps(str) {\n    var re = new RegExp('&nbsp;?', \"g\");\n    return str.replace(re, \" \");\n  }\n\n  function replaceNs(str) {\n    var re = new RegExp('\\\\n?', \"g\");\n    return str.replace(re, \"\");\n  }\n\n  function replaceTs(str) {\n    var re = new RegExp('\\\\t?', \"g\");\n    return str.replace(re, \"\");\n  }\n\n  function cachePage(rightAnswers) {\n    let t = common_$('.test-do')[0];\n    t = t.outerHTML;\n    t = replaceNbsps(t);\n    t = replaceNs(t);\n    t = replaceTs(t);\n    return t;\n  }\n\n  function objToServer(errorCnt) {\n    return {\n      questionCnt: common_$('.question').length,\n      errorCnt: errorCnt,\n      html: cachePage(),\n      testid: common_$('[data-test-id]')[0].dataset.testId,\n      testname: common_$('.test-name')[0].innerText,\n      user: common_$('.user-menu__fio')[0].innerText\n    };\n  }\n\n  function colorView(correctAnswers) {\n    let q = common_$('.question');\n    [].map.call(q, function (question) {\n      let answers = question.querySelectorAll('.a');\n      let errors = [];\n      [].map.call(answers, function (answer) {\n        let input = common_$(answer).find('input');\n        let id = answer.dataset.id;\n        checkCorrectAnswers(errors, id, correctAnswers, input, answer);\n      });\n      let id = question.dataset['id']; // id question\n\n      let paginItem = common_$(`.pagination [data-pagination='${+id}']`)[0];\n\n      if (errors.length) {\n        common_$(paginItem).addClass('redShadow');\n      } else {\n        common_$(paginItem).addClass('greenShadow');\n      }\n    });\n    return common_$('.redShadow').length;\n  }\n\n  function checkCorrectAnswers(errors, id, correctAnswers, input, answer) {\n    let correctAnser = correctAnswers.indexOf(id) !== -1;\n\n    if (input.checked && correctAnser) {\n      // checkbox нажат. а в correct answer нету. в correct_answers есть, его всегда подсвечиваем зеленым\n      answer.classList.add('done'); //green check зеленый значек\n    } else if (input.checked && !correctAnser) {\n      // checkbox нажат,и есть в correct answer. в correct_answers нет, кнопка не нажата\n      errors.push(true);\n    } else if (!input.checked && correctAnser) {\n      // кнопка не нажата, в correct_answers есть\n      answer.classList.add('done'); //green check зеленый значек\n\n      errors.push(true);\n    } else if (!input.checked && !correctAnser) {// кнопка не нажата, в correct_answers нет\n    }\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Admin/Settings/users.js\n\nfunction init() {}\n;// CONCATENATED MODULE: ./public/src/Admin/Settings/settings.js\n// import rights from '../Rights/rights'\n // import rights from \"./rights\";\n\nfunction settings() {\n  // rights()\n  init();\n}\n;// CONCATENATED MODULE: ./public/src/components/list/list.js\n\n\nfunction list() {\n  // debugger;\n  const tables = common_$('.custom-list__wrapper');\n\n  if (tables) {\n    [].forEach.call(tables, function (table) {\n      const contenteditable = common_$('[contenteditable]');\n      const headers = table.querySelectorAll('.head');\n      const sortables = table.querySelectorAll('[data-sort]');\n      const inputs = common_$(table).findAll('.head input');\n      const ids = common_$(table)[0].querySelectorAll('.id:not(.head');\n      const modelName = table.dataset['model'];\n      const rows = [];\n      common_$(table).on('click', handleClick.bind(this));\n      common_$(table).on('keyup', handleKeyUp.bind(this)); /// DEBOUNCE\n\n      const debounce = function (fn) {\n        let time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 700;\n        let timeout;\n        return function () {\n          const functionCall = () => fn.apply(this, arguments);\n\n          clearTimeout(timeout);\n          timeout = setTimeout(functionCall, time);\n        };\n      };\n\n      let debouncedInput = debounce(handleInput);\n\n      function handleKeyUp(_ref) {\n        let {\n          target\n        } = _ref;\n\n        // contenteditable\n        if (target.hasAttribute('contenteditable')) {\n          debouncedInput(table, contenteditable, target); /// search\n        } else if (target.closest('.head')) {\n          let header = target.closest('.head');\n          let index = [].findIndex.call(headers, (el, i, inputs) => {\n            return el === header;\n          });\n          search(index, target);\n        }\n      }\n\n      function handleClick(_ref2) {\n        let {\n          target\n        } = _ref2;\n\n        /// create\n        if (target.className === 'add-model') {\n          modelCreate(modelName); /// delete\n        } else if (target.className === '.del:not(.head)' || target.closest('.del:not(.head)')) {\n          modelDel(target.closest('.del:not(.head)')); /// edit\n        } else if (target.className === '.edit:not(.head)' || target.closest('.edit:not(.head)')) {\n          let id = target.closest('.edit:not(.head)').dataset['id'];\n          window.location = `/adminsc/${modelName}/edit/${id}`; /// sort\n        } else if (target.classList.contains('head')) {\n          let header = target.closest('.head');\n          let index = [].findIndex.call(headers, (el, i, inputs) => {\n            return el === header;\n          });\n          sortColumn(index);\n        }\n      } // DELETE\n\n\n      async function modelDel(el) {\n        // debugger\n        if (!confirm('Удалить пользователя?')) return;\n        let id = el.dataset['id'];\n        let res = await post(`/adminsc/${modelName}/delete`, {\n          id\n        });\n        res = JSON.parse(res);\n\n        if (res.msg === 'ok') {\n          delView(id);\n          popup.show(`id : ${id} удалено`);\n        }\n      }\n\n      function delView(id) {\n        let arr = common_$(`[data-id='${id}']`);\n        [].forEach.call(arr, function (el) {\n          el.remove();\n        });\n      } // CREATE\n\n\n      async function modelCreate(modelName, e) {\n        let res = await post(`/adminsc/${modelName}/create`, {});\n        res = JSON.parse(res);\n\n        if (res.id) {\n          window.location.href = `/adminsc/${modelName}/show`; // newRow(res.id - 1)\n        }\n      }\n\n      function newRow(id) {\n        let Row = [...rows[0]];\n        [].forEach.call(Row, function (el) {\n          let newEl = el.cloneNode(true);\n          let tableContent = common_$(table).find('.custom-list');\n          tableContent.appendChild(newEl);\n\n          if (['id'].includes(newEl.className)) {\n            newEl.innerText = id;\n          } else if (!['del', 'edit', 'save'].includes(newEl.className)) {\n            newEl.innerText = '';\n          }\n\n          newEl.dataset['id'] = id;\n        });\n      } /// SEARCH\n\n\n      function showAllRows() {\n        [].forEach.call(rows, row => {\n          [].forEach.call(row, el => {\n            el.style.display = 'flex';\n          });\n        });\n      }\n\n      function search(index, input) {\n        showAllRows();\n        const value = input.value;\n        [].forEach.call(inputs, inp => {\n          if (inp !== input) inp.value = '';\n        });\n        [].forEach.call(rows, function (row) {\n          const str = row[index].innerText;\n          const regexp = new RegExp(`${value}`, 'gi');\n\n          if (!str.match(regexp)) {\n            [].forEach.call(row, el => {\n              el.style.display = 'none';\n            });\n          }\n        });\n      }\n\n      ; // SORT\n\n      function sortColumn(index) {\n        // Получить текущее направление\n        const direction = directions[index] || 'asc'; // Фактор по направлению\n\n        const multiplier = direction === 'asc' ? 1 : -1;\n        const newRows = Array.from(rows);\n        newRows.sort(function (rowA, rowB) {\n          const cellA = rowA[index].innerHTML;\n          const cellB = rowB[index].innerHTML;\n          const a = transform(index, cellA);\n          const b = transform(index, cellB);\n\n          switch (true) {\n            case a > b:\n              return 1 * multiplier;\n\n            case a < b:\n              return -1 * multiplier;\n\n            case a === b:\n              return 0;\n          }\n        }); // Удалить старые строки\n\n        [].forEach.call(rows, function (nodeList) {\n          [].forEach.call(nodeList, el => {\n            el.remove();\n          });\n        }); // Поменять направление\n\n        directions[index] = direction === 'asc' ? 'desc' : 'asc'; // Добавить новую строку\n\n        newRows.forEach(function (newRow) {\n          newRow = Array.from(newRow);\n          newRow.reverse();\n          [].forEach.call(newRow, el => {\n            headers[headers.length - 1].after(el);\n          });\n        });\n      }\n\n      ; /// get table rows array\n\n      for (let i = 0; i < ids.length; i++) {\n        let id = ids[i].dataset.id;\n        let row = common_$(table)[0].querySelectorAll(`[data-id='${id}']`);\n        rows.push(row);\n      } // Направление сортировки\n\n\n      const directions = Array.from(sortables).map(function (sortable) {\n        return '';\n      }); // Преобразовать содержимое данной ячейки в заданном столбце\n\n      function transform(index, content) {\n        // Получить тип данных столбца\n        const type = sortables[index].getAttribute('data-type');\n\n        switch (type) {\n          case 'number':\n            return parseFloat(content);\n\n          case 'string':\n          default:\n            return content;\n        }\n      }\n\n      ; /// INPUT\n\n      function handleInput(table, contenteditable, target) {\n        if (!target.hasAttribute('contenteditable')) return false;\n        let model = makeServerModel(target, modelName);\n        save(model);\n      }\n\n      async function save(model) {\n        let url = `/adminsc/${model.modelName}/update`;\n        let res = await post(url, model.model);\n        res = JSON.parse(res);\n\n        if (res.msg === 'ok') {\n          popup.show('Сохранено!');\n        }\n      }\n\n      function makeServerModel(el, modelName) {\n        let field = el.dataset['field'];\n        return {\n          model: {\n            token: common_$(),\n            id: el.dataset.id,\n            [field]: el.innerText\n          },\n          modelName\n        };\n      }\n    });\n  } // })\n\n}\n;// CONCATENATED MODULE: ./public/src/Admin/Rights/rights.js\n\n\n // import contenteditable from '../../components/contenteditable'\n\nfunction rights() {\n  // debugger\n  // contenteditable()\n  common_$('.rights-table').on('click', handle);\n\n  function handle(_ref) {\n    let {\n      target\n    } = _ref;\n    if (target.closest('.del')) del(target.closest('.del'));\n    if (target.closest('.save')) save(target.closest('.save'));\n\n    function model(el) {\n      let dataId = el.dataset.id ?? 'new';\n      let fields = common_$(`[data-id='${dataId}']`);\n      let model = {};\n      model.toServ = {};\n      model.empty = {};\n      fields.map(f => {\n        if (f.classList.contains('id')) {\n          model.id = f;\n          model.toServ.id = f.dataset.id;\n        } else if (f.classList.contains('name')) {\n          model.name = f;\n          model.toServ.name = f.innerText.trim();\n        } else if (f.classList.contains('description')) {\n          model.description = f;\n          model.toServ.description = f.innerText.trim();\n        } else if (f.classList.contains('save.svg')) {\n          model.save = f;\n        } else if (f.classList.contains('del')) {\n          model.del = f;\n        }\n      });\n      model.empty.del = model.id.previousElementSibling.cloneNode(true);\n      model.empty.save = model.id.previousElementSibling.previousElementSibling.cloneNode(true);\n      model.empty.description = model.id.previousElementSibling.previousElementSibling.previousElementSibling.cloneNode(true);\n      model.empty.name = model.id.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.cloneNode(true);\n      model.empty.id = model.id.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.cloneNode(true);\n      return model;\n    }\n\n    function del(el) {\n      let mod = model(el);\n      if (mod.toServ.id === 'new') return;\n\n      if (confirm(\"Удалить право?\")) {\n        delDom(mod);\n        delServer(mod);\n      }\n    }\n\n    async function delServer(model) {\n      let res = await post('/right/delete', {\n        id: model.toServ.id\n      });\n      res = await JSON.parse(res);\n\n      if (res.msg === 'ok') {\n        popup.show('Удалено');\n      }\n    }\n\n    function delDom(model) {\n      model.id.remove();\n      model.name.remove();\n      model.description.remove();\n      model.save.remove();\n      model.del.remove();\n    }\n\n    function save(el) {\n      let mod = model(el);\n\n      if (mod.toServ.id !== 'new') {\n        update(mod.toServ);\n      } else {\n        if (!mod.toServ.name || !mod.toServ.description) return false;\n        create(mod);\n      }\n    }\n\n    async function update(toServ) {\n      let res = await post('/right/update', toServ);\n\n      if (await JSON.parse(res).updated) {\n        popup.show('Обновлено');\n      }\n    }\n\n    function clearModel(model) {\n      model.name.innerText = \"\";\n      model.description.innerText = \"\";\n    }\n\n    function createOnDom(model) {\n      let lastElement = common_$(\".id[data-id='new']\")[0];\n      lastElement.before(model.empty.id);\n      lastElement.before(model.empty.name);\n      lastElement.before(model.empty.description);\n      lastElement.before(model.empty.save);\n      lastElement.before(model.empty.del);\n    }\n\n    function assignNewValuesOnClone(model, id) {\n      model.empty.id.dataset.id = id;\n      model.empty.id.innerText = id;\n      model.empty.name.dataset.id = id;\n      model.empty.name.innerText = model.name.innerText.trim();\n      model.empty.description.dataset.id = id;\n      model.empty.description.innerText = model.description.innerText.trim();\n      model.empty.save.dataset.id = id;\n      model.empty.del.dataset.id = id;\n    }\n\n    async function create(model) {\n      let res = await post('/right/create', model.toServ);\n      res = await JSON.parse(res);\n\n      if (res.id) {\n        assignNewValuesOnClone(model, res.id - 1);\n        createOnDom(model);\n        clearModel(model);\n        popup.show('Сохранено');\n      }\n    }\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Admin/Planning/planning.js\n\n\nfunction planning() {\n  debugger;\n}\n;// CONCATENATED MODULE: ./public/src/Auth/getSex.js\n\nfunction getSex() {\n  function sex() {\n    const s = common_$('[name=\"sex\"]');\n\n    for (let f of s) {\n      if (f.checked) {\n        return f.value;\n      }\n    }\n\n    return 'm';\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Admin/user/user.js\n\n\n\nfunction user() {\n  let item = common_$('[data-model=\"user\"]')[0];\n\n  if (item) {\n    common_$(item).on('click', handleClick);\n  }\n\n  async function handleClick(_ref) {\n    let {\n      target\n    } = _ref;\n\n    if (!!target.closest('#save')) {\n      let wrapper = common_$('.user-item')[0];\n      let data = getModel(wrapper);\n      let res = await post('/adminsc/user/update', data);\n\n      if (res === 'ok') {\n        popup.show('Сохранено');\n      }\n    } else if (target.classList.contains('right')) {\n      let rights = common_$('input.right:checked');\n      let str = '';\n      [].map.call(rights, function (right) {\n        let s = right.previousElementSibling.innerText;\n        str += s + ',';\n      });\n      let tab = target.closest('[tab]');\n      tab.dataset.value = str;\n    }\n  }\n\n  function rights() {\n    let right = common_$('.right:checked');\n    let rights = '';\n    [].map.call(right, r => {\n      let str = r.previousElementSibling.innerText + ',';\n      rights += str;\n    }, rights);\n    return rights;\n  }\n\n  function confirm() {\n    const confirm = common_$('#conf option');\n\n    for (let f of confirm) {\n      if (f.selected) {\n        return f.value;\n      }\n    }\n\n    return '0';\n  }\n\n  function getModel(target) {\n    return {\n      id: common_$(target).find(\"#id\").innerText,\n      name: common_$(target).find('#name').innerText,\n      surName: common_$(target).find('#s-name').innerText,\n      middleName: common_$(target).find('#m-name').innerText,\n      birthDate: common_$(target).find('#bday').innerText,\n      phone: common_$(target).find('#phone').innerText,\n      email: common_$(target).find('#email').innerText,\n      hired: common_$(target).find('#hired').innerText,\n      fired: common_$(target).find('#fired').innerText,\n      confirm: confirm(),\n      sex: getSex(),\n      rights: rights()\n    };\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Test/open_test.js\n\n\n\nlet openTest = common_$('.opentest_wrap')[0];\n\nif (openTest) {\n  common_$(openTest).on('click', open_test_handleClick);\n  common_$(openTest).on('keyup', open_test_handleKeyup);\n}\n\nfunction open_test_handleKeyup(_ref) {\n  let {\n    target\n  } = _ref;\n\n  if (target.classList.contains('textarea')) {\n    let activePagination = common_$('[data-pagination].active')[0];\n\n    if (!target.innerText) {\n      activePagination.classList.remove('filled');\n    } else {\n      activePagination.classList.add('filled');\n    }\n  }\n}\n\nasync function open_test_handleClick(_ref2) {\n  let {\n    target\n  } = _ref2;\n  let testid = target.dataset.id;\n  let activeQuestion = common_$('.question.show')[0];\n  let paginations = common_$('[data-pagination]');\n  let activePagination = common_$('[data-pagination].active')[0];\n  let i = paginations.indexOf(activePagination);\n\n  if (target.id === 'prev') {\n    prevQuest();\n  } else if (target.id === 'next') {\n    nextQuest();\n  } else if (target.dataset.pagination) {\n    paginate();\n  } else if (target.classList.contains('led')) {\n    blink(target);\n  } else if (target.id === 'finish') {\n    finish();\n  }\n\n  async function finish() {\n    let questions = await getAnswers(testid);\n    let correctAnswers = correctCount(questions);\n    let obj = cachePage(correctAnswers);\n    let res = await post('/adminsc/opentestresult/finish', obj);\n\n    if (IsJson(res)) {\n      res = JSON.parse(res);\n\n      if (res.msg === 'ok') {\n        // popup.show(res.msg)\n        let canv = document.createElement(\"canvas\");\n        canv.id = 'c';\n      }\n    }\n  }\n\n  function replaceNbsps(str) {\n    var re = new RegExp('&nbsp;?', \"g\");\n    return str.replace(re, \" \");\n  }\n\n  function replaceNs(str) {\n    var re = new RegExp('\\\\n?', \"g\");\n    return str.replace(re, \"\");\n  }\n\n  function replaceTs(str) {\n    var re = new RegExp('\\\\t?', \"g\");\n    return str.replace(re, \"\");\n  }\n\n  function cachePage(rightAnswers) {\n    let t = common_$('.test')[0].outerHTML;\n    t = replaceNbsps(t);\n    t = replaceNs(t);\n    t = replaceTs(t);\n    return {\n      testId: +testid,\n      questionCnt: paginations.length,\n      html: t,\n      // html: `<!DOCTYPE ${document.doctype.name}>` + document.documentElement.outerHTML,\n      testname: common_$('.test-name')[0].innerText,\n      username: common_$('.user-menu__fio')[0].innerText,\n      rightAnswers\n    };\n  }\n\n  function paginate() {\n    if (target === activePagination) return false;\n    let aimPagination = target;\n    toggleQuestion(aimPagination, activeQuestion);\n    toggleNav(aimPagination, activePagination);\n  }\n\n  function prevQuest() {\n    if (i < 1) return false;\n    let aimPagination = paginations[i - 1];\n    toggleQuestion(aimPagination, activeQuestion);\n    toggleNav(aimPagination, activePagination);\n  }\n\n  function nextQuest() {\n    if (i > paginations.length - 2) return false;\n    let aimPagination = paginations[i + 1];\n    toggleQuestion(aimPagination, activeQuestion);\n    toggleNav(aimPagination, activePagination);\n  }\n}\n\nfunction correctCount(questions) {\n  let correct = 0;\n  questions.forEach(q => {\n    let q_id = q.id;\n    let q_el = common_$(`.question[data-id='${q_id}']`)[0];\n    let textarea = common_$(q_el).find('.textarea');\n    if (!q.Openanswer) return;\n    let word = '';\n    q.Openanswer.forEach(a => {\n      word += `(${a.answer})?`;\n    });\n    correct += highlight(`${word}`, textarea, true);\n  });\n  return correct;\n}\n\nfunction hiliter(word, element, addEventLis) {\n  let text = element.innerHTML;\n  let rgxp = new RegExp(word, 'g');\n  let arr = text.match(rgxp);\n  let correct = 0;\n  arr.forEach(w => {\n    if (!w) return;\n    correct = 1;\n    let r = new RegExp(w, 'g');\n    let repl = `<span style='color:red;'>` + w + '</span>';\n    element.innerHTML = element.innerHTML.replace(r, repl);\n  });\n  return correct;\n}\n\nasync function getAnswers(id) {\n  let res = await post('/adminsc/opentestresult/getanswers', {\n    id\n  });\n  res = JSON.parse(res);\n  return res;\n}\n\nfunction toggleNav(aimPagination, activePagination) {\n  activePagination.classList.toggle('active');\n  aimPagination.classList.toggle('active');\n}\n\nfunction toggleQuestion(aimPaginationId, activeQuestion) {\n  let aimQuestionId = aimPaginationId.dataset.pagination;\n  let aimQuestion = common_$(`.question[data-id='${aimQuestionId}']`)[0];\n  aimQuestion.classList.toggle('show');\n  activeQuestion.classList.toggle('show');\n}\n\nfunction highlight(word, el, addEventLis) {\n  return hiliter(word, el, addEventLis);\n}\n;// CONCATENATED MODULE: ./public/src/components/radio/radio.js\n\n\nfunction radio_radio() {\n  let radios = common_$('[custom-radio]');\n  [].map.call(radios, function (radio) {\n    common_$(radio).on('click', handleClick);\n\n    function handleClick(_ref) {\n      let {\n        target\n      } = _ref;\n      let targ = target.closest(\"label\");\n      radio.dataset.value = targ.dataset.value;\n    }\n  });\n}\n;// CONCATENATED MODULE: ./public/src/components/multiselect/multiselect.js\n\n\nfunction multiselect() {\n  function getSelected() {\n    if (multi) {\n      let selected = [].map.call(multi, function (select) {\n        let chips = select.querySelectorAll('.chip-wrap');\n        let objs = [].map.call(chips, function (chip) {\n          return chip.dataset.id;\n        });\n        let obj = {};\n        obj.field = select.dataset.field;\n        obj.ids = objs;\n        return obj;\n      });\n    } // debugger\n\n  }\n\n  let multi = common_$('[multi-select] ');\n\n  if (multi) {\n    [].forEach.call(multi, function (select) {\n      select.addEventListener('click', handleClick, false);\n      select.addEventListener('blur', handleBlur, false);\n\n      function handleBlur(_ref) {\n        let {\n          target\n        } = _ref;\n        let show = common_$(this).find('.show');\n\n        if (show) {\n          show.classList.remove('show');\n        }\n      }\n\n      function handleClick(_ref2) {\n        let {\n          target\n        } = _ref2;\n        let multi = target.closest('[multi-select]'); // открыть выбор элементов\n\n        if (target.closest('.arrow') || ['chip-wrap'].includes(target.className)) {\n          // let multiselect = target.closest('[multi-select] ')\n          let ul = multi.querySelector('ul');\n          ul.classList.toggle('show'); // нажатие по крестику чипа\n        } else if (['del'].includes(target.className)) {\n          let id = target.closest('.chip').dataset.id;\n          toggleBackground(id);\n          let chip = target.closest('.chip');\n          chip.remove(); // выбор элемента, проверка существования чипа и его добавление\n        } else if (target.tagName.toLowerCase() === 'label') {\n          let id = target.dataset.id; // let m = target.closest('[multi-select] ')\n\n          let chips = multi.querySelectorAll('.chip');\n          let exist = [].some.call(chips, chip => {\n            return chip.dataset.id === id;\n          });\n          let wrap = common_$(multi).find('.chip-wrap');\n\n          if (!exist) {\n            target.classList.toggle('selected');\n            let chip = createChip(id);\n            wrap.append(chip);\n          } else {\n            target.classList.toggle('selected');\n            wrap.querySelector(`[data-id='${id}']`).remove();\n          }\n        }\n\n        function toggleBackground(id) {\n          // let multi = target.closest('[multi-select] ')\n          common_$(multi).find(`label[data-id='${id}']`).classList.remove('selected');\n        }\n\n        function createChip(id) {\n          let chip = document.createElement('div');\n          chip.classList.add('chip');\n          chip.innerText = target.innerText;\n          chip.dataset['id'] = id;\n          let del = document.createElement('div');\n          del.classList.add('del');\n          del.innerText = 'X';\n          chip.append(del);\n          return chip;\n        }\n      }\n    });\n  }\n}\n;// CONCATENATED MODULE: ./public/src/components/catalog-item/catalog-item.js\n\n\nfunction catalogItem() {\n  let customCatalogItem = common_$('.item_wrap')[0];\n\n  if (customCatalogItem) {\n    common_$(customCatalogItem).on('click', handleClick.bind(this));\n  }\n\n  async function handleClick(_ref) {\n    let {\n      target\n    } = _ref;\n    let item = customCatalogItem;\n    let modelName = item.dataset.model;\n\n    if (target.closest('.save')) {\n      save(modelName);\n    } else if (target.closest('.del') && target.closest('.del').dataset.model) {\n      del(item, target.closest('.del').dataset.model);\n    } else if (target.classList.contains('tab')) {\n      handleTab(target, modelName);\n    }\n  }\n\n  async function handleTab(target) {\n    let visibleSection = common_$(`section.show`)[0];\n    visibleSection.classList.toggle('show');\n    let section = common_$(`section[data-id='${target.dataset.id}']`)[0];\n    section.classList.toggle('show');\n    let activeTab = common_$(`.tab.active`)[0];\n    activeTab.classList.toggle('active');\n    target.classList.toggle('active');\n  }\n\n  async function del(item, modelName) {\n    let id = item.dataset.id;\n    let res = await post(`/adminsc/${modelName}/delete`, {\n      id\n    });\n    res = JSON.parse(res);\n\n    if (res.msg === 'ok') {\n      window.location.href = `/adminsc/${modelName}`;\n    }\n  }\n\n  async function save(modelName) {\n    if (checkRequired()) return false;\n    let model = getModel();\n    let res = await post(`/adminsc/${modelName}/updateorcreate`, { ...model\n    });\n  }\n\n  function checkRequired() {\n    let required = common_$('[required]');\n    let errCount = 0;\n    [].forEach.call(required, function (el) {\n      if (!el.innerText) {\n        el.style.borderColor = 'red';\n        if (common_$(el).find('.error')) return;\n        let error = document.createElement('div');\n        error.innerText = 'Заполните поле';\n        error.classList.add('error');\n        el.closest('.value').appendChild(error);\n        errCount++;\n      }\n    });\n    return errCount;\n  }\n\n  function getModel() {\n    let fields = common_$('[data-field]');\n    let obj = {}; // debugger;\n\n    [].map.call(fields, field => {\n      if (field.hasAttribute('multi-select')) {\n        let chips = field.querySelectorAll('.chip');\n        let ids = [].map.call(chips, chip => {\n          return chip.dataset.id;\n        });\n        obj[field.dataset.field] = ids.toString();\n      } else if (field.hasAttribute('custom-select')) {\n        obj[field.dataset.field] = field.dataset.value;\n      } else if (field.dataset.type === 'inputs') {\n        obj[field.dataset.field] = getInputs(field);\n      } else if (field.hasAttribute('custom-radio')) {\n        obj[field.dataset.field] = field.dataset.value;\n      } else if (field.hasAttribute('tab')) {\n        obj[field.dataset.field] = field.dataset.value;\n      } else if (field.type === 'date') {\n        obj[field.dataset.field] = field.value;\n      } else {\n        obj[field.dataset.field] = field.innerText;\n      }\n    }, obj);\n    let isTest = common_$('[data-isTest]')[0];\n\n    if (isTest) {\n      obj.isTest = +isTest.dataset.istest;\n    }\n\n    return obj;\n  }\n\n  function getInputs(field) {\n    let inputs = field.querySelectorAll('input');\n    let names = [];\n    inputs.forEach(inp => {\n      if (!inp.checked) return;\n      let name = inp.parentNode.querySelector('.name').innerText;\n      if (!name) return;\n      names.push(name);\n    });\n    return names.join(',');\n  }\n}\n;// CONCATENATED MODULE: ./public/src/components/tooltip/tooltip.js\n\nfunction tooltips() {\n  document.addEventListener('mouseenter', showTip, true);\n  document.addEventListener('mouseleave', hideTip, true);\n\n  function showTip(_ref) {\n    let {\n      target\n    } = _ref;\n    // debugger\n    // если у нас есть подсказка...\n    if (!target.dataset || !target.dataset.tooltip) return;\n    let tooltipHtml = target.dataset.tooltip; // ...создадим элемент для подсказки\n\n    let tooltipElem = document.createElement('div');\n    tooltipElem.className = 'tooltip';\n    tooltipElem.innerHTML = tooltipHtml;\n    document.body.append(tooltipElem); // спозиционируем его сверху от аннотируемого элемента (top-center)\n\n    let coords = target.getBoundingClientRect();\n    let left = coords.left + (target.offsetWidth - tooltipElem.offsetWidth) / 2;\n    if (left < 0) left = 0; // не заезжать за левый край окна\n\n    let top = coords.top - tooltipElem.offsetHeight - 5;\n\n    if (top < 0) {\n      // если подсказка не помещается сверху, то отображать её снизу\n      top = coords.top + target.offsetHeight + 5;\n    }\n\n    tooltipElem.style.left = left + 'px';\n    tooltipElem.style.top = top + 'px';\n  }\n\n  ;\n\n  function hideTip() {\n    let tooltips = document.querySelectorAll('.tooltip');\n\n    if (tooltips) {\n      [].forEach.call(tooltips, tip => {\n        tip.remove();\n      });\n    }\n  }\n\n  ;\n}\n;// CONCATENATED MODULE: ./public/src/Admin/admin.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommon_$(document).ready(function () {\n  navigate(window.location.pathname);\n  radio_radio();\n  list();\n  multiselect();\n  catalogItem();\n  tooltips();\n  accordionShow();\n  testEdit(); // opentestEdit()\n\n  function navigate(str) {\n    // debugger\n    switch (true) {\n      case /\\/adminsc\\/settings/.test(str):\n      case /\\/adminsc\\/right\\/list/.test(str):\n      case /\\/adminsc\\/post\\/list/.test(str):\n      case /\\/adminsc\\/todo\\/list/.test(str):\n        rights();\n        common_$(\"[href='/adminsc/settings']\").addClass('current');\n        break;\n\n      case /\\/adminsc\\/testresult\\/results/.test(str):\n        common_$(\"[href='/adminsc/test/results']\").addClass('current');\n        break;\n\n      case /\\/auth\\/profile/.test(str):\n        user();\n        break;\n\n      case /\\/adminsc\\/crm/.test(str):\n        common_$(\"[href='/adminsc/crm']\").addClass('current');\n        break;\n\n      case /\\/adminsc\\/catalog/.test(str):\n        common_$(\"[href='/adminsc/catalog']\").addClass('current');\n        break;\n\n      case /\\/adminsc\\/planning/.test(str):\n        planning();\n        common_$(\"[href='/adminsc/planning']\").addClass('current');\n        break;\n\n      case /\\/adminsc\\/test\\/pathshow/.test(str):\n      case /\\/adminsc\\/test\\/edit/.test(str):\n        common_$(\"[href='/adminsc/test/edit']\").addClass('current');\n        break;\n\n      case /\\/test/.test(str) || /\\/test\\/result/.test(str):\n        testDo();\n        common_$(\"[href='/test/do']\").addClass('current');\n        break;\n\n      case /\\/adminsc\\/Sitemap/.test(str):\n        settings();\n        common_$(\"[href='/adminsc/settings']\").addClass('current');\n        break;\n\n      default:\n        common_$(\"[href='/adminsc']\").addClass('current');\n        break;\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFD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Q0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCx3Q0FBd0MscURBQXFEOzs7QUFHN0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxjQUFjO0FBQzFCOzs7QUFHQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFOztBQUVBLGdCQUFnQjs7QUFFaEIsc0NBQXNDLFlBQVk7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7OztBQUcxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0Isa0ZBQWtGOztBQUVsRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDOzs7QUFHaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7OztBQUdWLDZDQUE2Qzs7O0FBRzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHOzs7QUFHWjtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sR0FBRzs7QUFFVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ04sR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlNQUFpTTs7QUFFak07QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCwrREFBK0Q7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0EsaUVBQWlFOzs7QUFHakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTs7O0FBR1o7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNENBQTRDOztBQUU1QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdDQUF3Qzs7O0FBR3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOERBQThEOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHOzs7QUFHaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRzs7O0FBR2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRzs7O0FBR2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIsWUFBWSwwQkFBMEI7QUFDdEM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWE7QUFDYjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QixZQUFZLDRCQUE0QjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7OztBQUdBO0FBQ0EseUVBQXlFLGFBQWE7QUFDdEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7O0FBRUEsdUVBQXVFO0FBQ3ZFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGFBQWE7QUFDeEI7OztBQUdBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVEOztBQUV2RDs7QUFFQTtBQUNBLDJFQUEyRTs7QUFFM0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKLGtDQUFrQztBQUNsQyxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTdCLENBQUw7UUFDRTBDLFFBQUMsQ0FBQyw2QkFBRCxDQUFELENBQWlDaUQsUUFBakMsQ0FBMEMsU0FBMUM7UUFDQTs7TUFFRixLQUFLLFNBQVM3RCxJQUFULENBQWM5QixHQUFkLEtBQXNCLGlCQUFpQjhCLElBQWpCLENBQXNCOUIsR0FBdEIsQ0FBM0I7UUFDRXFWLE1BQU07UUFDTjNTLFFBQUMsQ0FBQyxtQkFBRCxDQUFELENBQXVCaUQsUUFBdkIsQ0FBZ0MsU0FBaEM7UUFDQTs7TUFFRixLQUFLLHFCQUFxQjdELElBQXJCLENBQTBCOUIsR0FBMUIsQ0FBTDtRQUNFK1csUUFBUTtRQUNSclUsUUFBQyxDQUFDLDRCQUFELENBQUQsQ0FBZ0NpRCxRQUFoQyxDQUF5QyxTQUF6QztRQUNBOztNQUVGO1FBQ0VqRCxRQUFDLENBQUMsbUJBQUQsQ0FBRCxDQUF1QmlELFFBQXZCLENBQWdDLFNBQWhDO1FBQ0E7SUEvQ0o7RUFpREQ7QUFFRixDQXBFRCIsInNvdXJjZXMiOlsid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvY29tbW9uLmpzPzU5MjEiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9jb21wb25lbnRzL2FjY29yZGlvbi9hY2NvcmRpb24uanM/MjViNSIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL2NvbXBvbmVudHMvYWRtaW5fc2lkZWJhci5qcz9kZWZmIiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvQWRtaW4vbW9kZWwvY2FjaGUuanM/MWUxNyIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL1Rlc3QvbW9kZWwvX3Rlc3RSZXN1bHQuanM/MTY2OCIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL1Rlc3QvdGVzdF9yZXN1bHRzL3Rlc3RfcmVzdWx0cy5qcz81MzRhIiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvVGVzdC9tb2RlbC9vcGVudGVzdC9vcGVucXVlc3Rpb24uanM/MjQ5MyIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9ub2RlX21vZHVsZXMvc29ydGFibGVqcy9tb2R1bGFyL3NvcnRhYmxlLmVzbS5qcz9hYTQ3Iiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvY29tcG9uZW50cy9zb3J0YWJsZS5qcz9kY2Y1Iiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvVGVzdC9tb2RlbC9vcGVudGVzdC9vcGVudGVzdC5qcz9iNTc3Iiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvVGVzdC9tb2RlbC9vcGVudGVzdC9vcGVuYW5zd2VyLmpzPzA2ZGUiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9UZXN0L29wZW50ZXN0LWVkaXQuanM/NjI4ZiIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL1Rlc3QvbW9kZWwvYW5zd2VyLmpzPzk5YWQiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9UZXN0L21vZGVsL3F1ZXN0aW9uLmpzPzIzZDkiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9jb21wb25lbnRzL3NlbGVjdC9XRFNTZWxlY3QuanM/YzQwZCIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL2NvbXBvbmVudHMvYWNjb3JkaW9uLXNob3cuanM/NWZjOSIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL1Rlc3QvbW9kZWwvdGVzdC5qcz85YTZhIiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvVGVzdC90ZXN0LWVkaXQuanM/YWQ1YSIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL2NvbXBvbmVudHMvdGVzdC1wYWdpbmF0aW9uL3Rlc3QtcGFnaW5hdGlvbi5qcz80YWUyIiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvVGVzdC9kby5qcz80YzM1Iiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvQWRtaW4vU2V0dGluZ3MvdXNlcnMuanM/NjlmZiIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL0FkbWluL1NldHRpbmdzL3NldHRpbmdzLmpzPzc5ZTUiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9jb21wb25lbnRzL2xpc3QvbGlzdC5qcz9mMDIzIiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvQWRtaW4vUmlnaHRzL3JpZ2h0cy5qcz82ZWUzIiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvQWRtaW4vUGxhbm5pbmcvcGxhbm5pbmcuanM/YmU2ZiIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL0F1dGgvZ2V0U2V4LmpzPzU1ZjQiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9BZG1pbi91c2VyL3VzZXIuanM/MGQxYSIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL1Rlc3Qvb3Blbl90ZXN0LmpzPzJkNzYiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9jb21wb25lbnRzL3JhZGlvL3JhZGlvLmpzP2VlNGIiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9jb21wb25lbnRzL211bHRpc2VsZWN0L211bHRpc2VsZWN0LmpzPzVhNTAiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9jb21wb25lbnRzL2NhdGFsb2ctaXRlbS9jYXRhbG9nLWl0ZW0uanM/OTYzMSIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL2NvbXBvbmVudHMvdG9vbHRpcC90b29sdGlwLmpzP2EwMTgiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9BZG1pbi9hZG1pbi5qcz8yNWM0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi9jb21tb24uc2NzcydcclxuXHJcbmNvbnN0IGRlYm91bmNlID0gKGZuLCB0aW1lID0gNzAwKSA9PiB7XHJcbiAgbGV0IHRpbWVvdXQ7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbCA9ICgpID0+IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbkNhbGwsIHRpbWUpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gSXNKc29uKHN0cikge1xyXG4gIHRyeSB7XHJcbiAgICBKU09OLnBhcnNlKHN0cik7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZHJvcERvd24oZWxlbWVudElkKSB7XHJcbiAgdmFyIGRyb3Bkb3duID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudElkKTtcclxuICB0cnkge1xyXG4gICAgc2hvd0Ryb3Bkb3duKGRyb3Bkb3duKTtcclxuICB9IGNhdGNoIChlKSB7XHJcblxyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBzaG93RHJvcGRvd24oZWxlbWVudCkge1xyXG4gIHZhciBldmVudDtcclxuICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xyXG4gIGV2ZW50LmluaXRNb3VzZUV2ZW50KCdtb3VzZWRvd24nLCB0cnVlLCB0cnVlLCB3aW5kb3cpO1xyXG4gIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbn07XHJcblxyXG5cclxubGV0IHZhbGlkYXRlID0ge1xyXG4gIHNvcnQ6ICgpID0+IHtcclxuICAgIGxldCBlcnJvciA9IHRoaXMubmV4dEVsZW1lbnRTaWJsaW5nXHJcbiAgICBsZXQgYXIgPSB0aGlzLnZhbHVlLm1hdGNoKC9cXEQrLylcclxuICAgIGlmIChhcikge1xyXG4gICAgICBlcnJvci5pbm5lclRleHQgPSAn0KLQvtC70YzQutC+INGG0LjRhNGA0YsnXHJcbiAgICAgIGVycm9yLnN0eWxlLm9wYWNpdHkgPSAnMSdcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChlcnJvci5zdHlsZS5vcGFjaXR5ID09PSBcIjFcIikge1xyXG4gICAgICAgIGVycm9yLnN0eWxlLm9wYWNpdHkgPSAnMCdcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgZW1haWw6IChlbWFpbCkgPT4ge1xyXG4gICAgaWYgKCFlbWFpbCkgcmV0dXJuIGZhbHNlXHJcbiAgICBsZXQgdGV4dCA9IFwi0J3QtdC/0YDQsNCy0LjQu9GM0L3Ri9C5INGE0L7RgNC80LDRgiDQv9C+0YfRgtGLXCJcclxuICAgIGxldCByZSA9IC9eKChbXjw+KClbXFxdXFxcXC4sOzpcXHNAXCJdKyhcXC5bXjw+KClbXFxdXFxcXC4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAKChcXFtbMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XFxdKXwoKFthLXpBLVpcXC0wLTldK1xcLikrW2EtekEtWl17Mix9KSkkLztcclxuICAgIGxldCByZXMgPSByZS50ZXN0KFN0cmluZyhlbWFpbCkudG9Mb3dlckNhc2UoKSlcclxuICAgIGlmICghcmVzKSByZXR1cm4gdGV4dFxyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfSxcclxuICBwYXNzd29yZDogKHBhc3N3b3JkKSA9PiB7XHJcbiAgICBpZiAoIXBhc3N3b3JkKSByZXR1cm4gZmFsc2VcclxuICAgIGxldCB0ZXh0ID0gXCLQn9Cw0YDQvtC70Ywg0LzQvtC20LXRgiDRgdC+0YHRgtC+0Y/RgtGMINC40LcgXFxuIFwiICtcclxuICAgICAgXCItINCR0L7Qu9GM0YjQuNC1INC70LDRgtC40L3RgdC60LjQtSDQsdC60YPQstGLIFxcblwiICtcclxuICAgICAgXCItINCc0LDQu9C10L3RjNC60LjQtSDQu9Cw0YLQuNC90YHQutC40LUg0LHRg9C60LLRiyBcXG5cIiArXHJcbiAgICAgIFwiLSDQptC40YTRgNGLIFxcblwiICtcclxuICAgICAgXCItINCU0L7Qu9C20LXQvSDRgdC+0LTQtdGA0LbQsNGC0Ywg0L3QtSDQvNC10L3QtdC1IDYg0YHQuNC80LLQvtC70L7QslwiXHJcbiAgICBsZXQgcmVzID0gL15bYS16QS1aXFwtMC05XXs2LDIwfSQvLnRlc3QocGFzc3dvcmQpXHJcbiAgICBpZiAoIXJlcykgcmV0dXJuIHRleHRcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxufVxyXG5cclxuXHJcbi8vIGZ1bmN0aW9uIHVwKCkge1xyXG4vLyAgICB2YXIgdG9wID0gTWF0aC5tYXgoZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApO1xyXG4vLyAgICBpZiAodG9wID4gMCkge1xyXG4vLyAgICAgICB3aW5kb3cuc2Nyb2xsQnkoMCwgLTEwMCk7XHJcbi8vICAgICAgIHZhciB0ID0gc2V0VGltZW91dCgndXAoKScsIDIwKTtcclxuLy8gICAgfVxyXG4vLyAgICBlbHNlXHJcbi8vICAgICAgIGNsZWFyVGltZW91dCh0KTtcclxuLy8gICAgcmV0dXJuIGZhbHNlO1xyXG4vLyB9XHJcblxyXG5sZXQgcG9wdXAgPSB7XHJcblxyXG4gIHNob3c6IGZ1bmN0aW9uICh0eHQsIGNhbGxiYWNrKSB7XHJcbiAgICBsZXQgY2xvc2UgPSB0aGlzLmVsKCdkaXYnLCAncG9wdXBfX2Nsb3NlJylcclxuICAgIGNsb3NlLmlubmVyVGV4dCA9ICdYJ1xyXG4gICAgbGV0IHBvcHVwX19pdGVtID0gdGhpcy5lbCgnZGl2JywgJ3BvcHVwX19pdGVtJylcclxuXHJcbiAgICBwb3B1cF9faXRlbS5pbm5lclRleHQgPSB0eHRcclxuICAgIHBvcHVwX19pdGVtLmFwcGVuZChjbG9zZSlcclxuICAgIGxldCBwb3B1cCA9ICQoJy5wb3B1cCcpWzBdXHJcbiAgICBpZiAoIXBvcHVwKSB7XHJcbiAgICAgIHBvcHVwID0gdGhpcy5lbCgnZGl2JywgJ3BvcHVwJylcclxuICAgIH1cclxuICAgIHBvcHVwLmFwcGVuZChwb3B1cF9faXRlbSlcclxuICAgIHBvcHVwLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5jbG9zZSwgdHJ1ZSlcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKHBvcHVwKVxyXG4gICAgbGV0IGhpZGVEZWxheSA9IDUwMDA7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgcG9wdXBfX2l0ZW0uY2xhc3NMaXN0LnJlbW92ZSgncG9wdXBfX2l0ZW0nKVxyXG4gICAgICBwb3B1cF9faXRlbS5jbGFzc0xpc3QuYWRkKCdwb3B1cC1oaWRlJylcclxuICAgIH0sIGhpZGVEZWxheSlcclxuICAgIGxldCByZW1vdmVEZWxheSA9IGhpZGVEZWxheSArIDk1MDtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBwb3B1cF9faXRlbS5yZW1vdmUoKVxyXG4gICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICBjYWxsYmFjaygpXHJcbiAgICAgIH1cclxuICAgIH0sIHJlbW92ZURlbGF5KVxyXG4gIH0sXHJcblxyXG4gIGNsb3NlOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgaWYgKGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygncG9wdXBfX2Nsb3NlJykpIHtcclxuICAgICAgbGV0IHBvcHVwID0gdGhpcy5jbG9zZXN0KCcucG9wdXAnKS5yZW1vdmUoKVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgZWw6IGZ1bmN0aW9uICh0YWdOYW1lLCBjbGFzc05hbWUpIHtcclxuICAgIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSlcclxuICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKVxyXG4gICAgcmV0dXJuIGVsXHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCB1bmlxID0gKGFycmF5KSA9PiBBcnJheS5mcm9tKG5ldyBTZXQoYXJyYXkpKTtcclxuXHJcblxyXG5hc3luYyBmdW5jdGlvbiBnZXQoa2V5KSB7XHJcbiAgbGV0IHAgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xyXG4gIHAgPSBwLm1hdGNoKG5ldyBSZWdFeHAoa2V5ICsgJz0oW14mPV0rKScpKTtcclxuICByZXR1cm4gcCA/IHBbMV0gOiBmYWxzZTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gcG9zdCh1cmwsIGRhdGEgPSB7fSkge1xyXG5cclxuICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICBkYXRhLnRva2VuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwidG9rZW5cIl0nKS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKVxyXG4gICAgICBsZXQgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgIHJlcS5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcclxuICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoXCJYLVJlcXVlc3RlZC1XaXRoXCIsIFwiWE1MSHR0cFJlcXVlc3RcIik7XHJcbiAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRm9ybURhdGEpIHtcclxuICAgICAgICByZXEuc2VuZChkYXRhKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xyXG4gICAgICAgIHJlcS5zZW5kKCdwYXJhbT0nICsgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICByZWplY3QoRXJyb3IoXCJOZXR3b3JrIEVycm9yXCIgKyBlKSk7XHJcbiAgICAgIH07XHJcbiAgICAgIHJlcS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbGV0IHJlcyA9IEpTT04ucGFyc2UocmVxLnJlc3BvbnNlKVxyXG4gICAgICAgIGxldCBtc2cgPSAkKCcubWVzc2FnZScpWzBdXHJcbiAgICAgICAgaWYgKHJlcy5wb3B1cCkge1xyXG4gICAgICAgICAgcG9wdXAuc2hvdyhyZXMucG9wdXApXHJcbiAgICAgICAgfSBlbHNlIGlmIChyZXMubXNnKSB7XHJcbiAgICAgICAgICBpZiAobXNnKSB7XHJcbiAgICAgICAgICAgIG1zZy5pbm5lckhUTUwgPSByZXMubXNnXHJcbiAgICAgICAgICAgIG1zZy5pbm5lckhUTUwgPSByZXMubXNnXHJcbiAgICAgICAgICAgICQobXNnKS5yZW1vdmVDbGFzcygnc3VjY2VzcycpXHJcbiAgICAgICAgICAgICQobXNnKS5yZW1vdmVDbGFzcygnZXJyb3InKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAocmVzLnN1Y2Nlc3MpIHtcclxuICAgICAgICAgIGlmIChtc2cpIHtcclxuICAgICAgICAgICAgbXNnLmlubmVySFRNTCA9IHJlcy5tc2dcclxuICAgICAgICAgICAgJChtc2cpLmFkZENsYXNzKCdlcnJvcicpXHJcbiAgICAgICAgICAgICQobXNnKS5yZW1vdmVDbGFzcygnc3VjY2VzcycpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChyZXMuZXJyb3IpIHtcclxuICAgICAgICAgIGlmIChtc2cpIHtcclxuICAgICAgICAgICAgbXNnLmlubmVySFRNTCA9ICcnXHJcbiAgICAgICAgICAgIG1zZy5pbm5lckhUTUwgPSByZXMuZXJyb3JcclxuICAgICAgICAgICAgJChtc2cpLnJlbW92ZUNsYXNzKCdzdWNjZXNzJylcclxuICAgICAgICAgICAgJChtc2cpLmFkZENsYXNzKCdlcnJvcicpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc29sdmUocmVzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIClcclxuXHJcbn1cclxuXHJcbmNsYXNzIEVsZW1lbnRDb2xsZWN0aW9uIGV4dGVuZHMgQXJyYXkge1xyXG5cclxuICAvLyBlbCA9IHRoaXNcclxuICAvLyBlbFR5cGUgPSBmdW5jdGlvbigpe3JldHVybiB7fS50b1N0cmluZy5jYWxsKHRoaXMpfVxyXG5cclxuICBvbihldmVudCwgY2JPclNlbGVjdG9yLCBjYikge1xyXG4gICAgaWYgKHR5cGVvZiBjYk9yU2VsZWN0b3IgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy5mb3JFYWNoKGUgPT4gZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYk9yU2VsZWN0b3IpKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5mb3JFYWNoKGVsZW0gPT4ge1xyXG4gICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZSA9PiB7XHJcbiAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IGNiT3JTZWxlY3RvcikgY2IoZSlcclxuICAgICAgICB9KVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpc1swXS5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJylcclxuICB9XHJcbiAgYXR0ciA9IGZ1bmN0aW9uIChhdHRyTmFtZSwgYXR0clZhbCkge1xyXG4gICAgaWYgKGF0dHJWYWwpIHtcclxuICAgICAgdGhpc1swXS5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJWYWwpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpc1swXS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpXHJcbiAgfVxyXG4gIHNlbGVjdGVkSW5kZXhWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLmxlbmd0aClcclxuICAgICAgcmV0dXJuIHRoaXNbMF0uc2VsZWN0ZWRPcHRpb25zWzBdLnZhbHVlXHJcbiAgfVxyXG4gIG9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5sZW5ndGgpIHJldHVybiB0aGlzWzBdLm9wdGlvbnNcclxuICB9XHJcbiAgY291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sZW5ndGhcclxuICB9XHJcbiAgdGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLmxlbmd0aCkgcmV0dXJuIHRoaXNbMF0uaW5uZXJUZXh0XHJcbiAgfVxyXG4gIGNoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5sZW5ndGgpIHJldHVybiB0aGlzWzBdLmNoZWNrZWRcclxuICB9XHJcbiAgZ2V0V2l0aFN0eWxlID0gZnVuY3Rpb24gKGF0dHIsIHZhbCkge1xyXG4gICAgbGV0IGFyciA9IFtdXHJcbiAgICB0aGlzLmZvckVhY2goKHMpID0+IHtcclxuICAgICAgaWYgKHMuc3R5bGVbYXR0cl0gPT09IHZhbCkge1xyXG4gICAgICAgIGFyci5wdXNoKHMpXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgICByZXR1cm4gYXJyXHJcbiAgfVxyXG4gIGFkZENsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xyXG4gICAgdGhpcy5mb3JFYWNoKChzKSA9PiB7XHJcbiAgICAgIHMuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpXHJcbiAgICB9KVxyXG4gIH1cclxuICByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcclxuICAgIHRoaXMuZm9yRWFjaCgocykgPT4ge1xyXG4gICAgICBzLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKVxyXG4gICAgfSlcclxuICB9XHJcbiAgaGFzQ2xhc3MgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XHJcbiAgICBpZiAodGhpcy5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSkgcmV0dXJuIHRydWVcclxuICB9XHJcbiAgYXBwZW5kID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICB0aGlzWzBdLmFwcGVuZENoaWxkKGVsKVxyXG4gIH1cclxuICBmaW5kID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIHRoaXNbMF0ucXVlcnlTZWxlY3RvcihpdGVtKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGV0IGZpbHRlcmVkID0gdGhpc1swXS5maWx0ZXIoKGVsKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGVsID09PSBpdGVtXHJcbiAgICAgIH0pXHJcbiAgICAgIHJldHVybiBmaWx0ZXJlZFswXVxyXG4gICAgfVxyXG4gIH1cclxuICBmaW5kQWxsID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIHRoaXNbMF0ucXVlcnlTZWxlY3RvckFsbChpdGVtKVxyXG4gICAgfVxyXG4gIH1cclxuICBjc3MgPSBmdW5jdGlvbiAoYXR0ciwgdmFsKSB7XHJcbiAgICBpZiAoIXZhbCkge1xyXG4gICAgICByZXR1cm4gdGhpc1swXS5zdHlsZVthdHRyXVxyXG4gICAgfVxyXG4gICAgdGhpcy5mb3JFYWNoKChzKSA9PiB7XHJcbiAgICAgIHMuc3R5bGVbYXR0cl0gPSB2YWxcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICByZWFkeShjYikge1xyXG4gICAgY29uc3QgaXNSZWFkeSA9IHRoaXMuc29tZShlID0+IHtcclxuICAgICAgcmV0dXJuIGUucmVhZHlTdGF0ZSAhPSBudWxsICYmIGUucmVhZHlTdGF0ZSAhPSAnbG9hZGluZydcclxuICAgIH0pXHJcbiAgICBpZiAoaXNSZWFkeSkge1xyXG4gICAgICBjYigpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgY2IpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uICQoc2VsZWN0b3IpIHtcclxuICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJyB8fCBzZWxlY3RvciBpbnN0YW5jZW9mIFN0cmluZykge1xyXG4gICAgcmV0dXJuIG5ldyBFbGVtZW50Q29sbGVjdGlvbiguLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIG5ldyBFbGVtZW50Q29sbGVjdGlvbihzZWxlY3RvcilcclxuICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBhZGRUb29sdGlwKGFyZ3MpIHtcclxuXHJcbiAgW10uZm9yRWFjaC5jYWxsKGFyZ3MsIChlbCkgPT4ge1xyXG4gICAgZWwub25tb3VzZWVudGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBsZXQgdGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgICAgdGlwLmNsYXNzTGlzdC5hZGQoJ3RpcCcpXHJcbiAgICAgIHRpcC5pbm5lclRleHQgPSBhcmdzLm1lc3NhZ2VcclxuXHJcbiAgICAgIGVsLmFwcGVuZCh0aXApXHJcbiAgICAgIGxldCByZW1vdmUgPSAoKSA9PiB0aXAucmVtb3ZlKClcclxuICAgICAgdGlwLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHJlbW92ZS5iaW5kKHRpcCksIHRydWUpXHJcbiAgICB9LmJpbmQoYXJncylcclxuXHJcbiAgICBlbC5vbm1vdXNlbGVhdmUgPSAoKSA9PiB7XHJcbiAgICAgIGxldCB0aXAgPSBlbC5xdWVyeVNlbGVjdG9yKCcudGlwJylcclxuICAgICAgdGlwLnJlbW92ZSgpXHJcbiAgICB9XHJcbiAgfSlcclxufVxyXG5cclxuXHJcbmV4cG9ydCB7XHJcbiAgZHJvcERvd24sXHJcbiAgYWRkVG9vbHRpcCxcclxuICBwb3B1cCxcclxuICBkZWJvdW5jZSxcclxuICBJc0pzb24sXHJcblxyXG4gIHBvc3QsIGdldCwgdW5pcSxcclxuICB2YWxpZGF0ZSwgJFxyXG59XHJcbiIsImltcG9ydCAnLi9hY2NvcmRpb24uc2NzcydcclxuaW1wb3J0IHskfSBmcm9tICcuLi8uLi9jb21tb24nXHJcblxyXG5sZXQgYWNjb3JkaW9ucyA9ICQoJ1thY2NvcmRpb25dJylcclxuaWYgKGFjY29yZGlvbnMpIHtcclxuXHJcbiAgbGV0IGNoZWNrYm94ZXMgPSAkKGBbYWNjb3JkaW9uXSBbdHlwZT0nY2hlY2tib3gnXWApXHJcbiAgaWYgKGNoZWNrYm94ZXMpIHtcclxuICAgIFsuLi5jaGVja2JveGVzXS5maWx0ZXIoY2ggPT4ge1xyXG4gICAgICBjaC5jaGVja2VkID0gZmFsc2VcclxuICAgIH0pXHJcbiAgfVxyXG4gICQoJ1thY2NvcmRpb25dJykub24oJ2NsaWNrJywgaGFuZGxlKVxyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGUoe3RhcmdldH0pIHtcclxuICBsZXQgbGkgPSB0YXJnZXQuY2xvc2VzdCgnbGknKVxyXG4gIGlmICghbGkpIHJldHVyblxyXG5cclxuICAvLyBsZXQgYWNjb3JkaW9uID0gbGkuY2xvc2VzdCgnW2FjY29yZGlvbl0nKVxyXG4gIGxldCB1bCA9ICQobGkpLmZpbmQoJ3VsJylcclxuICBpZiAoIXVsKSB7XHJcbiAgICByb3RhdGVBcnJvdyhsaSlcclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKHVsLmNsYXNzTGlzdC5jb250YWlucygnb3BlbicpKSB7XHJcbiAgICAgIHNsaWRlVXAodWwsIGxpKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gYWNjb3JkaW9uLnN0eWxlLmhlaWdodCA9IFwiYXV0b1wiXHJcbiAgICAgIGlmICghdWwpIHJldHVyblxyXG4gICAgICBsZXQgcGFyZW50ID0gbGkuY2xvc2VzdCgndWwnKVxyXG4gICAgICBjbG9zZVNpYmxpbmdzKHBhcmVudClcclxuICAgICAgc2xpZGVEb3duKHVsLCBsaSwgcGFyZW50KVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2xvc2VTaWJsaW5ncyhwYXJlbnQpIHtcclxuICBpZiAoIXBhcmVudCkgcmV0dXJuXHJcbiAgbGV0IG9wZW4gPSAkKHBhcmVudCkuZmluZCgnbGk+dWwub3BlbicpXHJcbiAgaWYgKG9wZW4pIHtcclxuICAgIGxldCBsaSA9IG9wZW4uY2xvc2VzdCgnbGknKVxyXG4gICAgc2xpZGVVcChvcGVuLCBsaSlcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNsaWRlRG93bih1bCwgbGksIHBhcmVudCkge1xyXG4gIGlmIChwYXJlbnQpIHtcclxuICAgIHBhcmVudC5zdHlsZS5tYXhIZWlnaHQgPSB1bC5zY3JvbGxIZWlnaHQgKyBwYXJlbnQuc2Nyb2xsSGVpZ2h0ICsgXCJweFwiO1xyXG4gIH1cclxuICB1bC5zdHlsZS5tYXhIZWlnaHQgPSB1bC5zY3JvbGxIZWlnaHQgKyBcInB4XCI7XHJcbiAgdWwuY2xhc3NMaXN0LnRvZ2dsZSgnb3BlbicpXHJcbiAgbGkuY2xhc3NMaXN0LnRvZ2dsZSgncm90YXRlJylcclxufVxyXG5cclxuZnVuY3Rpb24gc2xpZGVVcCh1bCwgbGkpIHtcclxuICB1bC5zdHlsZS5tYXhIZWlnaHQgPSAwICsgXCJweFwiO1xyXG4gIHVsLmNsYXNzTGlzdC50b2dnbGUoJ29wZW4nKVxyXG4gIGxpLmNsYXNzTGlzdC50b2dnbGUoJ3JvdGF0ZScpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJvdGF0ZUFycm93KGxpKSB7XHJcbiAgbGkuY2xhc3NMaXN0LnRvZ2dsZSgncm90YXRlJylcclxufVxyXG5cclxuZnVuY3Rpb24gaW5jcmVhc2VQYXJlbnQocGFyZW50LCB1bEhlaWdodCkge1xyXG4gIGlmICghcGFyZW50LmNsYXNzTGlzdC5jb250YWlucygnYWNjb3JkaW9uJykpIHtcclxuICAgIGxldCBwYXJlbnRIZWlnaHQgPSBwYXJzZUludChwYXJlbnQuc3R5bGUubWF4SGVpZ2h0KSArIHVsSGVpZ2h0XHJcbiAgICBwYXJlbnQuc3R5bGUubWF4SGVpZ2h0ID0gcGFyZW50SGVpZ2h0ICsgXCJweFwiO1xyXG4gIH1cclxufSIsImltcG9ydCB7JH0gZnJvbSAnLi4vY29tbW9uJ1xyXG5sZXQgc2lkZWJhciA9ICQoJy5hZG1pbl9zaWRlYmFyJylbMF1cclxuaWYgKHNpZGViYXIpIHtcclxuICAkKCdzdmcjYnVyZ2VyJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG4gICAgbGV0IGFjY29yZGlvbiA9ICQoJy5hZG1pbl9zaWRlYmFyIFthY2NvcmRpb25dJylbMF1cclxuICAgIGFjY29yZGlvbi5jbGFzc0xpc3QudG9nZ2xlKCdzaG93JylcclxuICB9KVxyXG59XHJcblxyXG4iLCJpbXBvcnQgeyQsIHBvcHVwLCBwb3N0fSBmcm9tIFwiLi4vLi4vY29tbW9uXCI7XHJcbmltcG9ydCBcIi4uLy4uL2NvbXBvbmVudHMvcG9wdXAuc2Nzc1wiO1xyXG5cclxuXHJcbmxldCBfY2FjaGUgPSB7XHJcbiAgICBjbGVhckNhY2hlOiBhc3luYyBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9hZG1pbnNjL2NsZWFyQ2FjaGUnLCB7fSlcclxuICAgICAgICBpZiAocmVzPT09J9Cj0YHQv9C10YjQvdC+Jykge1xyXG4gICAgICAgICAgICBwb3B1cC5zaG93KHJlcylcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNhY2hlKCkge1xyXG4gICAgJCgnLmNsZWFyQ2FjaGUnKS5vbignY2xpY2snLCBfY2FjaGUuY2xlYXJDYWNoZSlcclxufSIsImltcG9ydCB7JCwgcG9zdCwgcG9wdXB9IGZyb20gXCIuLi8uLi9jb21tb25cIjtcclxuXHJcbmV4cG9ydCBjb25zdCBfdGVzdFJlc3VsdCA9IHtcclxuXHJcblxyXG4gIGRlbFNlcnZlcjogYXN5bmMgKGlkKSA9PiB7XHJcbiAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCgnL2FkbWluc2MvdGVzdHJlc3VsdC9kZWxldGUnLCB7aWR9KVxyXG4gICAgaWYgKHJlcykge1xyXG4gICAgICBwb3B1cC5zaG93KCfQo9C00LDQu9C10L3QvicpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZGVsRG9tOiAoaWQpID0+IHtcclxuICAgIFtdLm1hcC5jYWxsKCQoYFtkYXRhLXJvdyA9IFwiJHtpZH1cIl1gKSwgZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICBpLnJlbW92ZSgpXHJcbiAgICAgIH1cclxuICAgIClcclxuICB9LFxyXG5cclxuICBkZWxldGU6IChpZCkgPT4ge1xyXG4gICAgaWYgKGNvbmZpcm0oXCLQo9C00LDQu9C40YLRjCDRgNC10LfRg9C70YzRgtCw0YIg0YLQtdGB0YLQsD9cIikpIHtcclxuICAgICAgX3Rlc3RSZXN1bHQuZGVsRG9tKGlkKVxyXG4gICAgICBfdGVzdFJlc3VsdC5kZWxTZXJ2ZXIoaWQpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbn0iLCJpbXBvcnQgJy4vdGVzdC1yZXN1bHRzX190YWJsZS5zY3NzJ1xyXG5pbXBvcnQgeyR9IGZyb20gJy4uLy4uL2NvbW1vbidcclxuaW1wb3J0IHtfdGVzdFJlc3VsdH0gZnJvbSAnLi4vbW9kZWwvX3Rlc3RSZXN1bHQnXHJcblxyXG5sZXQgdGVzdFJlc3VsdHMgPSAkKCcudGVzdC1yZXN1bHRzX190YWJsZScpWzBdXHJcbmlmICh0ZXN0UmVzdWx0cykge1xyXG4gICQodGVzdFJlc3VsdHMpLm9uKCdjbGljaycsIGhhbmRsZUNsaWNrKVxyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVDbGljayh7dGFyZ2V0fSkge1xyXG4gIGlmICghIXRhcmdldC5jbG9zZXN0KCcuZGVsLWJ0bicpKSB7XHJcbiAgICBsZXQgaWQgPSB0YXJnZXQuY2xvc2VzdCgnLmRlbC1idG4nKS5kYXRhc2V0LnJvd1xyXG4gICAgX3Rlc3RSZXN1bHQuZGVsZXRlKGlkKVxyXG4gIH1cclxuXHJcbn1cclxuXHJcblxyXG4iLCJpbXBvcnQgeyQsIHBvcHVwLCBwb3N0LCBhZGRUb29sdGlwfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uXCJcclxuXHJcbmNsYXNzIG9wZW5xdWVzdGlvbiB7XHJcblxyXG4gIG1vZGVsID0gJ29wZW5xdWVzdGlvbidcclxuICBxdWVzdGlvbnMgPSAkKCcucXVlc3Rpb25zPi5xdWVzdGlvbi1lZGl0JylcclxuICB0ZXN0SWQgPSArJCgnLnF1ZXN0aW9ucycpWzBdPy5kYXRhc2V0LnRlc3RJZCA/PyBudWxsXHJcbiAgcXVlc3Rpb25DbnQgPSAkKCcucXVlc3Rpb25zPi5xdWVzdGlvbi1lZGl0JykubGVuZ3RoID8/IG51bGxcclxuXHJcbiAgYXN5bmMgY3JlYXRlKHRhcmdldCkge1xyXG4gICAgbGV0IGlkID0gMFxyXG4gICAgbGV0IG9wZW50ZXN0X2lkID0gdGhpcy50ZXN0SWRcclxuICAgIGxldCBzb3J0ID0gdGhpcy5xdWVzdGlvbkNudCsxXHJcbiAgICBsZXQgcmVzID0gYXdhaXQgcG9zdChgL2FkbWluc2MvJHt0aGlzLm1vZGVsfS91cGRhdGVPckNyZWF0ZWAsXHJcbiAgICAgIHtpZCxvcGVudGVzdF9pZCxzb3J0fSlcclxuICAgIHJlcyA9IGF3YWl0IEpTT04ucGFyc2UocmVzKVxyXG5cclxuICAgIGlmIChyZXMuaWQpIHtcclxuICAgICAgbGV0IGNsb25lID0gdGhpcy5jbG9uZUVtcHR5TW9kZWwoKVxyXG4gICAgICBsZXQgYWRkQnRuID0gdGFyZ2V0LmNsb3Nlc3QoJy5xdWVzdGlvbl9fY3JlYXRlLWJ1dHRvbicpXHJcblxyXG4gICAgICBjbG9uZS5xdWVyeVNlbGVjdG9yKCcuc29ydCcpLmlubmVyVGV4dCA9IHRoaXMucXVlc3Rpb25DbnQgKyAxXHJcbiAgICAgIGNsb25lLnF1ZXJ5U2VsZWN0b3IoJy50ZXh0JykuaW5uZXJUZXh0ID0gJydcclxuICAgICAgY2xvbmUuaWQgPSByZXMuaWRcclxuICAgICAgYWRkQnRuLmJlZm9yZShjbG9uZSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNsb25lRW1wdHlNb2RlbCgpIHtcclxuICAgIGxldCBxdWVzdGlvbiA9ICQoJy5xdWVzdGlvbnMgLnF1ZXN0aW9uLWVkaXQnKVswXVxyXG4gICAgaWYgKHF1ZXN0aW9uKSB7XHJcbiAgICAgIGxldCBxID0gcXVlc3Rpb24uY2xvbmVOb2RlKHRydWUpXHJcbiAgICAgIGxldCBhbnMgPSBxLnF1ZXJ5U2VsZWN0b3JBbGwoJy5yb3cgLmFuc3dlcicpO1xyXG4gICAgICBbXS5mb3JFYWNoLmNhbGwoYW5zLCBmdW5jdGlvbiAoYW5zd2VyKSB7XHJcbiAgICAgICAgYW5zd2VyLnJlbW92ZSgpXHJcbiAgICAgIH0pXHJcbiAgICAgIHJldHVybiBxXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBzb3J0KHVwVG9RZXN0aW9uTnVtYmVyKSB7XHJcblxyXG4gICAgbGV0IHF1ZXN0aW9uc0VscyA9IHRoaXMucXVlc3Rpb25zLmZpbHRlcihmdW5jdGlvbiAoZWwsIGkpIHtcclxuICAgICAgICBpZiAoaSArIDEgPCB1cFRvUWVzdGlvbk51bWJlcikgcmV0dXJuIGVsXHJcbiAgICAgIH1cclxuICAgIClcclxuICAgIGxldCB0b0NoYW5nZSA9IHF1ZXN0aW9uc0Vscy5tYXAoKGVsKSA9PiB7XHJcbiAgICAgIHJldHVybiBlbC5pZFxyXG4gICAgfSlcclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KGAvJHt0aGlzLm1vZGVsfS9zb3J0YCwge3RvQ2hhbmdlfSlcclxuICAgIC8vIHJlcyA9IEpTT04ucGFyc2UocmVzKVxyXG4gICAgLy8gaWYgKHJlcy5tc2cpIHtcclxuICAgIC8vICAgcG9wdXAuc2hvdyhyZXMubXNnKVxyXG4gICAgLy8gfVxyXG4gICAgcXVlc3Rpb25zRWxzLm1hcCgoZWwsIGkpID0+IHtcclxuICAgICAgJChlbCkuZmluZCgnLnNvcnQnKS5pbm5lclRleHQgPSBpICsgMVxyXG5cclxuICAgIH0pXHJcbiAgfVxyXG5cclxuXHJcbiAgYXN5bmMgY2hhbmdlUGFyZW50KHRhcmdldCkge1xyXG4gICAgLy8gZGVidWdnZXJcclxuXHJcbiAgICBpZiAodGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ2xpJykgcmV0dXJuXHJcblxyXG4gICAgbGV0IGlkID0gdGFyZ2V0LmNsb3Nlc3QoJy5xdWVzdGlvbi1lZGl0JykuaWRcclxuICAgIGxldCB0ZXN0X2lkID0gdGFyZ2V0LmRhdGFzZXRbJ3ZhbHVlJ11cclxuICAgIGxldCB0ZXN0X25hbWUgPSB0YXJnZXQuaW5uZXJUZXh0XHJcbiAgICBpZiAoIStpZCB8fCAhK3Rlc3RfaWQgfHwgIXRlc3RfbmFtZSkgcmV0dXJuXHJcbiAgICBsZXQgcmVzID0gYXdhaXQgcG9zdChgL2FkbWluc2MvJHt0aGlzLm1vZGVsfS9jaGFuZ2VQYXJlbnRgLCB7aWQsIHRlc3RfaWR9KVxyXG4gICAgcmVzID0gSlNPTi5wYXJzZShyZXMpXHJcbiAgICBpZiAocmVzLm1zZyAhPT0gJ29rJykgdGhyb3cgKGUpO1xyXG4gICAgbGV0IHF1ZXN0aW9uID0gdGFyZ2V0LmNsb3Nlc3QoJy5xdWVzdGlvbi1lZGl0JylcclxuICAgIHF1ZXN0aW9uLnJlbW92ZSgpXHJcbiAgICBwb3B1cC5zaG93KCfQn9C10YDQtdC80LXRidC10L0g0LIgJyArIHRlc3RfbmFtZSlcclxuICB9XHJcblxyXG4gIHNob3dBbnN3ZXJzKHRhcmdldCkge1xyXG4gICAgbGV0IHJvdyA9IHRhcmdldC5jbG9zZXN0KCcucXVlc3Rpb24tZWRpdCcpXHJcbiAgICBsZXQgYW5zd2VycyA9ICQocm93KS5maW5kKCcucXVlc3Rpb25fX2Fuc3dlcnMnKVxyXG4gICAgYW5zd2Vycy5jbGFzc0xpc3QudG9nZ2xlKCdoZWlnaHQnKVxyXG4gICAgYW5zd2Vycy5jbGFzc0xpc3QudG9nZ2xlKCdzY2FsZScpXHJcbiAgICB0YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSgncm90YXRlJylcclxuICB9XHJcblxyXG4gIGFzeW5jIGRlbCh0YXJnZXQpIHtcclxuICAgIGlmIChjb25maXJtKFwi0KPQtNCw0LvQuNGC0Ywg0LLQvtC/0YDQvtGBINGB0L4g0LLRgdC10LzQuCDQtdCz0L4g0L7RgtCy0LXRgtCw0LzQuD9cIikpIHtcclxuICAgICAgbGV0IHF1ZXN0aW9uID0gdGFyZ2V0LmNsb3Nlc3QoJy5xdWVzdGlvbi1lZGl0JylcclxuICAgICAgbGV0IGlkID0gcXVlc3Rpb24uaWRcclxuXHJcbiAgICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KGAvYWRtaW5zYy8ke3RoaXMubW9kZWx9L2RlbGV0ZWAsIHtpZH0pXHJcbiAgICAgIHJlcyA9IEpTT04ucGFyc2UocmVzKVxyXG4gICAgICBpZiAocmVzKSB7XHJcbiAgICAgICAgcXVlc3Rpb24ucmVtb3ZlKClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBfb3BlbnF1ZXN0aW9uID0gbmV3IG9wZW5xdWVzdGlvbigpIiwiLyoqIVxuICogU29ydGFibGUgMS4xNS4wXG4gKiBAYXV0aG9yXHRSdWJhWGEgICA8dHJhc2hAcnViYXhhLm9yZz5cbiAqIEBhdXRob3JcdG93ZW5tICAgIDxvd2VuMjMzNTVAZ21haWwuY29tPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcblxuICAgIGlmIChlbnVtZXJhYmxlT25seSkge1xuICAgICAgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG5cbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuXG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxudmFyIHZlcnNpb24gPSBcIjEuMTUuMFwiO1xuXG5mdW5jdGlvbiB1c2VyQWdlbnQocGF0dGVybikge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm5hdmlnYXRvcikge1xuICAgIHJldHVybiAhISAvKkBfX1BVUkVfXyovbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaChwYXR0ZXJuKTtcbiAgfVxufVxuXG52YXIgSUUxMU9yTGVzcyA9IHVzZXJBZ2VudCgvKD86VHJpZGVudC4qcnZbIDpdPzExXFwufG1zaWV8aWVtb2JpbGV8V2luZG93cyBQaG9uZSkvaSk7XG52YXIgRWRnZSA9IHVzZXJBZ2VudCgvRWRnZS9pKTtcbnZhciBGaXJlRm94ID0gdXNlckFnZW50KC9maXJlZm94L2kpO1xudmFyIFNhZmFyaSA9IHVzZXJBZ2VudCgvc2FmYXJpL2kpICYmICF1c2VyQWdlbnQoL2Nocm9tZS9pKSAmJiAhdXNlckFnZW50KC9hbmRyb2lkL2kpO1xudmFyIElPUyA9IHVzZXJBZ2VudCgvaVAoYWR8b2R8aG9uZSkvaSk7XG52YXIgQ2hyb21lRm9yQW5kcm9pZCA9IHVzZXJBZ2VudCgvY2hyb21lL2kpICYmIHVzZXJBZ2VudCgvYW5kcm9pZC9pKTtcblxudmFyIGNhcHR1cmVNb2RlID0ge1xuICBjYXB0dXJlOiBmYWxzZSxcbiAgcGFzc2l2ZTogZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIG9uKGVsLCBldmVudCwgZm4pIHtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZm4sICFJRTExT3JMZXNzICYmIGNhcHR1cmVNb2RlKTtcbn1cblxuZnVuY3Rpb24gb2ZmKGVsLCBldmVudCwgZm4pIHtcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgZm4sICFJRTExT3JMZXNzICYmIGNhcHR1cmVNb2RlKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlcyhcbi8qKkhUTUxFbGVtZW50Ki9cbmVsLFxuLyoqU3RyaW5nKi9cbnNlbGVjdG9yKSB7XG4gIGlmICghc2VsZWN0b3IpIHJldHVybjtcbiAgc2VsZWN0b3JbMF0gPT09ICc+JyAmJiAoc2VsZWN0b3IgPSBzZWxlY3Rvci5zdWJzdHJpbmcoMSkpO1xuXG4gIGlmIChlbCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoZWwubWF0Y2hlcykge1xuICAgICAgICByZXR1cm4gZWwubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgICB9IGVsc2UgaWYgKGVsLm1zTWF0Y2hlc1NlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBlbC5tc01hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICB9IGVsc2UgaWYgKGVsLndlYmtpdE1hdGNoZXNTZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gZWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnRPckhvc3QoZWwpIHtcbiAgcmV0dXJuIGVsLmhvc3QgJiYgZWwgIT09IGRvY3VtZW50ICYmIGVsLmhvc3Qubm9kZVR5cGUgPyBlbC5ob3N0IDogZWwucGFyZW50Tm9kZTtcbn1cblxuZnVuY3Rpb24gY2xvc2VzdChcbi8qKkhUTUxFbGVtZW50Ki9cbmVsLFxuLyoqU3RyaW5nKi9cbnNlbGVjdG9yLFxuLyoqSFRNTEVsZW1lbnQqL1xuY3R4LCBpbmNsdWRlQ1RYKSB7XG4gIGlmIChlbCkge1xuICAgIGN0eCA9IGN0eCB8fCBkb2N1bWVudDtcblxuICAgIGRvIHtcbiAgICAgIGlmIChzZWxlY3RvciAhPSBudWxsICYmIChzZWxlY3RvclswXSA9PT0gJz4nID8gZWwucGFyZW50Tm9kZSA9PT0gY3R4ICYmIG1hdGNoZXMoZWwsIHNlbGVjdG9yKSA6IG1hdGNoZXMoZWwsIHNlbGVjdG9yKSkgfHwgaW5jbHVkZUNUWCAmJiBlbCA9PT0gY3R4KSB7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsID09PSBjdHgpIGJyZWFrO1xuICAgICAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuICAgIH0gd2hpbGUgKGVsID0gZ2V0UGFyZW50T3JIb3N0KGVsKSk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJfU1BBQ0UgPSAvXFxzKy9nO1xuXG5mdW5jdGlvbiB0b2dnbGVDbGFzcyhlbCwgbmFtZSwgc3RhdGUpIHtcbiAgaWYgKGVsICYmIG5hbWUpIHtcbiAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgICBlbC5jbGFzc0xpc3Rbc3RhdGUgPyAnYWRkJyA6ICdyZW1vdmUnXShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNsYXNzTmFtZSA9ICgnICcgKyBlbC5jbGFzc05hbWUgKyAnICcpLnJlcGxhY2UoUl9TUEFDRSwgJyAnKS5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJyk7XG4gICAgICBlbC5jbGFzc05hbWUgPSAoY2xhc3NOYW1lICsgKHN0YXRlID8gJyAnICsgbmFtZSA6ICcnKSkucmVwbGFjZShSX1NQQUNFLCAnICcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjc3MoZWwsIHByb3AsIHZhbCkge1xuICB2YXIgc3R5bGUgPSBlbCAmJiBlbC5zdHlsZTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChkb2N1bWVudC5kZWZhdWx0VmlldyAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgICAgIHZhbCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsICcnKTtcbiAgICAgIH0gZWxzZSBpZiAoZWwuY3VycmVudFN0eWxlKSB7XG4gICAgICAgIHZhbCA9IGVsLmN1cnJlbnRTdHlsZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb3AgPT09IHZvaWQgMCA/IHZhbCA6IHZhbFtwcm9wXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEocHJvcCBpbiBzdHlsZSkgJiYgcHJvcC5pbmRleE9mKCd3ZWJraXQnKSA9PT0gLTEpIHtcbiAgICAgICAgcHJvcCA9ICctd2Via2l0LScgKyBwcm9wO1xuICAgICAgfVxuXG4gICAgICBzdHlsZVtwcm9wXSA9IHZhbCArICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/ICcnIDogJ3B4Jyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hdHJpeChlbCwgc2VsZk9ubHkpIHtcbiAgdmFyIGFwcGxpZWRUcmFuc2Zvcm1zID0gJyc7XG5cbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcHBsaWVkVHJhbnNmb3JtcyA9IGVsO1xuICB9IGVsc2Uge1xuICAgIGRvIHtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBjc3MoZWwsICd0cmFuc2Zvcm0nKTtcblxuICAgICAgaWYgKHRyYW5zZm9ybSAmJiB0cmFuc2Zvcm0gIT09ICdub25lJykge1xuICAgICAgICBhcHBsaWVkVHJhbnNmb3JtcyA9IHRyYW5zZm9ybSArICcgJyArIGFwcGxpZWRUcmFuc2Zvcm1zO1xuICAgICAgfVxuICAgICAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuXG4gICAgfSB3aGlsZSAoIXNlbGZPbmx5ICYmIChlbCA9IGVsLnBhcmVudE5vZGUpKTtcbiAgfVxuXG4gIHZhciBtYXRyaXhGbiA9IHdpbmRvdy5ET01NYXRyaXggfHwgd2luZG93LldlYktpdENTU01hdHJpeCB8fCB3aW5kb3cuQ1NTTWF0cml4IHx8IHdpbmRvdy5NU0NTU01hdHJpeDtcbiAgLypqc2hpbnQgLVcwNTYgKi9cblxuICByZXR1cm4gbWF0cml4Rm4gJiYgbmV3IG1hdHJpeEZuKGFwcGxpZWRUcmFuc2Zvcm1zKTtcbn1cblxuZnVuY3Rpb24gZmluZChjdHgsIHRhZ05hbWUsIGl0ZXJhdG9yKSB7XG4gIGlmIChjdHgpIHtcbiAgICB2YXIgbGlzdCA9IGN0eC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIG4gPSBsaXN0Lmxlbmd0aDtcblxuICAgIGlmIChpdGVyYXRvcikge1xuICAgICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaXRlcmF0b3IobGlzdFtpXSwgaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKSB7XG4gIHZhciBzY3JvbGxpbmdFbGVtZW50ID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudDtcblxuICBpZiAoc2Nyb2xsaW5nRWxlbWVudCkge1xuICAgIHJldHVybiBzY3JvbGxpbmdFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cbn1cbi8qKlxuICogUmV0dXJucyB0aGUgXCJib3VuZGluZyBjbGllbnQgcmVjdFwiIG9mIGdpdmVuIGVsZW1lbnRcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICAgICAgICAgICAgICAgICAgICAgVGhlIGVsZW1lbnQgd2hvc2UgYm91bmRpbmdDbGllbnRSZWN0IGlzIHdhbnRlZFxuICogQHBhcmFtICB7W0Jvb2xlYW5dfSByZWxhdGl2ZVRvQ29udGFpbmluZ0Jsb2NrICBXaGV0aGVyIHRoZSByZWN0IHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgY29udGFpbmluZyBibG9jayBvZiAoaW5jbHVkaW5nKSB0aGUgY29udGFpbmVyXG4gKiBAcGFyYW0gIHtbQm9vbGVhbl19IHJlbGF0aXZlVG9Ob25TdGF0aWNQYXJlbnQgIFdoZXRoZXIgdGhlIHJlY3Qgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSByZWxhdGl2ZSBwYXJlbnQgb2YgKGluY2x1ZGluZykgdGhlIGNvbnRhaWVuclxuICogQHBhcmFtICB7W0Jvb2xlYW5dfSB1bmRvU2NhbGUgICAgICAgICAgICAgICAgICBXaGV0aGVyIHRoZSBjb250YWluZXIncyBzY2FsZSgpIHNob3VsZCBiZSB1bmRvbmVcbiAqIEBwYXJhbSAge1tIVE1MRWxlbWVudF19IGNvbnRhaW5lciAgICAgICAgICAgICAgVGhlIHBhcmVudCB0aGUgZWxlbWVudCB3aWxsIGJlIHBsYWNlZCBpblxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgYm91bmRpbmdDbGllbnRSZWN0IG9mIGVsLCB3aXRoIHNwZWNpZmllZCBhZGp1c3RtZW50c1xuICovXG5cblxuZnVuY3Rpb24gZ2V0UmVjdChlbCwgcmVsYXRpdmVUb0NvbnRhaW5pbmdCbG9jaywgcmVsYXRpdmVUb05vblN0YXRpY1BhcmVudCwgdW5kb1NjYWxlLCBjb250YWluZXIpIHtcbiAgaWYgKCFlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgZWwgIT09IHdpbmRvdykgcmV0dXJuO1xuICB2YXIgZWxSZWN0LCB0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIGhlaWdodCwgd2lkdGg7XG5cbiAgaWYgKGVsICE9PSB3aW5kb3cgJiYgZWwucGFyZW50Tm9kZSAmJiBlbCAhPT0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpKSB7XG4gICAgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdG9wID0gZWxSZWN0LnRvcDtcbiAgICBsZWZ0ID0gZWxSZWN0LmxlZnQ7XG4gICAgYm90dG9tID0gZWxSZWN0LmJvdHRvbTtcbiAgICByaWdodCA9IGVsUmVjdC5yaWdodDtcbiAgICBoZWlnaHQgPSBlbFJlY3QuaGVpZ2h0O1xuICAgIHdpZHRoID0gZWxSZWN0LndpZHRoO1xuICB9IGVsc2Uge1xuICAgIHRvcCA9IDA7XG4gICAgbGVmdCA9IDA7XG4gICAgYm90dG9tID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIHJpZ2h0ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gIH1cblxuICBpZiAoKHJlbGF0aXZlVG9Db250YWluaW5nQmxvY2sgfHwgcmVsYXRpdmVUb05vblN0YXRpY1BhcmVudCkgJiYgZWwgIT09IHdpbmRvdykge1xuICAgIC8vIEFkanVzdCBmb3IgdHJhbnNsYXRlKClcbiAgICBjb250YWluZXIgPSBjb250YWluZXIgfHwgZWwucGFyZW50Tm9kZTsgLy8gc29sdmVzICMxMTIzIChzZWU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNzk1MzgwNi82MDg4MzEyKVxuICAgIC8vIE5vdCBuZWVkZWQgb24gPD0gSUUxMVxuXG4gICAgaWYgKCFJRTExT3JMZXNzKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChjb250YWluZXIgJiYgY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiAoY3NzKGNvbnRhaW5lciwgJ3RyYW5zZm9ybScpICE9PSAnbm9uZScgfHwgcmVsYXRpdmVUb05vblN0YXRpY1BhcmVudCAmJiBjc3MoY29udGFpbmVyLCAncG9zaXRpb24nKSAhPT0gJ3N0YXRpYycpKSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIFNldCByZWxhdGl2ZSB0byBlZGdlcyBvZiBwYWRkaW5nIGJveCBvZiBjb250YWluZXJcblxuICAgICAgICAgIHRvcCAtPSBjb250YWluZXJSZWN0LnRvcCArIHBhcnNlSW50KGNzcyhjb250YWluZXIsICdib3JkZXItdG9wLXdpZHRoJykpO1xuICAgICAgICAgIGxlZnQgLT0gY29udGFpbmVyUmVjdC5sZWZ0ICsgcGFyc2VJbnQoY3NzKGNvbnRhaW5lciwgJ2JvcmRlci1sZWZ0LXdpZHRoJykpO1xuICAgICAgICAgIGJvdHRvbSA9IHRvcCArIGVsUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgcmlnaHQgPSBsZWZ0ICsgZWxSZWN0LndpZHRoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cblxuICAgICAgfSB3aGlsZSAoY29udGFpbmVyID0gY29udGFpbmVyLnBhcmVudE5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1bmRvU2NhbGUgJiYgZWwgIT09IHdpbmRvdykge1xuICAgIC8vIEFkanVzdCBmb3Igc2NhbGUoKVxuICAgIHZhciBlbE1hdHJpeCA9IG1hdHJpeChjb250YWluZXIgfHwgZWwpLFxuICAgICAgICBzY2FsZVggPSBlbE1hdHJpeCAmJiBlbE1hdHJpeC5hLFxuICAgICAgICBzY2FsZVkgPSBlbE1hdHJpeCAmJiBlbE1hdHJpeC5kO1xuXG4gICAgaWYgKGVsTWF0cml4KSB7XG4gICAgICB0b3AgLz0gc2NhbGVZO1xuICAgICAgbGVmdCAvPSBzY2FsZVg7XG4gICAgICB3aWR0aCAvPSBzY2FsZVg7XG4gICAgICBoZWlnaHQgLz0gc2NhbGVZO1xuICAgICAgYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICAgICAgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IHRvcCxcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIGJvdHRvbTogYm90dG9tLFxuICAgIHJpZ2h0OiByaWdodCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGEgc2lkZSBvZiBhbiBlbGVtZW50IGlzIHNjcm9sbGVkIHBhc3QgYSBzaWRlIG9mIGl0cyBwYXJlbnRzXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gIGVsICAgICAgICAgICBUaGUgZWxlbWVudCB3aG8ncyBzaWRlIGJlaW5nIHNjcm9sbGVkIG91dCBvZiB2aWV3IGlzIGluIHF1ZXN0aW9uXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIGVsU2lkZSAgICAgICBTaWRlIG9mIHRoZSBlbGVtZW50IGluIHF1ZXN0aW9uICgndG9wJywgJ2xlZnQnLCAncmlnaHQnLCAnYm90dG9tJylcbiAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgcGFyZW50U2lkZSAgIFNpZGUgb2YgdGhlIHBhcmVudCBpbiBxdWVzdGlvbiAoJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdHRvbScpXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gICAgICAgICAgICAgICBUaGUgcGFyZW50IHNjcm9sbCBlbGVtZW50IHRoYXQgdGhlIGVsJ3Mgc2lkZSBpcyBzY3JvbGxlZCBwYXN0LCBvciBudWxsIGlmIHRoZXJlIGlzIG5vIHN1Y2ggZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gaXNTY3JvbGxlZFBhc3QoZWwsIGVsU2lkZSwgcGFyZW50U2lkZSkge1xuICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWwsIHRydWUpLFxuICAgICAgZWxTaWRlVmFsID0gZ2V0UmVjdChlbClbZWxTaWRlXTtcbiAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuXG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICB2YXIgcGFyZW50U2lkZVZhbCA9IGdldFJlY3QocGFyZW50KVtwYXJlbnRTaWRlXSxcbiAgICAgICAgdmlzaWJsZSA9IHZvaWQgMDtcblxuICAgIGlmIChwYXJlbnRTaWRlID09PSAndG9wJyB8fCBwYXJlbnRTaWRlID09PSAnbGVmdCcpIHtcbiAgICAgIHZpc2libGUgPSBlbFNpZGVWYWwgPj0gcGFyZW50U2lkZVZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlzaWJsZSA9IGVsU2lkZVZhbCA8PSBwYXJlbnRTaWRlVmFsO1xuICAgIH1cblxuICAgIGlmICghdmlzaWJsZSkgcmV0dXJuIHBhcmVudDtcbiAgICBpZiAocGFyZW50ID09PSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCkpIGJyZWFrO1xuICAgIHBhcmVudCA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KHBhcmVudCwgZmFsc2UpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBHZXRzIG50aCBjaGlsZCBvZiBlbCwgaWdub3JpbmcgaGlkZGVuIGNoaWxkcmVuLCBzb3J0YWJsZSdzIGVsZW1lbnRzIChkb2VzIG5vdCBpZ25vcmUgY2xvbmUgaWYgaXQncyB2aXNpYmxlKVxuICogYW5kIG5vbi1kcmFnZ2FibGUgZWxlbWVudHNcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICAgICBUaGUgcGFyZW50IGVsZW1lbnRcbiAqIEBwYXJhbSAge051bWJlcn0gY2hpbGROdW0gICAgICBUaGUgaW5kZXggb2YgdGhlIGNoaWxkXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgICAgICAgUGFyZW50IFNvcnRhYmxlJ3Mgb3B0aW9uc1xuICogQHJldHVybiB7SFRNTEVsZW1lbnR9ICAgICAgICAgIFRoZSBjaGlsZCBhdCBpbmRleCBjaGlsZE51bSwgb3IgbnVsbCBpZiBub3QgZm91bmRcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldENoaWxkKGVsLCBjaGlsZE51bSwgb3B0aW9ucywgaW5jbHVkZURyYWdFbCkge1xuICB2YXIgY3VycmVudENoaWxkID0gMCxcbiAgICAgIGkgPSAwLFxuICAgICAgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcblxuICB3aGlsZSAoaSA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGlmIChjaGlsZHJlbltpXS5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScgJiYgY2hpbGRyZW5baV0gIT09IFNvcnRhYmxlLmdob3N0ICYmIChpbmNsdWRlRHJhZ0VsIHx8IGNoaWxkcmVuW2ldICE9PSBTb3J0YWJsZS5kcmFnZ2VkKSAmJiBjbG9zZXN0KGNoaWxkcmVuW2ldLCBvcHRpb25zLmRyYWdnYWJsZSwgZWwsIGZhbHNlKSkge1xuICAgICAgaWYgKGN1cnJlbnRDaGlsZCA9PT0gY2hpbGROdW0pIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50Q2hpbGQrKztcbiAgICB9XG5cbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogR2V0cyB0aGUgbGFzdCBjaGlsZCBpbiB0aGUgZWwsIGlnbm9yaW5nIGdob3N0RWwgb3IgaW52aXNpYmxlIGVsZW1lbnRzIChjbG9uZXMpXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgICAgUGFyZW50IGVsZW1lbnRcbiAqIEBwYXJhbSAge3NlbGVjdG9yfSBzZWxlY3RvciAgICBBbnkgb3RoZXIgZWxlbWVudHMgdGhhdCBzaG91bGQgYmUgaWdub3JlZFxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9ICAgICAgICAgIFRoZSBsYXN0IGNoaWxkLCBpZ25vcmluZyBnaG9zdEVsXG4gKi9cblxuXG5mdW5jdGlvbiBsYXN0Q2hpbGQoZWwsIHNlbGVjdG9yKSB7XG4gIHZhciBsYXN0ID0gZWwubGFzdEVsZW1lbnRDaGlsZDtcblxuICB3aGlsZSAobGFzdCAmJiAobGFzdCA9PT0gU29ydGFibGUuZ2hvc3QgfHwgY3NzKGxhc3QsICdkaXNwbGF5JykgPT09ICdub25lJyB8fCBzZWxlY3RvciAmJiAhbWF0Y2hlcyhsYXN0LCBzZWxlY3RvcikpKSB7XG4gICAgbGFzdCA9IGxhc3QucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgfVxuXG4gIHJldHVybiBsYXN0IHx8IG51bGw7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGluZGV4IG9mIGFuIGVsZW1lbnQgd2l0aGluIGl0cyBwYXJlbnQgZm9yIGEgc2VsZWN0ZWQgc2V0IG9mXG4gKiBlbGVtZW50c1xuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsXG4gKiBAcGFyYW0gIHtzZWxlY3Rvcn0gc2VsZWN0b3JcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGluZGV4KGVsLCBzZWxlY3Rvcikge1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIGlmICghZWwgfHwgIWVsLnBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuXG5cbiAgd2hpbGUgKGVsID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZykge1xuICAgIGlmIChlbC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnVEVNUExBVEUnICYmIGVsICE9PSBTb3J0YWJsZS5jbG9uZSAmJiAoIXNlbGVjdG9yIHx8IG1hdGNoZXMoZWwsIHNlbGVjdG9yKSkpIHtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY3JvbGwgb2Zmc2V0IG9mIHRoZSBnaXZlbiBlbGVtZW50LCBhZGRlZCB3aXRoIGFsbCB0aGUgc2Nyb2xsIG9mZnNldHMgb2YgcGFyZW50IGVsZW1lbnRzLlxuICogVGhlIHZhbHVlIGlzIHJldHVybmVkIGluIHJlYWwgcGl4ZWxzLlxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgT2Zmc2V0cyBpbiB0aGUgZm9ybWF0IG9mIFtsZWZ0LCB0b3BdXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVNjcm9sbE9mZnNldChlbCkge1xuICB2YXIgb2Zmc2V0TGVmdCA9IDAsXG4gICAgICBvZmZzZXRUb3AgPSAwLFxuICAgICAgd2luU2Nyb2xsZXIgPSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG5cbiAgaWYgKGVsKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIGVsTWF0cml4ID0gbWF0cml4KGVsKSxcbiAgICAgICAgICBzY2FsZVggPSBlbE1hdHJpeC5hLFxuICAgICAgICAgIHNjYWxlWSA9IGVsTWF0cml4LmQ7XG4gICAgICBvZmZzZXRMZWZ0ICs9IGVsLnNjcm9sbExlZnQgKiBzY2FsZVg7XG4gICAgICBvZmZzZXRUb3AgKz0gZWwuc2Nyb2xsVG9wICogc2NhbGVZO1xuICAgIH0gd2hpbGUgKGVsICE9PSB3aW5TY3JvbGxlciAmJiAoZWwgPSBlbC5wYXJlbnROb2RlKSk7XG4gIH1cblxuICByZXR1cm4gW29mZnNldExlZnQsIG9mZnNldFRvcF07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBvYmplY3Qgd2l0aGluIHRoZSBnaXZlbiBhcnJheVxuICogQHBhcmFtICB7QXJyYXl9IGFyciAgIEFycmF5IHRoYXQgbWF5IG9yIG1heSBub3QgaG9sZCB0aGUgb2JqZWN0XG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iaiAgQW4gb2JqZWN0IHRoYXQgaGFzIGEga2V5LXZhbHVlIHBhaXIgdW5pcXVlIHRvIGFuZCBpZGVudGljYWwgdG8gYSBrZXktdmFsdWUgcGFpciBpbiB0aGUgb2JqZWN0IHlvdSB3YW50IHRvIGZpbmRcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICBUaGUgaW5kZXggb2YgdGhlIG9iamVjdCBpbiB0aGUgYXJyYXksIG9yIC0xXG4gKi9cblxuXG5mdW5jdGlvbiBpbmRleE9mT2JqZWN0KGFyciwgb2JqKSB7XG4gIGZvciAodmFyIGkgaW4gYXJyKSB7XG4gICAgaWYgKCFhcnIuaGFzT3duUHJvcGVydHkoaSkpIGNvbnRpbnVlO1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG9ialtrZXldID09PSBhcnJbaV1ba2V5XSkgcmV0dXJuIE51bWJlcihpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsLCBpbmNsdWRlU2VsZikge1xuICAvLyBza2lwIHRvIHdpbmRvd1xuICBpZiAoIWVsIHx8ICFlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHJldHVybiBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gIHZhciBlbGVtID0gZWw7XG4gIHZhciBnb3RTZWxmID0gZmFsc2U7XG5cbiAgZG8ge1xuICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gZ2V0IGVsZW0gY3NzIGlmIGl0IGlzbid0IGV2ZW4gb3ZlcmZsb3dpbmcgaW4gdGhlIGZpcnN0IHBsYWNlIChwZXJmb3JtYW5jZSlcbiAgICBpZiAoZWxlbS5jbGllbnRXaWR0aCA8IGVsZW0uc2Nyb2xsV2lkdGggfHwgZWxlbS5jbGllbnRIZWlnaHQgPCBlbGVtLnNjcm9sbEhlaWdodCkge1xuICAgICAgdmFyIGVsZW1DU1MgPSBjc3MoZWxlbSk7XG5cbiAgICAgIGlmIChlbGVtLmNsaWVudFdpZHRoIDwgZWxlbS5zY3JvbGxXaWR0aCAmJiAoZWxlbUNTUy5vdmVyZmxvd1ggPT0gJ2F1dG8nIHx8IGVsZW1DU1Mub3ZlcmZsb3dYID09ICdzY3JvbGwnKSB8fCBlbGVtLmNsaWVudEhlaWdodCA8IGVsZW0uc2Nyb2xsSGVpZ2h0ICYmIChlbGVtQ1NTLm92ZXJmbG93WSA9PSAnYXV0bycgfHwgZWxlbUNTUy5vdmVyZmxvd1kgPT0gJ3Njcm9sbCcpKSB7XG4gICAgICAgIGlmICghZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgfHwgZWxlbSA9PT0gZG9jdW1lbnQuYm9keSkgcmV0dXJuIGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgICAgICAgaWYgKGdvdFNlbGYgfHwgaW5jbHVkZVNlbGYpIHJldHVybiBlbGVtO1xuICAgICAgICBnb3RTZWxmID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuXG4gIH0gd2hpbGUgKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpO1xuXG4gIHJldHVybiBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChkc3QsIHNyYykge1xuICBpZiAoZHN0ICYmIHNyYykge1xuICAgIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICAgIGlmIChzcmMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBkc3Rba2V5XSA9IHNyY1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59XG5cbmZ1bmN0aW9uIGlzUmVjdEVxdWFsKHJlY3QxLCByZWN0Mikge1xuICByZXR1cm4gTWF0aC5yb3VuZChyZWN0MS50b3ApID09PSBNYXRoLnJvdW5kKHJlY3QyLnRvcCkgJiYgTWF0aC5yb3VuZChyZWN0MS5sZWZ0KSA9PT0gTWF0aC5yb3VuZChyZWN0Mi5sZWZ0KSAmJiBNYXRoLnJvdW5kKHJlY3QxLmhlaWdodCkgPT09IE1hdGgucm91bmQocmVjdDIuaGVpZ2h0KSAmJiBNYXRoLnJvdW5kKHJlY3QxLndpZHRoKSA9PT0gTWF0aC5yb3VuZChyZWN0Mi53aWR0aCk7XG59XG5cbnZhciBfdGhyb3R0bGVUaW1lb3V0O1xuXG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjaywgbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIV90aHJvdHRsZVRpbWVvdXQpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwoX3RoaXMsIGFyZ3NbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICBfdGhyb3R0bGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aHJvdHRsZVRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICB9LCBtcyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjYW5jZWxUaHJvdHRsZSgpIHtcbiAgY2xlYXJUaW1lb3V0KF90aHJvdHRsZVRpbWVvdXQpO1xuICBfdGhyb3R0bGVUaW1lb3V0ID0gdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBzY3JvbGxCeShlbCwgeCwgeSkge1xuICBlbC5zY3JvbGxMZWZ0ICs9IHg7XG4gIGVsLnNjcm9sbFRvcCArPSB5O1xufVxuXG5mdW5jdGlvbiBjbG9uZShlbCkge1xuICB2YXIgUG9seW1lciA9IHdpbmRvdy5Qb2x5bWVyO1xuICB2YXIgJCA9IHdpbmRvdy5qUXVlcnkgfHwgd2luZG93LlplcHRvO1xuXG4gIGlmIChQb2x5bWVyICYmIFBvbHltZXIuZG9tKSB7XG4gICAgcmV0dXJuIFBvbHltZXIuZG9tKGVsKS5jbG9uZU5vZGUodHJ1ZSk7XG4gIH0gZWxzZSBpZiAoJCkge1xuICAgIHJldHVybiAkKGVsKS5jbG9uZSh0cnVlKVswXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWwuY2xvbmVOb2RlKHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldFJlY3QoZWwsIHJlY3QpIHtcbiAgY3NzKGVsLCAncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcbiAgY3NzKGVsLCAndG9wJywgcmVjdC50b3ApO1xuICBjc3MoZWwsICdsZWZ0JywgcmVjdC5sZWZ0KTtcbiAgY3NzKGVsLCAnd2lkdGgnLCByZWN0LndpZHRoKTtcbiAgY3NzKGVsLCAnaGVpZ2h0JywgcmVjdC5oZWlnaHQpO1xufVxuXG5mdW5jdGlvbiB1bnNldFJlY3QoZWwpIHtcbiAgY3NzKGVsLCAncG9zaXRpb24nLCAnJyk7XG4gIGNzcyhlbCwgJ3RvcCcsICcnKTtcbiAgY3NzKGVsLCAnbGVmdCcsICcnKTtcbiAgY3NzKGVsLCAnd2lkdGgnLCAnJyk7XG4gIGNzcyhlbCwgJ2hlaWdodCcsICcnKTtcbn1cblxudmFyIGV4cGFuZG8gPSAnU29ydGFibGUnICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbmZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlTWFuYWdlcigpIHtcbiAgdmFyIGFuaW1hdGlvblN0YXRlcyA9IFtdLFxuICAgICAgYW5pbWF0aW9uQ2FsbGJhY2tJZDtcbiAgcmV0dXJuIHtcbiAgICBjYXB0dXJlQW5pbWF0aW9uU3RhdGU6IGZ1bmN0aW9uIGNhcHR1cmVBbmltYXRpb25TdGF0ZSgpIHtcbiAgICAgIGFuaW1hdGlvblN0YXRlcyA9IFtdO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKSByZXR1cm47XG4gICAgICB2YXIgY2hpbGRyZW4gPSBbXS5zbGljZS5jYWxsKHRoaXMuZWwuY2hpbGRyZW4pO1xuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNzcyhjaGlsZCwgJ2Rpc3BsYXknKSA9PT0gJ25vbmUnIHx8IGNoaWxkID09PSBTb3J0YWJsZS5naG9zdCkgcmV0dXJuO1xuICAgICAgICBhbmltYXRpb25TdGF0ZXMucHVzaCh7XG4gICAgICAgICAgdGFyZ2V0OiBjaGlsZCxcbiAgICAgICAgICByZWN0OiBnZXRSZWN0KGNoaWxkKVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZnJvbVJlY3QgPSBfb2JqZWN0U3ByZWFkMih7fSwgYW5pbWF0aW9uU3RhdGVzW2FuaW1hdGlvblN0YXRlcy5sZW5ndGggLSAxXS5yZWN0KTsgLy8gSWYgYW5pbWF0aW5nOiBjb21wZW5zYXRlIGZvciBjdXJyZW50IGFuaW1hdGlvblxuXG5cbiAgICAgICAgaWYgKGNoaWxkLnRoaXNBbmltYXRpb25EdXJhdGlvbikge1xuICAgICAgICAgIHZhciBjaGlsZE1hdHJpeCA9IG1hdHJpeChjaGlsZCwgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoY2hpbGRNYXRyaXgpIHtcbiAgICAgICAgICAgIGZyb21SZWN0LnRvcCAtPSBjaGlsZE1hdHJpeC5mO1xuICAgICAgICAgICAgZnJvbVJlY3QubGVmdCAtPSBjaGlsZE1hdHJpeC5lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkLmZyb21SZWN0ID0gZnJvbVJlY3Q7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGFkZEFuaW1hdGlvblN0YXRlOiBmdW5jdGlvbiBhZGRBbmltYXRpb25TdGF0ZShzdGF0ZSkge1xuICAgICAgYW5pbWF0aW9uU3RhdGVzLnB1c2goc3RhdGUpO1xuICAgIH0sXG4gICAgcmVtb3ZlQW5pbWF0aW9uU3RhdGU6IGZ1bmN0aW9uIHJlbW92ZUFuaW1hdGlvblN0YXRlKHRhcmdldCkge1xuICAgICAgYW5pbWF0aW9uU3RhdGVzLnNwbGljZShpbmRleE9mT2JqZWN0KGFuaW1hdGlvblN0YXRlcywge1xuICAgICAgICB0YXJnZXQ6IHRhcmdldFxuICAgICAgfSksIDEpO1xuICAgIH0sXG4gICAgYW5pbWF0ZUFsbDogZnVuY3Rpb24gYW5pbWF0ZUFsbChjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChhbmltYXRpb25DYWxsYmFja0lkKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYW5pbWF0aW5nID0gZmFsc2UsXG4gICAgICAgICAgYW5pbWF0aW9uVGltZSA9IDA7XG4gICAgICBhbmltYXRpb25TdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIHRpbWUgPSAwLFxuICAgICAgICAgICAgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0LFxuICAgICAgICAgICAgZnJvbVJlY3QgPSB0YXJnZXQuZnJvbVJlY3QsXG4gICAgICAgICAgICB0b1JlY3QgPSBnZXRSZWN0KHRhcmdldCksXG4gICAgICAgICAgICBwcmV2RnJvbVJlY3QgPSB0YXJnZXQucHJldkZyb21SZWN0LFxuICAgICAgICAgICAgcHJldlRvUmVjdCA9IHRhcmdldC5wcmV2VG9SZWN0LFxuICAgICAgICAgICAgYW5pbWF0aW5nUmVjdCA9IHN0YXRlLnJlY3QsXG4gICAgICAgICAgICB0YXJnZXRNYXRyaXggPSBtYXRyaXgodGFyZ2V0LCB0cnVlKTtcblxuICAgICAgICBpZiAodGFyZ2V0TWF0cml4KSB7XG4gICAgICAgICAgLy8gQ29tcGVuc2F0ZSBmb3IgY3VycmVudCBhbmltYXRpb25cbiAgICAgICAgICB0b1JlY3QudG9wIC09IHRhcmdldE1hdHJpeC5mO1xuICAgICAgICAgIHRvUmVjdC5sZWZ0IC09IHRhcmdldE1hdHJpeC5lO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0LnRvUmVjdCA9IHRvUmVjdDtcblxuICAgICAgICBpZiAodGFyZ2V0LnRoaXNBbmltYXRpb25EdXJhdGlvbikge1xuICAgICAgICAgIC8vIENvdWxkIGFsc28gY2hlY2sgaWYgYW5pbWF0aW5nUmVjdCBpcyBiZXR3ZWVuIGZyb21SZWN0IGFuZCB0b1JlY3RcbiAgICAgICAgICBpZiAoaXNSZWN0RXF1YWwocHJldkZyb21SZWN0LCB0b1JlY3QpICYmICFpc1JlY3RFcXVhbChmcm9tUmVjdCwgdG9SZWN0KSAmJiAvLyBNYWtlIHN1cmUgYW5pbWF0aW5nUmVjdCBpcyBvbiBsaW5lIGJldHdlZW4gdG9SZWN0ICYgZnJvbVJlY3RcbiAgICAgICAgICAoYW5pbWF0aW5nUmVjdC50b3AgLSB0b1JlY3QudG9wKSAvIChhbmltYXRpbmdSZWN0LmxlZnQgLSB0b1JlY3QubGVmdCkgPT09IChmcm9tUmVjdC50b3AgLSB0b1JlY3QudG9wKSAvIChmcm9tUmVjdC5sZWZ0IC0gdG9SZWN0LmxlZnQpKSB7XG4gICAgICAgICAgICAvLyBJZiByZXR1cm5pbmcgdG8gc2FtZSBwbGFjZSBhcyBzdGFydGVkIGZyb20gYW5pbWF0aW9uIGFuZCBvbiBzYW1lIGF4aXNcbiAgICAgICAgICAgIHRpbWUgPSBjYWxjdWxhdGVSZWFsVGltZShhbmltYXRpbmdSZWN0LCBwcmV2RnJvbVJlY3QsIHByZXZUb1JlY3QsIF90aGlzLm9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBpZiBmcm9tUmVjdCAhPSB0b1JlY3Q6IGFuaW1hdGVcblxuXG4gICAgICAgIGlmICghaXNSZWN0RXF1YWwodG9SZWN0LCBmcm9tUmVjdCkpIHtcbiAgICAgICAgICB0YXJnZXQucHJldkZyb21SZWN0ID0gZnJvbVJlY3Q7XG4gICAgICAgICAgdGFyZ2V0LnByZXZUb1JlY3QgPSB0b1JlY3Q7XG5cbiAgICAgICAgICBpZiAoIXRpbWUpIHtcbiAgICAgICAgICAgIHRpbWUgPSBfdGhpcy5vcHRpb25zLmFuaW1hdGlvbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy5hbmltYXRlKHRhcmdldCwgYW5pbWF0aW5nUmVjdCwgdG9SZWN0LCB0aW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aW1lKSB7XG4gICAgICAgICAgYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBhbmltYXRpb25UaW1lID0gTWF0aC5tYXgoYW5pbWF0aW9uVGltZSwgdGltZSk7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRhcmdldC5hbmltYXRpb25SZXNldFRpbWVyKTtcbiAgICAgICAgICB0YXJnZXQuYW5pbWF0aW9uUmVzZXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGFyZ2V0LmFuaW1hdGlvblRpbWUgPSAwO1xuICAgICAgICAgICAgdGFyZ2V0LnByZXZGcm9tUmVjdCA9IG51bGw7XG4gICAgICAgICAgICB0YXJnZXQuZnJvbVJlY3QgPSBudWxsO1xuICAgICAgICAgICAgdGFyZ2V0LnByZXZUb1JlY3QgPSBudWxsO1xuICAgICAgICAgICAgdGFyZ2V0LnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgfSwgdGltZSk7XG4gICAgICAgICAgdGFyZ2V0LnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IHRpbWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvbkNhbGxiYWNrSWQpO1xuXG4gICAgICBpZiAoIWFuaW1hdGluZykge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5pbWF0aW9uQ2FsbGJhY2tJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG4gICAgICAgIH0sIGFuaW1hdGlvblRpbWUpO1xuICAgICAgfVxuXG4gICAgICBhbmltYXRpb25TdGF0ZXMgPSBbXTtcbiAgICB9LFxuICAgIGFuaW1hdGU6IGZ1bmN0aW9uIGFuaW1hdGUodGFyZ2V0LCBjdXJyZW50UmVjdCwgdG9SZWN0LCBkdXJhdGlvbikge1xuICAgICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2l0aW9uJywgJycpO1xuICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJycpO1xuICAgICAgICB2YXIgZWxNYXRyaXggPSBtYXRyaXgodGhpcy5lbCksXG4gICAgICAgICAgICBzY2FsZVggPSBlbE1hdHJpeCAmJiBlbE1hdHJpeC5hLFxuICAgICAgICAgICAgc2NhbGVZID0gZWxNYXRyaXggJiYgZWxNYXRyaXguZCxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVggPSAoY3VycmVudFJlY3QubGVmdCAtIHRvUmVjdC5sZWZ0KSAvIChzY2FsZVggfHwgMSksXG4gICAgICAgICAgICB0cmFuc2xhdGVZID0gKGN1cnJlbnRSZWN0LnRvcCAtIHRvUmVjdC50b3ApIC8gKHNjYWxlWSB8fCAxKTtcbiAgICAgICAgdGFyZ2V0LmFuaW1hdGluZ1ggPSAhIXRyYW5zbGF0ZVg7XG4gICAgICAgIHRhcmdldC5hbmltYXRpbmdZID0gISF0cmFuc2xhdGVZO1xuICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZTNkKCcgKyB0cmFuc2xhdGVYICsgJ3B4LCcgKyB0cmFuc2xhdGVZICsgJ3B4LDApJyk7XG4gICAgICAgIHRoaXMuZm9yUmVwYWludER1bW15ID0gcmVwYWludCh0YXJnZXQpOyAvLyByZXBhaW50XG5cbiAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zaXRpb24nLCAndHJhbnNmb3JtICcgKyBkdXJhdGlvbiArICdtcycgKyAodGhpcy5vcHRpb25zLmVhc2luZyA/ICcgJyArIHRoaXMub3B0aW9ucy5lYXNpbmcgOiAnJykpO1xuICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZTNkKDAsMCwwKScpO1xuICAgICAgICB0eXBlb2YgdGFyZ2V0LmFuaW1hdGVkID09PSAnbnVtYmVyJyAmJiBjbGVhclRpbWVvdXQodGFyZ2V0LmFuaW1hdGVkKTtcbiAgICAgICAgdGFyZ2V0LmFuaW1hdGVkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zZm9ybScsICcnKTtcbiAgICAgICAgICB0YXJnZXQuYW5pbWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0YXJnZXQuYW5pbWF0aW5nWCA9IGZhbHNlO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRpbmdZID0gZmFsc2U7XG4gICAgICAgIH0sIGR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlcGFpbnQodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQub2Zmc2V0V2lkdGg7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJlYWxUaW1lKGFuaW1hdGluZ1JlY3QsIGZyb21SZWN0LCB0b1JlY3QsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhmcm9tUmVjdC50b3AgLSBhbmltYXRpbmdSZWN0LnRvcCwgMikgKyBNYXRoLnBvdyhmcm9tUmVjdC5sZWZ0IC0gYW5pbWF0aW5nUmVjdC5sZWZ0LCAyKSkgLyBNYXRoLnNxcnQoTWF0aC5wb3coZnJvbVJlY3QudG9wIC0gdG9SZWN0LnRvcCwgMikgKyBNYXRoLnBvdyhmcm9tUmVjdC5sZWZ0IC0gdG9SZWN0LmxlZnQsIDIpKSAqIG9wdGlvbnMuYW5pbWF0aW9uO1xufVxuXG52YXIgcGx1Z2lucyA9IFtdO1xudmFyIGRlZmF1bHRzID0ge1xuICBpbml0aWFsaXplQnlEZWZhdWx0OiB0cnVlXG59O1xudmFyIFBsdWdpbk1hbmFnZXIgPSB7XG4gIG1vdW50OiBmdW5jdGlvbiBtb3VudChwbHVnaW4pIHtcbiAgICAvLyBTZXQgZGVmYXVsdCBzdGF0aWMgcHJvcGVydGllc1xuICAgIGZvciAodmFyIG9wdGlvbiBpbiBkZWZhdWx0cykge1xuICAgICAgaWYgKGRlZmF1bHRzLmhhc093blByb3BlcnR5KG9wdGlvbikgJiYgIShvcHRpb24gaW4gcGx1Z2luKSkge1xuICAgICAgICBwbHVnaW5bb3B0aW9uXSA9IGRlZmF1bHRzW29wdGlvbl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICBpZiAocC5wbHVnaW5OYW1lID09PSBwbHVnaW4ucGx1Z2luTmFtZSkge1xuICAgICAgICB0aHJvdyBcIlNvcnRhYmxlOiBDYW5ub3QgbW91bnQgcGx1Z2luIFwiLmNvbmNhdChwbHVnaW4ucGx1Z2luTmFtZSwgXCIgbW9yZSB0aGFuIG9uY2VcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gIH0sXG4gIHBsdWdpbkV2ZW50OiBmdW5jdGlvbiBwbHVnaW5FdmVudChldmVudE5hbWUsIHNvcnRhYmxlLCBldnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5ldmVudENhbmNlbGVkID0gZmFsc2U7XG5cbiAgICBldnQuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuZXZlbnRDYW5jZWxlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIHZhciBldmVudE5hbWVHbG9iYWwgPSBldmVudE5hbWUgKyAnR2xvYmFsJztcbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgaWYgKCFzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV0pIHJldHVybjsgLy8gRmlyZSBnbG9iYWwgZXZlbnRzIGlmIGl0IGV4aXN0cyBpbiB0aGlzIHNvcnRhYmxlXG5cbiAgICAgIGlmIChzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV1bZXZlbnROYW1lR2xvYmFsXSkge1xuICAgICAgICBzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV1bZXZlbnROYW1lR2xvYmFsXShfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlXG4gICAgICAgIH0sIGV2dCkpO1xuICAgICAgfSAvLyBPbmx5IGZpcmUgcGx1Z2luIGV2ZW50IGlmIHBsdWdpbiBpcyBlbmFibGVkIGluIHRoaXMgc29ydGFibGUsXG4gICAgICAvLyBhbmQgcGx1Z2luIGhhcyBldmVudCBkZWZpbmVkXG5cblxuICAgICAgaWYgKHNvcnRhYmxlLm9wdGlvbnNbcGx1Z2luLnBsdWdpbk5hbWVdICYmIHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVdKSB7XG4gICAgICAgIHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVdKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGVcbiAgICAgICAgfSwgZXZ0KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGluaXRpYWxpemVQbHVnaW5zOiBmdW5jdGlvbiBpbml0aWFsaXplUGx1Z2lucyhzb3J0YWJsZSwgZWwsIGRlZmF1bHRzLCBvcHRpb25zKSB7XG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIHZhciBwbHVnaW5OYW1lID0gcGx1Z2luLnBsdWdpbk5hbWU7XG4gICAgICBpZiAoIXNvcnRhYmxlLm9wdGlvbnNbcGx1Z2luTmFtZV0gJiYgIXBsdWdpbi5pbml0aWFsaXplQnlEZWZhdWx0KSByZXR1cm47XG4gICAgICB2YXIgaW5pdGlhbGl6ZWQgPSBuZXcgcGx1Z2luKHNvcnRhYmxlLCBlbCwgc29ydGFibGUub3B0aW9ucyk7XG4gICAgICBpbml0aWFsaXplZC5zb3J0YWJsZSA9IHNvcnRhYmxlO1xuICAgICAgaW5pdGlhbGl6ZWQub3B0aW9ucyA9IHNvcnRhYmxlLm9wdGlvbnM7XG4gICAgICBzb3J0YWJsZVtwbHVnaW5OYW1lXSA9IGluaXRpYWxpemVkOyAvLyBBZGQgZGVmYXVsdCBvcHRpb25zIGZyb20gcGx1Z2luXG5cbiAgICAgIF9leHRlbmRzKGRlZmF1bHRzLCBpbml0aWFsaXplZC5kZWZhdWx0cyk7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBvcHRpb24gaW4gc29ydGFibGUub3B0aW9ucykge1xuICAgICAgaWYgKCFzb3J0YWJsZS5vcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbikpIGNvbnRpbnVlO1xuICAgICAgdmFyIG1vZGlmaWVkID0gdGhpcy5tb2RpZnlPcHRpb24oc29ydGFibGUsIG9wdGlvbiwgc29ydGFibGUub3B0aW9uc1tvcHRpb25dKTtcblxuICAgICAgaWYgKHR5cGVvZiBtb2RpZmllZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc29ydGFibGUub3B0aW9uc1tvcHRpb25dID0gbW9kaWZpZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBnZXRFdmVudFByb3BlcnRpZXM6IGZ1bmN0aW9uIGdldEV2ZW50UHJvcGVydGllcyhuYW1lLCBzb3J0YWJsZSkge1xuICAgIHZhciBldmVudFByb3BlcnRpZXMgPSB7fTtcbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgaWYgKHR5cGVvZiBwbHVnaW4uZXZlbnRQcm9wZXJ0aWVzICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG5cbiAgICAgIF9leHRlbmRzKGV2ZW50UHJvcGVydGllcywgcGx1Z2luLmV2ZW50UHJvcGVydGllcy5jYWxsKHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXSwgbmFtZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBldmVudFByb3BlcnRpZXM7XG4gIH0sXG4gIG1vZGlmeU9wdGlvbjogZnVuY3Rpb24gbW9kaWZ5T3B0aW9uKHNvcnRhYmxlLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBtb2RpZmllZFZhbHVlO1xuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAvLyBQbHVnaW4gbXVzdCBleGlzdCBvbiB0aGUgU29ydGFibGVcbiAgICAgIGlmICghc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdKSByZXR1cm47IC8vIElmIHN0YXRpYyBvcHRpb24gbGlzdGVuZXIgZXhpc3RzIGZvciB0aGlzIG9wdGlvbiwgY2FsbCBpbiB0aGUgY29udGV4dCBvZiB0aGUgU29ydGFibGUncyBpbnN0YW5jZSBvZiB0aGlzIHBsdWdpblxuXG4gICAgICBpZiAocGx1Z2luLm9wdGlvbkxpc3RlbmVycyAmJiB0eXBlb2YgcGx1Z2luLm9wdGlvbkxpc3RlbmVyc1tuYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtb2RpZmllZFZhbHVlID0gcGx1Z2luLm9wdGlvbkxpc3RlbmVyc1tuYW1lXS5jYWxsKHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtb2RpZmllZFZhbHVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KF9yZWYpIHtcbiAgdmFyIHNvcnRhYmxlID0gX3JlZi5zb3J0YWJsZSxcbiAgICAgIHJvb3RFbCA9IF9yZWYucm9vdEVsLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIHRhcmdldEVsID0gX3JlZi50YXJnZXRFbCxcbiAgICAgIGNsb25lRWwgPSBfcmVmLmNsb25lRWwsXG4gICAgICB0b0VsID0gX3JlZi50b0VsLFxuICAgICAgZnJvbUVsID0gX3JlZi5mcm9tRWwsXG4gICAgICBvbGRJbmRleCA9IF9yZWYub2xkSW5kZXgsXG4gICAgICBuZXdJbmRleCA9IF9yZWYubmV3SW5kZXgsXG4gICAgICBvbGREcmFnZ2FibGVJbmRleCA9IF9yZWYub2xkRHJhZ2dhYmxlSW5kZXgsXG4gICAgICBuZXdEcmFnZ2FibGVJbmRleCA9IF9yZWYubmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgICBvcmlnaW5hbEV2ZW50ID0gX3JlZi5vcmlnaW5hbEV2ZW50LFxuICAgICAgcHV0U29ydGFibGUgPSBfcmVmLnB1dFNvcnRhYmxlLFxuICAgICAgZXh0cmFFdmVudFByb3BlcnRpZXMgPSBfcmVmLmV4dHJhRXZlbnRQcm9wZXJ0aWVzO1xuICBzb3J0YWJsZSA9IHNvcnRhYmxlIHx8IHJvb3RFbCAmJiByb290RWxbZXhwYW5kb107XG4gIGlmICghc29ydGFibGUpIHJldHVybjtcbiAgdmFyIGV2dCxcbiAgICAgIG9wdGlvbnMgPSBzb3J0YWJsZS5vcHRpb25zLFxuICAgICAgb25OYW1lID0gJ29uJyArIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cigxKTsgLy8gU3VwcG9ydCBmb3IgbmV3IEN1c3RvbUV2ZW50IGZlYXR1cmVcblxuICBpZiAod2luZG93LkN1c3RvbUV2ZW50ICYmICFJRTExT3JMZXNzICYmICFFZGdlKSB7XG4gICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KG5hbWUsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZ0LmluaXRFdmVudChuYW1lLCB0cnVlLCB0cnVlKTtcbiAgfVxuXG4gIGV2dC50byA9IHRvRWwgfHwgcm9vdEVsO1xuICBldnQuZnJvbSA9IGZyb21FbCB8fCByb290RWw7XG4gIGV2dC5pdGVtID0gdGFyZ2V0RWwgfHwgcm9vdEVsO1xuICBldnQuY2xvbmUgPSBjbG9uZUVsO1xuICBldnQub2xkSW5kZXggPSBvbGRJbmRleDtcbiAgZXZ0Lm5ld0luZGV4ID0gbmV3SW5kZXg7XG4gIGV2dC5vbGREcmFnZ2FibGVJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4O1xuICBldnQubmV3RHJhZ2dhYmxlSW5kZXggPSBuZXdEcmFnZ2FibGVJbmRleDtcbiAgZXZ0Lm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuICBldnQucHVsbE1vZGUgPSBwdXRTb3J0YWJsZSA/IHB1dFNvcnRhYmxlLmxhc3RQdXRNb2RlIDogdW5kZWZpbmVkO1xuXG4gIHZhciBhbGxFdmVudFByb3BlcnRpZXMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZXh0cmFFdmVudFByb3BlcnRpZXMpLCBQbHVnaW5NYW5hZ2VyLmdldEV2ZW50UHJvcGVydGllcyhuYW1lLCBzb3J0YWJsZSkpO1xuXG4gIGZvciAodmFyIG9wdGlvbiBpbiBhbGxFdmVudFByb3BlcnRpZXMpIHtcbiAgICBldnRbb3B0aW9uXSA9IGFsbEV2ZW50UHJvcGVydGllc1tvcHRpb25dO1xuICB9XG5cbiAgaWYgKHJvb3RFbCkge1xuICAgIHJvb3RFbC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gIH1cblxuICBpZiAob3B0aW9uc1tvbk5hbWVdKSB7XG4gICAgb3B0aW9uc1tvbk5hbWVdLmNhbGwoc29ydGFibGUsIGV2dCk7XG4gIH1cbn1cblxudmFyIF9leGNsdWRlZCA9IFtcImV2dFwiXTtcblxudmFyIHBsdWdpbkV2ZW50ID0gZnVuY3Rpb24gcGx1Z2luRXZlbnQoZXZlbnROYW1lLCBzb3J0YWJsZSkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgICBvcmlnaW5hbEV2ZW50ID0gX3JlZi5ldnQsXG4gICAgICBkYXRhID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG5cbiAgUGx1Z2luTWFuYWdlci5wbHVnaW5FdmVudC5iaW5kKFNvcnRhYmxlKShldmVudE5hbWUsIHNvcnRhYmxlLCBfb2JqZWN0U3ByZWFkMih7XG4gICAgZHJhZ0VsOiBkcmFnRWwsXG4gICAgcGFyZW50RWw6IHBhcmVudEVsLFxuICAgIGdob3N0RWw6IGdob3N0RWwsXG4gICAgcm9vdEVsOiByb290RWwsXG4gICAgbmV4dEVsOiBuZXh0RWwsXG4gICAgbGFzdERvd25FbDogbGFzdERvd25FbCxcbiAgICBjbG9uZUVsOiBjbG9uZUVsLFxuICAgIGNsb25lSGlkZGVuOiBjbG9uZUhpZGRlbixcbiAgICBkcmFnU3RhcnRlZDogbW92ZWQsXG4gICAgcHV0U29ydGFibGU6IHB1dFNvcnRhYmxlLFxuICAgIGFjdGl2ZVNvcnRhYmxlOiBTb3J0YWJsZS5hY3RpdmUsXG4gICAgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudCxcbiAgICBvbGRJbmRleDogb2xkSW5kZXgsXG4gICAgb2xkRHJhZ2dhYmxlSW5kZXg6IG9sZERyYWdnYWJsZUluZGV4LFxuICAgIG5ld0luZGV4OiBuZXdJbmRleCxcbiAgICBuZXdEcmFnZ2FibGVJbmRleDogbmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgaGlkZUdob3N0Rm9yVGFyZ2V0OiBfaGlkZUdob3N0Rm9yVGFyZ2V0LFxuICAgIHVuaGlkZUdob3N0Rm9yVGFyZ2V0OiBfdW5oaWRlR2hvc3RGb3JUYXJnZXQsXG4gICAgY2xvbmVOb3dIaWRkZW46IGZ1bmN0aW9uIGNsb25lTm93SGlkZGVuKCkge1xuICAgICAgY2xvbmVIaWRkZW4gPSB0cnVlO1xuICAgIH0sXG4gICAgY2xvbmVOb3dTaG93bjogZnVuY3Rpb24gY2xvbmVOb3dTaG93bigpIHtcbiAgICAgIGNsb25lSGlkZGVuID0gZmFsc2U7XG4gICAgfSxcbiAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQ6IGZ1bmN0aW9uIGRpc3BhdGNoU29ydGFibGVFdmVudChuYW1lKSB7XG4gICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBkYXRhKSk7XG59O1xuXG5mdW5jdGlvbiBfZGlzcGF0Y2hFdmVudChpbmZvKSB7XG4gIGRpc3BhdGNoRXZlbnQoX29iamVjdFNwcmVhZDIoe1xuICAgIHB1dFNvcnRhYmxlOiBwdXRTb3J0YWJsZSxcbiAgICBjbG9uZUVsOiBjbG9uZUVsLFxuICAgIHRhcmdldEVsOiBkcmFnRWwsXG4gICAgcm9vdEVsOiByb290RWwsXG4gICAgb2xkSW5kZXg6IG9sZEluZGV4LFxuICAgIG9sZERyYWdnYWJsZUluZGV4OiBvbGREcmFnZ2FibGVJbmRleCxcbiAgICBuZXdJbmRleDogbmV3SW5kZXgsXG4gICAgbmV3RHJhZ2dhYmxlSW5kZXg6IG5ld0RyYWdnYWJsZUluZGV4XG4gIH0sIGluZm8pKTtcbn1cblxudmFyIGRyYWdFbCxcbiAgICBwYXJlbnRFbCxcbiAgICBnaG9zdEVsLFxuICAgIHJvb3RFbCxcbiAgICBuZXh0RWwsXG4gICAgbGFzdERvd25FbCxcbiAgICBjbG9uZUVsLFxuICAgIGNsb25lSGlkZGVuLFxuICAgIG9sZEluZGV4LFxuICAgIG5ld0luZGV4LFxuICAgIG9sZERyYWdnYWJsZUluZGV4LFxuICAgIG5ld0RyYWdnYWJsZUluZGV4LFxuICAgIGFjdGl2ZUdyb3VwLFxuICAgIHB1dFNvcnRhYmxlLFxuICAgIGF3YWl0aW5nRHJhZ1N0YXJ0ZWQgPSBmYWxzZSxcbiAgICBpZ25vcmVOZXh0Q2xpY2sgPSBmYWxzZSxcbiAgICBzb3J0YWJsZXMgPSBbXSxcbiAgICB0YXBFdnQsXG4gICAgdG91Y2hFdnQsXG4gICAgbGFzdER4LFxuICAgIGxhc3REeSxcbiAgICB0YXBEaXN0YW5jZUxlZnQsXG4gICAgdGFwRGlzdGFuY2VUb3AsXG4gICAgbW92ZWQsXG4gICAgbGFzdFRhcmdldCxcbiAgICBsYXN0RGlyZWN0aW9uLFxuICAgIHBhc3RGaXJzdEludmVydFRocmVzaCA9IGZhbHNlLFxuICAgIGlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQgPSBmYWxzZSxcbiAgICB0YXJnZXRNb3ZlRGlzdGFuY2UsXG4gICAgLy8gRm9yIHBvc2l0aW9uaW5nIGdob3N0IGFic29sdXRlbHlcbmdob3N0UmVsYXRpdmVQYXJlbnQsXG4gICAgZ2hvc3RSZWxhdGl2ZVBhcmVudEluaXRpYWxTY3JvbGwgPSBbXSxcbiAgICAvLyAobGVmdCwgdG9wKVxuX3NpbGVudCA9IGZhbHNlLFxuICAgIHNhdmVkSW5wdXRDaGVja2VkID0gW107XG4vKiogQGNvbnN0ICovXG5cbnZhciBkb2N1bWVudEV4aXN0cyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcsXG4gICAgUG9zaXRpb25HaG9zdEFic29sdXRlbHkgPSBJT1MsXG4gICAgQ1NTRmxvYXRQcm9wZXJ0eSA9IEVkZ2UgfHwgSUUxMU9yTGVzcyA/ICdjc3NGbG9hdCcgOiAnZmxvYXQnLFxuICAgIC8vIFRoaXMgd2lsbCBub3QgcGFzcyBmb3IgSUU5LCBiZWNhdXNlIElFOSBEbkQgb25seSB3b3JrcyBvbiBhbmNob3JzXG5zdXBwb3J0RHJhZ2dhYmxlID0gZG9jdW1lbnRFeGlzdHMgJiYgIUNocm9tZUZvckFuZHJvaWQgJiYgIUlPUyAmJiAnZHJhZ2dhYmxlJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICBzdXBwb3J0Q3NzUG9pbnRlckV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCFkb2N1bWVudEV4aXN0cykgcmV0dXJuOyAvLyBmYWxzZSB3aGVuIDw9IElFMTFcblxuICBpZiAoSUUxMU9yTGVzcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3gnKTtcbiAgZWwuc3R5bGUuY3NzVGV4dCA9ICdwb2ludGVyLWV2ZW50czphdXRvJztcbiAgcmV0dXJuIGVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPT09ICdhdXRvJztcbn0oKSxcbiAgICBfZGV0ZWN0RGlyZWN0aW9uID0gZnVuY3Rpb24gX2RldGVjdERpcmVjdGlvbihlbCwgb3B0aW9ucykge1xuICB2YXIgZWxDU1MgPSBjc3MoZWwpLFxuICAgICAgZWxXaWR0aCA9IHBhcnNlSW50KGVsQ1NTLndpZHRoKSAtIHBhcnNlSW50KGVsQ1NTLnBhZGRpbmdMZWZ0KSAtIHBhcnNlSW50KGVsQ1NTLnBhZGRpbmdSaWdodCkgLSBwYXJzZUludChlbENTUy5ib3JkZXJMZWZ0V2lkdGgpIC0gcGFyc2VJbnQoZWxDU1MuYm9yZGVyUmlnaHRXaWR0aCksXG4gICAgICBjaGlsZDEgPSBnZXRDaGlsZChlbCwgMCwgb3B0aW9ucyksXG4gICAgICBjaGlsZDIgPSBnZXRDaGlsZChlbCwgMSwgb3B0aW9ucyksXG4gICAgICBmaXJzdENoaWxkQ1NTID0gY2hpbGQxICYmIGNzcyhjaGlsZDEpLFxuICAgICAgc2Vjb25kQ2hpbGRDU1MgPSBjaGlsZDIgJiYgY3NzKGNoaWxkMiksXG4gICAgICBmaXJzdENoaWxkV2lkdGggPSBmaXJzdENoaWxkQ1NTICYmIHBhcnNlSW50KGZpcnN0Q2hpbGRDU1MubWFyZ2luTGVmdCkgKyBwYXJzZUludChmaXJzdENoaWxkQ1NTLm1hcmdpblJpZ2h0KSArIGdldFJlY3QoY2hpbGQxKS53aWR0aCxcbiAgICAgIHNlY29uZENoaWxkV2lkdGggPSBzZWNvbmRDaGlsZENTUyAmJiBwYXJzZUludChzZWNvbmRDaGlsZENTUy5tYXJnaW5MZWZ0KSArIHBhcnNlSW50KHNlY29uZENoaWxkQ1NTLm1hcmdpblJpZ2h0KSArIGdldFJlY3QoY2hpbGQyKS53aWR0aDtcblxuICBpZiAoZWxDU1MuZGlzcGxheSA9PT0gJ2ZsZXgnKSB7XG4gICAgcmV0dXJuIGVsQ1NTLmZsZXhEaXJlY3Rpb24gPT09ICdjb2x1bW4nIHx8IGVsQ1NTLmZsZXhEaXJlY3Rpb24gPT09ICdjb2x1bW4tcmV2ZXJzZScgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICB9XG5cbiAgaWYgKGVsQ1NTLmRpc3BsYXkgPT09ICdncmlkJykge1xuICAgIHJldHVybiBlbENTUy5ncmlkVGVtcGxhdGVDb2x1bW5zLnNwbGl0KCcgJykubGVuZ3RoIDw9IDEgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICB9XG5cbiAgaWYgKGNoaWxkMSAmJiBmaXJzdENoaWxkQ1NTW1wiZmxvYXRcIl0gJiYgZmlyc3RDaGlsZENTU1tcImZsb2F0XCJdICE9PSAnbm9uZScpIHtcbiAgICB2YXIgdG91Y2hpbmdTaWRlQ2hpbGQyID0gZmlyc3RDaGlsZENTU1tcImZsb2F0XCJdID09PSAnbGVmdCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIHJldHVybiBjaGlsZDIgJiYgKHNlY29uZENoaWxkQ1NTLmNsZWFyID09PSAnYm90aCcgfHwgc2Vjb25kQ2hpbGRDU1MuY2xlYXIgPT09IHRvdWNoaW5nU2lkZUNoaWxkMikgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkMSAmJiAoZmlyc3RDaGlsZENTUy5kaXNwbGF5ID09PSAnYmxvY2snIHx8IGZpcnN0Q2hpbGRDU1MuZGlzcGxheSA9PT0gJ2ZsZXgnIHx8IGZpcnN0Q2hpbGRDU1MuZGlzcGxheSA9PT0gJ3RhYmxlJyB8fCBmaXJzdENoaWxkQ1NTLmRpc3BsYXkgPT09ICdncmlkJyB8fCBmaXJzdENoaWxkV2lkdGggPj0gZWxXaWR0aCAmJiBlbENTU1tDU1NGbG9hdFByb3BlcnR5XSA9PT0gJ25vbmUnIHx8IGNoaWxkMiAmJiBlbENTU1tDU1NGbG9hdFByb3BlcnR5XSA9PT0gJ25vbmUnICYmIGZpcnN0Q2hpbGRXaWR0aCArIHNlY29uZENoaWxkV2lkdGggPiBlbFdpZHRoKSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG59LFxuICAgIF9kcmFnRWxJblJvd0NvbHVtbiA9IGZ1bmN0aW9uIF9kcmFnRWxJblJvd0NvbHVtbihkcmFnUmVjdCwgdGFyZ2V0UmVjdCwgdmVydGljYWwpIHtcbiAgdmFyIGRyYWdFbFMxT3BwID0gdmVydGljYWwgPyBkcmFnUmVjdC5sZWZ0IDogZHJhZ1JlY3QudG9wLFxuICAgICAgZHJhZ0VsUzJPcHAgPSB2ZXJ0aWNhbCA/IGRyYWdSZWN0LnJpZ2h0IDogZHJhZ1JlY3QuYm90dG9tLFxuICAgICAgZHJhZ0VsT3BwTGVuZ3RoID0gdmVydGljYWwgPyBkcmFnUmVjdC53aWR0aCA6IGRyYWdSZWN0LmhlaWdodCxcbiAgICAgIHRhcmdldFMxT3BwID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LmxlZnQgOiB0YXJnZXRSZWN0LnRvcCxcbiAgICAgIHRhcmdldFMyT3BwID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LnJpZ2h0IDogdGFyZ2V0UmVjdC5ib3R0b20sXG4gICAgICB0YXJnZXRPcHBMZW5ndGggPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3Qud2lkdGggOiB0YXJnZXRSZWN0LmhlaWdodDtcbiAgcmV0dXJuIGRyYWdFbFMxT3BwID09PSB0YXJnZXRTMU9wcCB8fCBkcmFnRWxTMk9wcCA9PT0gdGFyZ2V0UzJPcHAgfHwgZHJhZ0VsUzFPcHAgKyBkcmFnRWxPcHBMZW5ndGggLyAyID09PSB0YXJnZXRTMU9wcCArIHRhcmdldE9wcExlbmd0aCAvIDI7XG59LFxuXG4vKipcclxuICogRGV0ZWN0cyBmaXJzdCBuZWFyZXN0IGVtcHR5IHNvcnRhYmxlIHRvIFggYW5kIFkgcG9zaXRpb24gdXNpbmcgZW1wdHlJbnNlcnRUaHJlc2hvbGQuXHJcbiAqIEBwYXJhbSAge051bWJlcn0geCAgICAgIFggcG9zaXRpb25cclxuICogQHBhcmFtICB7TnVtYmVyfSB5ICAgICAgWSBwb3NpdGlvblxyXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gICBFbGVtZW50IG9mIHRoZSBmaXJzdCBmb3VuZCBuZWFyZXN0IFNvcnRhYmxlXHJcbiAqL1xuX2RldGVjdE5lYXJlc3RFbXB0eVNvcnRhYmxlID0gZnVuY3Rpb24gX2RldGVjdE5lYXJlc3RFbXB0eVNvcnRhYmxlKHgsIHkpIHtcbiAgdmFyIHJldDtcbiAgc29ydGFibGVzLnNvbWUoZnVuY3Rpb24gKHNvcnRhYmxlKSB7XG4gICAgdmFyIHRocmVzaG9sZCA9IHNvcnRhYmxlW2V4cGFuZG9dLm9wdGlvbnMuZW1wdHlJbnNlcnRUaHJlc2hvbGQ7XG4gICAgaWYgKCF0aHJlc2hvbGQgfHwgbGFzdENoaWxkKHNvcnRhYmxlKSkgcmV0dXJuO1xuICAgIHZhciByZWN0ID0gZ2V0UmVjdChzb3J0YWJsZSksXG4gICAgICAgIGluc2lkZUhvcml6b250YWxseSA9IHggPj0gcmVjdC5sZWZ0IC0gdGhyZXNob2xkICYmIHggPD0gcmVjdC5yaWdodCArIHRocmVzaG9sZCxcbiAgICAgICAgaW5zaWRlVmVydGljYWxseSA9IHkgPj0gcmVjdC50b3AgLSB0aHJlc2hvbGQgJiYgeSA8PSByZWN0LmJvdHRvbSArIHRocmVzaG9sZDtcblxuICAgIGlmIChpbnNpZGVIb3Jpem9udGFsbHkgJiYgaW5zaWRlVmVydGljYWxseSkge1xuICAgICAgcmV0dXJuIHJldCA9IHNvcnRhYmxlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXQ7XG59LFxuICAgIF9wcmVwYXJlR3JvdXAgPSBmdW5jdGlvbiBfcHJlcGFyZUdyb3VwKG9wdGlvbnMpIHtcbiAgZnVuY3Rpb24gdG9Gbih2YWx1ZSwgcHVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodG8sIGZyb20sIGRyYWdFbCwgZXZ0KSB7XG4gICAgICB2YXIgc2FtZUdyb3VwID0gdG8ub3B0aW9ucy5ncm91cC5uYW1lICYmIGZyb20ub3B0aW9ucy5ncm91cC5uYW1lICYmIHRvLm9wdGlvbnMuZ3JvdXAubmFtZSA9PT0gZnJvbS5vcHRpb25zLmdyb3VwLm5hbWU7XG5cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmIChwdWxsIHx8IHNhbWVHcm91cCkpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBwdWxsIHZhbHVlXG4gICAgICAgIC8vIERlZmF1bHQgcHVsbCBhbmQgcHV0IHZhbHVlIGlmIHNhbWUgZ3JvdXBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAocHVsbCAmJiB2YWx1ZSA9PT0gJ2Nsb25lJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdG9Gbih2YWx1ZSh0bywgZnJvbSwgZHJhZ0VsLCBldnQpLCBwdWxsKSh0bywgZnJvbSwgZHJhZ0VsLCBldnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG90aGVyR3JvdXAgPSAocHVsbCA/IHRvIDogZnJvbSkub3B0aW9ucy5ncm91cC5uYW1lO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZSA9PT0gb3RoZXJHcm91cCB8fCB2YWx1ZS5qb2luICYmIHZhbHVlLmluZGV4T2Yob3RoZXJHcm91cCkgPiAtMTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGdyb3VwID0ge307XG4gIHZhciBvcmlnaW5hbEdyb3VwID0gb3B0aW9ucy5ncm91cDtcblxuICBpZiAoIW9yaWdpbmFsR3JvdXAgfHwgX3R5cGVvZihvcmlnaW5hbEdyb3VwKSAhPSAnb2JqZWN0Jykge1xuICAgIG9yaWdpbmFsR3JvdXAgPSB7XG4gICAgICBuYW1lOiBvcmlnaW5hbEdyb3VwXG4gICAgfTtcbiAgfVxuXG4gIGdyb3VwLm5hbWUgPSBvcmlnaW5hbEdyb3VwLm5hbWU7XG4gIGdyb3VwLmNoZWNrUHVsbCA9IHRvRm4ob3JpZ2luYWxHcm91cC5wdWxsLCB0cnVlKTtcbiAgZ3JvdXAuY2hlY2tQdXQgPSB0b0ZuKG9yaWdpbmFsR3JvdXAucHV0KTtcbiAgZ3JvdXAucmV2ZXJ0Q2xvbmUgPSBvcmlnaW5hbEdyb3VwLnJldmVydENsb25lO1xuICBvcHRpb25zLmdyb3VwID0gZ3JvdXA7XG59LFxuICAgIF9oaWRlR2hvc3RGb3JUYXJnZXQgPSBmdW5jdGlvbiBfaGlkZUdob3N0Rm9yVGFyZ2V0KCkge1xuICBpZiAoIXN1cHBvcnRDc3NQb2ludGVyRXZlbnRzICYmIGdob3N0RWwpIHtcbiAgICBjc3MoZ2hvc3RFbCwgJ2Rpc3BsYXknLCAnbm9uZScpO1xuICB9XG59LFxuICAgIF91bmhpZGVHaG9zdEZvclRhcmdldCA9IGZ1bmN0aW9uIF91bmhpZGVHaG9zdEZvclRhcmdldCgpIHtcbiAgaWYgKCFzdXBwb3J0Q3NzUG9pbnRlckV2ZW50cyAmJiBnaG9zdEVsKSB7XG4gICAgY3NzKGdob3N0RWwsICdkaXNwbGF5JywgJycpO1xuICB9XG59OyAvLyAjMTE4NCBmaXggLSBQcmV2ZW50IGNsaWNrIGV2ZW50IG9uIGZhbGxiYWNrIGlmIGRyYWdnZWQgYnV0IGl0ZW0gbm90IGNoYW5nZWQgcG9zaXRpb25cblxuXG5pZiAoZG9jdW1lbnRFeGlzdHMgJiYgIUNocm9tZUZvckFuZHJvaWQpIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgaWYgKGlnbm9yZU5leHRDbGljaykge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uICYmIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2dC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gJiYgZXZ0LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgaWdub3JlTmV4dENsaWNrID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB0cnVlKTtcbn1cblxudmFyIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50ID0gZnVuY3Rpb24gbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQoZXZ0KSB7XG4gIGlmIChkcmFnRWwpIHtcbiAgICBldnQgPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0O1xuXG4gICAgdmFyIG5lYXJlc3QgPSBfZGV0ZWN0TmVhcmVzdEVtcHR5U29ydGFibGUoZXZ0LmNsaWVudFgsIGV2dC5jbGllbnRZKTtcblxuICAgIGlmIChuZWFyZXN0KSB7XG4gICAgICAvLyBDcmVhdGUgaW1pdGF0aW9uIGV2ZW50XG4gICAgICB2YXIgZXZlbnQgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSBpbiBldnQpIHtcbiAgICAgICAgaWYgKGV2dC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIGV2ZW50W2ldID0gZXZ0W2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnRhcmdldCA9IGV2ZW50LnJvb3RFbCA9IG5lYXJlc3Q7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IHZvaWQgMDtcblxuICAgICAgbmVhcmVzdFtleHBhbmRvXS5fb25EcmFnT3ZlcihldmVudCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgX2NoZWNrT3V0c2lkZVRhcmdldEVsID0gZnVuY3Rpb24gX2NoZWNrT3V0c2lkZVRhcmdldEVsKGV2dCkge1xuICBpZiAoZHJhZ0VsKSB7XG4gICAgZHJhZ0VsLnBhcmVudE5vZGVbZXhwYW5kb10uX2lzT3V0c2lkZVRoaXNFbChldnQudGFyZ2V0KTtcbiAgfVxufTtcbi8qKlxyXG4gKiBAY2xhc3MgIFNvcnRhYmxlXHJcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSAgZWxcclxuICogQHBhcmFtICB7T2JqZWN0fSAgICAgICBbb3B0aW9uc11cclxuICovXG5cblxuZnVuY3Rpb24gU29ydGFibGUoZWwsIG9wdGlvbnMpIHtcbiAgaWYgKCEoZWwgJiYgZWwubm9kZVR5cGUgJiYgZWwubm9kZVR5cGUgPT09IDEpKSB7XG4gICAgdGhyb3cgXCJTb3J0YWJsZTogYGVsYCBtdXN0IGJlIGFuIEhUTUxFbGVtZW50LCBub3QgXCIuY29uY2F0KHt9LnRvU3RyaW5nLmNhbGwoZWwpKTtcbiAgfVxuXG4gIHRoaXMuZWwgPSBlbDsgLy8gcm9vdCBlbGVtZW50XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IF9leHRlbmRzKHt9LCBvcHRpb25zKTsgLy8gRXhwb3J0IGluc3RhbmNlXG5cbiAgZWxbZXhwYW5kb10gPSB0aGlzO1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgZ3JvdXA6IG51bGwsXG4gICAgc29ydDogdHJ1ZSxcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgc3RvcmU6IG51bGwsXG4gICAgaGFuZGxlOiBudWxsLFxuICAgIGRyYWdnYWJsZTogL15bdW9dbCQvaS50ZXN0KGVsLm5vZGVOYW1lKSA/ICc+bGknIDogJz4qJyxcbiAgICBzd2FwVGhyZXNob2xkOiAxLFxuICAgIC8vIHBlcmNlbnRhZ2U7IDAgPD0geCA8PSAxXG4gICAgaW52ZXJ0U3dhcDogZmFsc2UsXG4gICAgLy8gaW52ZXJ0IGFsd2F5c1xuICAgIGludmVydGVkU3dhcFRocmVzaG9sZDogbnVsbCxcbiAgICAvLyB3aWxsIGJlIHNldCB0byBzYW1lIGFzIHN3YXBUaHJlc2hvbGQgaWYgZGVmYXVsdFxuICAgIHJlbW92ZUNsb25lT25IaWRlOiB0cnVlLFxuICAgIGRpcmVjdGlvbjogZnVuY3Rpb24gZGlyZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIF9kZXRlY3REaXJlY3Rpb24oZWwsIHRoaXMub3B0aW9ucyk7XG4gICAgfSxcbiAgICBnaG9zdENsYXNzOiAnc29ydGFibGUtZ2hvc3QnLFxuICAgIGNob3NlbkNsYXNzOiAnc29ydGFibGUtY2hvc2VuJyxcbiAgICBkcmFnQ2xhc3M6ICdzb3J0YWJsZS1kcmFnJyxcbiAgICBpZ25vcmU6ICdhLCBpbWcnLFxuICAgIGZpbHRlcjogbnVsbCxcbiAgICBwcmV2ZW50T25GaWx0ZXI6IHRydWUsXG4gICAgYW5pbWF0aW9uOiAwLFxuICAgIGVhc2luZzogbnVsbCxcbiAgICBzZXREYXRhOiBmdW5jdGlvbiBzZXREYXRhKGRhdGFUcmFuc2ZlciwgZHJhZ0VsKSB7XG4gICAgICBkYXRhVHJhbnNmZXIuc2V0RGF0YSgnVGV4dCcsIGRyYWdFbC50ZXh0Q29udGVudCk7XG4gICAgfSxcbiAgICBkcm9wQnViYmxlOiBmYWxzZSxcbiAgICBkcmFnb3ZlckJ1YmJsZTogZmFsc2UsXG4gICAgZGF0YUlkQXR0cjogJ2RhdGEtaWQnLFxuICAgIGRlbGF5OiAwLFxuICAgIGRlbGF5T25Ub3VjaE9ubHk6IGZhbHNlLFxuICAgIHRvdWNoU3RhcnRUaHJlc2hvbGQ6IChOdW1iZXIucGFyc2VJbnQgPyBOdW1iZXIgOiB3aW5kb3cpLnBhcnNlSW50KHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCAxMCkgfHwgMSxcbiAgICBmb3JjZUZhbGxiYWNrOiBmYWxzZSxcbiAgICBmYWxsYmFja0NsYXNzOiAnc29ydGFibGUtZmFsbGJhY2snLFxuICAgIGZhbGxiYWNrT25Cb2R5OiBmYWxzZSxcbiAgICBmYWxsYmFja1RvbGVyYW5jZTogMCxcbiAgICBmYWxsYmFja09mZnNldDoge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9LFxuICAgIHN1cHBvcnRQb2ludGVyOiBTb3J0YWJsZS5zdXBwb3J0UG9pbnRlciAhPT0gZmFsc2UgJiYgJ1BvaW50ZXJFdmVudCcgaW4gd2luZG93ICYmICFTYWZhcmksXG4gICAgZW1wdHlJbnNlcnRUaHJlc2hvbGQ6IDVcbiAgfTtcbiAgUGx1Z2luTWFuYWdlci5pbml0aWFsaXplUGx1Z2lucyh0aGlzLCBlbCwgZGVmYXVsdHMpOyAvLyBTZXQgZGVmYXVsdCBvcHRpb25zXG5cbiAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0cykge1xuICAgICEobmFtZSBpbiBvcHRpb25zKSAmJiAob3B0aW9uc1tuYW1lXSA9IGRlZmF1bHRzW25hbWVdKTtcbiAgfVxuXG4gIF9wcmVwYXJlR3JvdXAob3B0aW9ucyk7IC8vIEJpbmQgYWxsIHByaXZhdGUgbWV0aG9kc1xuXG5cbiAgZm9yICh2YXIgZm4gaW4gdGhpcykge1xuICAgIGlmIChmbi5jaGFyQXQoMCkgPT09ICdfJyAmJiB0eXBlb2YgdGhpc1tmbl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbZm5dID0gdGhpc1tmbl0uYmluZCh0aGlzKTtcbiAgICB9XG4gIH0gLy8gU2V0dXAgZHJhZyBtb2RlXG5cblxuICB0aGlzLm5hdGl2ZURyYWdnYWJsZSA9IG9wdGlvbnMuZm9yY2VGYWxsYmFjayA/IGZhbHNlIDogc3VwcG9ydERyYWdnYWJsZTtcblxuICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAvLyBUb3VjaCBzdGFydCB0aHJlc2hvbGQgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiB0aGUgbmF0aXZlIGRyYWdzdGFydCB0aHJlc2hvbGRcbiAgICB0aGlzLm9wdGlvbnMudG91Y2hTdGFydFRocmVzaG9sZCA9IDE7XG4gIH0gLy8gQmluZCBldmVudHNcblxuXG4gIGlmIChvcHRpb25zLnN1cHBvcnRQb2ludGVyKSB7XG4gICAgb24oZWwsICdwb2ludGVyZG93bicsIHRoaXMuX29uVGFwU3RhcnQpO1xuICB9IGVsc2Uge1xuICAgIG9uKGVsLCAnbW91c2Vkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XG4gICAgb24oZWwsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25UYXBTdGFydCk7XG4gIH1cblxuICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICBvbihlbCwgJ2RyYWdvdmVyJywgdGhpcyk7XG4gICAgb24oZWwsICdkcmFnZW50ZXInLCB0aGlzKTtcbiAgfVxuXG4gIHNvcnRhYmxlcy5wdXNoKHRoaXMuZWwpOyAvLyBSZXN0b3JlIHNvcnRpbmdcblxuICBvcHRpb25zLnN0b3JlICYmIG9wdGlvbnMuc3RvcmUuZ2V0ICYmIHRoaXMuc29ydChvcHRpb25zLnN0b3JlLmdldCh0aGlzKSB8fCBbXSk7IC8vIEFkZCBhbmltYXRpb24gc3RhdGUgbWFuYWdlclxuXG4gIF9leHRlbmRzKHRoaXMsIEFuaW1hdGlvblN0YXRlTWFuYWdlcigpKTtcbn1cblxuU29ydGFibGUucHJvdG90eXBlID1cbi8qKiBAbGVuZHMgU29ydGFibGUucHJvdG90eXBlICovXG57XG4gIGNvbnN0cnVjdG9yOiBTb3J0YWJsZSxcbiAgX2lzT3V0c2lkZVRoaXNFbDogZnVuY3Rpb24gX2lzT3V0c2lkZVRoaXNFbCh0YXJnZXQpIHtcbiAgICBpZiAoIXRoaXMuZWwuY29udGFpbnModGFyZ2V0KSAmJiB0YXJnZXQgIT09IHRoaXMuZWwpIHtcbiAgICAgIGxhc3RUYXJnZXQgPSBudWxsO1xuICAgIH1cbiAgfSxcbiAgX2dldERpcmVjdGlvbjogZnVuY3Rpb24gX2dldERpcmVjdGlvbihldnQsIHRhcmdldCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5vcHRpb25zLmRpcmVjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMub3B0aW9ucy5kaXJlY3Rpb24uY2FsbCh0aGlzLCBldnQsIHRhcmdldCwgZHJhZ0VsKSA6IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gIH0sXG4gIF9vblRhcFN0YXJ0OiBmdW5jdGlvbiBfb25UYXBTdGFydChcbiAgLyoqIEV2ZW50fFRvdWNoRXZlbnQgKi9cbiAgZXZ0KSB7XG4gICAgaWYgKCFldnQuY2FuY2VsYWJsZSkgcmV0dXJuO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgZWwgPSB0aGlzLmVsLFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBwcmV2ZW50T25GaWx0ZXIgPSBvcHRpb25zLnByZXZlbnRPbkZpbHRlcixcbiAgICAgICAgdHlwZSA9IGV2dC50eXBlLFxuICAgICAgICB0b3VjaCA9IGV2dC50b3VjaGVzICYmIGV2dC50b3VjaGVzWzBdIHx8IGV2dC5wb2ludGVyVHlwZSAmJiBldnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgJiYgZXZ0LFxuICAgICAgICB0YXJnZXQgPSAodG91Y2ggfHwgZXZ0KS50YXJnZXQsXG4gICAgICAgIG9yaWdpbmFsVGFyZ2V0ID0gZXZ0LnRhcmdldC5zaGFkb3dSb290ICYmIChldnQucGF0aCAmJiBldnQucGF0aFswXSB8fCBldnQuY29tcG9zZWRQYXRoICYmIGV2dC5jb21wb3NlZFBhdGgoKVswXSkgfHwgdGFyZ2V0LFxuICAgICAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcblxuICAgIF9zYXZlSW5wdXRDaGVja2VkU3RhdGUoZWwpOyAvLyBEb24ndCB0cmlnZ2VyIHN0YXJ0IGV2ZW50IHdoZW4gYW4gZWxlbWVudCBpcyBiZWVuIGRyYWdnZWQsIG90aGVyd2lzZSB0aGUgZXZ0Lm9sZGluZGV4IGFsd2F5cyB3cm9uZyB3aGVuIHNldCBvcHRpb24uZ3JvdXAuXG5cblxuICAgIGlmIChkcmFnRWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoL21vdXNlZG93bnxwb2ludGVyZG93bi8udGVzdCh0eXBlKSAmJiBldnQuYnV0dG9uICE9PSAwIHx8IG9wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjsgLy8gb25seSBsZWZ0IGJ1dHRvbiBhbmQgZW5hYmxlZFxuICAgIH0gLy8gY2FuY2VsIGRuZCBpZiBvcmlnaW5hbCB0YXJnZXQgaXMgY29udGVudCBlZGl0YWJsZVxuXG5cbiAgICBpZiAob3JpZ2luYWxUYXJnZXQuaXNDb250ZW50RWRpdGFibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFNhZmFyaSBpZ25vcmVzIGZ1cnRoZXIgZXZlbnQgaGFuZGxpbmcgYWZ0ZXIgbW91c2Vkb3duXG5cblxuICAgIGlmICghdGhpcy5uYXRpdmVEcmFnZ2FibGUgJiYgU2FmYXJpICYmIHRhcmdldCAmJiB0YXJnZXQudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnU0VMRUNUJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRhcmdldCA9IGNsb3Nlc3QodGFyZ2V0LCBvcHRpb25zLmRyYWdnYWJsZSwgZWwsIGZhbHNlKTtcblxuICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0LmFuaW1hdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxhc3REb3duRWwgPT09IHRhcmdldCkge1xuICAgICAgLy8gSWdub3JpbmcgZHVwbGljYXRlIGBkb3duYFxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50XG5cblxuICAgIG9sZEluZGV4ID0gaW5kZXgodGFyZ2V0KTtcbiAgICBvbGREcmFnZ2FibGVJbmRleCA9IGluZGV4KHRhcmdldCwgb3B0aW9ucy5kcmFnZ2FibGUpOyAvLyBDaGVjayBmaWx0ZXJcblxuICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZmlsdGVyLmNhbGwodGhpcywgZXZ0LCB0YXJnZXQsIHRoaXMpKSB7XG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgICAgcm9vdEVsOiBvcmlnaW5hbFRhcmdldCxcbiAgICAgICAgICBuYW1lOiAnZmlsdGVyJyxcbiAgICAgICAgICB0YXJnZXRFbDogdGFyZ2V0LFxuICAgICAgICAgIHRvRWw6IGVsLFxuICAgICAgICAgIGZyb21FbDogZWxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGx1Z2luRXZlbnQoJ2ZpbHRlcicsIF90aGlzLCB7XG4gICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXZlbnRPbkZpbHRlciAmJiBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuOyAvLyBjYW5jZWwgZG5kXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaWx0ZXIpIHtcbiAgICAgIGZpbHRlciA9IGZpbHRlci5zcGxpdCgnLCcpLnNvbWUoZnVuY3Rpb24gKGNyaXRlcmlhKSB7XG4gICAgICAgIGNyaXRlcmlhID0gY2xvc2VzdChvcmlnaW5hbFRhcmdldCwgY3JpdGVyaWEudHJpbSgpLCBlbCwgZmFsc2UpO1xuXG4gICAgICAgIGlmIChjcml0ZXJpYSkge1xuICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgICAgIHJvb3RFbDogY3JpdGVyaWEsXG4gICAgICAgICAgICBuYW1lOiAnZmlsdGVyJyxcbiAgICAgICAgICAgIHRhcmdldEVsOiB0YXJnZXQsXG4gICAgICAgICAgICBmcm9tRWw6IGVsLFxuICAgICAgICAgICAgdG9FbDogZWxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHBsdWdpbkV2ZW50KCdmaWx0ZXInLCBfdGhpcywge1xuICAgICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgcHJldmVudE9uRmlsdGVyICYmIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47IC8vIGNhbmNlbCBkbmRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5oYW5kbGUgJiYgIWNsb3Nlc3Qob3JpZ2luYWxUYXJnZXQsIG9wdGlvbnMuaGFuZGxlLCBlbCwgZmFsc2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBQcmVwYXJlIGBkcmFnc3RhcnRgXG5cblxuICAgIHRoaXMuX3ByZXBhcmVEcmFnU3RhcnQoZXZ0LCB0b3VjaCwgdGFyZ2V0KTtcbiAgfSxcbiAgX3ByZXBhcmVEcmFnU3RhcnQ6IGZ1bmN0aW9uIF9wcmVwYXJlRHJhZ1N0YXJ0KFxuICAvKiogRXZlbnQgKi9cbiAgZXZ0LFxuICAvKiogVG91Y2ggKi9cbiAgdG91Y2gsXG4gIC8qKiBIVE1MRWxlbWVudCAqL1xuICB0YXJnZXQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBlbCA9IF90aGlzLmVsLFxuICAgICAgICBvcHRpb25zID0gX3RoaXMub3B0aW9ucyxcbiAgICAgICAgb3duZXJEb2N1bWVudCA9IGVsLm93bmVyRG9jdW1lbnQsXG4gICAgICAgIGRyYWdTdGFydEZuO1xuXG4gICAgaWYgKHRhcmdldCAmJiAhZHJhZ0VsICYmIHRhcmdldC5wYXJlbnROb2RlID09PSBlbCkge1xuICAgICAgdmFyIGRyYWdSZWN0ID0gZ2V0UmVjdCh0YXJnZXQpO1xuICAgICAgcm9vdEVsID0gZWw7XG4gICAgICBkcmFnRWwgPSB0YXJnZXQ7XG4gICAgICBwYXJlbnRFbCA9IGRyYWdFbC5wYXJlbnROb2RlO1xuICAgICAgbmV4dEVsID0gZHJhZ0VsLm5leHRTaWJsaW5nO1xuICAgICAgbGFzdERvd25FbCA9IHRhcmdldDtcbiAgICAgIGFjdGl2ZUdyb3VwID0gb3B0aW9ucy5ncm91cDtcbiAgICAgIFNvcnRhYmxlLmRyYWdnZWQgPSBkcmFnRWw7XG4gICAgICB0YXBFdnQgPSB7XG4gICAgICAgIHRhcmdldDogZHJhZ0VsLFxuICAgICAgICBjbGllbnRYOiAodG91Y2ggfHwgZXZ0KS5jbGllbnRYLFxuICAgICAgICBjbGllbnRZOiAodG91Y2ggfHwgZXZ0KS5jbGllbnRZXG4gICAgICB9O1xuICAgICAgdGFwRGlzdGFuY2VMZWZ0ID0gdGFwRXZ0LmNsaWVudFggLSBkcmFnUmVjdC5sZWZ0O1xuICAgICAgdGFwRGlzdGFuY2VUb3AgPSB0YXBFdnQuY2xpZW50WSAtIGRyYWdSZWN0LnRvcDtcbiAgICAgIHRoaXMuX2xhc3RYID0gKHRvdWNoIHx8IGV2dCkuY2xpZW50WDtcbiAgICAgIHRoaXMuX2xhc3RZID0gKHRvdWNoIHx8IGV2dCkuY2xpZW50WTtcbiAgICAgIGRyYWdFbC5zdHlsZVsnd2lsbC1jaGFuZ2UnXSA9ICdhbGwnO1xuXG4gICAgICBkcmFnU3RhcnRGbiA9IGZ1bmN0aW9uIGRyYWdTdGFydEZuKCkge1xuICAgICAgICBwbHVnaW5FdmVudCgnZGVsYXlFbmRlZCcsIF90aGlzLCB7XG4gICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgICAgICBfdGhpcy5fb25Ecm9wKCk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gRGVsYXllZCBkcmFnIGhhcyBiZWVuIHRyaWdnZXJlZFxuICAgICAgICAvLyB3ZSBjYW4gcmUtZW5hYmxlIHRoZSBldmVudHM6IHRvdWNobW92ZS9tb3VzZW1vdmVcblxuXG4gICAgICAgIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMoKTtcblxuICAgICAgICBpZiAoIUZpcmVGb3ggJiYgX3RoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgICAgZHJhZ0VsLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIH0gLy8gQmluZCB0aGUgZXZlbnRzOiBkcmFnc3RhcnQvZHJhZ2VuZFxuXG5cbiAgICAgICAgX3RoaXMuX3RyaWdnZXJEcmFnU3RhcnQoZXZ0LCB0b3VjaCk7IC8vIERyYWcgc3RhcnQgZXZlbnRcblxuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgICAgbmFtZTogJ2Nob29zZScsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgIH0pOyAvLyBDaG9zZW4gaXRlbVxuXG5cbiAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmNob3NlbkNsYXNzLCB0cnVlKTtcbiAgICAgIH07IC8vIERpc2FibGUgXCJkcmFnZ2FibGVcIlxuXG5cbiAgICAgIG9wdGlvbnMuaWdub3JlLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiAoY3JpdGVyaWEpIHtcbiAgICAgICAgZmluZChkcmFnRWwsIGNyaXRlcmlhLnRyaW0oKSwgX2Rpc2FibGVEcmFnZ2FibGUpO1xuICAgICAgfSk7XG4gICAgICBvbihvd25lckRvY3VtZW50LCAnZHJhZ292ZXInLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgICBvbihvd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNobW92ZScsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCBfdGhpcy5fb25Ecm9wKTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIF90aGlzLl9vbkRyb3ApOyAvLyBNYWtlIGRyYWdFbCBkcmFnZ2FibGUgKG11c3QgYmUgYmVmb3JlIGRlbGF5IGZvciBGaXJlRm94KVxuXG4gICAgICBpZiAoRmlyZUZveCAmJiB0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudG91Y2hTdGFydFRocmVzaG9sZCA9IDQ7XG4gICAgICAgIGRyYWdFbC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBwbHVnaW5FdmVudCgnZGVsYXlTdGFydCcsIHRoaXMsIHtcbiAgICAgICAgZXZ0OiBldnRcbiAgICAgIH0pOyAvLyBEZWxheSBpcyBpbXBvc3NpYmxlIGZvciBuYXRpdmUgRG5EIGluIEVkZ2Ugb3IgSUVcblxuICAgICAgaWYgKG9wdGlvbnMuZGVsYXkgJiYgKCFvcHRpb25zLmRlbGF5T25Ub3VjaE9ubHkgfHwgdG91Y2gpICYmICghdGhpcy5uYXRpdmVEcmFnZ2FibGUgfHwgIShFZGdlIHx8IElFMTFPckxlc3MpKSkge1xuICAgICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgICAgIHRoaXMuX29uRHJvcCgpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIElmIHRoZSB1c2VyIG1vdmVzIHRoZSBwb2ludGVyIG9yIGxldCBnbyB0aGUgY2xpY2sgb3IgdG91Y2hcbiAgICAgICAgLy8gYmVmb3JlIHRoZSBkZWxheSBoYXMgYmVlbiByZWFjaGVkOlxuICAgICAgICAvLyBkaXNhYmxlIHRoZSBkZWxheWVkIGRyYWdcblxuXG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIF90aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2htb3ZlJywgX3RoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgICAgIG9wdGlvbnMuc3VwcG9ydFBvaW50ZXIgJiYgb24ob3duZXJEb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgX3RoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgICAgIF90aGlzLl9kcmFnU3RhcnRUaW1lciA9IHNldFRpbWVvdXQoZHJhZ1N0YXJ0Rm4sIG9wdGlvbnMuZGVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHJhZ1N0YXJ0Rm4oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIF9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXI6IGZ1bmN0aW9uIF9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIoXG4gIC8qKiBUb3VjaEV2ZW50fFBvaW50ZXJFdmVudCAqKi9cbiAgZSkge1xuICAgIHZhciB0b3VjaCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XG5cbiAgICBpZiAoTWF0aC5tYXgoTWF0aC5hYnModG91Y2guY2xpZW50WCAtIHRoaXMuX2xhc3RYKSwgTWF0aC5hYnModG91Y2guY2xpZW50WSAtIHRoaXMuX2xhc3RZKSkgPj0gTWF0aC5mbG9vcih0aGlzLm9wdGlvbnMudG91Y2hTdGFydFRocmVzaG9sZCAvICh0aGlzLm5hdGl2ZURyYWdnYWJsZSAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSkpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZygpO1xuICAgIH1cbiAgfSxcbiAgX2Rpc2FibGVEZWxheWVkRHJhZzogZnVuY3Rpb24gX2Rpc2FibGVEZWxheWVkRHJhZygpIHtcbiAgICBkcmFnRWwgJiYgX2Rpc2FibGVEcmFnZ2FibGUoZHJhZ0VsKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fZHJhZ1N0YXJ0VGltZXIpO1xuXG4gICAgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnRXZlbnRzKCk7XG4gIH0sXG4gIF9kaXNhYmxlRGVsYXllZERyYWdFdmVudHM6IGZ1bmN0aW9uIF9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMoKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSB0aGlzLmVsLm93bmVyRG9jdW1lbnQ7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICB9LFxuICBfdHJpZ2dlckRyYWdTdGFydDogZnVuY3Rpb24gX3RyaWdnZXJEcmFnU3RhcnQoXG4gIC8qKiBFdmVudCAqL1xuICBldnQsXG4gIC8qKiBUb3VjaCAqL1xuICB0b3VjaCkge1xuICAgIHRvdWNoID0gdG91Y2ggfHwgZXZ0LnBvaW50ZXJUeXBlID09ICd0b3VjaCcgJiYgZXZ0O1xuXG4gICAgaWYgKCF0aGlzLm5hdGl2ZURyYWdnYWJsZSB8fCB0b3VjaCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgICAgICBvbihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgfSBlbHNlIGlmICh0b3VjaCkge1xuICAgICAgICBvbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvbihkcmFnRWwsICdkcmFnZW5kJywgdGhpcyk7XG4gICAgICBvbihyb290RWwsICdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChkb2N1bWVudC5zZWxlY3Rpb24pIHtcbiAgICAgICAgLy8gVGltZW91dCBuZWNjZXNzYXJ5IGZvciBJRTlcbiAgICAgICAgX25leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkb2N1bWVudC5zZWxlY3Rpb24uZW1wdHkoKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuICB9LFxuICBfZHJhZ1N0YXJ0ZWQ6IGZ1bmN0aW9uIF9kcmFnU3RhcnRlZChmYWxsYmFjaywgZXZ0KSB7XG5cbiAgICBhd2FpdGluZ0RyYWdTdGFydGVkID0gZmFsc2U7XG5cbiAgICBpZiAocm9vdEVsICYmIGRyYWdFbCkge1xuICAgICAgcGx1Z2luRXZlbnQoJ2RyYWdTdGFydGVkJywgdGhpcywge1xuICAgICAgICBldnQ6IGV2dFxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICBvbihkb2N1bWVudCwgJ2RyYWdvdmVyJywgX2NoZWNrT3V0c2lkZVRhcmdldEVsKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7IC8vIEFwcGx5IGVmZmVjdFxuXG4gICAgICAhZmFsbGJhY2sgJiYgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmRyYWdDbGFzcywgZmFsc2UpO1xuICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmdob3N0Q2xhc3MsIHRydWUpO1xuICAgICAgU29ydGFibGUuYWN0aXZlID0gdGhpcztcbiAgICAgIGZhbGxiYWNrICYmIHRoaXMuX2FwcGVuZEdob3N0KCk7IC8vIERyYWcgc3RhcnQgZXZlbnRcblxuICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgbmFtZTogJ3N0YXJ0JyxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbnVsbGluZygpO1xuICAgIH1cbiAgfSxcbiAgX2VtdWxhdGVEcmFnT3ZlcjogZnVuY3Rpb24gX2VtdWxhdGVEcmFnT3ZlcigpIHtcbiAgICBpZiAodG91Y2hFdnQpIHtcbiAgICAgIHRoaXMuX2xhc3RYID0gdG91Y2hFdnQuY2xpZW50WDtcbiAgICAgIHRoaXMuX2xhc3RZID0gdG91Y2hFdnQuY2xpZW50WTtcblxuICAgICAgX2hpZGVHaG9zdEZvclRhcmdldCgpO1xuXG4gICAgICB2YXIgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaEV2dC5jbGllbnRYLCB0b3VjaEV2dC5jbGllbnRZKTtcbiAgICAgIHZhciBwYXJlbnQgPSB0YXJnZXQ7XG5cbiAgICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0LnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnNoYWRvd1Jvb3QuZWxlbWVudEZyb21Qb2ludCh0b3VjaEV2dC5jbGllbnRYLCB0b3VjaEV2dC5jbGllbnRZKTtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gcGFyZW50KSBicmVhaztcbiAgICAgICAgcGFyZW50ID0gdGFyZ2V0O1xuICAgICAgfVxuXG4gICAgICBkcmFnRWwucGFyZW50Tm9kZVtleHBhbmRvXS5faXNPdXRzaWRlVGhpc0VsKHRhcmdldCk7XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmIChwYXJlbnRbZXhwYW5kb10pIHtcbiAgICAgICAgICAgIHZhciBpbnNlcnRlZCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGluc2VydGVkID0gcGFyZW50W2V4cGFuZG9dLl9vbkRyYWdPdmVyKHtcbiAgICAgICAgICAgICAgY2xpZW50WDogdG91Y2hFdnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgY2xpZW50WTogdG91Y2hFdnQuY2xpZW50WSxcbiAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgIHJvb3RFbDogcGFyZW50XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGluc2VydGVkICYmICF0aGlzLm9wdGlvbnMuZHJhZ292ZXJCdWJibGUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGFyZ2V0ID0gcGFyZW50OyAvLyBzdG9yZSBsYXN0IGVsZW1lbnRcbiAgICAgICAgfVxuICAgICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG4gICAgICAgIHdoaWxlIChwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIF91bmhpZGVHaG9zdEZvclRhcmdldCgpO1xuICAgIH1cbiAgfSxcbiAgX29uVG91Y2hNb3ZlOiBmdW5jdGlvbiBfb25Ub3VjaE1vdmUoXG4gIC8qKlRvdWNoRXZlbnQqL1xuICBldnQpIHtcbiAgICBpZiAodGFwRXZ0KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBmYWxsYmFja1RvbGVyYW5jZSA9IG9wdGlvbnMuZmFsbGJhY2tUb2xlcmFuY2UsXG4gICAgICAgICAgZmFsbGJhY2tPZmZzZXQgPSBvcHRpb25zLmZhbGxiYWNrT2Zmc2V0LFxuICAgICAgICAgIHRvdWNoID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCxcbiAgICAgICAgICBnaG9zdE1hdHJpeCA9IGdob3N0RWwgJiYgbWF0cml4KGdob3N0RWwsIHRydWUpLFxuICAgICAgICAgIHNjYWxlWCA9IGdob3N0RWwgJiYgZ2hvc3RNYXRyaXggJiYgZ2hvc3RNYXRyaXguYSxcbiAgICAgICAgICBzY2FsZVkgPSBnaG9zdEVsICYmIGdob3N0TWF0cml4ICYmIGdob3N0TWF0cml4LmQsXG4gICAgICAgICAgcmVsYXRpdmVTY3JvbGxPZmZzZXQgPSBQb3NpdGlvbkdob3N0QWJzb2x1dGVseSAmJiBnaG9zdFJlbGF0aXZlUGFyZW50ICYmIGdldFJlbGF0aXZlU2Nyb2xsT2Zmc2V0KGdob3N0UmVsYXRpdmVQYXJlbnQpLFxuICAgICAgICAgIGR4ID0gKHRvdWNoLmNsaWVudFggLSB0YXBFdnQuY2xpZW50WCArIGZhbGxiYWNrT2Zmc2V0LngpIC8gKHNjYWxlWCB8fCAxKSArIChyZWxhdGl2ZVNjcm9sbE9mZnNldCA/IHJlbGF0aXZlU2Nyb2xsT2Zmc2V0WzBdIC0gZ2hvc3RSZWxhdGl2ZVBhcmVudEluaXRpYWxTY3JvbGxbMF0gOiAwKSAvIChzY2FsZVggfHwgMSksXG4gICAgICAgICAgZHkgPSAodG91Y2guY2xpZW50WSAtIHRhcEV2dC5jbGllbnRZICsgZmFsbGJhY2tPZmZzZXQueSkgLyAoc2NhbGVZIHx8IDEpICsgKHJlbGF0aXZlU2Nyb2xsT2Zmc2V0ID8gcmVsYXRpdmVTY3JvbGxPZmZzZXRbMV0gLSBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbFsxXSA6IDApIC8gKHNjYWxlWSB8fCAxKTsgLy8gb25seSBzZXQgdGhlIHN0YXR1cyB0byBkcmFnZ2luZywgd2hlbiB3ZSBhcmUgYWN0dWFsbHkgZHJhZ2dpbmdcblxuICAgICAgaWYgKCFTb3J0YWJsZS5hY3RpdmUgJiYgIWF3YWl0aW5nRHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgaWYgKGZhbGxiYWNrVG9sZXJhbmNlICYmIE1hdGgubWF4KE1hdGguYWJzKHRvdWNoLmNsaWVudFggLSB0aGlzLl9sYXN0WCksIE1hdGguYWJzKHRvdWNoLmNsaWVudFkgLSB0aGlzLl9sYXN0WSkpIDwgZmFsbGJhY2tUb2xlcmFuY2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vbkRyYWdTdGFydChldnQsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2hvc3RFbCkge1xuICAgICAgICBpZiAoZ2hvc3RNYXRyaXgpIHtcbiAgICAgICAgICBnaG9zdE1hdHJpeC5lICs9IGR4IC0gKGxhc3REeCB8fCAwKTtcbiAgICAgICAgICBnaG9zdE1hdHJpeC5mICs9IGR5IC0gKGxhc3REeSB8fCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnaG9zdE1hdHJpeCA9IHtcbiAgICAgICAgICAgIGE6IDEsXG4gICAgICAgICAgICBiOiAwLFxuICAgICAgICAgICAgYzogMCxcbiAgICAgICAgICAgIGQ6IDEsXG4gICAgICAgICAgICBlOiBkeCxcbiAgICAgICAgICAgIGY6IGR5XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjc3NNYXRyaXggPSBcIm1hdHJpeChcIi5jb25jYXQoZ2hvc3RNYXRyaXguYSwgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5iLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmMsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguZCwgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5lLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmYsIFwiKVwiKTtcbiAgICAgICAgY3NzKGdob3N0RWwsICd3ZWJraXRUcmFuc2Zvcm0nLCBjc3NNYXRyaXgpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ21velRyYW5zZm9ybScsIGNzc01hdHJpeCk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAnbXNUcmFuc2Zvcm0nLCBjc3NNYXRyaXgpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zZm9ybScsIGNzc01hdHJpeCk7XG4gICAgICAgIGxhc3REeCA9IGR4O1xuICAgICAgICBsYXN0RHkgPSBkeTtcbiAgICAgICAgdG91Y2hFdnQgPSB0b3VjaDtcbiAgICAgIH1cblxuICAgICAgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LFxuICBfYXBwZW5kR2hvc3Q6IGZ1bmN0aW9uIF9hcHBlbmRHaG9zdCgpIHtcbiAgICAvLyBCdWcgaWYgdXNpbmcgc2NhbGUoKTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjYzNzA1OFxuICAgIC8vIE5vdCBiZWluZyBhZGp1c3RlZCBmb3JcbiAgICBpZiAoIWdob3N0RWwpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLm9wdGlvbnMuZmFsbGJhY2tPbkJvZHkgPyBkb2N1bWVudC5ib2R5IDogcm9vdEVsLFxuICAgICAgICAgIHJlY3QgPSBnZXRSZWN0KGRyYWdFbCwgdHJ1ZSwgUG9zaXRpb25HaG9zdEFic29sdXRlbHksIHRydWUsIGNvbnRhaW5lciksXG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9uczsgLy8gUG9zaXRpb24gYWJzb2x1dGVseVxuXG4gICAgICBpZiAoUG9zaXRpb25HaG9zdEFic29sdXRlbHkpIHtcbiAgICAgICAgLy8gR2V0IHJlbGF0aXZlbHkgcG9zaXRpb25lZCBwYXJlbnRcbiAgICAgICAgZ2hvc3RSZWxhdGl2ZVBhcmVudCA9IGNvbnRhaW5lcjtcblxuICAgICAgICB3aGlsZSAoY3NzKGdob3N0UmVsYXRpdmVQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJyAmJiBjc3MoZ2hvc3RSZWxhdGl2ZVBhcmVudCwgJ3RyYW5zZm9ybScpID09PSAnbm9uZScgJiYgZ2hvc3RSZWxhdGl2ZVBhcmVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICBnaG9zdFJlbGF0aXZlUGFyZW50ID0gZ2hvc3RSZWxhdGl2ZVBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdob3N0UmVsYXRpdmVQYXJlbnQgIT09IGRvY3VtZW50LmJvZHkgJiYgZ2hvc3RSZWxhdGl2ZVBhcmVudCAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgaWYgKGdob3N0UmVsYXRpdmVQYXJlbnQgPT09IGRvY3VtZW50KSBnaG9zdFJlbGF0aXZlUGFyZW50ID0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgICAgICAgIHJlY3QudG9wICs9IGdob3N0UmVsYXRpdmVQYXJlbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgIHJlY3QubGVmdCArPSBnaG9zdFJlbGF0aXZlUGFyZW50LnNjcm9sbExlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2hvc3RSZWxhdGl2ZVBhcmVudCA9IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdob3N0UmVsYXRpdmVQYXJlbnRJbml0aWFsU2Nyb2xsID0gZ2V0UmVsYXRpdmVTY3JvbGxPZmZzZXQoZ2hvc3RSZWxhdGl2ZVBhcmVudCk7XG4gICAgICB9XG5cbiAgICAgIGdob3N0RWwgPSBkcmFnRWwuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgdG9nZ2xlQ2xhc3MoZ2hvc3RFbCwgb3B0aW9ucy5naG9zdENsYXNzLCBmYWxzZSk7XG4gICAgICB0b2dnbGVDbGFzcyhnaG9zdEVsLCBvcHRpb25zLmZhbGxiYWNrQ2xhc3MsIHRydWUpO1xuICAgICAgdG9nZ2xlQ2xhc3MoZ2hvc3RFbCwgb3B0aW9ucy5kcmFnQ2xhc3MsIHRydWUpO1xuICAgICAgY3NzKGdob3N0RWwsICd0cmFuc2l0aW9uJywgJycpO1xuICAgICAgY3NzKGdob3N0RWwsICd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ2JveC1zaXppbmcnLCAnYm9yZGVyLWJveCcpO1xuICAgICAgY3NzKGdob3N0RWwsICdtYXJnaW4nLCAwKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAndG9wJywgcmVjdC50b3ApO1xuICAgICAgY3NzKGdob3N0RWwsICdsZWZ0JywgcmVjdC5sZWZ0KTtcbiAgICAgIGNzcyhnaG9zdEVsLCAnd2lkdGgnLCByZWN0LndpZHRoKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAnaGVpZ2h0JywgcmVjdC5oZWlnaHQpO1xuICAgICAgY3NzKGdob3N0RWwsICdvcGFjaXR5JywgJzAuOCcpO1xuICAgICAgY3NzKGdob3N0RWwsICdwb3NpdGlvbicsIFBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5ID8gJ2Fic29sdXRlJyA6ICdmaXhlZCcpO1xuICAgICAgY3NzKGdob3N0RWwsICd6SW5kZXgnLCAnMTAwMDAwJyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3BvaW50ZXJFdmVudHMnLCAnbm9uZScpO1xuICAgICAgU29ydGFibGUuZ2hvc3QgPSBnaG9zdEVsO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGdob3N0RWwpOyAvLyBTZXQgdHJhbnNmb3JtLW9yaWdpblxuXG4gICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zZm9ybS1vcmlnaW4nLCB0YXBEaXN0YW5jZUxlZnQgLyBwYXJzZUludChnaG9zdEVsLnN0eWxlLndpZHRoKSAqIDEwMCArICclICcgKyB0YXBEaXN0YW5jZVRvcCAvIHBhcnNlSW50KGdob3N0RWwuc3R5bGUuaGVpZ2h0KSAqIDEwMCArICclJyk7XG4gICAgfVxuICB9LFxuICBfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uIF9vbkRyYWdTdGFydChcbiAgLyoqRXZlbnQqL1xuICBldnQsXG4gIC8qKmJvb2xlYW4qL1xuICBmYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgZGF0YVRyYW5zZmVyID0gZXZ0LmRhdGFUcmFuc2ZlcjtcbiAgICB2YXIgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnM7XG4gICAgcGx1Z2luRXZlbnQoJ2RyYWdTdGFydCcsIHRoaXMsIHtcbiAgICAgIGV2dDogZXZ0XG4gICAgfSk7XG5cbiAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgdGhpcy5fb25Ecm9wKCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwbHVnaW5FdmVudCgnc2V0dXBDbG9uZScsIHRoaXMpO1xuXG4gICAgaWYgKCFTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICBjbG9uZUVsID0gY2xvbmUoZHJhZ0VsKTtcbiAgICAgIGNsb25lRWwucmVtb3ZlQXR0cmlidXRlKFwiaWRcIik7XG4gICAgICBjbG9uZUVsLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgY2xvbmVFbC5zdHlsZVsnd2lsbC1jaGFuZ2UnXSA9ICcnO1xuXG4gICAgICB0aGlzLl9oaWRlQ2xvbmUoKTtcblxuICAgICAgdG9nZ2xlQ2xhc3MoY2xvbmVFbCwgdGhpcy5vcHRpb25zLmNob3NlbkNsYXNzLCBmYWxzZSk7XG4gICAgICBTb3J0YWJsZS5jbG9uZSA9IGNsb25lRWw7XG4gICAgfSAvLyAjMTE0MzogSUZyYW1lIHN1cHBvcnQgd29ya2Fyb3VuZFxuXG5cbiAgICBfdGhpcy5jbG9uZUlkID0gX25leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHBsdWdpbkV2ZW50KCdjbG9uZScsIF90aGlzKTtcbiAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm47XG5cbiAgICAgIGlmICghX3RoaXMub3B0aW9ucy5yZW1vdmVDbG9uZU9uSGlkZSkge1xuICAgICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGNsb25lRWwsIGRyYWdFbCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLl9oaWRlQ2xvbmUoKTtcblxuICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgIG5hbWU6ICdjbG9uZSdcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgICFmYWxsYmFjayAmJiB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuZHJhZ0NsYXNzLCB0cnVlKTsgLy8gU2V0IHByb3BlciBkcm9wIGV2ZW50c1xuXG4gICAgaWYgKGZhbGxiYWNrKSB7XG4gICAgICBpZ25vcmVOZXh0Q2xpY2sgPSB0cnVlO1xuICAgICAgX3RoaXMuX2xvb3BJZCA9IHNldEludGVydmFsKF90aGlzLl9lbXVsYXRlRHJhZ092ZXIsIDUwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVW5kbyB3aGF0IHdhcyBzZXQgaW4gX3ByZXBhcmVEcmFnU3RhcnQgYmVmb3JlIGRyYWcgc3RhcnRlZFxuICAgICAgb2ZmKGRvY3VtZW50LCAnbW91c2V1cCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgb2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCBfdGhpcy5fb25Ecm9wKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgX3RoaXMuX29uRHJvcCk7XG5cbiAgICAgIGlmIChkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSAnbW92ZSc7XG4gICAgICAgIG9wdGlvbnMuc2V0RGF0YSAmJiBvcHRpb25zLnNldERhdGEuY2FsbChfdGhpcywgZGF0YVRyYW5zZmVyLCBkcmFnRWwpO1xuICAgICAgfVxuXG4gICAgICBvbihkb2N1bWVudCwgJ2Ryb3AnLCBfdGhpcyk7IC8vICMxMjc2IGZpeDpcblxuICAgICAgY3NzKGRyYWdFbCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGVaKDApJyk7XG4gICAgfVxuXG4gICAgYXdhaXRpbmdEcmFnU3RhcnRlZCA9IHRydWU7XG4gICAgX3RoaXMuX2RyYWdTdGFydElkID0gX25leHRUaWNrKF90aGlzLl9kcmFnU3RhcnRlZC5iaW5kKF90aGlzLCBmYWxsYmFjaywgZXZ0KSk7XG4gICAgb24oZG9jdW1lbnQsICdzZWxlY3RzdGFydCcsIF90aGlzKTtcbiAgICBtb3ZlZCA9IHRydWU7XG5cbiAgICBpZiAoU2FmYXJpKSB7XG4gICAgICBjc3MoZG9jdW1lbnQuYm9keSwgJ3VzZXItc2VsZWN0JywgJ25vbmUnKTtcbiAgICB9XG4gIH0sXG4gIC8vIFJldHVybnMgdHJ1ZSAtIGlmIG5vIGZ1cnRoZXIgYWN0aW9uIGlzIG5lZWRlZCAoZWl0aGVyIGluc2VydGVkIG9yIGFub3RoZXIgY29uZGl0aW9uKVxuICBfb25EcmFnT3ZlcjogZnVuY3Rpb24gX29uRHJhZ092ZXIoXG4gIC8qKkV2ZW50Ki9cbiAgZXZ0KSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbCxcbiAgICAgICAgdGFyZ2V0ID0gZXZ0LnRhcmdldCxcbiAgICAgICAgZHJhZ1JlY3QsXG4gICAgICAgIHRhcmdldFJlY3QsXG4gICAgICAgIHJldmVydCxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZ3JvdXAgPSBvcHRpb25zLmdyb3VwLFxuICAgICAgICBhY3RpdmVTb3J0YWJsZSA9IFNvcnRhYmxlLmFjdGl2ZSxcbiAgICAgICAgaXNPd25lciA9IGFjdGl2ZUdyb3VwID09PSBncm91cCxcbiAgICAgICAgY2FuU29ydCA9IG9wdGlvbnMuc29ydCxcbiAgICAgICAgZnJvbVNvcnRhYmxlID0gcHV0U29ydGFibGUgfHwgYWN0aXZlU29ydGFibGUsXG4gICAgICAgIHZlcnRpY2FsLFxuICAgICAgICBfdGhpcyA9IHRoaXMsXG4gICAgICAgIGNvbXBsZXRlZEZpcmVkID0gZmFsc2U7XG5cbiAgICBpZiAoX3NpbGVudCkgcmV0dXJuO1xuXG4gICAgZnVuY3Rpb24gZHJhZ092ZXJFdmVudChuYW1lLCBleHRyYSkge1xuICAgICAgcGx1Z2luRXZlbnQobmFtZSwgX3RoaXMsIF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgZXZ0OiBldnQsXG4gICAgICAgIGlzT3duZXI6IGlzT3duZXIsXG4gICAgICAgIGF4aXM6IHZlcnRpY2FsID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJyxcbiAgICAgICAgcmV2ZXJ0OiByZXZlcnQsXG4gICAgICAgIGRyYWdSZWN0OiBkcmFnUmVjdCxcbiAgICAgICAgdGFyZ2V0UmVjdDogdGFyZ2V0UmVjdCxcbiAgICAgICAgY2FuU29ydDogY2FuU29ydCxcbiAgICAgICAgZnJvbVNvcnRhYmxlOiBmcm9tU29ydGFibGUsXG4gICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICBjb21wbGV0ZWQ6IGNvbXBsZXRlZCxcbiAgICAgICAgb25Nb3ZlOiBmdW5jdGlvbiBvbk1vdmUodGFyZ2V0LCBhZnRlcikge1xuICAgICAgICAgIHJldHVybiBfb25Nb3ZlKHJvb3RFbCwgZWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldCwgZ2V0UmVjdCh0YXJnZXQpLCBldnQsIGFmdGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2hhbmdlZDogY2hhbmdlZFxuICAgICAgfSwgZXh0cmEpKTtcbiAgICB9IC8vIENhcHR1cmUgYW5pbWF0aW9uIHN0YXRlXG5cblxuICAgIGZ1bmN0aW9uIGNhcHR1cmUoKSB7XG4gICAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlckFuaW1hdGlvbkNhcHR1cmUnKTtcblxuICAgICAgX3RoaXMuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG5cbiAgICAgIGlmIChfdGhpcyAhPT0gZnJvbVNvcnRhYmxlKSB7XG4gICAgICAgIGZyb21Tb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICAgIH1cbiAgICB9IC8vIFJldHVybiBpbnZvY2F0aW9uIHdoZW4gZHJhZ0VsIGlzIGluc2VydGVkIChvciBjb21wbGV0ZWQpXG5cblxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlZChpbnNlcnRpb24pIHtcbiAgICAgIGRyYWdPdmVyRXZlbnQoJ2RyYWdPdmVyQ29tcGxldGVkJywge1xuICAgICAgICBpbnNlcnRpb246IGluc2VydGlvblxuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbnNlcnRpb24pIHtcbiAgICAgICAgLy8gQ2xvbmVzIG11c3QgYmUgaGlkZGVuIGJlZm9yZSBmb2xkaW5nIGFuaW1hdGlvbiB0byBjYXB0dXJlIGRyYWdSZWN0QWJzb2x1dGUgcHJvcGVybHlcbiAgICAgICAgaWYgKGlzT3duZXIpIHtcbiAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5faGlkZUNsb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWN0aXZlU29ydGFibGUuX3Nob3dDbG9uZShfdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXMgIT09IGZyb21Tb3J0YWJsZSkge1xuICAgICAgICAgIC8vIFNldCBnaG9zdCBjbGFzcyB0byBuZXcgc29ydGFibGUncyBnaG9zdCBjbGFzc1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgcHV0U29ydGFibGUgPyBwdXRTb3J0YWJsZS5vcHRpb25zLmdob3N0Q2xhc3MgOiBhY3RpdmVTb3J0YWJsZS5vcHRpb25zLmdob3N0Q2xhc3MsIGZhbHNlKTtcbiAgICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuZ2hvc3RDbGFzcywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHV0U29ydGFibGUgIT09IF90aGlzICYmIF90aGlzICE9PSBTb3J0YWJsZS5hY3RpdmUpIHtcbiAgICAgICAgICBwdXRTb3J0YWJsZSA9IF90aGlzO1xuICAgICAgICB9IGVsc2UgaWYgKF90aGlzID09PSBTb3J0YWJsZS5hY3RpdmUgJiYgcHV0U29ydGFibGUpIHtcbiAgICAgICAgICBwdXRTb3J0YWJsZSA9IG51bGw7XG4gICAgICAgIH0gLy8gQW5pbWF0aW9uXG5cblxuICAgICAgICBpZiAoZnJvbVNvcnRhYmxlID09PSBfdGhpcykge1xuICAgICAgICAgIF90aGlzLl9pZ25vcmVXaGlsZUFuaW1hdGluZyA9IHRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmFuaW1hdGVBbGwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRyYWdPdmVyRXZlbnQoJ2RyYWdPdmVyQW5pbWF0aW9uQ29tcGxldGUnKTtcbiAgICAgICAgICBfdGhpcy5faWdub3JlV2hpbGVBbmltYXRpbmcgPSBudWxsO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoX3RoaXMgIT09IGZyb21Tb3J0YWJsZSkge1xuICAgICAgICAgIGZyb21Tb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gICAgICAgICAgZnJvbVNvcnRhYmxlLl9pZ25vcmVXaGlsZUFuaW1hdGluZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gTnVsbCBsYXN0VGFyZ2V0IGlmIGl0IGlzIG5vdCBpbnNpZGUgYSBwcmV2aW91c2x5IHN3YXBwZWQgZWxlbWVudFxuXG5cbiAgICAgIGlmICh0YXJnZXQgPT09IGRyYWdFbCAmJiAhZHJhZ0VsLmFuaW1hdGVkIHx8IHRhcmdldCA9PT0gZWwgJiYgIXRhcmdldC5hbmltYXRlZCkge1xuICAgICAgICBsYXN0VGFyZ2V0ID0gbnVsbDtcbiAgICAgIH0gLy8gbm8gYnViYmxpbmcgYW5kIG5vdCBmYWxsYmFja1xuXG5cbiAgICAgIGlmICghb3B0aW9ucy5kcmFnb3ZlckJ1YmJsZSAmJiAhZXZ0LnJvb3RFbCAmJiB0YXJnZXQgIT09IGRvY3VtZW50KSB7XG4gICAgICAgIGRyYWdFbC5wYXJlbnROb2RlW2V4cGFuZG9dLl9pc091dHNpZGVUaGlzRWwoZXZ0LnRhcmdldCk7IC8vIERvIG5vdCBkZXRlY3QgZm9yIGVtcHR5IGluc2VydCBpZiBhbHJlYWR5IGluc2VydGVkXG5cblxuICAgICAgICAhaW5zZXJ0aW9uICYmIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KGV2dCk7XG4gICAgICB9XG5cbiAgICAgICFvcHRpb25zLmRyYWdvdmVyQnViYmxlICYmIGV2dC5zdG9wUHJvcGFnYXRpb24gJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgcmV0dXJuIGNvbXBsZXRlZEZpcmVkID0gdHJ1ZTtcbiAgICB9IC8vIENhbGwgd2hlbiBkcmFnRWwgaGFzIGJlZW4gaW5zZXJ0ZWRcblxuXG4gICAgZnVuY3Rpb24gY2hhbmdlZCgpIHtcbiAgICAgIG5ld0luZGV4ID0gaW5kZXgoZHJhZ0VsKTtcbiAgICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gaW5kZXgoZHJhZ0VsLCBvcHRpb25zLmRyYWdnYWJsZSk7XG5cbiAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgc29ydGFibGU6IF90aGlzLFxuICAgICAgICBuYW1lOiAnY2hhbmdlJyxcbiAgICAgICAgdG9FbDogZWwsXG4gICAgICAgIG5ld0luZGV4OiBuZXdJbmRleCxcbiAgICAgICAgbmV3RHJhZ2dhYmxlSW5kZXg6IG5ld0RyYWdnYWJsZUluZGV4LFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChldnQucHJldmVudERlZmF1bHQgIT09IHZvaWQgMCkge1xuICAgICAgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gY2xvc2VzdCh0YXJnZXQsIG9wdGlvbnMuZHJhZ2dhYmxlLCBlbCwgdHJ1ZSk7XG4gICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXInKTtcbiAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuIGNvbXBsZXRlZEZpcmVkO1xuXG4gICAgaWYgKGRyYWdFbC5jb250YWlucyhldnQudGFyZ2V0KSB8fCB0YXJnZXQuYW5pbWF0ZWQgJiYgdGFyZ2V0LmFuaW1hdGluZ1ggJiYgdGFyZ2V0LmFuaW1hdGluZ1kgfHwgX3RoaXMuX2lnbm9yZVdoaWxlQW5pbWF0aW5nID09PSB0YXJnZXQpIHtcbiAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgIH1cblxuICAgIGlnbm9yZU5leHRDbGljayA9IGZhbHNlO1xuXG4gICAgaWYgKGFjdGl2ZVNvcnRhYmxlICYmICFvcHRpb25zLmRpc2FibGVkICYmIChpc093bmVyID8gY2FuU29ydCB8fCAocmV2ZXJ0ID0gcGFyZW50RWwgIT09IHJvb3RFbCkgLy8gUmV2ZXJ0aW5nIGl0ZW0gaW50byB0aGUgb3JpZ2luYWwgbGlzdFxuICAgIDogcHV0U29ydGFibGUgPT09IHRoaXMgfHwgKHRoaXMubGFzdFB1dE1vZGUgPSBhY3RpdmVHcm91cC5jaGVja1B1bGwodGhpcywgYWN0aXZlU29ydGFibGUsIGRyYWdFbCwgZXZ0KSkgJiYgZ3JvdXAuY2hlY2tQdXQodGhpcywgYWN0aXZlU29ydGFibGUsIGRyYWdFbCwgZXZ0KSkpIHtcbiAgICAgIHZlcnRpY2FsID0gdGhpcy5fZ2V0RGlyZWN0aW9uKGV2dCwgdGFyZ2V0KSA9PT0gJ3ZlcnRpY2FsJztcbiAgICAgIGRyYWdSZWN0ID0gZ2V0UmVjdChkcmFnRWwpO1xuICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXJWYWxpZCcpO1xuICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybiBjb21wbGV0ZWRGaXJlZDtcblxuICAgICAgaWYgKHJldmVydCkge1xuICAgICAgICBwYXJlbnRFbCA9IHJvb3RFbDsgLy8gYWN0dWFsaXphdGlvblxuXG4gICAgICAgIGNhcHR1cmUoKTtcblxuICAgICAgICB0aGlzLl9oaWRlQ2xvbmUoKTtcblxuICAgICAgICBkcmFnT3ZlckV2ZW50KCdyZXZlcnQnKTtcblxuICAgICAgICBpZiAoIVNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgICAgICBpZiAobmV4dEVsKSB7XG4gICAgICAgICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgbmV4dEVsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm9vdEVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlZCh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsTGFzdENoaWxkID0gbGFzdENoaWxkKGVsLCBvcHRpb25zLmRyYWdnYWJsZSk7XG5cbiAgICAgIGlmICghZWxMYXN0Q2hpbGQgfHwgX2dob3N0SXNMYXN0KGV2dCwgdmVydGljYWwsIHRoaXMpICYmICFlbExhc3RDaGlsZC5hbmltYXRlZCkge1xuICAgICAgICAvLyBJbnNlcnQgdG8gZW5kIG9mIGxpc3RcbiAgICAgICAgLy8gSWYgYWxyZWFkeSBhdCBlbmQgb2YgbGlzdDogRG8gbm90IGluc2VydFxuICAgICAgICBpZiAoZWxMYXN0Q2hpbGQgPT09IGRyYWdFbCkge1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgICB9IC8vIGlmIHRoZXJlIGlzIGEgbGFzdCBlbGVtZW50LCBpdCBpcyB0aGUgdGFyZ2V0XG5cblxuICAgICAgICBpZiAoZWxMYXN0Q2hpbGQgJiYgZWwgPT09IGV2dC50YXJnZXQpIHtcbiAgICAgICAgICB0YXJnZXQgPSBlbExhc3RDaGlsZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICB0YXJnZXRSZWN0ID0gZ2V0UmVjdCh0YXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9vbk1vdmUocm9vdEVsLCBlbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCBldnQsICEhdGFyZ2V0KSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBjYXB0dXJlKCk7XG5cbiAgICAgICAgICBpZiAoZWxMYXN0Q2hpbGQgJiYgZWxMYXN0Q2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIC8vIHRoZSBsYXN0IGRyYWdnYWJsZSBlbGVtZW50IGlzIG5vdCB0aGUgbGFzdCBub2RlXG4gICAgICAgICAgICBlbC5pbnNlcnRCZWZvcmUoZHJhZ0VsLCBlbExhc3RDaGlsZC5uZXh0U2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFyZW50RWwgPSBlbDsgLy8gYWN0dWFsaXphdGlvblxuXG4gICAgICAgICAgY2hhbmdlZCgpO1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZWxMYXN0Q2hpbGQgJiYgX2dob3N0SXNGaXJzdChldnQsIHZlcnRpY2FsLCB0aGlzKSkge1xuICAgICAgICAvLyBJbnNlcnQgdG8gc3RhcnQgb2YgbGlzdFxuICAgICAgICB2YXIgZmlyc3RDaGlsZCA9IGdldENoaWxkKGVsLCAwLCBvcHRpb25zLCB0cnVlKTtcblxuICAgICAgICBpZiAoZmlyc3RDaGlsZCA9PT0gZHJhZ0VsKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQgPSBmaXJzdENoaWxkO1xuICAgICAgICB0YXJnZXRSZWN0ID0gZ2V0UmVjdCh0YXJnZXQpO1xuXG4gICAgICAgIGlmIChfb25Nb3ZlKHJvb3RFbCwgZWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldCwgdGFyZ2V0UmVjdCwgZXZ0LCBmYWxzZSkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgY2FwdHVyZSgpO1xuICAgICAgICAgIGVsLmluc2VydEJlZm9yZShkcmFnRWwsIGZpcnN0Q2hpbGQpO1xuICAgICAgICAgIHBhcmVudEVsID0gZWw7IC8vIGFjdHVhbGl6YXRpb25cblxuICAgICAgICAgIGNoYW5nZWQoKTtcbiAgICAgICAgICByZXR1cm4gY29tcGxldGVkKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldC5wYXJlbnROb2RlID09PSBlbCkge1xuICAgICAgICB0YXJnZXRSZWN0ID0gZ2V0UmVjdCh0YXJnZXQpO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gMCxcbiAgICAgICAgICAgIHRhcmdldEJlZm9yZUZpcnN0U3dhcCxcbiAgICAgICAgICAgIGRpZmZlcmVudExldmVsID0gZHJhZ0VsLnBhcmVudE5vZGUgIT09IGVsLFxuICAgICAgICAgICAgZGlmZmVyZW50Um93Q29sID0gIV9kcmFnRWxJblJvd0NvbHVtbihkcmFnRWwuYW5pbWF0ZWQgJiYgZHJhZ0VsLnRvUmVjdCB8fCBkcmFnUmVjdCwgdGFyZ2V0LmFuaW1hdGVkICYmIHRhcmdldC50b1JlY3QgfHwgdGFyZ2V0UmVjdCwgdmVydGljYWwpLFxuICAgICAgICAgICAgc2lkZTEgPSB2ZXJ0aWNhbCA/ICd0b3AnIDogJ2xlZnQnLFxuICAgICAgICAgICAgc2Nyb2xsZWRQYXN0VG9wID0gaXNTY3JvbGxlZFBhc3QodGFyZ2V0LCAndG9wJywgJ3RvcCcpIHx8IGlzU2Nyb2xsZWRQYXN0KGRyYWdFbCwgJ3RvcCcsICd0b3AnKSxcbiAgICAgICAgICAgIHNjcm9sbEJlZm9yZSA9IHNjcm9sbGVkUGFzdFRvcCA/IHNjcm9sbGVkUGFzdFRvcC5zY3JvbGxUb3AgOiB2b2lkIDA7XG5cbiAgICAgICAgaWYgKGxhc3RUYXJnZXQgIT09IHRhcmdldCkge1xuICAgICAgICAgIHRhcmdldEJlZm9yZUZpcnN0U3dhcCA9IHRhcmdldFJlY3Rbc2lkZTFdO1xuICAgICAgICAgIHBhc3RGaXJzdEludmVydFRocmVzaCA9IGZhbHNlO1xuICAgICAgICAgIGlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQgPSAhZGlmZmVyZW50Um93Q29sICYmIG9wdGlvbnMuaW52ZXJ0U3dhcCB8fCBkaWZmZXJlbnRMZXZlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpcmVjdGlvbiA9IF9nZXRTd2FwRGlyZWN0aW9uKGV2dCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCwgZGlmZmVyZW50Um93Q29sID8gMSA6IG9wdGlvbnMuc3dhcFRocmVzaG9sZCwgb3B0aW9ucy5pbnZlcnRlZFN3YXBUaHJlc2hvbGQgPT0gbnVsbCA/IG9wdGlvbnMuc3dhcFRocmVzaG9sZCA6IG9wdGlvbnMuaW52ZXJ0ZWRTd2FwVGhyZXNob2xkLCBpc0NpcmN1bXN0YW50aWFsSW52ZXJ0LCBsYXN0VGFyZ2V0ID09PSB0YXJnZXQpO1xuICAgICAgICB2YXIgc2libGluZztcblxuICAgICAgICBpZiAoZGlyZWN0aW9uICE9PSAwKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGJlc2lkZSBkcmFnRWwgaW4gcmVzcGVjdGl2ZSBkaXJlY3Rpb24gKGlnbm9yaW5nIGhpZGRlbiBlbGVtZW50cylcbiAgICAgICAgICB2YXIgZHJhZ0luZGV4ID0gaW5kZXgoZHJhZ0VsKTtcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGRyYWdJbmRleCAtPSBkaXJlY3Rpb247XG4gICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50RWwuY2hpbGRyZW5bZHJhZ0luZGV4XTtcbiAgICAgICAgICB9IHdoaWxlIChzaWJsaW5nICYmIChjc3Moc2libGluZywgJ2Rpc3BsYXknKSA9PT0gJ25vbmUnIHx8IHNpYmxpbmcgPT09IGdob3N0RWwpKTtcbiAgICAgICAgfSAvLyBJZiBkcmFnRWwgaXMgYWxyZWFkeSBiZXNpZGUgdGFyZ2V0OiBEbyBub3QgaW5zZXJ0XG5cblxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAwIHx8IHNpYmxpbmcgPT09IHRhcmdldCkge1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgbGFzdERpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gdGFyZ2V0Lm5leHRFbGVtZW50U2libGluZyxcbiAgICAgICAgICAgIGFmdGVyID0gZmFsc2U7XG4gICAgICAgIGFmdGVyID0gZGlyZWN0aW9uID09PSAxO1xuXG4gICAgICAgIHZhciBtb3ZlVmVjdG9yID0gX29uTW92ZShyb290RWwsIGVsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXQsIHRhcmdldFJlY3QsIGV2dCwgYWZ0ZXIpO1xuXG4gICAgICAgIGlmIChtb3ZlVmVjdG9yICE9PSBmYWxzZSkge1xuICAgICAgICAgIGlmIChtb3ZlVmVjdG9yID09PSAxIHx8IG1vdmVWZWN0b3IgPT09IC0xKSB7XG4gICAgICAgICAgICBhZnRlciA9IG1vdmVWZWN0b3IgPT09IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3NpbGVudCA9IHRydWU7XG4gICAgICAgICAgc2V0VGltZW91dChfdW5zaWxlbnQsIDMwKTtcbiAgICAgICAgICBjYXB0dXJlKCk7XG5cbiAgICAgICAgICBpZiAoYWZ0ZXIgJiYgIW5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChkcmFnRWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZHJhZ0VsLCBhZnRlciA/IG5leHRTaWJsaW5nIDogdGFyZ2V0KTtcbiAgICAgICAgICB9IC8vIFVuZG8gY2hyb21lJ3Mgc2Nyb2xsIGFkanVzdG1lbnQgKGhhcyBubyBlZmZlY3Qgb24gb3RoZXIgYnJvd3NlcnMpXG5cblxuICAgICAgICAgIGlmIChzY3JvbGxlZFBhc3RUb3ApIHtcbiAgICAgICAgICAgIHNjcm9sbEJ5KHNjcm9sbGVkUGFzdFRvcCwgMCwgc2Nyb2xsQmVmb3JlIC0gc2Nyb2xsZWRQYXN0VG9wLnNjcm9sbFRvcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFyZW50RWwgPSBkcmFnRWwucGFyZW50Tm9kZTsgLy8gYWN0dWFsaXphdGlvblxuICAgICAgICAgIC8vIG11c3QgYmUgZG9uZSBiZWZvcmUgYW5pbWF0aW9uXG5cbiAgICAgICAgICBpZiAodGFyZ2V0QmVmb3JlRmlyc3RTd2FwICE9PSB1bmRlZmluZWQgJiYgIWlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQpIHtcbiAgICAgICAgICAgIHRhcmdldE1vdmVEaXN0YW5jZSA9IE1hdGguYWJzKHRhcmdldEJlZm9yZUZpcnN0U3dhcCAtIGdldFJlY3QodGFyZ2V0KVtzaWRlMV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoYW5nZWQoKTtcbiAgICAgICAgICByZXR1cm4gY29tcGxldGVkKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbC5jb250YWlucyhkcmFnRWwpKSB7XG4gICAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgX2lnbm9yZVdoaWxlQW5pbWF0aW5nOiBudWxsLFxuICBfb2ZmTW92ZUV2ZW50czogZnVuY3Rpb24gX29mZk1vdmVFdmVudHMoKSB7XG4gICAgb2ZmKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgIG9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICBvZmYoZG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICBvZmYoZG9jdW1lbnQsICdkcmFnb3ZlcicsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICBvZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgb2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICB9LFxuICBfb2ZmVXBFdmVudHM6IGZ1bmN0aW9uIF9vZmZVcEV2ZW50cygpIHtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IHRoaXMuZWwub3duZXJEb2N1bWVudDtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9vbkRyb3ApO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vbkRyb3ApO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAncG9pbnRlcnVwJywgdGhpcy5fb25Ecm9wKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgdGhpcy5fb25Ecm9wKTtcbiAgICBvZmYoZG9jdW1lbnQsICdzZWxlY3RzdGFydCcsIHRoaXMpO1xuICB9LFxuICBfb25Ecm9wOiBmdW5jdGlvbiBfb25Ecm9wKFxuICAvKipFdmVudCovXG4gIGV2dCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWwsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7IC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGRyYWdnZWQgZWxlbWVudCB3aXRoaW4gaXRzIHBhcmVudFxuXG4gICAgbmV3SW5kZXggPSBpbmRleChkcmFnRWwpO1xuICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gaW5kZXgoZHJhZ0VsLCBvcHRpb25zLmRyYWdnYWJsZSk7XG4gICAgcGx1Z2luRXZlbnQoJ2Ryb3AnLCB0aGlzLCB7XG4gICAgICBldnQ6IGV2dFxuICAgIH0pO1xuICAgIHBhcmVudEVsID0gZHJhZ0VsICYmIGRyYWdFbC5wYXJlbnROb2RlOyAvLyBHZXQgYWdhaW4gYWZ0ZXIgcGx1Z2luIGV2ZW50XG5cbiAgICBuZXdJbmRleCA9IGluZGV4KGRyYWdFbCk7XG4gICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBpbmRleChkcmFnRWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcblxuICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICB0aGlzLl9udWxsaW5nKCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhd2FpdGluZ0RyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgaXNDaXJjdW1zdGFudGlhbEludmVydCA9IGZhbHNlO1xuICAgIHBhc3RGaXJzdEludmVydFRocmVzaCA9IGZhbHNlO1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fbG9vcElkKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fZHJhZ1N0YXJ0VGltZXIpO1xuXG4gICAgX2NhbmNlbE5leHRUaWNrKHRoaXMuY2xvbmVJZCk7XG5cbiAgICBfY2FuY2VsTmV4dFRpY2sodGhpcy5fZHJhZ1N0YXJ0SWQpOyAvLyBVbmJpbmQgZXZlbnRzXG5cblxuICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgb2ZmKGRvY3VtZW50LCAnZHJvcCcsIHRoaXMpO1xuICAgICAgb2ZmKGVsLCAnZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xuICAgIH1cblxuICAgIHRoaXMuX29mZk1vdmVFdmVudHMoKTtcblxuICAgIHRoaXMuX29mZlVwRXZlbnRzKCk7XG5cbiAgICBpZiAoU2FmYXJpKSB7XG4gICAgICBjc3MoZG9jdW1lbnQuYm9keSwgJ3VzZXItc2VsZWN0JywgJycpO1xuICAgIH1cblxuICAgIGNzcyhkcmFnRWwsICd0cmFuc2Zvcm0nLCAnJyk7XG5cbiAgICBpZiAoZXZ0KSB7XG4gICAgICBpZiAobW92ZWQpIHtcbiAgICAgICAgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICFvcHRpb25zLmRyb3BCdWJibGUgJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBnaG9zdEVsICYmIGdob3N0RWwucGFyZW50Tm9kZSAmJiBnaG9zdEVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZ2hvc3RFbCk7XG5cbiAgICAgIGlmIChyb290RWwgPT09IHBhcmVudEVsIHx8IHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLmxhc3RQdXRNb2RlICE9PSAnY2xvbmUnKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjbG9uZShzKVxuICAgICAgICBjbG9uZUVsICYmIGNsb25lRWwucGFyZW50Tm9kZSAmJiBjbG9uZUVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvbmVFbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkcmFnRWwpIHtcbiAgICAgICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgICAgb2ZmKGRyYWdFbCwgJ2RyYWdlbmQnLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9kaXNhYmxlRHJhZ2dhYmxlKGRyYWdFbCk7XG5cbiAgICAgICAgZHJhZ0VsLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJyc7IC8vIFJlbW92ZSBjbGFzc2VzXG4gICAgICAgIC8vIGdob3N0Q2xhc3MgaXMgYWRkZWQgaW4gZHJhZ1N0YXJ0ZWRcblxuICAgICAgICBpZiAobW92ZWQgJiYgIWF3YWl0aW5nRHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIHB1dFNvcnRhYmxlID8gcHV0U29ydGFibGUub3B0aW9ucy5naG9zdENsYXNzIDogdGhpcy5vcHRpb25zLmdob3N0Q2xhc3MsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgdGhpcy5vcHRpb25zLmNob3NlbkNsYXNzLCBmYWxzZSk7IC8vIERyYWcgc3RvcCBldmVudFxuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICBuYW1lOiAndW5jaG9vc2UnLFxuICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgIG5ld0luZGV4OiBudWxsLFxuICAgICAgICAgIG5ld0RyYWdnYWJsZUluZGV4OiBudWxsLFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocm9vdEVsICE9PSBwYXJlbnRFbCkge1xuICAgICAgICAgIGlmIChuZXdJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBBZGQgZXZlbnRcbiAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgcm9vdEVsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgbmFtZTogJ2FkZCcsXG4gICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBmcm9tRWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICB9KTsgLy8gUmVtb3ZlIGV2ZW50XG5cblxuICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgICAgbmFtZTogJ3JlbW92ZScsXG4gICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgIH0pOyAvLyBkcmFnIGZyb20gb25lIGxpc3QgYW5kIGRyb3AgaW50byBhbm90aGVyXG5cblxuICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICByb290RWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBuYW1lOiAnc29ydCcsXG4gICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBmcm9tRWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgICAgbmFtZTogJ3NvcnQnLFxuICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwdXRTb3J0YWJsZSAmJiBwdXRTb3J0YWJsZS5zYXZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG5ld0luZGV4ICE9PSBvbGRJbmRleCkge1xuICAgICAgICAgICAgaWYgKG5ld0luZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgLy8gZHJhZyAmIGRyb3Agd2l0aGluIHRoZSBzYW1lIGxpc3RcbiAgICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1cGRhdGUnLFxuICAgICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3NvcnQnLFxuICAgICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoU29ydGFibGUuYWN0aXZlKSB7XG4gICAgICAgICAgLyoganNoaW50IGVxbnVsbDp0cnVlICovXG4gICAgICAgICAgaWYgKG5ld0luZGV4ID09IG51bGwgfHwgbmV3SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBuZXdJbmRleCA9IG9sZEluZGV4O1xuICAgICAgICAgICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBvbGREcmFnZ2FibGVJbmRleDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgIG5hbWU6ICdlbmQnLFxuICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICB9KTsgLy8gU2F2ZSBzb3J0aW5nXG5cblxuICAgICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbnVsbGluZygpO1xuICB9LFxuICBfbnVsbGluZzogZnVuY3Rpb24gX251bGxpbmcoKSB7XG4gICAgcGx1Z2luRXZlbnQoJ251bGxpbmcnLCB0aGlzKTtcbiAgICByb290RWwgPSBkcmFnRWwgPSBwYXJlbnRFbCA9IGdob3N0RWwgPSBuZXh0RWwgPSBjbG9uZUVsID0gbGFzdERvd25FbCA9IGNsb25lSGlkZGVuID0gdGFwRXZ0ID0gdG91Y2hFdnQgPSBtb3ZlZCA9IG5ld0luZGV4ID0gbmV3RHJhZ2dhYmxlSW5kZXggPSBvbGRJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4ID0gbGFzdFRhcmdldCA9IGxhc3REaXJlY3Rpb24gPSBwdXRTb3J0YWJsZSA9IGFjdGl2ZUdyb3VwID0gU29ydGFibGUuZHJhZ2dlZCA9IFNvcnRhYmxlLmdob3N0ID0gU29ydGFibGUuY2xvbmUgPSBTb3J0YWJsZS5hY3RpdmUgPSBudWxsO1xuICAgIHNhdmVkSW5wdXRDaGVja2VkLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICBlbC5jaGVja2VkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBzYXZlZElucHV0Q2hlY2tlZC5sZW5ndGggPSBsYXN0RHggPSBsYXN0RHkgPSAwO1xuICB9LFxuICBoYW5kbGVFdmVudDogZnVuY3Rpb24gaGFuZGxlRXZlbnQoXG4gIC8qKkV2ZW50Ki9cbiAgZXZ0KSB7XG4gICAgc3dpdGNoIChldnQudHlwZSkge1xuICAgICAgY2FzZSAnZHJvcCc6XG4gICAgICBjYXNlICdkcmFnZW5kJzpcbiAgICAgICAgdGhpcy5fb25Ecm9wKGV2dCk7XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2RyYWdlbnRlcic6XG4gICAgICBjYXNlICdkcmFnb3Zlcic6XG4gICAgICAgIGlmIChkcmFnRWwpIHtcbiAgICAgICAgICB0aGlzLl9vbkRyYWdPdmVyKGV2dCk7XG5cbiAgICAgICAgICBfZ2xvYmFsRHJhZ092ZXIoZXZ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzZWxlY3RzdGFydCc6XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogU2VyaWFsaXplcyB0aGUgaXRlbSBpbnRvIGFuIGFycmF5IG9mIHN0cmluZy5cclxuICAgKiBAcmV0dXJucyB7U3RyaW5nW119XHJcbiAgICovXG4gIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgdmFyIG9yZGVyID0gW10sXG4gICAgICAgIGVsLFxuICAgICAgICBjaGlsZHJlbiA9IHRoaXMuZWwuY2hpbGRyZW4sXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBuID0gY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgIGVsID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChjbG9zZXN0KGVsLCBvcHRpb25zLmRyYWdnYWJsZSwgdGhpcy5lbCwgZmFsc2UpKSB7XG4gICAgICAgIG9yZGVyLnB1c2goZWwuZ2V0QXR0cmlidXRlKG9wdGlvbnMuZGF0YUlkQXR0cikgfHwgX2dlbmVyYXRlSWQoZWwpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3JkZXI7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogU29ydHMgdGhlIGVsZW1lbnRzIGFjY29yZGluZyB0byB0aGUgYXJyYXkuXHJcbiAgICogQHBhcmFtICB7U3RyaW5nW119ICBvcmRlciAgb3JkZXIgb2YgdGhlIGl0ZW1zXHJcbiAgICovXG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQob3JkZXIsIHVzZUFuaW1hdGlvbikge1xuICAgIHZhciBpdGVtcyA9IHt9LFxuICAgICAgICByb290RWwgPSB0aGlzLmVsO1xuICAgIHRoaXMudG9BcnJheSgpLmZvckVhY2goZnVuY3Rpb24gKGlkLCBpKSB7XG4gICAgICB2YXIgZWwgPSByb290RWwuY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChjbG9zZXN0KGVsLCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlLCByb290RWwsIGZhbHNlKSkge1xuICAgICAgICBpdGVtc1tpZF0gPSBlbDtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICB1c2VBbmltYXRpb24gJiYgdGhpcy5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICBvcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgaWYgKGl0ZW1zW2lkXSkge1xuICAgICAgICByb290RWwucmVtb3ZlQ2hpbGQoaXRlbXNbaWRdKTtcbiAgICAgICAgcm9vdEVsLmFwcGVuZENoaWxkKGl0ZW1zW2lkXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdXNlQW5pbWF0aW9uICYmIHRoaXMuYW5pbWF0ZUFsbCgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNhdmUgdGhlIGN1cnJlbnQgc29ydGluZ1xyXG4gICAqL1xuICBzYXZlOiBmdW5jdGlvbiBzYXZlKCkge1xuICAgIHZhciBzdG9yZSA9IHRoaXMub3B0aW9ucy5zdG9yZTtcbiAgICBzdG9yZSAmJiBzdG9yZS5zZXQgJiYgc3RvcmUuc2V0KHRoaXMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldCwgZ2V0IHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IgYnkgdGVzdGluZyB0aGUgZWxlbWVudCBpdHNlbGYgYW5kIHRyYXZlcnNpbmcgdXAgdGhyb3VnaCBpdHMgYW5jZXN0b3JzIGluIHRoZSBET00gdHJlZS5cclxuICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICBlbFxyXG4gICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgICAgIFtzZWxlY3Rvcl0gIGRlZmF1bHQ6IGBvcHRpb25zLmRyYWdnYWJsZWBcclxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8bnVsbH1cclxuICAgKi9cbiAgY2xvc2VzdDogZnVuY3Rpb24gY2xvc2VzdCQxKGVsLCBzZWxlY3Rvcikge1xuICAgIHJldHVybiBjbG9zZXN0KGVsLCBzZWxlY3RvciB8fCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlLCB0aGlzLmVsLCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogU2V0L2dldCBvcHRpb25cclxuICAgKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXHJcbiAgICogQHBhcmFtICAgeyp9ICAgICAgW3ZhbHVlXVxyXG4gICAqIEByZXR1cm5zIHsqfVxyXG4gICAqL1xuICBvcHRpb246IGZ1bmN0aW9uIG9wdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBvcHRpb25zW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbW9kaWZpZWRWYWx1ZSA9IFBsdWdpbk1hbmFnZXIubW9kaWZ5T3B0aW9uKHRoaXMsIG5hbWUsIHZhbHVlKTtcblxuICAgICAgaWYgKHR5cGVvZiBtb2RpZmllZFZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvcHRpb25zW25hbWVdID0gbW9kaWZpZWRWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgPT09ICdncm91cCcpIHtcbiAgICAgICAgX3ByZXBhcmVHcm91cChvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRGVzdHJveVxyXG4gICAqL1xuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHBsdWdpbkV2ZW50KCdkZXN0cm95JywgdGhpcyk7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBlbFtleHBhbmRvXSA9IG51bGw7XG4gICAgb2ZmKGVsLCAnbW91c2Vkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XG4gICAgb2ZmKGVsLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVGFwU3RhcnQpO1xuICAgIG9mZihlbCwgJ3BvaW50ZXJkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XG5cbiAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgIG9mZihlbCwgJ2RyYWdvdmVyJywgdGhpcyk7XG4gICAgICBvZmYoZWwsICdkcmFnZW50ZXInLCB0aGlzKTtcbiAgICB9IC8vIFJlbW92ZSBkcmFnZ2FibGUgYXR0cmlidXRlc1xuXG5cbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkcmFnZ2FibGVdJyksIGZ1bmN0aW9uIChlbCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdkcmFnZ2FibGUnKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX29uRHJvcCgpO1xuXG4gICAgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnRXZlbnRzKCk7XG5cbiAgICBzb3J0YWJsZXMuc3BsaWNlKHNvcnRhYmxlcy5pbmRleE9mKHRoaXMuZWwpLCAxKTtcbiAgICB0aGlzLmVsID0gZWwgPSBudWxsO1xuICB9LFxuICBfaGlkZUNsb25lOiBmdW5jdGlvbiBfaGlkZUNsb25lKCkge1xuICAgIGlmICghY2xvbmVIaWRkZW4pIHtcbiAgICAgIHBsdWdpbkV2ZW50KCdoaWRlQ2xvbmUnLCB0aGlzKTtcbiAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm47XG4gICAgICBjc3MoY2xvbmVFbCwgJ2Rpc3BsYXknLCAnbm9uZScpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlICYmIGNsb25lRWwucGFyZW50Tm9kZSkge1xuICAgICAgICBjbG9uZUVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvbmVFbCk7XG4gICAgICB9XG5cbiAgICAgIGNsb25lSGlkZGVuID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG4gIF9zaG93Q2xvbmU6IGZ1bmN0aW9uIF9zaG93Q2xvbmUocHV0U29ydGFibGUpIHtcbiAgICBpZiAocHV0U29ydGFibGUubGFzdFB1dE1vZGUgIT09ICdjbG9uZScpIHtcbiAgICAgIHRoaXMuX2hpZGVDbG9uZSgpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNsb25lSGlkZGVuKSB7XG4gICAgICBwbHVnaW5FdmVudCgnc2hvd0Nsb25lJywgdGhpcyk7XG4gICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuOyAvLyBzaG93IGNsb25lIGF0IGRyYWdFbCBvciBvcmlnaW5hbCBwb3NpdGlvblxuXG4gICAgICBpZiAoZHJhZ0VsLnBhcmVudE5vZGUgPT0gcm9vdEVsICYmICF0aGlzLm9wdGlvbnMuZ3JvdXAucmV2ZXJ0Q2xvbmUpIHtcbiAgICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShjbG9uZUVsLCBkcmFnRWwpO1xuICAgICAgfSBlbHNlIGlmIChuZXh0RWwpIHtcbiAgICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShjbG9uZUVsLCBuZXh0RWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdEVsLmFwcGVuZENoaWxkKGNsb25lRWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmdyb3VwLnJldmVydENsb25lKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0ZShkcmFnRWwsIGNsb25lRWwpO1xuICAgICAgfVxuXG4gICAgICBjc3MoY2xvbmVFbCwgJ2Rpc3BsYXknLCAnJyk7XG4gICAgICBjbG9uZUhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2dsb2JhbERyYWdPdmVyKFxuLyoqRXZlbnQqL1xuZXZ0KSB7XG4gIGlmIChldnQuZGF0YVRyYW5zZmVyKSB7XG4gICAgZXZ0LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ21vdmUnO1xuICB9XG5cbiAgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmZ1bmN0aW9uIF9vbk1vdmUoZnJvbUVsLCB0b0VsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXRFbCwgdGFyZ2V0UmVjdCwgb3JpZ2luYWxFdmVudCwgd2lsbEluc2VydEFmdGVyKSB7XG4gIHZhciBldnQsXG4gICAgICBzb3J0YWJsZSA9IGZyb21FbFtleHBhbmRvXSxcbiAgICAgIG9uTW92ZUZuID0gc29ydGFibGUub3B0aW9ucy5vbk1vdmUsXG4gICAgICByZXRWYWw7IC8vIFN1cHBvcnQgZm9yIG5ldyBDdXN0b21FdmVudCBmZWF0dXJlXG5cbiAgaWYgKHdpbmRvdy5DdXN0b21FdmVudCAmJiAhSUUxMU9yTGVzcyAmJiAhRWRnZSkge1xuICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudCgnbW92ZScsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZ0LmluaXRFdmVudCgnbW92ZScsIHRydWUsIHRydWUpO1xuICB9XG5cbiAgZXZ0LnRvID0gdG9FbDtcbiAgZXZ0LmZyb20gPSBmcm9tRWw7XG4gIGV2dC5kcmFnZ2VkID0gZHJhZ0VsO1xuICBldnQuZHJhZ2dlZFJlY3QgPSBkcmFnUmVjdDtcbiAgZXZ0LnJlbGF0ZWQgPSB0YXJnZXRFbCB8fCB0b0VsO1xuICBldnQucmVsYXRlZFJlY3QgPSB0YXJnZXRSZWN0IHx8IGdldFJlY3QodG9FbCk7XG4gIGV2dC53aWxsSW5zZXJ0QWZ0ZXIgPSB3aWxsSW5zZXJ0QWZ0ZXI7XG4gIGV2dC5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgZnJvbUVsLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuICBpZiAob25Nb3ZlRm4pIHtcbiAgICByZXRWYWwgPSBvbk1vdmVGbi5jYWxsKHNvcnRhYmxlLCBldnQsIG9yaWdpbmFsRXZlbnQpO1xuICB9XG5cbiAgcmV0dXJuIHJldFZhbDtcbn1cblxuZnVuY3Rpb24gX2Rpc2FibGVEcmFnZ2FibGUoZWwpIHtcbiAgZWwuZHJhZ2dhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF91bnNpbGVudCgpIHtcbiAgX3NpbGVudCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfZ2hvc3RJc0ZpcnN0KGV2dCwgdmVydGljYWwsIHNvcnRhYmxlKSB7XG4gIHZhciByZWN0ID0gZ2V0UmVjdChnZXRDaGlsZChzb3J0YWJsZS5lbCwgMCwgc29ydGFibGUub3B0aW9ucywgdHJ1ZSkpO1xuICB2YXIgc3BhY2VyID0gMTA7XG4gIHJldHVybiB2ZXJ0aWNhbCA/IGV2dC5jbGllbnRYIDwgcmVjdC5sZWZ0IC0gc3BhY2VyIHx8IGV2dC5jbGllbnRZIDwgcmVjdC50b3AgJiYgZXZ0LmNsaWVudFggPCByZWN0LnJpZ2h0IDogZXZ0LmNsaWVudFkgPCByZWN0LnRvcCAtIHNwYWNlciB8fCBldnQuY2xpZW50WSA8IHJlY3QuYm90dG9tICYmIGV2dC5jbGllbnRYIDwgcmVjdC5sZWZ0O1xufVxuXG5mdW5jdGlvbiBfZ2hvc3RJc0xhc3QoZXZ0LCB2ZXJ0aWNhbCwgc29ydGFibGUpIHtcbiAgdmFyIHJlY3QgPSBnZXRSZWN0KGxhc3RDaGlsZChzb3J0YWJsZS5lbCwgc29ydGFibGUub3B0aW9ucy5kcmFnZ2FibGUpKTtcbiAgdmFyIHNwYWNlciA9IDEwO1xuICByZXR1cm4gdmVydGljYWwgPyBldnQuY2xpZW50WCA+IHJlY3QucmlnaHQgKyBzcGFjZXIgfHwgZXZ0LmNsaWVudFggPD0gcmVjdC5yaWdodCAmJiBldnQuY2xpZW50WSA+IHJlY3QuYm90dG9tICYmIGV2dC5jbGllbnRYID49IHJlY3QubGVmdCA6IGV2dC5jbGllbnRYID4gcmVjdC5yaWdodCAmJiBldnQuY2xpZW50WSA+IHJlY3QudG9wIHx8IGV2dC5jbGllbnRYIDw9IHJlY3QucmlnaHQgJiYgZXZ0LmNsaWVudFkgPiByZWN0LmJvdHRvbSArIHNwYWNlcjtcbn1cblxuZnVuY3Rpb24gX2dldFN3YXBEaXJlY3Rpb24oZXZ0LCB0YXJnZXQsIHRhcmdldFJlY3QsIHZlcnRpY2FsLCBzd2FwVGhyZXNob2xkLCBpbnZlcnRlZFN3YXBUaHJlc2hvbGQsIGludmVydFN3YXAsIGlzTGFzdFRhcmdldCkge1xuICB2YXIgbW91c2VPbkF4aXMgPSB2ZXJ0aWNhbCA/IGV2dC5jbGllbnRZIDogZXZ0LmNsaWVudFgsXG4gICAgICB0YXJnZXRMZW5ndGggPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QuaGVpZ2h0IDogdGFyZ2V0UmVjdC53aWR0aCxcbiAgICAgIHRhcmdldFMxID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LnRvcCA6IHRhcmdldFJlY3QubGVmdCxcbiAgICAgIHRhcmdldFMyID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LmJvdHRvbSA6IHRhcmdldFJlY3QucmlnaHQsXG4gICAgICBpbnZlcnQgPSBmYWxzZTtcblxuICBpZiAoIWludmVydFN3YXApIHtcbiAgICAvLyBOZXZlciBpbnZlcnQgb3IgY3JlYXRlIGRyYWdFbCBzaGFkb3cgd2hlbiB0YXJnZXQgbW92ZW1lbmV0IGNhdXNlcyBtb3VzZSB0byBtb3ZlIHBhc3QgdGhlIGVuZCBvZiByZWd1bGFyIHN3YXBUaHJlc2hvbGRcbiAgICBpZiAoaXNMYXN0VGFyZ2V0ICYmIHRhcmdldE1vdmVEaXN0YW5jZSA8IHRhcmdldExlbmd0aCAqIHN3YXBUaHJlc2hvbGQpIHtcbiAgICAgIC8vIG11bHRpcGxpZWQgb25seSBieSBzd2FwVGhyZXNob2xkIGJlY2F1c2UgbW91c2Ugd2lsbCBhbHJlYWR5IGJlIGluc2lkZSB0YXJnZXQgYnkgKDEgLSB0aHJlc2hvbGQpICogdGFyZ2V0TGVuZ3RoIC8gMlxuICAgICAgLy8gY2hlY2sgaWYgcGFzdCBmaXJzdCBpbnZlcnQgdGhyZXNob2xkIG9uIHNpZGUgb3Bwb3NpdGUgb2YgbGFzdERpcmVjdGlvblxuICAgICAgaWYgKCFwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggJiYgKGxhc3REaXJlY3Rpb24gPT09IDEgPyBtb3VzZU9uQXhpcyA+IHRhcmdldFMxICsgdGFyZ2V0TGVuZ3RoICogaW52ZXJ0ZWRTd2FwVGhyZXNob2xkIC8gMiA6IG1vdXNlT25BeGlzIDwgdGFyZ2V0UzIgLSB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyKSkge1xuICAgICAgICAvLyBwYXN0IGZpcnN0IGludmVydCB0aHJlc2hvbGQsIGRvIG5vdCByZXN0cmljdCBpbnZlcnRlZCB0aHJlc2hvbGQgdG8gZHJhZ0VsIHNoYWRvd1xuICAgICAgICBwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBhc3RGaXJzdEludmVydFRocmVzaCkge1xuICAgICAgICAvLyBkcmFnRWwgc2hhZG93ICh0YXJnZXQgbW92ZSBkaXN0YW5jZSBzaGFkb3cpXG4gICAgICAgIGlmIChsYXN0RGlyZWN0aW9uID09PSAxID8gbW91c2VPbkF4aXMgPCB0YXJnZXRTMSArIHRhcmdldE1vdmVEaXN0YW5jZSAvLyBvdmVyIGRyYWdFbCBzaGFkb3dcbiAgICAgICAgOiBtb3VzZU9uQXhpcyA+IHRhcmdldFMyIC0gdGFyZ2V0TW92ZURpc3RhbmNlKSB7XG4gICAgICAgICAgcmV0dXJuIC1sYXN0RGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZlcnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWd1bGFyXG4gICAgICBpZiAobW91c2VPbkF4aXMgPiB0YXJnZXRTMSArIHRhcmdldExlbmd0aCAqICgxIC0gc3dhcFRocmVzaG9sZCkgLyAyICYmIG1vdXNlT25BeGlzIDwgdGFyZ2V0UzIgLSB0YXJnZXRMZW5ndGggKiAoMSAtIHN3YXBUaHJlc2hvbGQpIC8gMikge1xuICAgICAgICByZXR1cm4gX2dldEluc2VydERpcmVjdGlvbih0YXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGludmVydCA9IGludmVydCB8fCBpbnZlcnRTd2FwO1xuXG4gIGlmIChpbnZlcnQpIHtcbiAgICAvLyBJbnZlcnQgb2YgcmVndWxhclxuICAgIGlmIChtb3VzZU9uQXhpcyA8IHRhcmdldFMxICsgdGFyZ2V0TGVuZ3RoICogaW52ZXJ0ZWRTd2FwVGhyZXNob2xkIC8gMiB8fCBtb3VzZU9uQXhpcyA+IHRhcmdldFMyIC0gdGFyZ2V0TGVuZ3RoICogaW52ZXJ0ZWRTd2FwVGhyZXNob2xkIC8gMikge1xuICAgICAgcmV0dXJuIG1vdXNlT25BeGlzID4gdGFyZ2V0UzEgKyB0YXJnZXRMZW5ndGggLyAyID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuLyoqXHJcbiAqIEdldHMgdGhlIGRpcmVjdGlvbiBkcmFnRWwgbXVzdCBiZSBzd2FwcGVkIHJlbGF0aXZlIHRvIHRhcmdldCBpbiBvcmRlciB0byBtYWtlIGl0XHJcbiAqIHNlZW0gdGhhdCBkcmFnRWwgaGFzIGJlZW4gXCJpbnNlcnRlZFwiIGludG8gdGhhdCBlbGVtZW50J3MgcG9zaXRpb25cclxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IHRhcmdldCAgICAgICBUaGUgdGFyZ2V0IHdob3NlIHBvc2l0aW9uIGRyYWdFbCBpcyBiZWluZyBpbnNlcnRlZCBhdFxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgIERpcmVjdGlvbiBkcmFnRWwgbXVzdCBiZSBzd2FwcGVkXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIF9nZXRJbnNlcnREaXJlY3Rpb24odGFyZ2V0KSB7XG4gIGlmIChpbmRleChkcmFnRWwpIDwgaW5kZXgodGFyZ2V0KSkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAtMTtcbiAgfVxufVxuLyoqXHJcbiAqIEdlbmVyYXRlIGlkXHJcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gZWxcclxuICogQHJldHVybnMge1N0cmluZ31cclxuICogQHByaXZhdGVcclxuICovXG5cblxuZnVuY3Rpb24gX2dlbmVyYXRlSWQoZWwpIHtcbiAgdmFyIHN0ciA9IGVsLnRhZ05hbWUgKyBlbC5jbGFzc05hbWUgKyBlbC5zcmMgKyBlbC5ocmVmICsgZWwudGV4dENvbnRlbnQsXG4gICAgICBpID0gc3RyLmxlbmd0aCxcbiAgICAgIHN1bSA9IDA7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHN1bSArPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuXG4gIHJldHVybiBzdW0udG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBfc2F2ZUlucHV0Q2hlY2tlZFN0YXRlKHJvb3QpIHtcbiAgc2F2ZWRJbnB1dENoZWNrZWQubGVuZ3RoID0gMDtcbiAgdmFyIGlucHV0cyA9IHJvb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lucHV0Jyk7XG4gIHZhciBpZHggPSBpbnB1dHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpZHgtLSkge1xuICAgIHZhciBlbCA9IGlucHV0c1tpZHhdO1xuICAgIGVsLmNoZWNrZWQgJiYgc2F2ZWRJbnB1dENoZWNrZWQucHVzaChlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX25leHRUaWNrKGZuKSB7XG4gIHJldHVybiBzZXRUaW1lb3V0KGZuLCAwKTtcbn1cblxuZnVuY3Rpb24gX2NhbmNlbE5leHRUaWNrKGlkKSB7XG4gIHJldHVybiBjbGVhclRpbWVvdXQoaWQpO1xufSAvLyBGaXhlZCAjOTczOlxuXG5cbmlmIChkb2N1bWVudEV4aXN0cykge1xuICBvbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIGZ1bmN0aW9uIChldnQpIHtcbiAgICBpZiAoKFNvcnRhYmxlLmFjdGl2ZSB8fCBhd2FpdGluZ0RyYWdTdGFydGVkKSAmJiBldnQuY2FuY2VsYWJsZSkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9KTtcbn0gLy8gRXhwb3J0IHV0aWxzXG5cblxuU29ydGFibGUudXRpbHMgPSB7XG4gIG9uOiBvbixcbiAgb2ZmOiBvZmYsXG4gIGNzczogY3NzLFxuICBmaW5kOiBmaW5kLFxuICBpczogZnVuY3Rpb24gaXMoZWwsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuICEhY2xvc2VzdChlbCwgc2VsZWN0b3IsIGVsLCBmYWxzZSk7XG4gIH0sXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0aHJvdHRsZTogdGhyb3R0bGUsXG4gIGNsb3Nlc3Q6IGNsb3Nlc3QsXG4gIHRvZ2dsZUNsYXNzOiB0b2dnbGVDbGFzcyxcbiAgY2xvbmU6IGNsb25lLFxuICBpbmRleDogaW5kZXgsXG4gIG5leHRUaWNrOiBfbmV4dFRpY2ssXG4gIGNhbmNlbE5leHRUaWNrOiBfY2FuY2VsTmV4dFRpY2ssXG4gIGRldGVjdERpcmVjdGlvbjogX2RldGVjdERpcmVjdGlvbixcbiAgZ2V0Q2hpbGQ6IGdldENoaWxkXG59O1xuLyoqXHJcbiAqIEdldCB0aGUgU29ydGFibGUgaW5zdGFuY2Ugb2YgYW4gZWxlbWVudFxyXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudFxyXG4gKiBAcmV0dXJuIHtTb3J0YWJsZXx1bmRlZmluZWR9ICAgICAgICAgVGhlIGluc3RhbmNlIG9mIFNvcnRhYmxlXHJcbiAqL1xuXG5Tb3J0YWJsZS5nZXQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudFtleHBhbmRvXTtcbn07XG4vKipcclxuICogTW91bnQgYSBwbHVnaW4gdG8gU29ydGFibGVcclxuICogQHBhcmFtICB7Li4uU29ydGFibGVQbHVnaW58U29ydGFibGVQbHVnaW5bXX0gcGx1Z2lucyAgICAgICBQbHVnaW5zIGJlaW5nIG1vdW50ZWRcclxuICovXG5cblxuU29ydGFibGUubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHBsdWdpbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAocGx1Z2luc1swXS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHBsdWdpbnMgPSBwbHVnaW5zWzBdO1xuICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIGlmICghcGx1Z2luLnByb3RvdHlwZSB8fCAhcGx1Z2luLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgdGhyb3cgXCJTb3J0YWJsZTogTW91bnRlZCBwbHVnaW4gbXVzdCBiZSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCBub3QgXCIuY29uY2F0KHt9LnRvU3RyaW5nLmNhbGwocGx1Z2luKSk7XG4gICAgfVxuXG4gICAgaWYgKHBsdWdpbi51dGlscykgU29ydGFibGUudXRpbHMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgU29ydGFibGUudXRpbHMpLCBwbHVnaW4udXRpbHMpO1xuICAgIFBsdWdpbk1hbmFnZXIubW91bnQocGx1Z2luKTtcbiAgfSk7XG59O1xuLyoqXHJcbiAqIENyZWF0ZSBzb3J0YWJsZSBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSAgZWxcclxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgW29wdGlvbnNdXHJcbiAqL1xuXG5cblNvcnRhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFNvcnRhYmxlKGVsLCBvcHRpb25zKTtcbn07IC8vIEV4cG9ydFxuXG5cblNvcnRhYmxlLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG52YXIgYXV0b1Njcm9sbHMgPSBbXSxcbiAgICBzY3JvbGxFbCxcbiAgICBzY3JvbGxSb290RWwsXG4gICAgc2Nyb2xsaW5nID0gZmFsc2UsXG4gICAgbGFzdEF1dG9TY3JvbGxYLFxuICAgIGxhc3RBdXRvU2Nyb2xsWSxcbiAgICB0b3VjaEV2dCQxLFxuICAgIHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsO1xuXG5mdW5jdGlvbiBBdXRvU2Nyb2xsUGx1Z2luKCkge1xuICBmdW5jdGlvbiBBdXRvU2Nyb2xsKCkge1xuICAgIHRoaXMuZGVmYXVsdHMgPSB7XG4gICAgICBzY3JvbGw6IHRydWUsXG4gICAgICBmb3JjZUF1dG9TY3JvbGxGYWxsYmFjazogZmFsc2UsXG4gICAgICBzY3JvbGxTZW5zaXRpdml0eTogMzAsXG4gICAgICBzY3JvbGxTcGVlZDogMTAsXG4gICAgICBidWJibGVTY3JvbGw6IHRydWVcbiAgICB9OyAvLyBCaW5kIGFsbCBwcml2YXRlIG1ldGhvZHNcblxuICAgIGZvciAodmFyIGZuIGluIHRoaXMpIHtcbiAgICAgIGlmIChmbi5jaGFyQXQoMCkgPT09ICdfJyAmJiB0eXBlb2YgdGhpc1tmbl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpc1tmbl0gPSB0aGlzW2ZuXS5iaW5kKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIEF1dG9TY3JvbGwucHJvdG90eXBlID0ge1xuICAgIGRyYWdTdGFydGVkOiBmdW5jdGlvbiBkcmFnU3RhcnRlZChfcmVmKSB7XG4gICAgICB2YXIgb3JpZ2luYWxFdmVudCA9IF9yZWYub3JpZ2luYWxFdmVudDtcblxuICAgICAgaWYgKHRoaXMuc29ydGFibGUubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAnZHJhZ292ZXInLCB0aGlzLl9oYW5kbGVBdXRvU2Nyb2xsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcbiAgICAgICAgICBvbihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbEV2ZW50LnRvdWNoZXMpIHtcbiAgICAgICAgICBvbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb24oZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkcmFnT3ZlckNvbXBsZXRlZDogZnVuY3Rpb24gZHJhZ092ZXJDb21wbGV0ZWQoX3JlZjIpIHtcbiAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gX3JlZjIub3JpZ2luYWxFdmVudDtcblxuICAgICAgLy8gRm9yIHdoZW4gYnViYmxpbmcgaXMgY2FuY2VsZWQgYW5kIHVzaW5nIGZhbGxiYWNrIChmYWxsYmFjayAndG91Y2htb3ZlJyBhbHdheXMgcmVhY2hlZClcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmRyYWdPdmVyQnViYmxlICYmICFvcmlnaW5hbEV2ZW50LnJvb3RFbCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVBdXRvU2Nyb2xsKG9yaWdpbmFsRXZlbnQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZHJvcDogZnVuY3Rpb24gZHJvcCgpIHtcbiAgICAgIGlmICh0aGlzLnNvcnRhYmxlLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICBvZmYoZG9jdW1lbnQsICdkcmFnb3ZlcicsIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICBvZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICBvZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgfVxuXG4gICAgICBjbGVhclBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKCk7XG4gICAgICBjbGVhckF1dG9TY3JvbGxzKCk7XG4gICAgICBjYW5jZWxUaHJvdHRsZSgpO1xuICAgIH0sXG4gICAgbnVsbGluZzogZnVuY3Rpb24gbnVsbGluZygpIHtcbiAgICAgIHRvdWNoRXZ0JDEgPSBzY3JvbGxSb290RWwgPSBzY3JvbGxFbCA9IHNjcm9sbGluZyA9IHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsID0gbGFzdEF1dG9TY3JvbGxYID0gbGFzdEF1dG9TY3JvbGxZID0gbnVsbDtcbiAgICAgIGF1dG9TY3JvbGxzLmxlbmd0aCA9IDA7XG4gICAgfSxcbiAgICBfaGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsOiBmdW5jdGlvbiBfaGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKGV2dCkge1xuICAgICAgdGhpcy5faGFuZGxlQXV0b1Njcm9sbChldnQsIHRydWUpO1xuICAgIH0sXG4gICAgX2hhbmRsZUF1dG9TY3JvbGw6IGZ1bmN0aW9uIF9oYW5kbGVBdXRvU2Nyb2xsKGV2dCwgZmFsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB4ID0gKGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpLmNsaWVudFgsXG4gICAgICAgICAgeSA9IChldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0KS5jbGllbnRZLFxuICAgICAgICAgIGVsZW0gPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgICAgdG91Y2hFdnQkMSA9IGV2dDsgLy8gSUUgZG9lcyBub3Qgc2VlbSB0byBoYXZlIG5hdGl2ZSBhdXRvc2Nyb2xsLFxuICAgICAgLy8gRWRnZSdzIGF1dG9zY3JvbGwgc2VlbXMgdG9vIGNvbmRpdGlvbmFsLFxuICAgICAgLy8gTUFDT1MgU2FmYXJpIGRvZXMgbm90IGhhdmUgYXV0b3Njcm9sbCxcbiAgICAgIC8vIEZpcmVmb3ggYW5kIENocm9tZSBhcmUgZ29vZFxuXG4gICAgICBpZiAoZmFsbGJhY2sgfHwgdGhpcy5vcHRpb25zLmZvcmNlQXV0b1Njcm9sbEZhbGxiYWNrIHx8IEVkZ2UgfHwgSUUxMU9yTGVzcyB8fCBTYWZhcmkpIHtcbiAgICAgICAgYXV0b1Njcm9sbChldnQsIHRoaXMub3B0aW9ucywgZWxlbSwgZmFsbGJhY2spOyAvLyBMaXN0ZW5lciBmb3IgcG9pbnRlciBlbGVtZW50IGNoYW5nZVxuXG4gICAgICAgIHZhciBvZ0VsZW1TY3JvbGxlciA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsZW0sIHRydWUpO1xuXG4gICAgICAgIGlmIChzY3JvbGxpbmcgJiYgKCFwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCB8fCB4ICE9PSBsYXN0QXV0b1Njcm9sbFggfHwgeSAhPT0gbGFzdEF1dG9TY3JvbGxZKSkge1xuICAgICAgICAgIHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsICYmIGNsZWFyUG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwoKTsgLy8gRGV0ZWN0IGZvciBwb2ludGVyIGVsZW0gY2hhbmdlLCBlbXVsYXRpbmcgbmF0aXZlIERuRCBiZWhhdmlvdXJcblxuICAgICAgICAgIHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5ld0VsZW0gPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHgsIHkpLCB0cnVlKTtcblxuICAgICAgICAgICAgaWYgKG5ld0VsZW0gIT09IG9nRWxlbVNjcm9sbGVyKSB7XG4gICAgICAgICAgICAgIG9nRWxlbVNjcm9sbGVyID0gbmV3RWxlbTtcbiAgICAgICAgICAgICAgY2xlYXJBdXRvU2Nyb2xscygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdXRvU2Nyb2xsKGV2dCwgX3RoaXMub3B0aW9ucywgbmV3RWxlbSwgZmFsbGJhY2spO1xuICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICBsYXN0QXV0b1Njcm9sbFggPSB4O1xuICAgICAgICAgIGxhc3RBdXRvU2Nyb2xsWSA9IHk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIERuRCBpcyBlbmFibGVkIChhbmQgYnJvd3NlciBoYXMgZ29vZCBhdXRvc2Nyb2xsaW5nKSwgZmlyc3QgYXV0b3Njcm9sbCB3aWxsIGFscmVhZHkgc2Nyb2xsLCBzbyBnZXQgcGFyZW50IGF1dG9zY3JvbGwgb2YgZmlyc3QgYXV0b3Njcm9sbFxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5idWJibGVTY3JvbGwgfHwgZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWxlbSwgdHJ1ZSkgPT09IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKSkge1xuICAgICAgICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhdXRvU2Nyb2xsKGV2dCwgdGhpcy5vcHRpb25zLCBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbGVtLCBmYWxzZSksIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcyhBdXRvU2Nyb2xsLCB7XG4gICAgcGx1Z2luTmFtZTogJ3Njcm9sbCcsXG4gICAgaW5pdGlhbGl6ZUJ5RGVmYXVsdDogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY2xlYXJBdXRvU2Nyb2xscygpIHtcbiAgYXV0b1Njcm9sbHMuZm9yRWFjaChmdW5jdGlvbiAoYXV0b1Njcm9sbCkge1xuICAgIGNsZWFySW50ZXJ2YWwoYXV0b1Njcm9sbC5waWQpO1xuICB9KTtcbiAgYXV0b1Njcm9sbHMgPSBbXTtcbn1cblxuZnVuY3Rpb24gY2xlYXJQb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCgpIHtcbiAgY2xlYXJJbnRlcnZhbChwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCk7XG59XG5cbnZhciBhdXRvU2Nyb2xsID0gdGhyb3R0bGUoZnVuY3Rpb24gKGV2dCwgb3B0aW9ucywgcm9vdEVsLCBpc0ZhbGxiYWNrKSB7XG4gIC8vIEJ1ZzogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTA1NTIxXG4gIGlmICghb3B0aW9ucy5zY3JvbGwpIHJldHVybjtcbiAgdmFyIHggPSAoZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCkuY2xpZW50WCxcbiAgICAgIHkgPSAoZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCkuY2xpZW50WSxcbiAgICAgIHNlbnMgPSBvcHRpb25zLnNjcm9sbFNlbnNpdGl2aXR5LFxuICAgICAgc3BlZWQgPSBvcHRpb25zLnNjcm9sbFNwZWVkLFxuICAgICAgd2luU2Nyb2xsZXIgPSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gIHZhciBzY3JvbGxUaGlzSW5zdGFuY2UgPSBmYWxzZSxcbiAgICAgIHNjcm9sbEN1c3RvbUZuOyAvLyBOZXcgc2Nyb2xsIHJvb3QsIHNldCBzY3JvbGxFbFxuXG4gIGlmIChzY3JvbGxSb290RWwgIT09IHJvb3RFbCkge1xuICAgIHNjcm9sbFJvb3RFbCA9IHJvb3RFbDtcbiAgICBjbGVhckF1dG9TY3JvbGxzKCk7XG4gICAgc2Nyb2xsRWwgPSBvcHRpb25zLnNjcm9sbDtcbiAgICBzY3JvbGxDdXN0b21GbiA9IG9wdGlvbnMuc2Nyb2xsRm47XG5cbiAgICBpZiAoc2Nyb2xsRWwgPT09IHRydWUpIHtcbiAgICAgIHNjcm9sbEVsID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQocm9vdEVsLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbGF5ZXJzT3V0ID0gMDtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBzY3JvbGxFbDtcblxuICBkbyB7XG4gICAgdmFyIGVsID0gY3VycmVudFBhcmVudCxcbiAgICAgICAgcmVjdCA9IGdldFJlY3QoZWwpLFxuICAgICAgICB0b3AgPSByZWN0LnRvcCxcbiAgICAgICAgYm90dG9tID0gcmVjdC5ib3R0b20sXG4gICAgICAgIGxlZnQgPSByZWN0LmxlZnQsXG4gICAgICAgIHJpZ2h0ID0gcmVjdC5yaWdodCxcbiAgICAgICAgd2lkdGggPSByZWN0LndpZHRoLFxuICAgICAgICBoZWlnaHQgPSByZWN0LmhlaWdodCxcbiAgICAgICAgY2FuU2Nyb2xsWCA9IHZvaWQgMCxcbiAgICAgICAgY2FuU2Nyb2xsWSA9IHZvaWQgMCxcbiAgICAgICAgc2Nyb2xsV2lkdGggPSBlbC5zY3JvbGxXaWR0aCxcbiAgICAgICAgc2Nyb2xsSGVpZ2h0ID0gZWwuc2Nyb2xsSGVpZ2h0LFxuICAgICAgICBlbENTUyA9IGNzcyhlbCksXG4gICAgICAgIHNjcm9sbFBvc1ggPSBlbC5zY3JvbGxMZWZ0LFxuICAgICAgICBzY3JvbGxQb3NZID0gZWwuc2Nyb2xsVG9wO1xuXG4gICAgaWYgKGVsID09PSB3aW5TY3JvbGxlcikge1xuICAgICAgY2FuU2Nyb2xsWCA9IHdpZHRoIDwgc2Nyb2xsV2lkdGggJiYgKGVsQ1NTLm92ZXJmbG93WCA9PT0gJ2F1dG8nIHx8IGVsQ1NTLm92ZXJmbG93WCA9PT0gJ3Njcm9sbCcgfHwgZWxDU1Mub3ZlcmZsb3dYID09PSAndmlzaWJsZScpO1xuICAgICAgY2FuU2Nyb2xsWSA9IGhlaWdodCA8IHNjcm9sbEhlaWdodCAmJiAoZWxDU1Mub3ZlcmZsb3dZID09PSAnYXV0bycgfHwgZWxDU1Mub3ZlcmZsb3dZID09PSAnc2Nyb2xsJyB8fCBlbENTUy5vdmVyZmxvd1kgPT09ICd2aXNpYmxlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhblNjcm9sbFggPSB3aWR0aCA8IHNjcm9sbFdpZHRoICYmIChlbENTUy5vdmVyZmxvd1ggPT09ICdhdXRvJyB8fCBlbENTUy5vdmVyZmxvd1ggPT09ICdzY3JvbGwnKTtcbiAgICAgIGNhblNjcm9sbFkgPSBoZWlnaHQgPCBzY3JvbGxIZWlnaHQgJiYgKGVsQ1NTLm92ZXJmbG93WSA9PT0gJ2F1dG8nIHx8IGVsQ1NTLm92ZXJmbG93WSA9PT0gJ3Njcm9sbCcpO1xuICAgIH1cblxuICAgIHZhciB2eCA9IGNhblNjcm9sbFggJiYgKE1hdGguYWJzKHJpZ2h0IC0geCkgPD0gc2VucyAmJiBzY3JvbGxQb3NYICsgd2lkdGggPCBzY3JvbGxXaWR0aCkgLSAoTWF0aC5hYnMobGVmdCAtIHgpIDw9IHNlbnMgJiYgISFzY3JvbGxQb3NYKTtcbiAgICB2YXIgdnkgPSBjYW5TY3JvbGxZICYmIChNYXRoLmFicyhib3R0b20gLSB5KSA8PSBzZW5zICYmIHNjcm9sbFBvc1kgKyBoZWlnaHQgPCBzY3JvbGxIZWlnaHQpIC0gKE1hdGguYWJzKHRvcCAtIHkpIDw9IHNlbnMgJiYgISFzY3JvbGxQb3NZKTtcblxuICAgIGlmICghYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbGF5ZXJzT3V0OyBpKyspIHtcbiAgICAgICAgaWYgKCFhdXRvU2Nyb2xsc1tpXSkge1xuICAgICAgICAgIGF1dG9TY3JvbGxzW2ldID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS52eCAhPSB2eCB8fCBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnZ5ICE9IHZ5IHx8IGF1dG9TY3JvbGxzW2xheWVyc091dF0uZWwgIT09IGVsKSB7XG4gICAgICBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLmVsID0gZWw7XG4gICAgICBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnZ4ID0gdng7XG4gICAgICBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnZ5ID0gdnk7XG4gICAgICBjbGVhckludGVydmFsKGF1dG9TY3JvbGxzW2xheWVyc091dF0ucGlkKTtcblxuICAgICAgaWYgKHZ4ICE9IDAgfHwgdnkgIT0gMCkge1xuICAgICAgICBzY3JvbGxUaGlzSW5zdGFuY2UgPSB0cnVlO1xuICAgICAgICAvKiBqc2hpbnQgbG9vcGZ1bmM6dHJ1ZSAqL1xuXG4gICAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0ucGlkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIGVtdWxhdGUgZHJhZyBvdmVyIGR1cmluZyBhdXRvc2Nyb2xsIChmYWxsYmFjayksIGVtdWxhdGluZyBuYXRpdmUgRG5EIGJlaGF2aW91clxuICAgICAgICAgIGlmIChpc0ZhbGxiYWNrICYmIHRoaXMubGF5ZXIgPT09IDApIHtcbiAgICAgICAgICAgIFNvcnRhYmxlLmFjdGl2ZS5fb25Ub3VjaE1vdmUodG91Y2hFdnQkMSk7IC8vIFRvIG1vdmUgZ2hvc3QgaWYgaXQgaXMgcG9zaXRpb25lZCBhYnNvbHV0ZWx5XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2Nyb2xsT2Zmc2V0WSA9IGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLnZ5ID8gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnkgKiBzcGVlZCA6IDA7XG4gICAgICAgICAgdmFyIHNjcm9sbE9mZnNldFggPSBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS52eCA/IGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLnZ4ICogc3BlZWQgOiAwO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBzY3JvbGxDdXN0b21GbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHNjcm9sbEN1c3RvbUZuLmNhbGwoU29ydGFibGUuZHJhZ2dlZC5wYXJlbnROb2RlW2V4cGFuZG9dLCBzY3JvbGxPZmZzZXRYLCBzY3JvbGxPZmZzZXRZLCBldnQsIHRvdWNoRXZ0JDEsIGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLmVsKSAhPT0gJ2NvbnRpbnVlJykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2Nyb2xsQnkoYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0uZWwsIHNjcm9sbE9mZnNldFgsIHNjcm9sbE9mZnNldFkpO1xuICAgICAgICB9LmJpbmQoe1xuICAgICAgICAgIGxheWVyOiBsYXllcnNPdXRcbiAgICAgICAgfSksIDI0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXllcnNPdXQrKztcbiAgfSB3aGlsZSAob3B0aW9ucy5idWJibGVTY3JvbGwgJiYgY3VycmVudFBhcmVudCAhPT0gd2luU2Nyb2xsZXIgJiYgKGN1cnJlbnRQYXJlbnQgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChjdXJyZW50UGFyZW50LCBmYWxzZSkpKTtcblxuICBzY3JvbGxpbmcgPSBzY3JvbGxUaGlzSW5zdGFuY2U7IC8vIGluIGNhc2UgYW5vdGhlciBmdW5jdGlvbiBjYXRjaGVzIHNjcm9sbGluZyBhcyBmYWxzZSBpbiBiZXR3ZWVuIHdoZW4gaXQgaXMgbm90XG59LCAzMCk7XG5cbnZhciBkcm9wID0gZnVuY3Rpb24gZHJvcChfcmVmKSB7XG4gIHZhciBvcmlnaW5hbEV2ZW50ID0gX3JlZi5vcmlnaW5hbEV2ZW50LFxuICAgICAgcHV0U29ydGFibGUgPSBfcmVmLnB1dFNvcnRhYmxlLFxuICAgICAgZHJhZ0VsID0gX3JlZi5kcmFnRWwsXG4gICAgICBhY3RpdmVTb3J0YWJsZSA9IF9yZWYuYWN0aXZlU29ydGFibGUsXG4gICAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQgPSBfcmVmLmRpc3BhdGNoU29ydGFibGVFdmVudCxcbiAgICAgIGhpZGVHaG9zdEZvclRhcmdldCA9IF9yZWYuaGlkZUdob3N0Rm9yVGFyZ2V0LFxuICAgICAgdW5oaWRlR2hvc3RGb3JUYXJnZXQgPSBfcmVmLnVuaGlkZUdob3N0Rm9yVGFyZ2V0O1xuICBpZiAoIW9yaWdpbmFsRXZlbnQpIHJldHVybjtcbiAgdmFyIHRvU29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCBhY3RpdmVTb3J0YWJsZTtcbiAgaGlkZUdob3N0Rm9yVGFyZ2V0KCk7XG4gIHZhciB0b3VjaCA9IG9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgb3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPyBvcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdIDogb3JpZ2luYWxFdmVudDtcbiAgdmFyIHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSk7XG4gIHVuaGlkZUdob3N0Rm9yVGFyZ2V0KCk7XG5cbiAgaWYgKHRvU29ydGFibGUgJiYgIXRvU29ydGFibGUuZWwuY29udGFpbnModGFyZ2V0KSkge1xuICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCgnc3BpbGwnKTtcbiAgICB0aGlzLm9uU3BpbGwoe1xuICAgICAgZHJhZ0VsOiBkcmFnRWwsXG4gICAgICBwdXRTb3J0YWJsZTogcHV0U29ydGFibGVcbiAgICB9KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gUmV2ZXJ0KCkge31cblxuUmV2ZXJ0LnByb3RvdHlwZSA9IHtcbiAgc3RhcnRJbmRleDogbnVsbCxcbiAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiBkcmFnU3RhcnQoX3JlZjIpIHtcbiAgICB2YXIgb2xkRHJhZ2dhYmxlSW5kZXggPSBfcmVmMi5vbGREcmFnZ2FibGVJbmRleDtcbiAgICB0aGlzLnN0YXJ0SW5kZXggPSBvbGREcmFnZ2FibGVJbmRleDtcbiAgfSxcbiAgb25TcGlsbDogZnVuY3Rpb24gb25TcGlsbChfcmVmMykge1xuICAgIHZhciBkcmFnRWwgPSBfcmVmMy5kcmFnRWwsXG4gICAgICAgIHB1dFNvcnRhYmxlID0gX3JlZjMucHV0U29ydGFibGU7XG4gICAgdGhpcy5zb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcblxuICAgIGlmIChwdXRTb3J0YWJsZSkge1xuICAgICAgcHV0U29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG4gICAgfVxuXG4gICAgdmFyIG5leHRTaWJsaW5nID0gZ2V0Q2hpbGQodGhpcy5zb3J0YWJsZS5lbCwgdGhpcy5zdGFydEluZGV4LCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgaWYgKG5leHRTaWJsaW5nKSB7XG4gICAgICB0aGlzLnNvcnRhYmxlLmVsLmluc2VydEJlZm9yZShkcmFnRWwsIG5leHRTaWJsaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zb3J0YWJsZS5lbC5hcHBlbmRDaGlsZChkcmFnRWwpO1xuICAgIH1cblxuICAgIHRoaXMuc29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuXG4gICAgaWYgKHB1dFNvcnRhYmxlKSB7XG4gICAgICBwdXRTb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gICAgfVxuICB9LFxuICBkcm9wOiBkcm9wXG59O1xuXG5fZXh0ZW5kcyhSZXZlcnQsIHtcbiAgcGx1Z2luTmFtZTogJ3JldmVydE9uU3BpbGwnXG59KTtcblxuZnVuY3Rpb24gUmVtb3ZlKCkge31cblxuUmVtb3ZlLnByb3RvdHlwZSA9IHtcbiAgb25TcGlsbDogZnVuY3Rpb24gb25TcGlsbChfcmVmNCkge1xuICAgIHZhciBkcmFnRWwgPSBfcmVmNC5kcmFnRWwsXG4gICAgICAgIHB1dFNvcnRhYmxlID0gX3JlZjQucHV0U29ydGFibGU7XG4gICAgdmFyIHBhcmVudFNvcnRhYmxlID0gcHV0U29ydGFibGUgfHwgdGhpcy5zb3J0YWJsZTtcbiAgICBwYXJlbnRTb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICBkcmFnRWwucGFyZW50Tm9kZSAmJiBkcmFnRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkcmFnRWwpO1xuICAgIHBhcmVudFNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgfSxcbiAgZHJvcDogZHJvcFxufTtcblxuX2V4dGVuZHMoUmVtb3ZlLCB7XG4gIHBsdWdpbk5hbWU6ICdyZW1vdmVPblNwaWxsJ1xufSk7XG5cbnZhciBsYXN0U3dhcEVsO1xuXG5mdW5jdGlvbiBTd2FwUGx1Z2luKCkge1xuICBmdW5jdGlvbiBTd2FwKCkge1xuICAgIHRoaXMuZGVmYXVsdHMgPSB7XG4gICAgICBzd2FwQ2xhc3M6ICdzb3J0YWJsZS1zd2FwLWhpZ2hsaWdodCdcbiAgICB9O1xuICB9XG5cbiAgU3dhcC5wcm90b3R5cGUgPSB7XG4gICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiBkcmFnU3RhcnQoX3JlZikge1xuICAgICAgdmFyIGRyYWdFbCA9IF9yZWYuZHJhZ0VsO1xuICAgICAgbGFzdFN3YXBFbCA9IGRyYWdFbDtcbiAgICB9LFxuICAgIGRyYWdPdmVyVmFsaWQ6IGZ1bmN0aW9uIGRyYWdPdmVyVmFsaWQoX3JlZjIpIHtcbiAgICAgIHZhciBjb21wbGV0ZWQgPSBfcmVmMi5jb21wbGV0ZWQsXG4gICAgICAgICAgdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgICAgIG9uTW92ZSA9IF9yZWYyLm9uTW92ZSxcbiAgICAgICAgICBhY3RpdmVTb3J0YWJsZSA9IF9yZWYyLmFjdGl2ZVNvcnRhYmxlLFxuICAgICAgICAgIGNoYW5nZWQgPSBfcmVmMi5jaGFuZ2VkLFxuICAgICAgICAgIGNhbmNlbCA9IF9yZWYyLmNhbmNlbDtcbiAgICAgIGlmICghYWN0aXZlU29ydGFibGUub3B0aW9ucy5zd2FwKSByZXR1cm47XG4gICAgICB2YXIgZWwgPSB0aGlzLnNvcnRhYmxlLmVsLFxuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICB2YXIgcHJldlN3YXBFbCA9IGxhc3RTd2FwRWw7XG5cbiAgICAgICAgaWYgKG9uTW92ZSh0YXJnZXQpICE9PSBmYWxzZSkge1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKHRhcmdldCwgb3B0aW9ucy5zd2FwQ2xhc3MsIHRydWUpO1xuICAgICAgICAgIGxhc3RTd2FwRWwgPSB0YXJnZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdFN3YXBFbCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldlN3YXBFbCAmJiBwcmV2U3dhcEVsICE9PSBsYXN0U3dhcEVsKSB7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3MocHJldlN3YXBFbCwgb3B0aW9ucy5zd2FwQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjaGFuZ2VkKCk7XG4gICAgICBjb21wbGV0ZWQodHJ1ZSk7XG4gICAgICBjYW5jZWwoKTtcbiAgICB9LFxuICAgIGRyb3A6IGZ1bmN0aW9uIGRyb3AoX3JlZjMpIHtcbiAgICAgIHZhciBhY3RpdmVTb3J0YWJsZSA9IF9yZWYzLmFjdGl2ZVNvcnRhYmxlLFxuICAgICAgICAgIHB1dFNvcnRhYmxlID0gX3JlZjMucHV0U29ydGFibGUsXG4gICAgICAgICAgZHJhZ0VsID0gX3JlZjMuZHJhZ0VsO1xuICAgICAgdmFyIHRvU29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCB0aGlzLnNvcnRhYmxlO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBsYXN0U3dhcEVsICYmIHRvZ2dsZUNsYXNzKGxhc3RTd2FwRWwsIG9wdGlvbnMuc3dhcENsYXNzLCBmYWxzZSk7XG5cbiAgICAgIGlmIChsYXN0U3dhcEVsICYmIChvcHRpb25zLnN3YXAgfHwgcHV0U29ydGFibGUgJiYgcHV0U29ydGFibGUub3B0aW9ucy5zd2FwKSkge1xuICAgICAgICBpZiAoZHJhZ0VsICE9PSBsYXN0U3dhcEVsKSB7XG4gICAgICAgICAgdG9Tb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICAgICAgICBpZiAodG9Tb3J0YWJsZSAhPT0gYWN0aXZlU29ydGFibGUpIGFjdGl2ZVNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIHN3YXBOb2RlcyhkcmFnRWwsIGxhc3RTd2FwRWwpO1xuICAgICAgICAgIHRvU29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICAgICAgICAgIGlmICh0b1NvcnRhYmxlICE9PSBhY3RpdmVTb3J0YWJsZSkgYWN0aXZlU29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBudWxsaW5nOiBmdW5jdGlvbiBudWxsaW5nKCkge1xuICAgICAgbGFzdFN3YXBFbCA9IG51bGw7XG4gICAgfVxuICB9O1xuICByZXR1cm4gX2V4dGVuZHMoU3dhcCwge1xuICAgIHBsdWdpbk5hbWU6ICdzd2FwJyxcbiAgICBldmVudFByb3BlcnRpZXM6IGZ1bmN0aW9uIGV2ZW50UHJvcGVydGllcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN3YXBJdGVtOiBsYXN0U3dhcEVsXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHN3YXBOb2RlcyhuMSwgbjIpIHtcbiAgdmFyIHAxID0gbjEucGFyZW50Tm9kZSxcbiAgICAgIHAyID0gbjIucGFyZW50Tm9kZSxcbiAgICAgIGkxLFxuICAgICAgaTI7XG4gIGlmICghcDEgfHwgIXAyIHx8IHAxLmlzRXF1YWxOb2RlKG4yKSB8fCBwMi5pc0VxdWFsTm9kZShuMSkpIHJldHVybjtcbiAgaTEgPSBpbmRleChuMSk7XG4gIGkyID0gaW5kZXgobjIpO1xuXG4gIGlmIChwMS5pc0VxdWFsTm9kZShwMikgJiYgaTEgPCBpMikge1xuICAgIGkyKys7XG4gIH1cblxuICBwMS5pbnNlcnRCZWZvcmUobjIsIHAxLmNoaWxkcmVuW2kxXSk7XG4gIHAyLmluc2VydEJlZm9yZShuMSwgcDIuY2hpbGRyZW5baTJdKTtcbn1cblxudmFyIG11bHRpRHJhZ0VsZW1lbnRzID0gW10sXG4gICAgbXVsdGlEcmFnQ2xvbmVzID0gW10sXG4gICAgbGFzdE11bHRpRHJhZ1NlbGVjdCxcbiAgICAvLyBmb3Igc2VsZWN0aW9uIHdpdGggbW9kaWZpZXIga2V5IGRvd24gKFNISUZUKVxubXVsdGlEcmFnU29ydGFibGUsXG4gICAgaW5pdGlhbEZvbGRpbmcgPSBmYWxzZSxcbiAgICAvLyBJbml0aWFsIG11bHRpLWRyYWcgZm9sZCB3aGVuIGRyYWcgc3RhcnRlZFxuZm9sZGluZyA9IGZhbHNlLFxuICAgIC8vIEZvbGRpbmcgYW55IG90aGVyIHRpbWVcbmRyYWdTdGFydGVkID0gZmFsc2UsXG4gICAgZHJhZ0VsJDEsXG4gICAgY2xvbmVzRnJvbVJlY3QsXG4gICAgY2xvbmVzSGlkZGVuO1xuXG5mdW5jdGlvbiBNdWx0aURyYWdQbHVnaW4oKSB7XG4gIGZ1bmN0aW9uIE11bHRpRHJhZyhzb3J0YWJsZSkge1xuICAgIC8vIEJpbmQgYWxsIHByaXZhdGUgbWV0aG9kc1xuICAgIGZvciAodmFyIGZuIGluIHRoaXMpIHtcbiAgICAgIGlmIChmbi5jaGFyQXQoMCkgPT09ICdfJyAmJiB0eXBlb2YgdGhpc1tmbl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpc1tmbl0gPSB0aGlzW2ZuXS5iaW5kKHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc29ydGFibGUub3B0aW9ucy5hdm9pZEltcGxpY2l0RGVzZWxlY3QpIHtcbiAgICAgIGlmIChzb3J0YWJsZS5vcHRpb25zLnN1cHBvcnRQb2ludGVyKSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAncG9pbnRlcnVwJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgICAgICBvbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX2NoZWNrS2V5RG93bik7XG4gICAgb24oZG9jdW1lbnQsICdrZXl1cCcsIHRoaXMuX2NoZWNrS2V5VXApO1xuICAgIHRoaXMuZGVmYXVsdHMgPSB7XG4gICAgICBzZWxlY3RlZENsYXNzOiAnc29ydGFibGUtc2VsZWN0ZWQnLFxuICAgICAgbXVsdGlEcmFnS2V5OiBudWxsLFxuICAgICAgYXZvaWRJbXBsaWNpdERlc2VsZWN0OiBmYWxzZSxcbiAgICAgIHNldERhdGE6IGZ1bmN0aW9uIHNldERhdGEoZGF0YVRyYW5zZmVyLCBkcmFnRWwpIHtcbiAgICAgICAgdmFyIGRhdGEgPSAnJztcblxuICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoICYmIG11bHRpRHJhZ1NvcnRhYmxlID09PSBzb3J0YWJsZSkge1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQsIGkpIHtcbiAgICAgICAgICAgIGRhdGEgKz0gKCFpID8gJycgOiAnLCAnKSArIG11bHRpRHJhZ0VsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YSA9IGRyYWdFbC50ZXh0Q29udGVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFUcmFuc2Zlci5zZXREYXRhKCdUZXh0JywgZGF0YSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIE11bHRpRHJhZy5wcm90b3R5cGUgPSB7XG4gICAgbXVsdGlEcmFnS2V5RG93bjogZmFsc2UsXG4gICAgaXNNdWx0aURyYWc6IGZhbHNlLFxuICAgIGRlbGF5U3RhcnRHbG9iYWw6IGZ1bmN0aW9uIGRlbGF5U3RhcnRHbG9iYWwoX3JlZikge1xuICAgICAgdmFyIGRyYWdnZWQgPSBfcmVmLmRyYWdFbDtcbiAgICAgIGRyYWdFbCQxID0gZHJhZ2dlZDtcbiAgICB9LFxuICAgIGRlbGF5RW5kZWQ6IGZ1bmN0aW9uIGRlbGF5RW5kZWQoKSB7XG4gICAgICB0aGlzLmlzTXVsdGlEcmFnID0gfm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZHJhZ0VsJDEpO1xuICAgIH0sXG4gICAgc2V0dXBDbG9uZTogZnVuY3Rpb24gc2V0dXBDbG9uZShfcmVmMikge1xuICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjIuc29ydGFibGUsXG4gICAgICAgICAgY2FuY2VsID0gX3JlZjIuY2FuY2VsO1xuICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnKSByZXR1cm47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbXVsdGlEcmFnQ2xvbmVzLnB1c2goY2xvbmUobXVsdGlEcmFnRWxlbWVudHNbaV0pKTtcbiAgICAgICAgbXVsdGlEcmFnQ2xvbmVzW2ldLnNvcnRhYmxlSW5kZXggPSBtdWx0aURyYWdFbGVtZW50c1tpXS5zb3J0YWJsZUluZGV4O1xuICAgICAgICBtdWx0aURyYWdDbG9uZXNbaV0uZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIG11bHRpRHJhZ0Nsb25lc1tpXS5zdHlsZVsnd2lsbC1jaGFuZ2UnXSA9ICcnO1xuICAgICAgICB0b2dnbGVDbGFzcyhtdWx0aURyYWdDbG9uZXNbaV0sIHRoaXMub3B0aW9ucy5zZWxlY3RlZENsYXNzLCBmYWxzZSk7XG4gICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzW2ldID09PSBkcmFnRWwkMSAmJiB0b2dnbGVDbGFzcyhtdWx0aURyYWdDbG9uZXNbaV0sIHRoaXMub3B0aW9ucy5jaG9zZW5DbGFzcywgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBzb3J0YWJsZS5faGlkZUNsb25lKCk7XG5cbiAgICAgIGNhbmNlbCgpO1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKF9yZWYzKSB7XG4gICAgICB2YXIgc29ydGFibGUgPSBfcmVmMy5zb3J0YWJsZSxcbiAgICAgICAgICByb290RWwgPSBfcmVmMy5yb290RWwsXG4gICAgICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50ID0gX3JlZjMuZGlzcGF0Y2hTb3J0YWJsZUV2ZW50LFxuICAgICAgICAgIGNhbmNlbCA9IF9yZWYzLmNhbmNlbDtcbiAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZykgcmV0dXJuO1xuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5yZW1vdmVDbG9uZU9uSGlkZSkge1xuICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoICYmIG11bHRpRHJhZ1NvcnRhYmxlID09PSBzb3J0YWJsZSkge1xuICAgICAgICAgIGluc2VydE11bHRpRHJhZ0Nsb25lcyh0cnVlLCByb290RWwpO1xuICAgICAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCgnY2xvbmUnKTtcbiAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc2hvd0Nsb25lOiBmdW5jdGlvbiBzaG93Q2xvbmUoX3JlZjQpIHtcbiAgICAgIHZhciBjbG9uZU5vd1Nob3duID0gX3JlZjQuY2xvbmVOb3dTaG93bixcbiAgICAgICAgICByb290RWwgPSBfcmVmNC5yb290RWwsXG4gICAgICAgICAgY2FuY2VsID0gX3JlZjQuY2FuY2VsO1xuICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnKSByZXR1cm47XG4gICAgICBpbnNlcnRNdWx0aURyYWdDbG9uZXMoZmFsc2UsIHJvb3RFbCk7XG4gICAgICBtdWx0aURyYWdDbG9uZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgY3NzKGNsb25lLCAnZGlzcGxheScsICcnKTtcbiAgICAgIH0pO1xuICAgICAgY2xvbmVOb3dTaG93bigpO1xuICAgICAgY2xvbmVzSGlkZGVuID0gZmFsc2U7XG4gICAgICBjYW5jZWwoKTtcbiAgICB9LFxuICAgIGhpZGVDbG9uZTogZnVuY3Rpb24gaGlkZUNsb25lKF9yZWY1KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgc29ydGFibGUgPSBfcmVmNS5zb3J0YWJsZSxcbiAgICAgICAgICBjbG9uZU5vd0hpZGRlbiA9IF9yZWY1LmNsb25lTm93SGlkZGVuLFxuICAgICAgICAgIGNhbmNlbCA9IF9yZWY1LmNhbmNlbDtcbiAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZykgcmV0dXJuO1xuICAgICAgbXVsdGlEcmFnQ2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgIGNzcyhjbG9uZSwgJ2Rpc3BsYXknLCAnbm9uZScpO1xuXG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlICYmIGNsb25lLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjbG9uZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjbG9uZU5vd0hpZGRlbigpO1xuICAgICAgY2xvbmVzSGlkZGVuID0gdHJ1ZTtcbiAgICAgIGNhbmNlbCgpO1xuICAgIH0sXG4gICAgZHJhZ1N0YXJ0R2xvYmFsOiBmdW5jdGlvbiBkcmFnU3RhcnRHbG9iYWwoX3JlZjYpIHtcbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWY2LnNvcnRhYmxlO1xuXG4gICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcgJiYgbXVsdGlEcmFnU29ydGFibGUpIHtcbiAgICAgICAgbXVsdGlEcmFnU29ydGFibGUubXVsdGlEcmFnLl9kZXNlbGVjdE11bHRpRHJhZygpO1xuICAgICAgfVxuXG4gICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgIG11bHRpRHJhZ0VsZW1lbnQuc29ydGFibGVJbmRleCA9IGluZGV4KG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgfSk7IC8vIFNvcnQgbXVsdGktZHJhZyBlbGVtZW50c1xuXG4gICAgICBtdWx0aURyYWdFbGVtZW50cyA9IG11bHRpRHJhZ0VsZW1lbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEuc29ydGFibGVJbmRleCAtIGIuc29ydGFibGVJbmRleDtcbiAgICAgIH0pO1xuICAgICAgZHJhZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgZHJhZ1N0YXJ0ZWQ6IGZ1bmN0aW9uIGRyYWdTdGFydGVkKF9yZWY3KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjcuc29ydGFibGU7XG4gICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zb3J0KSB7XG4gICAgICAgIC8vIENhcHR1cmUgcmVjdHMsXG4gICAgICAgIC8vIGhpZGUgbXVsdGkgZHJhZyBlbGVtZW50cyAoYnkgcG9zaXRpb25pbmcgdGhlbSBhYnNvbHV0ZSksXG4gICAgICAgIC8vIHNldCBtdWx0aSBkcmFnIGVsZW1lbnRzIHJlY3RzIHRvIGRyYWdSZWN0LFxuICAgICAgICAvLyBzaG93IG11bHRpIGRyYWcgZWxlbWVudHMsXG4gICAgICAgIC8vIGFuaW1hdGUgdG8gcmVjdHMsXG4gICAgICAgIC8vIHVuc2V0IHJlY3RzICYgcmVtb3ZlIGZyb20gRE9NXG4gICAgICAgIHNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQgPT09IGRyYWdFbCQxKSByZXR1cm47XG4gICAgICAgICAgICBjc3MobXVsdGlEcmFnRWxlbWVudCwgJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGRyYWdSZWN0ID0gZ2V0UmVjdChkcmFnRWwkMSwgZmFsc2UsIHRydWUsIHRydWUpO1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50ID09PSBkcmFnRWwkMSkgcmV0dXJuO1xuICAgICAgICAgICAgc2V0UmVjdChtdWx0aURyYWdFbGVtZW50LCBkcmFnUmVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9sZGluZyA9IHRydWU7XG4gICAgICAgICAgaW5pdGlhbEZvbGRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNvcnRhYmxlLmFuaW1hdGVBbGwoZnVuY3Rpb24gKCkge1xuICAgICAgICBmb2xkaW5nID0gZmFsc2U7XG4gICAgICAgIGluaXRpYWxGb2xkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHVuc2V0UmVjdChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBSZW1vdmUgYWxsIGF1eGlsaWFyeSBtdWx0aWRyYWcgaXRlbXMgZnJvbSBlbCwgaWYgc29ydGluZyBlbmFibGVkXG5cblxuICAgICAgICBpZiAoX3RoaXMyLm9wdGlvbnMuc29ydCkge1xuICAgICAgICAgIHJlbW92ZU11bHRpRHJhZ0VsZW1lbnRzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZHJhZ092ZXI6IGZ1bmN0aW9uIGRyYWdPdmVyKF9yZWY4KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gX3JlZjgudGFyZ2V0LFxuICAgICAgICAgIGNvbXBsZXRlZCA9IF9yZWY4LmNvbXBsZXRlZCxcbiAgICAgICAgICBjYW5jZWwgPSBfcmVmOC5jYW5jZWw7XG5cbiAgICAgIGlmIChmb2xkaW5nICYmIH5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKHRhcmdldCkpIHtcbiAgICAgICAgY29tcGxldGVkKGZhbHNlKTtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZXZlcnQ6IGZ1bmN0aW9uIHJldmVydChfcmVmOSkge1xuICAgICAgdmFyIGZyb21Tb3J0YWJsZSA9IF9yZWY5LmZyb21Tb3J0YWJsZSxcbiAgICAgICAgICByb290RWwgPSBfcmVmOS5yb290RWwsXG4gICAgICAgICAgc29ydGFibGUgPSBfcmVmOS5zb3J0YWJsZSxcbiAgICAgICAgICBkcmFnUmVjdCA9IF9yZWY5LmRyYWdSZWN0O1xuXG4gICAgICBpZiAobXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBTZXR1cCB1bmZvbGQgYW5pbWF0aW9uXG4gICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICBzb3J0YWJsZS5hZGRBbmltYXRpb25TdGF0ZSh7XG4gICAgICAgICAgICB0YXJnZXQ6IG11bHRpRHJhZ0VsZW1lbnQsXG4gICAgICAgICAgICByZWN0OiBmb2xkaW5nID8gZ2V0UmVjdChtdWx0aURyYWdFbGVtZW50KSA6IGRyYWdSZWN0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdW5zZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnQuZnJvbVJlY3QgPSBkcmFnUmVjdDtcbiAgICAgICAgICBmcm9tU29ydGFibGUucmVtb3ZlQW5pbWF0aW9uU3RhdGUobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBmb2xkaW5nID0gZmFsc2U7XG4gICAgICAgIGluc2VydE11bHRpRHJhZ0VsZW1lbnRzKCF0aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUsIHJvb3RFbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcmFnT3ZlckNvbXBsZXRlZDogZnVuY3Rpb24gZHJhZ092ZXJDb21wbGV0ZWQoX3JlZjEwKSB7XG4gICAgICB2YXIgc29ydGFibGUgPSBfcmVmMTAuc29ydGFibGUsXG4gICAgICAgICAgaXNPd25lciA9IF9yZWYxMC5pc093bmVyLFxuICAgICAgICAgIGluc2VydGlvbiA9IF9yZWYxMC5pbnNlcnRpb24sXG4gICAgICAgICAgYWN0aXZlU29ydGFibGUgPSBfcmVmMTAuYWN0aXZlU29ydGFibGUsXG4gICAgICAgICAgcGFyZW50RWwgPSBfcmVmMTAucGFyZW50RWwsXG4gICAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmMTAucHV0U29ydGFibGU7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgaWYgKGluc2VydGlvbikge1xuICAgICAgICAvLyBDbG9uZXMgbXVzdCBiZSBoaWRkZW4gYmVmb3JlIGZvbGRpbmcgYW5pbWF0aW9uIHRvIGNhcHR1cmUgZHJhZ1JlY3RBYnNvbHV0ZSBwcm9wZXJseVxuICAgICAgICBpZiAoaXNPd25lcikge1xuICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlLl9oaWRlQ2xvbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluaXRpYWxGb2xkaW5nID0gZmFsc2U7IC8vIElmIGxlYXZpbmcgc29ydDpmYWxzZSByb290LCBvciBhbHJlYWR5IGZvbGRpbmcgLSBGb2xkIHRvIG5ldyBsb2NhdGlvblxuXG4gICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbiAmJiBtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggPiAxICYmIChmb2xkaW5nIHx8ICFpc093bmVyICYmICFhY3RpdmVTb3J0YWJsZS5vcHRpb25zLnNvcnQgJiYgIXB1dFNvcnRhYmxlKSkge1xuICAgICAgICAgIC8vIEZvbGQ6IFNldCBhbGwgbXVsdGkgZHJhZyBlbGVtZW50cydzIHJlY3RzIHRvIGRyYWdFbCdzIHJlY3Qgd2hlbiBtdWx0aS1kcmFnIGVsZW1lbnRzIGFyZSBpbnZpc2libGVcbiAgICAgICAgICB2YXIgZHJhZ1JlY3RBYnNvbHV0ZSA9IGdldFJlY3QoZHJhZ0VsJDEsIGZhbHNlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudCA9PT0gZHJhZ0VsJDEpIHJldHVybjtcbiAgICAgICAgICAgIHNldFJlY3QobXVsdGlEcmFnRWxlbWVudCwgZHJhZ1JlY3RBYnNvbHV0ZSk7IC8vIE1vdmUgZWxlbWVudChzKSB0byBlbmQgb2YgcGFyZW50RWwgc28gdGhhdCBpdCBkb2VzIG5vdCBpbnRlcmZlcmUgd2l0aCBtdWx0aS1kcmFnIGNsb25lcyBpbnNlcnRpb24gaWYgdGhleSBhcmUgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIHdoaWxlIGZvbGRpbmcsIGFuZCBzbyB0aGF0IHdlIGNhbiBjYXB0dXJlIHRoZW0gYWdhaW4gYmVjYXVzZSBvbGQgc29ydGFibGUgd2lsbCBubyBsb25nZXIgYmUgZnJvbVNvcnRhYmxlXG5cbiAgICAgICAgICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvbGRpbmcgPSB0cnVlO1xuICAgICAgICB9IC8vIENsb25lcyBtdXN0IGJlIHNob3duIChhbmQgY2hlY2sgdG8gcmVtb3ZlIG11bHRpIGRyYWdzKSBhZnRlciBmb2xkaW5nIHdoZW4gaW50ZXJmZXJpbmcgbXVsdGlEcmFnRWxlbWVudHMgYXJlIG1vdmVkIG91dFxuXG5cbiAgICAgICAgaWYgKCFpc093bmVyKSB7XG4gICAgICAgICAgLy8gT25seSByZW1vdmUgaWYgbm90IGZvbGRpbmcgKGZvbGRpbmcgd2lsbCByZW1vdmUgdGhlbSBhbnl3YXlzKVxuICAgICAgICAgIGlmICghZm9sZGluZykge1xuICAgICAgICAgICAgcmVtb3ZlTXVsdGlEcmFnRWxlbWVudHMoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIGNsb25lc0hpZGRlbkJlZm9yZSA9IGNsb25lc0hpZGRlbjtcblxuICAgICAgICAgICAgYWN0aXZlU29ydGFibGUuX3Nob3dDbG9uZShzb3J0YWJsZSk7IC8vIFVuZm9sZCBhbmltYXRpb24gZm9yIGNsb25lcyBpZiBzaG93aW5nIGZyb20gaGlkZGVuXG5cblxuICAgICAgICAgICAgaWYgKGFjdGl2ZVNvcnRhYmxlLm9wdGlvbnMuYW5pbWF0aW9uICYmICFjbG9uZXNIaWRkZW4gJiYgY2xvbmVzSGlkZGVuQmVmb3JlKSB7XG4gICAgICAgICAgICAgIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlLmFkZEFuaW1hdGlvblN0YXRlKHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogY2xvbmUsXG4gICAgICAgICAgICAgICAgICByZWN0OiBjbG9uZXNGcm9tUmVjdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNsb25lLmZyb21SZWN0ID0gY2xvbmVzRnJvbVJlY3Q7XG4gICAgICAgICAgICAgICAgY2xvbmUudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlLl9zaG93Q2xvbmUoc29ydGFibGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZHJhZ092ZXJBbmltYXRpb25DYXB0dXJlOiBmdW5jdGlvbiBkcmFnT3ZlckFuaW1hdGlvbkNhcHR1cmUoX3JlZjExKSB7XG4gICAgICB2YXIgZHJhZ1JlY3QgPSBfcmVmMTEuZHJhZ1JlY3QsXG4gICAgICAgICAgaXNPd25lciA9IF9yZWYxMS5pc093bmVyLFxuICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlID0gX3JlZjExLmFjdGl2ZVNvcnRhYmxlO1xuICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICBtdWx0aURyYWdFbGVtZW50LnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IG51bGw7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGFjdGl2ZVNvcnRhYmxlLm9wdGlvbnMuYW5pbWF0aW9uICYmICFpc093bmVyICYmIGFjdGl2ZVNvcnRhYmxlLm11bHRpRHJhZy5pc011bHRpRHJhZykge1xuICAgICAgICBjbG9uZXNGcm9tUmVjdCA9IF9leHRlbmRzKHt9LCBkcmFnUmVjdCk7XG4gICAgICAgIHZhciBkcmFnTWF0cml4ID0gbWF0cml4KGRyYWdFbCQxLCB0cnVlKTtcbiAgICAgICAgY2xvbmVzRnJvbVJlY3QudG9wIC09IGRyYWdNYXRyaXguZjtcbiAgICAgICAgY2xvbmVzRnJvbVJlY3QubGVmdCAtPSBkcmFnTWF0cml4LmU7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcmFnT3ZlckFuaW1hdGlvbkNvbXBsZXRlOiBmdW5jdGlvbiBkcmFnT3ZlckFuaW1hdGlvbkNvbXBsZXRlKCkge1xuICAgICAgaWYgKGZvbGRpbmcpIHtcbiAgICAgICAgZm9sZGluZyA9IGZhbHNlO1xuICAgICAgICByZW1vdmVNdWx0aURyYWdFbGVtZW50cygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZHJvcDogZnVuY3Rpb24gZHJvcChfcmVmMTIpIHtcbiAgICAgIHZhciBldnQgPSBfcmVmMTIub3JpZ2luYWxFdmVudCxcbiAgICAgICAgICByb290RWwgPSBfcmVmMTIucm9vdEVsLFxuICAgICAgICAgIHBhcmVudEVsID0gX3JlZjEyLnBhcmVudEVsLFxuICAgICAgICAgIHNvcnRhYmxlID0gX3JlZjEyLnNvcnRhYmxlLFxuICAgICAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCA9IF9yZWYxMi5kaXNwYXRjaFNvcnRhYmxlRXZlbnQsXG4gICAgICAgICAgb2xkSW5kZXggPSBfcmVmMTIub2xkSW5kZXgsXG4gICAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmMTIucHV0U29ydGFibGU7XG4gICAgICB2YXIgdG9Tb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IHRoaXMuc29ydGFibGU7XG4gICAgICBpZiAoIWV2dCkgcmV0dXJuO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgY2hpbGRyZW4gPSBwYXJlbnRFbC5jaGlsZHJlbjsgLy8gTXVsdGktZHJhZyBzZWxlY3Rpb25cblxuICAgICAgaWYgKCFkcmFnU3RhcnRlZCkge1xuICAgICAgICBpZiAob3B0aW9ucy5tdWx0aURyYWdLZXkgJiYgIXRoaXMubXVsdGlEcmFnS2V5RG93bikge1xuICAgICAgICAgIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwkMSwgb3B0aW9ucy5zZWxlY3RlZENsYXNzLCAhfm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZHJhZ0VsJDEpKTtcblxuICAgICAgICBpZiAoIX5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGRyYWdFbCQxKSkge1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLnB1c2goZHJhZ0VsJDEpO1xuICAgICAgICAgIGRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlLFxuICAgICAgICAgICAgcm9vdEVsOiByb290RWwsXG4gICAgICAgICAgICBuYW1lOiAnc2VsZWN0JyxcbiAgICAgICAgICAgIHRhcmdldEVsOiBkcmFnRWwkMSxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgIH0pOyAvLyBNb2RpZmllciBhY3RpdmF0ZWQsIHNlbGVjdCBmcm9tIGxhc3QgdG8gZHJhZ0VsXG5cbiAgICAgICAgICBpZiAoZXZ0LnNoaWZ0S2V5ICYmIGxhc3RNdWx0aURyYWdTZWxlY3QgJiYgc29ydGFibGUuZWwuY29udGFpbnMobGFzdE11bHRpRHJhZ1NlbGVjdCkpIHtcbiAgICAgICAgICAgIHZhciBsYXN0SW5kZXggPSBpbmRleChsYXN0TXVsdGlEcmFnU2VsZWN0KSxcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5kZXggPSBpbmRleChkcmFnRWwkMSk7XG5cbiAgICAgICAgICAgIGlmICh+bGFzdEluZGV4ICYmIH5jdXJyZW50SW5kZXggJiYgbGFzdEluZGV4ICE9PSBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgLy8gTXVzdCBpbmNsdWRlIGxhc3RNdWx0aURyYWdTZWxlY3QgKHNlbGVjdCBpdCksIGluIGNhc2UgbW9kaWZpZWQgc2VsZWN0aW9uIGZyb20gbm8gc2VsZWN0aW9uXG4gICAgICAgICAgICAgIC8vIChidXQgcHJldmlvdXMgc2VsZWN0aW9uIGV4aXN0ZWQpXG4gICAgICAgICAgICAgIHZhciBuLCBpO1xuXG4gICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgIG4gPSBjdXJyZW50SW5kZXg7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaSA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICBuID0gbGFzdEluZGV4ICsgMTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKH5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGNoaWxkcmVuW2ldKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoY2hpbGRyZW5baV0sIG9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMucHVzaChjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGUsXG4gICAgICAgICAgICAgICAgICByb290RWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgICAgIG5hbWU6ICdzZWxlY3QnLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0RWw6IGNoaWxkcmVuW2ldLFxuICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdE11bHRpRHJhZ1NlbGVjdCA9IGRyYWdFbCQxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlID0gdG9Tb3J0YWJsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5zcGxpY2UobXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihkcmFnRWwkMSksIDEpO1xuICAgICAgICAgIGxhc3RNdWx0aURyYWdTZWxlY3QgPSBudWxsO1xuICAgICAgICAgIGRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlLFxuICAgICAgICAgICAgcm9vdEVsOiByb290RWwsXG4gICAgICAgICAgICBuYW1lOiAnZGVzZWxlY3QnLFxuICAgICAgICAgICAgdGFyZ2V0RWw6IGRyYWdFbCQxLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gTXVsdGktZHJhZyBkcm9wXG5cblxuICAgICAgaWYgKGRyYWdTdGFydGVkICYmIHRoaXMuaXNNdWx0aURyYWcpIHtcbiAgICAgICAgZm9sZGluZyA9IGZhbHNlOyAvLyBEbyBub3QgXCJ1bmZvbGRcIiBhZnRlciBhcm91bmQgZHJhZ0VsIGlmIHJldmVydGVkXG5cbiAgICAgICAgaWYgKChwYXJlbnRFbFtleHBhbmRvXS5vcHRpb25zLnNvcnQgfHwgcGFyZW50RWwgIT09IHJvb3RFbCkgJiYgbXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHZhciBkcmFnUmVjdCA9IGdldFJlY3QoZHJhZ0VsJDEpLFxuICAgICAgICAgICAgICBtdWx0aURyYWdJbmRleCA9IGluZGV4KGRyYWdFbCQxLCAnOm5vdCguJyArIHRoaXMub3B0aW9ucy5zZWxlY3RlZENsYXNzICsgJyknKTtcbiAgICAgICAgICBpZiAoIWluaXRpYWxGb2xkaW5nICYmIG9wdGlvbnMuYW5pbWF0aW9uKSBkcmFnRWwkMS50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSBudWxsO1xuICAgICAgICAgIHRvU29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG5cbiAgICAgICAgICBpZiAoIWluaXRpYWxGb2xkaW5nKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgZHJhZ0VsJDEuZnJvbVJlY3QgPSBkcmFnUmVjdDtcbiAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnQudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50ICE9PSBkcmFnRWwkMSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBmb2xkaW5nID8gZ2V0UmVjdChtdWx0aURyYWdFbGVtZW50KSA6IGRyYWdSZWN0O1xuICAgICAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudC5mcm9tUmVjdCA9IHJlY3Q7IC8vIFByZXBhcmUgdW5mb2xkIGFuaW1hdGlvblxuXG4gICAgICAgICAgICAgICAgICB0b1NvcnRhYmxlLmFkZEFuaW1hdGlvblN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBtdWx0aURyYWdFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICByZWN0OiByZWN0XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSAvLyBNdWx0aSBkcmFnIGVsZW1lbnRzIGFyZSBub3QgbmVjZXNzYXJpbHkgcmVtb3ZlZCBmcm9tIHRoZSBET00gb24gZHJvcCwgc28gdG8gcmVpbnNlcnRcbiAgICAgICAgICAgIC8vIHByb3Blcmx5IHRoZXkgbXVzdCBhbGwgYmUgcmVtb3ZlZFxuXG5cbiAgICAgICAgICAgIHJlbW92ZU11bHRpRHJhZ0VsZW1lbnRzKCk7XG4gICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGlmIChjaGlsZHJlblttdWx0aURyYWdJbmRleF0pIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRFbC5pbnNlcnRCZWZvcmUobXVsdGlEcmFnRWxlbWVudCwgY2hpbGRyZW5bbXVsdGlEcmFnSW5kZXhdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG11bHRpRHJhZ0luZGV4Kys7XG4gICAgICAgICAgICB9KTsgLy8gSWYgaW5pdGlhbCBmb2xkaW5nIGlzIGRvbmUsIHRoZSBlbGVtZW50cyBtYXkgaGF2ZSBjaGFuZ2VkIHBvc2l0aW9uIGJlY2F1c2UgdGhleSBhcmUgbm93XG4gICAgICAgICAgICAvLyB1bmZvbGRpbmcgYXJvdW5kIGRyYWdFbCwgZXZlbiB0aG91Z2ggZHJhZ0VsIG1heSBub3QgaGF2ZSBoaXMgaW5kZXggY2hhbmdlZCwgc28gdXBkYXRlIGV2ZW50XG4gICAgICAgICAgICAvLyBtdXN0IGJlIGZpcmVkIGhlcmUgYXMgU29ydGFibGUgd2lsbCBub3QuXG5cbiAgICAgICAgICAgIGlmIChvbGRJbmRleCA9PT0gaW5kZXgoZHJhZ0VsJDEpKSB7XG4gICAgICAgICAgICAgIHZhciB1cGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50LnNvcnRhYmxlSW5kZXggIT09IGluZGV4KG11bHRpRHJhZ0VsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICB1cGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCgndXBkYXRlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIE11c3QgYmUgZG9uZSBhZnRlciBjYXB0dXJpbmcgaW5kaXZpZHVhbCByZWN0cyAoc2Nyb2xsIGJhcilcblxuXG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgdW5zZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRvU29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbXVsdGlEcmFnU29ydGFibGUgPSB0b1NvcnRhYmxlO1xuICAgICAgfSAvLyBSZW1vdmUgY2xvbmVzIGlmIG5lY2Vzc2FyeVxuXG5cbiAgICAgIGlmIChyb290RWwgPT09IHBhcmVudEVsIHx8IHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLmxhc3RQdXRNb2RlICE9PSAnY2xvbmUnKSB7XG4gICAgICAgIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICAgIGNsb25lLnBhcmVudE5vZGUgJiYgY2xvbmUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgbnVsbGluZ0dsb2JhbDogZnVuY3Rpb24gbnVsbGluZ0dsb2JhbCgpIHtcbiAgICAgIHRoaXMuaXNNdWx0aURyYWcgPSBkcmFnU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgbXVsdGlEcmFnQ2xvbmVzLmxlbmd0aCA9IDA7XG4gICAgfSxcbiAgICBkZXN0cm95R2xvYmFsOiBmdW5jdGlvbiBkZXN0cm95R2xvYmFsKCkge1xuICAgICAgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcoKTtcblxuICAgICAgb2ZmKGRvY3VtZW50LCAncG9pbnRlcnVwJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgICAgb2ZmKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgICAgb2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX2NoZWNrS2V5RG93bik7XG4gICAgICBvZmYoZG9jdW1lbnQsICdrZXl1cCcsIHRoaXMuX2NoZWNrS2V5VXApO1xuICAgIH0sXG4gICAgX2Rlc2VsZWN0TXVsdGlEcmFnOiBmdW5jdGlvbiBfZGVzZWxlY3RNdWx0aURyYWcoZXZ0KSB7XG4gICAgICBpZiAodHlwZW9mIGRyYWdTdGFydGVkICE9PSBcInVuZGVmaW5lZFwiICYmIGRyYWdTdGFydGVkKSByZXR1cm47IC8vIE9ubHkgZGVzZWxlY3QgaWYgc2VsZWN0aW9uIGlzIGluIHRoaXMgc29ydGFibGVcblxuICAgICAgaWYgKG11bHRpRHJhZ1NvcnRhYmxlICE9PSB0aGlzLnNvcnRhYmxlKSByZXR1cm47IC8vIE9ubHkgZGVzZWxlY3QgaWYgdGFyZ2V0IGlzIG5vdCBpdGVtIGluIHRoaXMgc29ydGFibGVcblxuICAgICAgaWYgKGV2dCAmJiBjbG9zZXN0KGV2dC50YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUsIHRoaXMuc29ydGFibGUuZWwsIGZhbHNlKSkgcmV0dXJuOyAvLyBPbmx5IGRlc2VsZWN0IGlmIGxlZnQgY2xpY2tcblxuICAgICAgaWYgKGV2dCAmJiBldnQuYnV0dG9uICE9PSAwKSByZXR1cm47XG5cbiAgICAgIHdoaWxlIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGVsID0gbXVsdGlEcmFnRWxlbWVudHNbMF07XG4gICAgICAgIHRvZ2dsZUNsYXNzKGVsLCB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgZmFsc2UpO1xuICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5zaGlmdCgpO1xuICAgICAgICBkaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICBzb3J0YWJsZTogdGhpcy5zb3J0YWJsZSxcbiAgICAgICAgICByb290RWw6IHRoaXMuc29ydGFibGUuZWwsXG4gICAgICAgICAgbmFtZTogJ2Rlc2VsZWN0JyxcbiAgICAgICAgICB0YXJnZXRFbDogZWwsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2NoZWNrS2V5RG93bjogZnVuY3Rpb24gX2NoZWNrS2V5RG93bihldnQpIHtcbiAgICAgIGlmIChldnQua2V5ID09PSB0aGlzLm9wdGlvbnMubXVsdGlEcmFnS2V5KSB7XG4gICAgICAgIHRoaXMubXVsdGlEcmFnS2V5RG93biA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBfY2hlY2tLZXlVcDogZnVuY3Rpb24gX2NoZWNrS2V5VXAoZXZ0KSB7XG4gICAgICBpZiAoZXZ0LmtleSA9PT0gdGhpcy5vcHRpb25zLm11bHRpRHJhZ0tleSkge1xuICAgICAgICB0aGlzLm11bHRpRHJhZ0tleURvd24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcyhNdWx0aURyYWcsIHtcbiAgICAvLyBTdGF0aWMgbWV0aG9kcyAmIHByb3BlcnRpZXNcbiAgICBwbHVnaW5OYW1lOiAnbXVsdGlEcmFnJyxcbiAgICB1dGlsczoge1xuICAgICAgLyoqXHJcbiAgICAgICAqIFNlbGVjdHMgdGhlIHByb3ZpZGVkIG11bHRpLWRyYWcgaXRlbVxyXG4gICAgICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgVGhlIGVsZW1lbnQgdG8gYmUgc2VsZWN0ZWRcclxuICAgICAgICovXG4gICAgICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdChlbCkge1xuICAgICAgICB2YXIgc29ydGFibGUgPSBlbC5wYXJlbnROb2RlW2V4cGFuZG9dO1xuICAgICAgICBpZiAoIXNvcnRhYmxlIHx8ICFzb3J0YWJsZS5vcHRpb25zLm11bHRpRHJhZyB8fCB+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihlbCkpIHJldHVybjtcblxuICAgICAgICBpZiAobXVsdGlEcmFnU29ydGFibGUgJiYgbXVsdGlEcmFnU29ydGFibGUgIT09IHNvcnRhYmxlKSB7XG4gICAgICAgICAgbXVsdGlEcmFnU29ydGFibGUubXVsdGlEcmFnLl9kZXNlbGVjdE11bHRpRHJhZygpO1xuXG4gICAgICAgICAgbXVsdGlEcmFnU29ydGFibGUgPSBzb3J0YWJsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvZ2dsZUNsYXNzKGVsLCBzb3J0YWJsZS5vcHRpb25zLnNlbGVjdGVkQ2xhc3MsIHRydWUpO1xuICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5wdXNoKGVsKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxyXG4gICAgICAgKiBEZXNlbGVjdHMgdGhlIHByb3ZpZGVkIG11bHRpLWRyYWcgaXRlbVxyXG4gICAgICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgVGhlIGVsZW1lbnQgdG8gYmUgZGVzZWxlY3RlZFxyXG4gICAgICAgKi9cbiAgICAgIGRlc2VsZWN0OiBmdW5jdGlvbiBkZXNlbGVjdChlbCkge1xuICAgICAgICB2YXIgc29ydGFibGUgPSBlbC5wYXJlbnROb2RlW2V4cGFuZG9dLFxuICAgICAgICAgICAgaW5kZXggPSBtdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGVsKTtcbiAgICAgICAgaWYgKCFzb3J0YWJsZSB8fCAhc29ydGFibGUub3B0aW9ucy5tdWx0aURyYWcgfHwgIX5pbmRleCkgcmV0dXJuO1xuICAgICAgICB0b2dnbGVDbGFzcyhlbCwgc29ydGFibGUub3B0aW9ucy5zZWxlY3RlZENsYXNzLCBmYWxzZSk7XG4gICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBldmVudFByb3BlcnRpZXM6IGZ1bmN0aW9uIGV2ZW50UHJvcGVydGllcygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgb2xkSW5kaWNpZXMgPSBbXSxcbiAgICAgICAgICBuZXdJbmRpY2llcyA9IFtdO1xuICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICBvbGRJbmRpY2llcy5wdXNoKHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50OiBtdWx0aURyYWdFbGVtZW50LFxuICAgICAgICAgIGluZGV4OiBtdWx0aURyYWdFbGVtZW50LnNvcnRhYmxlSW5kZXhcbiAgICAgICAgfSk7IC8vIG11bHRpRHJhZ0VsZW1lbnRzIHdpbGwgYWxyZWFkeSBiZSBzb3J0ZWQgaWYgZm9sZGluZ1xuXG4gICAgICAgIHZhciBuZXdJbmRleDtcblxuICAgICAgICBpZiAoZm9sZGluZyAmJiBtdWx0aURyYWdFbGVtZW50ICE9PSBkcmFnRWwkMSkge1xuICAgICAgICAgIG5ld0luZGV4ID0gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9sZGluZykge1xuICAgICAgICAgIG5ld0luZGV4ID0gaW5kZXgobXVsdGlEcmFnRWxlbWVudCwgJzpub3QoLicgKyBfdGhpczMub3B0aW9ucy5zZWxlY3RlZENsYXNzICsgJyknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdJbmRleCA9IGluZGV4KG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3SW5kaWNpZXMucHVzaCh7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudDogbXVsdGlEcmFnRWxlbWVudCxcbiAgICAgICAgICBpbmRleDogbmV3SW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGl0ZW1zOiBfdG9Db25zdW1hYmxlQXJyYXkobXVsdGlEcmFnRWxlbWVudHMpLFxuICAgICAgICBjbG9uZXM6IFtdLmNvbmNhdChtdWx0aURyYWdDbG9uZXMpLFxuICAgICAgICBvbGRJbmRpY2llczogb2xkSW5kaWNpZXMsXG4gICAgICAgIG5ld0luZGljaWVzOiBuZXdJbmRpY2llc1xuICAgICAgfTtcbiAgICB9LFxuICAgIG9wdGlvbkxpc3RlbmVyczoge1xuICAgICAgbXVsdGlEcmFnS2V5OiBmdW5jdGlvbiBtdWx0aURyYWdLZXkoa2V5KSB7XG4gICAgICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdjdHJsJykge1xuICAgICAgICAgIGtleSA9ICdDb250cm9sJztcbiAgICAgICAgfSBlbHNlIGlmIChrZXkubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGtleSA9IGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHIoMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluc2VydE11bHRpRHJhZ0VsZW1lbnRzKGNsb25lc0luc2VydGVkLCByb290RWwpIHtcbiAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCwgaSkge1xuICAgIHZhciB0YXJnZXQgPSByb290RWwuY2hpbGRyZW5bbXVsdGlEcmFnRWxlbWVudC5zb3J0YWJsZUluZGV4ICsgKGNsb25lc0luc2VydGVkID8gTnVtYmVyKGkpIDogMCldO1xuXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShtdWx0aURyYWdFbGVtZW50LCB0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290RWwuYXBwZW5kQ2hpbGQobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxyXG4gKiBJbnNlcnQgbXVsdGktZHJhZyBjbG9uZXNcclxuICogQHBhcmFtICB7W0Jvb2xlYW5dfSBlbGVtZW50c0luc2VydGVkICBXaGV0aGVyIHRoZSBtdWx0aS1kcmFnIGVsZW1lbnRzIGFyZSBpbnNlcnRlZFxyXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gcm9vdEVsXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGluc2VydE11bHRpRHJhZ0Nsb25lcyhlbGVtZW50c0luc2VydGVkLCByb290RWwpIHtcbiAgbXVsdGlEcmFnQ2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKGNsb25lLCBpKSB7XG4gICAgdmFyIHRhcmdldCA9IHJvb3RFbC5jaGlsZHJlbltjbG9uZS5zb3J0YWJsZUluZGV4ICsgKGVsZW1lbnRzSW5zZXJ0ZWQgPyBOdW1iZXIoaSkgOiAwKV07XG5cbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGNsb25lLCB0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290RWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU11bHRpRHJhZ0VsZW1lbnRzKCkge1xuICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQgPT09IGRyYWdFbCQxKSByZXR1cm47XG4gICAgbXVsdGlEcmFnRWxlbWVudC5wYXJlbnROb2RlICYmIG11bHRpRHJhZ0VsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChtdWx0aURyYWdFbGVtZW50KTtcbiAgfSk7XG59XG5cblNvcnRhYmxlLm1vdW50KG5ldyBBdXRvU2Nyb2xsUGx1Z2luKCkpO1xuU29ydGFibGUubW91bnQoUmVtb3ZlLCBSZXZlcnQpO1xuXG5leHBvcnQgZGVmYXVsdCBTb3J0YWJsZTtcbmV4cG9ydCB7IE11bHRpRHJhZ1BsdWdpbiBhcyBNdWx0aURyYWcsIFNvcnRhYmxlLCBTd2FwUGx1Z2luIGFzIFN3YXAgfTtcbiIsImltcG9ydCBTb3J0YWJsZSBmcm9tICdzb3J0YWJsZWpzJ1xyXG5pbXBvcnQgeyQsIHBvcHVwLCBwb3N0fSBmcm9tICcuLi9jb21tb24nXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzb3J0YWJsZShjb250YWluZXJTZWxlY3RvciwgZWxTZWxlY3RvciwgbW9kZWwpIHtcclxuXHJcbiAgbGV0IGNvbnRhaW5lciA9ICQoY29udGFpbmVyU2VsZWN0b3IpWzBdO1xyXG4gIC8vIGRlYnVnZ2VyXHJcbiAgaWYgKGNvbnRhaW5lcikge1xyXG4gICAgLy8gbGV0IGVscyA9ICQoZWxTZWxlY3Rvcik7XHJcbiAgICBsZXQgc29ydGFibGUgPSBTb3J0YWJsZS5jcmVhdGUoY29udGFpbmVyLCB7XHJcbiAgICAgIGFuaW1hdGlvbjogMTUwLFxyXG4gICAgICBvbkVuZDogZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIGxldCBvbGRJID0gZXZ0Lm9sZEluZGV4XHJcbiAgICAgICAgbGV0IG5ld0kgPSBldnQubmV3SW5kZXhcclxuICAgICAgICAvLyBsZXQgcXVlc3Rpb25zID0gX3F1ZXN0aW9uLnF1ZXN0aW9ucygpXHJcbiAgICAgICAgaWYgKG9sZEkgPiBuZXdJKSB7XHJcbiAgICAgICAgICBzb3J0KG9sZEkpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNvcnQobmV3SSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHNvcnQodXBUb1Flc3Rpb25OdW1iZXIpIHtcclxuICAgICAgICAgIGxldCBlbHMgPSAkKGVsU2VsZWN0b3IpO1xyXG4gICAgICAgICAgbGV0IHF1ZXN0aW9uc0VscyA9IFtdLm1hcC5jYWxsKGVscywgZnVuY3Rpb24gKGVsLCBpKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGkgLSAxIDwgdXBUb1Flc3Rpb25OdW1iZXIpIHJldHVybiBlbFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICApXHJcblxyXG4gICAgICAgICAgbGV0IHRvQ2hhbmdlID0gcXVlc3Rpb25zRWxzLm1hcCgoZWwpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsLmlkXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoYC9hZG1pbnNjLyR7bW9kZWx9L3NvcnRgLCB7dG9DaGFuZ2V9KVxyXG4gICAgICAgICAgLy8gcmVzID0gSlNPTi5wYXJzZShyZXMpXHJcbiAgICAgICAgICAvLyBpZiAocmVzLm1zZykge1xyXG4gICAgICAgICAgLy8gICBwb3B1cC5zaG93KHJlcy5tc2cpXHJcbiAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICBxdWVzdGlvbnNFbHMubWFwKChlbCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAkKGVsKS5maW5kKCcuc29ydCcpLmlubmVyVGV4dCA9IGkgKyAxXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgIH0pXHJcbiAgfVxyXG5cclxufSIsImltcG9ydCB7JCwgcG9wdXAsIHBvc3R9IGZyb20gJy4uLy4uLy4uL2NvbW1vbidcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIF90ZXN0IHtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLm1vZGVsID0gJ29wZW50ZXN0J1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgY3JlYXRlKCkge1xyXG4gICAgbGV0IHRlc3QgPSBfdGVzdC5zZXJ2ZXJNb2RlbCgpXHJcbiAgICB0ZXN0LmlkID0gMFxyXG4gICAgdGVzdC5pc1Rlc3QgPSAxXHJcbiAgICBkZWJ1Z2dlclxyXG4gICAgbGV0IHVybCA9IGAvJHt0aGlzLm1vZGVsfS91cGRhdGVPckNyZWF0ZWBcclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KHVybCwgdGVzdClcclxuICAgIHJlcyA9IGF3YWl0IEpTT04ucGFyc2UocmVzKVxyXG4gICAgZGVidWdnZXJcclxuICAgIGlmIChyZXMpIHtcclxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBgL2FkbWluc2MvJHttb2RlbH0vZWRpdC8ke3Jlcy5pZH1gXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjdXJyZW50USgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOiAkKCcubmF2LWFjdGl2ZScpWzBdLmlubmVyVGV4dCAtIDEsXHJcbiAgICAgIFFFbDogJCgnLnF1ZXN0aW9uLmZsZXgxJylbMF0sXHJcbiAgICAgIG5hdkxlbmd0aDogJCgnW2RhdGEtcGFnaW5hdGlvbl0nKS5sZW5ndGgsXHJcbiAgICAgIFFQcmV2YzogJCgnLnF1ZXN0aW9uLmZsZXgxJylbMF0ucHJldmlvdXNFbGVtZW50U2libGluZyxcclxuICAgICAgUU5leHRFbDogJCgnLnF1ZXN0aW9uLmZsZXgxJylbMF0ubmV4dEVsZW1lbnRTaWJsaW5nLFxyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIHZpZXdNb2RlbCgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOiArd2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoJy8nKS5wb3AoKSxcclxuICAgICAgdGVzdF9uYW1lOiAkKCcjdGVzdF9uYW1lJykudGV4dCgpLFxyXG4gICAgICBlbmFibGU6ICQoJyNlbmFibGUnKVswXSxcclxuICAgICAgcGFyZW50OiAkKCdzZWxlY3QnKS5zZWxlY3RlZEluZGV4VmFsdWUoKSxcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICBpZCgpIHtcclxuICAgIHJldHVybiBpZCA/PyAkKCcudGVzdC1uYW1lJylbMF0uZGF0YXNldC50ZXN0aWRcclxuICB9XHJcblxyXG5cclxuICBjaGlsZHJlbigpIHtcclxuICAgIGxldCBjaGlsZHJlbkxlbmdodCA9ICQoJy5jaGlsZHJlbicpLmxlbmd0aFxyXG4gICAgaWYgKGNoaWxkcmVuTGVuZ2h0KVxyXG4gICAgICByZXR1cm4gY2hpbGRyZW5MZW5naHRcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuXHJcblxyXG4gIGFzeW5jIHBhdGhfY3JlYXRlKCkge1xyXG4gICAgbGV0IHRlc3RfcGF0aCA9IF90ZXN0LnNlcnZlck1vZGVsKClcclxuICAgIHRlc3RfcGF0aC5pZCA9IDBcclxuICAgIHRlc3RfcGF0aC5pc1Rlc3QgPSAwXHJcbiAgICBsZXQgdXJsID0gYC9hZG1pbnNjLyR7bW9kZWx9L2NyZWF0ZWBcclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KHVybCwgdGVzdF9wYXRoKVxyXG4gICAgcmVzID0gYXdhaXQgSlNPTi5wYXJzZShyZXMpXHJcbiAgICBpZiAocmVzKSB7XHJcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYC9hZG1pbnNjLyR7bW9kZWx9L2VkaXQvJHtyZXMuaWQgLSAxfWBcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICBuYW1lKCkge1xyXG4gICAgcmV0dXJuICQoJy50ZXN0LW5hbWUnKVswXS5pbm5lclRleHRcclxuICB9XHJcblxyXG5cclxuXHJcbiAgc2VsZWN0ZWRWYWx1ZUN1c3RvbVNlbGVjdChjbGFzc05hbWUpIHtcclxuXHJcbiAgICBsZXQgc2VsZWN0ID0gJChgW2RhdGEtZmllbGQ9JHtjbGFzc05hbWV9XWApWzBdXHJcbiAgICBsZXQgc2VsZWN0ZWQgPSBbLi4uc2VsZWN0Lm9wdGlvbnNdLmZpbHRlcigob3B0KSA9PiBvcHQuc2VsZWN0ZWQpXHJcbiAgICBpZiAoc2VsZWN0ZWQpIHtcclxuICAgICAgcmV0dXJuICtzZWxlY3RlZFswXS52YWx1ZVxyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIHNlcnZlck1vZGVsKCkge1xyXG4gICAgbGV0IG1vZGVsID0ge1xyXG4gICAgICBpZDogK3dpbmRvdy5sb2NhdGlvbi5ocmVmLnNwbGl0KCcvJykucG9wKCksXHJcbiAgICAgIHRlc3RfbmFtZTogJCgnI3Rlc3RfbmFtZScpWzBdLnZhbHVlLFxyXG4gICAgICBpc1Rlc3Q6ICskKCdbaXNUZXN0XScpWzBdLmdldEF0dHJpYnV0ZSgnaXNUZXN0JyksXHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGZpZWxkcyA9ICQoJy5jdXN0b20tc2VsZWN0Jyk7XHJcbiAgICBbXS5mb3JFYWNoLmNhbGwoZmllbGRzLCBmdW5jdGlvbiAoZmllbGQpIHtcclxuICAgICAgbW9kZWxbZmllbGQuZGF0YXNldFsnZmllbGQnXV0gPSBmaWVsZC5kYXRhc2V0WydpZCddXHJcbiAgICB9KVxyXG4gICAgcmV0dXJuIG1vZGVsXHJcbiAgfVxyXG5cclxuICBhc3luYyB1cGRhdGUoKSB7XHJcbiAgICBsZXQgbW9kZWwgPSBfdGVzdC5zZXJ2ZXJNb2RlbCgpXHJcbiAgICBsZXQgdXJsID0gYC9hZG1pbnNjLyR7bW9kZWx9L3VwZGF0ZS8ke21vZGVsLmlkfWBcclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KHVybCwgbW9kZWwpXHJcbiAgICByZXMgPSBhd2FpdCBKU09OLnBhcnNlKHJlcylcclxuICAgIGlmIChyZXMpIHtcclxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBgL2FkbWluc2MvJHttb2RlbH0vZWRpdC8ke21vZGVsLmlkfWBcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICBhc3luYyBkZWwoKSB7XHJcbiAgICBpZiAoX3Rlc3QuY2hpbGRyZW4oKSkge1xyXG4gICAgICBwb3B1cC5zaG93KCfQodC90LDRh9Cw0LvQsCDRg9C00LDQu9C40YLQtSDQstGB0LUg0YLQtdGB0YLRiyDQuNC3INC/0LDQv9C60LgnKVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuXHJcbiAgICBsZXQgaWQgPSBfdGVzdC5pZCgpXHJcbiAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCgnL2FkbWluc2MvJHttb2RlbH0vZGVsZXRlJywge2lkfSlcclxuICAgIHJlcyA9IGF3YWl0IEpTT04ucGFyc2UocmVzKVxyXG4gICAgaWYgKHJlcy5ub3RBZG1pbikge1xyXG4gICAgICBwb3B1cC5zaG93KCfQktC40LTQuNC80L7RgdGC0Ywg0YLQtdGB0YLQsCDRgdC60YDRi9GC0LAuINCn0YLQvtCx0Ysg0YPQtNCw0LvQuNGC0Ywg0L/QvtC70L3QvtGB0YLRjNGOIC0g0L7QsdGA0LDRgtC40YLQtdGB0Ywg0Log0JPQlCcpXHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IGAvYWRtaW5zYy8ke21vZGVsfS9lZGl0LzQwMGBcclxuICAgICAgfSwgNDAwMClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IGAvYWRtaW5zYy8ke21vZGVsfS9lZGl0LzQwMGBcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxufSIsImltcG9ydCB7JCwgcG9wdXAsIHBvc3R9IGZyb20gJy4uLy4uLy4uL2NvbW1vbidcclxuXHJcbmV4cG9ydCBsZXQgX2Fuc3dlciA9IHtcclxuXHJcbiAgYXN5bmMgY3JlYXRlKGJ1dHRvbikge1xyXG5cclxuICAgIGxldCBxdWVzdGlvbiA9IGJ1dHRvbi5jbG9zZXN0KCcucXVlc3Rpb24tZWRpdCcpXHJcbiAgICBsZXQgb3BlbnF1ZXN0aW9uX2lkID0gcXVlc3Rpb24uaWRcclxuICAgIGxldCBzb3J0ID0gcXVlc3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnLmFuc3dlcicpLmxlbmd0aCArIDFcclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KCcvb3BlbmFuc3dlci91cGRhdGVPckNyZWF0ZScsXHJcbiAgICAgIHtvcGVucXVlc3Rpb25faWQsIHNvcnR9KVxyXG4gICAgcmVzID0gSlNPTi5wYXJzZShyZXMpXHJcbiAgICBsZXQgaWQgPSByZXMuaWRcclxuICAgIGlmIChpZCkge1xyXG4gICAgICBsZXQgaHRtbCA9IHJlcy5odG1sXHJcbiAgICAgIGJ1dHRvbi5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmViZWdpblwiLCBodG1sKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcG9wdXAuc2hvdygn0KHQvtGF0YDQsNC90LXQvdC+JylcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBhc3luYyBkZWwodGFyZ2V0KSB7XHJcbiAgICBsZXQgZGVsX2J1dHRvbiA9IHRhcmdldC5jbG9zZXN0KCcuZGVsZXRlJylcclxuICAgIGlmICghZGVsX2J1dHRvbikgcmV0dXJuIGZhbHNlXHJcbiAgICBpZiAoY29uZmlybShcItCj0LTQsNC70LjRgtGMINGN0YLQvtGCINC+0YLQstC10YI/XCIpKSB7XHJcbiAgICAgIGxldCBhbnN3ZXIgPSBkZWxfYnV0dG9uLmNsb3Nlc3QoJy5hbnN3ZXInKVxyXG4gICAgICBsZXQgaWQgPSArYW5zd2VyLmRhdGFzZXRbJ2Fuc3dlcklkJ11cclxuICAgICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9vcGVuYW5zd2VyL2RlbGV0ZScsIHtpZH0pXHJcbiAgICAgIHJlcyA9IEpTT04ucGFyc2UocmVzKVxyXG4gICAgICBpZiAocmVzLm1zZyA9PT0gJ29rJykge1xyXG4gICAgICAgIGFuc3dlci5yZW1vdmUoKVxyXG4gICAgICAgIHBvcHVwLnNob3coJ9Ce0YLQstC10YIg0YPQtNCw0LvQtdC9JylcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbn1cclxuIiwiaW1wb3J0ICcuL3Rlc3QtZWRpdC5zY3NzJ1xyXG5pbXBvcnQgJy4uL2NvbXBvbmVudHMvZm9vdGVyL2Zvb3Rlci5zY3NzJ1xyXG5cclxuaW1wb3J0ICcuL3Rlc3QtZWRpdC1tZW51LnNjc3MnXHJcbmltcG9ydCAnLi4vY29tcG9uZW50cy9wb3B1cC5zY3NzJ1xyXG5cclxuaW1wb3J0ICcuL3Rlc3QtdXBkYXRlJ1xyXG5pbXBvcnQgJy4uL0FkbWluL2FkbWluJ1xyXG5cclxuaW1wb3J0IHskLCBwb3N0LCBwb3B1cCwgZGVib3VuY2V9IGZyb20gJy4uL2NvbW1vbidcclxuXHJcbmltcG9ydCB7X29wZW5xdWVzdGlvbn0gZnJvbSBcIi4vbW9kZWwvb3BlbnRlc3Qvb3BlbnF1ZXN0aW9uXCJcclxuaW1wb3J0IHNvcnRhYmxlIGZyb20gXCIuLi9jb21wb25lbnRzL3NvcnRhYmxlXCJcclxuaW1wb3J0IF90ZXN0IGZyb20gXCIuL21vZGVsL29wZW50ZXN0L29wZW50ZXN0XCI7XHJcbmltcG9ydCB7X2Fuc3dlcn0gZnJvbSBcIi4vbW9kZWwvb3BlbnRlc3Qvb3BlbmFuc3dlclwiO1xyXG5cclxuXHJcbmxldCBvcGVudGVzdEVkaXQgPSAkKCcub3BlbnRlc3QtZWRpdC13cmFwcGVyJylbMF1cclxuaWYgKG9wZW50ZXN0RWRpdCkge1xyXG5cclxuICBzb3J0YWJsZSgnLm9wZW50ZXN0LWVkaXQtd3JhcHBlciAucXVlc3Rpb25zJyxcclxuICAgICcub3BlbnRlc3QtZWRpdC13cmFwcGVyIC5xdWVzdGlvbi1lZGl0JyxcclxuICAgICdvcGVucXVlc3Rpb24nKVxyXG5cclxuXHJcbiAgJChvcGVudGVzdEVkaXQpLm9uKCdjaGFuZ2UnLCBoYW5kbGVDaGFuZ2UpXHJcblxyXG4gICQob3BlbnRlc3RFZGl0KS5vbignY2xpY2snLCAoe3RhcmdldH0pID0+IHtcclxuICAgICAgY29uc3QgdGVzdCA9IG5ldyBfdGVzdCgpXHJcbiAgICAgIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCd0ZXN0LXBhdGhfX3VwZGF0ZScpKSB7XHJcbiAgICAgICAgdGVzdC51cGRhdGUoKVxyXG4gICAgICB9IGVsc2UgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3Rlc3RfX3VwZGF0ZScpKSB7XHJcbiAgICAgICAgdGVzdC51cGRhdGUoKVxyXG4gICAgICB9IGVsc2UgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3Rlc3RfX3NhdmUnKSkge1xyXG4gICAgICAgIHRlc3QudXBkYXRlKClcclxuICAgICAgfSBlbHNlIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCd0ZXN0X19kZWxldGUnKSkge1xyXG4gICAgICAgIHRlc3QuZGVsZXRlKClcclxuICAgICAgfSBlbHNlIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCd0ZXN0LXBhdGhfX2NyZWF0ZScpKSB7XHJcbiAgICAgICAgdGVzdC5wYXRoX2NyZWF0ZSgpXHJcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygndGVzdF9fY3JlYXRlJykpIHtcclxuICAgICAgICB0ZXN0LmNyZWF0ZSgpXHJcbiAgICAgIH0gZWxzZSBpZiAoISF0YXJnZXQuY2xvc2VzdCgnLnF1ZXN0aW9uX19zaG93LWFuc3dlcnMnKSkge1xyXG4gICAgICAgIF9vcGVucXVlc3Rpb24uc2hvd0Fuc3dlcnModGFyZ2V0KVxyXG4gICAgICB9IGVsc2UgaWYgKCEhdGFyZ2V0LmNsb3Nlc3QoJy5xdWVzdGlvbl9fZGVsZXRlJykpIHtcclxuICAgICAgICBfb3BlbnF1ZXN0aW9uLmRlbCh0YXJnZXQpXHJcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygncXVlc3Rpb25fX2NyZWF0ZS1idXR0b24nKSkge1xyXG4gICAgICAgIF9vcGVucXVlc3Rpb24uY3JlYXRlKHRhcmdldClcclxuICAgICAgfSBlbHNlIGlmICghIXRhcmdldC5jbG9zZXN0KCcuZGVsZXRlJykpIHtcclxuICAgICAgICBfYW5zd2VyLmRlbCh0YXJnZXQpXHJcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYW5zd2VyX19jcmVhdGUtYnV0dG9uJykpIHtcclxuICAgICAgICBfYW5zd2VyLmNyZWF0ZSh0YXJnZXQpXHJcbiAgICAgIH0gZWxzZSBpZiAoISF0YXJnZXQuY2xvc2VzdCgnLnF1ZXN0aW9uLWVkaXRfX3BhcmVudC1zZWxlY3QnKSkge1xyXG4gICAgICAgIF9vcGVucXVlc3Rpb24uY2hhbmdlUGFyZW50KHRhcmdldClcclxuICAgICAgfSBlbHNlIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdsZWQnKSkge1xyXG4gICAgICAgIHRhcmdldC5jbGFzc0xpc3QudG9nZ2xlKCdhbmltYXRlZCcpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICApXHJcblxyXG4gIGxldCBoYW5kbGVLZXl1cCA9IGFzeW5jIGZ1bmN0aW9uICh7dGFyZ2V0fSkge1xyXG5cclxuICAgIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCd0ZXh0JykpIHtcclxuICAgICAgbGV0IGFuc3dlciA9IHRhcmdldC5jbG9zZXN0KCcuYW5zd2VyJylcclxuICAgICAgaWYgKGFuc3dlcikge1xyXG4gICAgICAgIHNhdmVBbnN3ZXIoYW5zd2VyKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxldCBpZCA9IHRhcmdldC5jbG9zZXN0KCcucXVlc3Rpb24tZWRpdCcpLmlkXHJcbiAgICAgICAgbGV0IHF1ZXN0aW9uID0gdGFyZ2V0LmlubmVyVGV4dFxyXG4gICAgICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KCcvYWRtaW5zYy9vcGVucXVlc3Rpb24vdXBkYXRlT3JDcmVhdGUnLFxyXG4gICAgICAgICAge2lkLCBxdWVzdGlvbn0pXHJcbiAgICAgICAgcmVzID0gYXdhaXQgSlNPTi5wYXJzZShyZXMpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGxldCBkZWJvdW5jZWRJbnB1dCA9IGRlYm91bmNlKGhhbmRsZUtleXVwKVxyXG4gICQob3BlbnRlc3RFZGl0KS5vbigna2V5dXAnLCBkZWJvdW5jZWRJbnB1dClcclxuXHJcbn1cclxuXHJcblxyXG5hc3luYyBmdW5jdGlvbiBzYXZlQW5zd2VyKGFuc3dlckVsKSB7XHJcbiAgbGV0IGlkID0gYW5zd2VyRWwuZGF0YXNldC5hbnN3ZXJJZFxyXG4gIGxldCBpc19jb3JyZWN0ID0gK2Fuc3dlckVsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JykuY2hlY2tlZFxyXG4gIGxldCBvcGVucXVlc3Rpb25faWQgPSBhbnN3ZXJFbC5jbG9zZXN0KCcucXVlc3Rpb24tZWRpdCcpLmlkXHJcbiAgbGV0IGFuc3dlciA9IGFuc3dlckVsLnF1ZXJ5U2VsZWN0b3IoJy50ZXh0JykuaW5uZXJUZXh0XHJcbiAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9hZG1pbnNjL29wZW5hbnN3ZXIvdXBkYXRlT3JDcmVhdGUnLFxyXG4gICAge2lkLCBhbnN3ZXIsIG9wZW5xdWVzdGlvbl9pZCwgaXNfY29ycmVjdH0pXHJcbiAgcmVzID0gSlNPTi5wYXJzZShyZXMpXHJcbiAgaWYgKHJlcy5tc2cgPT09ICdvaycpIHtcclxuICAgIHBvcHVwLnNob3coJ9Ch0L7RhdGA0LDQvdC10L0nKVxyXG4gIH1cclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKHt0YXJnZXR9KSB7XHJcbiAgbGV0IGFuc3dlciA9IHRhcmdldC5jbG9zZXN0KCcuYW5zd2VyJylcclxuXHJcbiAgaWYgKGFuc3dlcikge1xyXG4gICAgc2F2ZUFuc3dlcihhbnN3ZXIpXHJcbiAgfVxyXG5cclxufVxyXG5cclxuXHJcblxyXG4iLCJpbXBvcnQgeyQsIHBvcHVwLCBwb3N0fSBmcm9tICcuLi8uLi9jb21tb24nXHJcblxyXG5leHBvcnQgbGV0IF9hbnN3ZXIgPSB7XHJcblxyXG4gIGVsOiAoYWRkX2J1dHRvbikgPT4ge1xyXG4gICAgbGV0IGFuc3dlcnMgPSBhZGRfYnV0dG9uLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbCgnLmFuc3dlcicpXHJcbiAgICBsZXQgcHJldl9zb3J0ID0gMFxyXG4gICAgaWYgKGFuc3dlcnMubGVuZ3RoKSB7XHJcbiAgICAgIHByZXZfc29ydCA9ICskKGFuc3dlcnNbYW5zd2Vycy5sZW5ndGggLSAxXSkuZmluZCgnLnNvcnQnKS5pbm5lclRleHRcclxuICAgIH1cclxuICAgIGxldCBlbCA9ICQoJy5hbnN3ZXJfX2NyZWF0ZScpLmZpbmQoJy5hbnN3ZXInKS5jbG9uZU5vZGUodHJ1ZSlcclxuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2Fuc3dlcicpXHJcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdhbnN3ZXJfX2NyZWF0ZScpXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBlbDogZWwsXHJcbiAgICAgIGlkOiAnbmV3JyxcclxuICAgICAgcV9pZDogK2FkZF9idXR0b24uY2xvc2VzdCgnLnF1ZXN0aW9uLWVkaXQnKS5pZCxcclxuICAgICAgcHJldmlvdXNfc29ydDogcHJldl9zb3J0LFxyXG4gICAgICBhbnN3ZXJDbnQ6IGFuc3dlcnMubGVuZ3RoLFxyXG4gICAgICBzb3J0OiAkKGVsKS5maW5kKCcuc29ydCcpLFxyXG4gICAgICBjaGVja2VkOiAkKGVsKS5maW5kKCdpbnB1dCcpLFxyXG4gICAgICB0ZXh0OiAkKGVsKS5maW5kKCcudGV4dCcpLFxyXG4gICAgICBkZWxldGU6ICQoJChlbCkuZmluZCgnLmRlbGV0ZScpKS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2Fuc3dlci5kZWwodGhpcylcclxuICAgICAgfSlcclxuICAgIH1cclxuICB9LFxyXG4gIGdldE1vZGVsRm9yU2VydmVyKGVsKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBhbnN3ZXI6ICcnLFxyXG4gICAgICBwYXJlbnRfcXVlc3Rpb246IGVsLnFfaWQsXHJcbiAgICAgIGNvcnJlY3RfYW5zd2VyOiAwLFxyXG4gICAgICBwaWNhOiAnJ1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGFzeW5jIGNyZWF0ZShidXR0b24pIHtcclxuICAgIC8vIGRlYnVnZ2VyXHJcbiAgICBsZXQgYV9pZCA9IGF3YWl0IGNyZWF0ZU9uU2VydmVyKGJ1dHRvbilcclxuICAgIHNob3coYV9pZClcclxuXHJcbiAgICBhc3luYyBmdW5jdGlvbiBjcmVhdGVPblNlcnZlcihidXR0b24pIHtcclxuICAgICAgbGV0IG5ld0VsID0gX2Fuc3dlci5nZXRNb2RlbEZvclNlcnZlcihfYW5zd2VyLmVsKGJ1dHRvbikpXHJcblxyXG4gICAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCgnL2Fuc3dlci9jcmVhdGUnLCBuZXdFbClcclxuICAgICAgcmVzID0gSlNPTi5wYXJzZShyZXMpXHJcblxyXG4gICAgICByZXR1cm4gcmVzLmlkXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2hvdyhhX2lkKSB7XHJcbiAgICAgIGxldCBlbCA9IF9hbnN3ZXIuZWwoYnV0dG9uKVxyXG5cclxuICAgICAgZWwuY2hlY2tlZC5jaGVja2VkID0gZmFsc2VcclxuICAgICAgZWwuZWwuZGF0YXNldFsnYW5zd2VySWQnXSA9IGFfaWRcclxuICAgICAgZWwudGV4dC5pbm5lclRleHQgPSAnJ1xyXG4gICAgICBlbC5zb3J0LmlubmVyVGV4dCA9IGVsLmFuc3dlckNudCArIDFcclxuXHJcbiAgICAgIGVsLmVsLnN0eWxlLmRpc3BsYXkgPSAnZmxleCdcclxuICAgICAgYnV0dG9uLmJlZm9yZShlbC5lbClcclxuICAgICAgZWwuZWwuc3R5bGUub3BhY2l0eSA9IDFcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBhc3luYyBkZWwodGFyZ2V0KSB7XHJcbiAgICBsZXQgZGVsX2J1dHRvbiA9IHRhcmdldC5jbG9zZXN0KCcuZGVsZXRlJylcclxuICAgIGlmICghZGVsX2J1dHRvbikgcmV0dXJuIGZhbHNlXHJcbiAgICBpZiAoY29uZmlybShcItCj0LTQsNC70LjRgtGMINGN0YLQvtGCINC+0YLQstC10YI/XCIpKSB7XHJcbiAgICAgIGxldCByZXMgPSBhd2FpdCBkZWxldGVGcm9tU2VydmVyKGRlbF9idXR0b24pXHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlRnJvbVNlcnZlcihkZWxfYnV0dG9uKSB7XHJcblxyXG4gICAgICBsZXQgYV9pZCA9ICtkZWxfYnV0dG9uLmNsb3Nlc3QoJy5hbnN3ZXInKS5kYXRhc2V0WydhbnN3ZXJJZCddXHJcbiAgICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KCcvYW5zd2VyL2RlbGV0ZScsIHthX2lkfSlcclxuICAgICAgcmVzID0gSlNPTi5wYXJzZShyZXMpXHJcbiAgICAgIGlmIChyZXMubXNnID09PSAnb2snKSB7XHJcbiAgICAgICAgZGVsX2J1dHRvbi5jbG9zZXN0KCcuYW5zd2VyJykucmVtb3ZlKClcclxuICAgICAgICBwb3B1cC5zaG93KCfQntGC0LLQtdGCINGD0LTQsNC70LXQvScpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG59XHJcbiIsImltcG9ydCB7JCwgcG9wdXAsIHBvc3QsIGFkZFRvb2x0aXB9IGZyb20gXCIuLi8uLi9jb21tb25cIlxyXG5pbXBvcnQge19hbnN3ZXJ9IGZyb20gXCIuL2Fuc3dlclwiO1xyXG5cclxuZXhwb3J0IGxldCBfcXVlc3Rpb24gPSB7XHJcblxyXG5cclxuXHJcblxyXG4gIGNoYW5nZVBhcmVudDogYXN5bmMgZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgZGVidWdnZXJcclxuICAgIGxldCBvcHQgPSB0YXJnZXQub3B0aW9uc1t0YXJnZXQuc2VsZWN0ZWRJbmRleF1cclxuICAgIGxldCBpZCA9IHRhcmdldC5jbG9zZXN0KCcucXVlc3Rpb24tZWRpdCcpLmlkXHJcbiAgICBsZXQgdGVzdF9pZCA9IG9wdC5kYXRhc2V0WydxdWVzdGlvblBhcmVudElkJ11cclxuICAgIGxldCB0ZXN0X25hbWUgPSBvcHQudmFsdWVcclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KCcvYWRtaW5zYy9xdWVzdGlvbi9jaGFuZ2VQYXJlbnQnLCB7aWQsIHRlc3RfaWR9KVxyXG4gICAgcmVzID0gSlNPTi5wYXJzZShyZXMpXHJcbiAgICBpZiAocmVzLm1zZyAhPT0gJ29rJykgdGhyb3cgKGUpO1xyXG4gICAgbGV0IHF1ZXN0aW9uID0gdGFyZ2V0LmNsb3Nlc3QoJy5xdWVzdGlvbi1lZGl0JylcclxuICAgIHF1ZXN0aW9uLnJlbW92ZSgpXHJcbiAgICBwb3B1cC5zaG93KCfQn9C10YDQtdC80LXRidC10L0g0LIgJyArIHRlc3RfbmFtZSlcclxuICAgIC8vIGRlYnVnZ2VyXHJcbiAgfSxcclxuXHJcblxyXG4gIHNob3dUaXA6IChhY3Rpb24sIGV2ZW50KSA9PiB7XHJcbiAgICBsZXQgZWwgPSBldmVudC50YXJnZXRcclxuICAgIGxldCB0aXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXHJcblxyXG4gICAgaWYgKGFjdGlvbiA9PT0gJ3NhdmUuc3ZnJykge1xyXG4gICAgICBhZGRUb29sdGlwKGVsLCAn0YHQvtGF0YDQsNC90LjRgtGMJylcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyBzaG93Rmlyc3Q6ICgpID0+IHtcclxuICAvLyAgIGxldCBxdWVzdGlvbiA9IF9xdWVzdGlvbi5jbG9uZUVtcHR5TW9kZWwoKVxyXG4gIC8vICAgaWYgKCFxdWVzdGlvbikgcmV0dXJuXHJcbiAgLy9cclxuICAvLyAgIGxldCBtb2RlbCA9IF9xdWVzdGlvbi52aWV3TW9kZWwocXVlc3Rpb24pXHJcbiAgLy8gICBtb2RlbC5zb3J0LmlubmVyVGV4dCA9ICcxJ1xyXG4gIC8vICAgJChtb2RlbC5zYXZlKS5vbignY2xpY2snLCBfcXVlc3Rpb24uc2F2ZSlcclxuICAvLyAgICQobW9kZWwuZGVsKS5vbignY2xpY2snLCBfcXVlc3Rpb24uZGVsZXRlKVxyXG4gIC8vXHJcbiAgLy8gICAkKHF1ZXN0aW9uKS5hZGRDbGFzcygncXVlc3Rpb24tZWRpdCcpXHJcbiAgLy8gICAkKHF1ZXN0aW9uKS5yZW1vdmVDbGFzcygncXVlc3Rpb25fX2NyZWF0ZScpXHJcbiAgLy9cclxuICAvLyAgIGxldCBxdWVzdGlvbnMgPSAkKCcucXVlc3Rpb25zJylbMF1cclxuICAvLyAgIHF1ZXN0aW9ucy5wcmVwZW5kKHF1ZXN0aW9uKVxyXG4gIC8vIH0sXHJcblxyXG4gIGNsb25lRW1wdHlNb2RlbDogKCkgPT4ge1xyXG4gICAgbGV0IHF1ZXN0aW9uID0gJCgnLnF1ZXN0aW9ucyAucXVlc3Rpb25fX2NyZWF0ZSAucXVlc3Rpb24tZWRpdCcpWzBdXHJcbiAgICBpZiAocXVlc3Rpb24pIHJldHVybiBxdWVzdGlvbi5jbG9uZU5vZGUodHJ1ZSlcclxuICB9LFxyXG5cclxuICBzaG93QW5zd2VyczogKHRhcmdldCkgPT4ge1xyXG4gICAgbGV0IHJvdyA9IHRhcmdldC5jbG9zZXN0KCcucXVlc3Rpb24tZWRpdCcpXHJcbiAgICBsZXQgYW5zd2VycyA9ICQocm93KS5maW5kKCcucXVlc3Rpb25fX2Fuc3dlcnMnKVxyXG4gICAgYW5zd2Vycy5jbGFzc0xpc3QudG9nZ2xlKCdoZWlnaHQnKVxyXG4gICAgYW5zd2Vycy5jbGFzc0xpc3QudG9nZ2xlKCdzY2FsZScpXHJcbiAgICB0YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSgncm90YXRlJylcclxuICB9LFxyXG5cclxuICB2aWV3TW9kZWw6IChlbCkgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaWQ6ICtlbC5pZCxcclxuICAgICAgZWw6IGVsLFxyXG4gICAgICBzb3J0OiBlbC5xdWVyeVNlbGVjdG9yKCcuc29ydCcpLFxyXG4gICAgICBzYXZlOiBlbC5xdWVyeVNlbGVjdG9yKCcucXVlc3Rpb25fX3NhdmUnKSxcclxuICAgICAgdGV4dDogZWwucXVlcnlTZWxlY3RvcignLnF1ZXN0aW9uX190ZXh0JyksXHJcbiAgICAgIGRlbDogZWwucXVlcnlTZWxlY3RvcignLnF1ZXN0aW9uX19kZWxldGUnKSxcclxuICAgICAgY3JlYXRlQW5zd2VyQnV0dG9uOiBlbC5xdWVyeVNlbGVjdG9yKCcuYW5zd2VyX19jcmVhdGUtYnV0dG9uJyksXHJcbiAgICAgIGFkZEJ1dHRvbjogJCgkKCcucXVlc3Rpb25zJylbMF0pLmZpbmQoJy5xdWVzdGlvbl9fY3JlYXRlLWJ1dHRvbicpLFxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHNlcnZlck1vZGVsOiAoKSA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBxdWVzdGlvbjoge1xyXG4gICAgICAgIGlkOiBudWxsLFxyXG4gICAgICAgIHF1c3Rpb246ICcnLFxyXG4gICAgICAgIHBhcmVudDogK3dpbmRvdy5sb2NhdGlvbi5ocmVmLnNwbGl0KCcvJykucG9wKCksXHJcbiAgICAgICAgc29ydDogX3F1ZXN0aW9uLmxhc3RTb3J0KCksXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICBxdWVzdGlvbnM6ICgpID0+IHtcclxuICAgIHJldHVybiAkKCcucXVlc3Rpb25zPi5xdWVzdGlvbi1lZGl0JylcclxuICAgIC8vIHJldHVybiAkKCcucXVlc3Rpb25zPi5xdWVzdGlvbi1lZGl0JykuZWxcclxuICB9LFxyXG5cclxuICBxdWVzdGlvbnNDb3VudDogKCkgPT4ge1xyXG4gICAgcmV0dXJuICQoJy5xdWVzdGlvbnM+LnF1ZXN0aW9uLWVkaXQnKS5lbC5sZW5ndGhcclxuICB9LFxyXG5cclxuICBsYXN0U29ydDogKCkgPT4ge1xyXG4gICAgbGV0IHFzID0gX3F1ZXN0aW9uLnF1ZXN0aW9ucygpXHJcbiAgICBsZXQgbGVuZ3RoID0gcXMubGVuZ3RoIC0gMVxyXG4gICAgbGV0IGxhc3QgPSArX3F1ZXN0aW9uLnZpZXdNb2RlbChxc1tsZW5ndGhdKS5zb3J0LmlubmVyVGV4dFxyXG4gICAgcmV0dXJuIGxhc3QgKyAxXHJcbiAgfSxcclxuXHJcbiAgY3JlYXRlOlxyXG4gICAgYXN5bmMgKGUpID0+IHtcclxuICAgICAgbGV0IHFfaWQgPSBhd2FpdCBfcXVlc3Rpb24uY3JlYXRlT25TZXJ2ZXIoZSlcclxuICAgICAgaWYgKHFfaWQpIHtcclxuICAgICAgICBfcXVlc3Rpb24uY3JlYXRlT25WaWV3KHFfaWQpXHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gIGNyZWF0ZU9uU2VydmVyOlxyXG4gICAgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBsZXQgcXVlc3Rpb24gPSBfcXVlc3Rpb24uc2VydmVyTW9kZWwoKVxyXG4gICAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCgnL3F1ZXN0aW9uL3VwZGF0ZU9yQ3JlYXRlJywge3F1ZXN0aW9uOiBxdWVzdGlvbi5xdWVzdGlvbiwgYW5zd2Vyczoge319KVxyXG4gICAgICByZXMgPSBhd2FpdCBKU09OLnBhcnNlKHJlcylcclxuXHJcbiAgICAgIHJldHVybiByZXMuaWRcclxuICAgIH0sXHJcblxyXG4gIGNyZWF0ZU9uVmlldzpcclxuICAgIChxX2lkKSA9PiB7XHJcbiAgICAgIGxldCBjbG9uZSA9IF9xdWVzdGlvbi5jbG9uZUVtcHR5TW9kZWwoKVxyXG5cclxuICAgICAgbGV0IG1vZGVsID0gX3F1ZXN0aW9uLnZpZXdNb2RlbChjbG9uZSlcclxuICAgICAgbW9kZWwuc29ydC5pbm5lclRleHQgPSBfcXVlc3Rpb24ubGFzdFNvcnQoKVxyXG4gICAgICBtb2RlbC50ZXh0LmlubmVyVGV4dCA9ICcnXHJcbiAgICAgIG1vZGVsLmVsLmlkID0gcV9pZFxyXG5cclxuICAgICAgbW9kZWwuYWRkQnV0dG9uLmJlZm9yZShjbG9uZSlcclxuICAgIH0sXHJcblxyXG5cclxuICBzYXZlOlxyXG4gICAgYXN5bmMgKHRhcmdldCkgPT4ge1xyXG4gICAgICBsZXQgcXVlc3Rpb24gPSB0YXJnZXQuY2xvc2VzdCgnLnF1ZXN0aW9uLWVkaXQnKVxyXG4gICAgICBsZXQgcmVzID0gYXdhaXQgcG9zdChcclxuICAgICAgICAnL3F1ZXN0aW9uL1VwZGF0ZU9yQ3JlYXRlJyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBxdWVzdGlvbjogX3F1ZXN0aW9uLmdldE1vZGVsRm9yU2VydmVyKHF1ZXN0aW9uKSxcclxuICAgICAgICAgIGFuc3dlcnM6IF9xdWVzdGlvbi5nZXRBbnN3ZXJzKHF1ZXN0aW9uKSxcclxuICAgICAgICB9KVxyXG4gICAgICByZXMgPSBhd2FpdCBKU09OLnBhcnNlKHJlcylcclxuICAgICAgLy8gcG9wdXAuc2hvdyhyZXMubXNnKVxyXG4gICAgfSxcclxuXHJcbiAgZGVsZXRlOlxyXG4gICAgYXN5bmMgKHRhcmdldCkgPT4ge1xyXG4gICAgICBpZiAoY29uZmlybShcItCj0LTQsNC70LjRgtGMINCy0L7Qv9GA0L7RgSDRgdC+INCy0YHQtdC80Lgg0LXQs9C+INC+0YLQstC10YLQsNC80Lg/XCIpKSB7XHJcbiAgICAgICAgbGV0IHZpZXdNb2RlbCA9IF9xdWVzdGlvbi52aWV3TW9kZWwodGFyZ2V0LmNsb3Nlc3QoJy5xdWVzdGlvbi1lZGl0JykpXHJcbiAgICAgICAgbGV0IGlkID0gdmlld01vZGVsLmlkXHJcblxyXG4gICAgICAgIGxldCBkZWxldGVkID0gYXdhaXQgX3F1ZXN0aW9uLmRlbGV0ZUZyb21TZXJ2ZXIoaWQpXHJcbiAgICAgICAgaWYgKGRlbGV0ZWQpIHtcclxuICAgICAgICAgIF9xdWVzdGlvbi5kZWxldGVGcm9tVmlldyh2aWV3TW9kZWwpXHJcbiAgICAgICAgICAvLyBwb3B1cC5zaG93KGRlbGV0ZWQubXNnKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgZGVsZXRlRnJvbVZpZXc6XHJcbiAgICBhc3luYyAodmlld01vZGVsKSA9PiB7XHJcbiAgICAgIHZpZXdNb2RlbC5lbC5yZW1vdmUoKVxyXG4gICAgfSxcclxuXHJcbiAgZGVsZXRlRnJvbVNlcnZlcjpcclxuICAgIGFzeW5jIChxX2lkKSA9PiB7XHJcbiAgICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KCcvcXVlc3Rpb24vZGVsZXRlJywge3FfaWR9KVxyXG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXMpXHJcbiAgICB9LFxyXG5cclxuICBnZXRNb2RlbEZvclNlcnZlcjpcclxuICAgIChxdWVzdGlvbikgPT4ge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkOiArcXVlc3Rpb24uaWQsXHJcbiAgICAgICAgcGFyZW50OiArJCgnLnF1ZXN0aW9ucycpWzBdLmRhdGFzZXQudGVzdElkLFxyXG4gICAgICAgIHBpY3E6ICcnLFxyXG4gICAgICAgIHF1c3Rpb246ICQocXVlc3Rpb24pLmZpbmQoJy5xdWVzdGlvbl9fdGV4dCcpLmlubmVyVGV4dCxcclxuICAgICAgICBzb3J0OiArJChxdWVzdGlvbikuZmluZCgnLnNvcnQnKS5pbm5lclRleHQsXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgZ2V0QW5zd2VyczpcclxuICAgIChxdWVzdGlvbikgPT4ge1xyXG4gICAgICBsZXQgYW5zd2VyQmxvY2tzID0gcXVlc3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnLmFuc3dlcicpXHJcbiAgICAgIHJldHVybiBbLi4uYW5zd2VyQmxvY2tzXS5tYXAoKGEpID0+IHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgaWQ6ICthLmRhdGFzZXRbJ2Fuc3dlcklkJ10sXHJcbiAgICAgICAgICBhbnN3ZXI6IGEucXVlcnlTZWxlY3RvcignLnRleHQnKS5pbm5lclRleHQsXHJcbiAgICAgICAgICBjb3JyZWN0X2Fuc3dlcjogK2EucXVlcnlTZWxlY3RvcignW3R5cGU9XCJjaGVja2JveFwiXScpLmNoZWNrZWQsXHJcbiAgICAgICAgICBwYXJlbnRfcXVlc3Rpb246ICtxdWVzdGlvbi5pZCxcclxuICAgICAgICAgIHBpY2E6ICcnLFxyXG4gICAgICAgIH1cclxuICAgICAgfSwgcXVlc3Rpb24pXHJcbiAgICB9LFxyXG59XHJcblxyXG4iLCJpbXBvcnQgJy4vV0RTU2VsZWN0LnNjc3MnXHJcbmltcG9ydCAnLi9jdXN0b21TZWxlY3Quc2NzcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdEU1NlbGVjdCB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGVsKSB7XHJcblxyXG4gICAgaWYgKCFlbCkgcmV0dXJuIGZhbHNlXHJcbiAgICBpZiAoZWwubXVsdGlwbGUpIHJldHVybiBmYWxzZVxyXG5cclxuICAgIHRoaXMudGl0bGUgPSBlbC50aXRsZSA/PyAnJ1xyXG4gICAgdGhpcy5maWVsZCA9IGVsLmRhdGFzZXRbJ2ZpZWxkJ11cclxuICAgIHRoaXMub3B0aW9ucyA9IGdldEZvcm1hdHRlZE9wdGlvbnMoZWwucXVlcnlTZWxlY3RvckFsbChcIm9wdGlvblwiKSlcclxuXHJcbiAgICB0aGlzLnNlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcclxuICAgIGlmIChlbC5jbGFzc05hbWUpIHRoaXMuc2VsLmNsYXNzTGlzdC5hZGQoZWwuY2xhc3NOYW1lKVxyXG5cclxuICAgIHRoaXMubGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKVxyXG4gICAgdGhpcy5hcnJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcclxuICAgIHRoaXMuc3BhY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXHJcblxyXG4gICAgdGhpcy51bCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiKVxyXG4gICAgc2V0dXAodGhpcylcclxuICAgIGVsLmFmdGVyKHRoaXMuc2VsKVxyXG4gICAgLy8gZWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiXHJcbiAgICBlbC5yZW1vdmUoKVxyXG4gIH1cclxuXHJcbiAgZ2V0IHNlbGVjdGVkT3B0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5maW5kKG9wdGlvbiA9PiBvcHRpb24uc2VsZWN0ZWQpXHJcbiAgfVxyXG5cclxuICBnZXQgc2VsZWN0ZWRPcHRpb25JbmRleCgpIHtcclxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaW5kZXhPZih0aGlzLnNlbGVjdGVkT3B0aW9uKVxyXG4gIH1cclxuXHJcbiAgc2VsZWN0VmFsdWUodmFsdWUpIHtcclxuICAgIGNvbnN0IG5leHQgPSB0aGlzLm9wdGlvbnMuZmluZChvcHRpb24gPT4ge1xyXG4gICAgICByZXR1cm4gb3B0aW9uLnZhbHVlID09PSB2YWx1ZVxyXG4gICAgfSlcclxuICAgIGNvbnN0IHByZXYgPSB0aGlzLnNlbGVjdGVkT3B0aW9uXHJcbiAgICBwcmV2LnNlbGVjdGVkID0gZmFsc2VcclxuICAgIC8vIHByZXYuZWxlbWVudC5zZWxlY3RlZCA9IGZhbHNlXHJcblxyXG4gICAgbmV4dC5zZWxlY3RlZCA9IHRydWVcclxuICAgIC8vIG5leHQuZWxlbWVudC5zZWxlY3RlZCA9IHRydWVcclxuXHJcbiAgICB0aGlzLnNwYWNlLmlubmVyVGV4dCA9IG5leHQubGFiZWxcclxuICAgIHRoaXMubGFiZWwuY2xvc2VzdCgnW2N1c3RvbS1zZWxlY3RdJykuZGF0YXNldFsnaWQnXSA9IG5leHQudmFsdWVcclxuICAgIHRoaXMubGFiZWwuY2xvc2VzdCgnW2N1c3RvbS1zZWxlY3RdJykuZGF0YXNldFsndmFsdWUnXSA9IG5leHQudmFsdWVcclxuICAgIHRoaXMudWxcclxuICAgICAgLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXZhbHVlPVwiJHtwcmV2LnZhbHVlfVwiXWApXHJcbiAgICAgIC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIilcclxuICAgIGNvbnN0IG5ld0N1c3RvbUVsZW1lbnQgPSB0aGlzLnVsLnF1ZXJ5U2VsZWN0b3IoXHJcbiAgICAgIGBbZGF0YS12YWx1ZT1cIiR7bmV4dC52YWx1ZX1cIl1gXHJcbiAgICApXHJcbiAgICBuZXdDdXN0b21FbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKVxyXG4gICAgbmV3Q3VzdG9tRWxlbWVudC5zY3JvbGxJbnRvVmlldyh7YmxvY2s6IFwibmVhcmVzdFwifSlcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldHVwKHNlbGVjdCkge1xyXG5cclxuICBpZiAoc2VsZWN0LnRpdGxlKSB7XHJcbiAgICBzZWxlY3QudGl0bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxyXG4gICAgc2VsZWN0LnRpdGxlRWxlbWVudC5jbGFzc0xpc3QuYWRkKFwidGl0bGVcIilcclxuICAgIHNlbGVjdC50aXRsZUVsZW1lbnQuaW5uZXJUZXh0ID0gc2VsZWN0LnRpdGxlXHJcbiAgICBzZWxlY3Quc2VsLmFwcGVuZChzZWxlY3QudGl0bGVFbGVtZW50KVxyXG4gIH1cclxuXHJcbiAgLy8gc2VsZWN0LnNlbC5jbGFzc0xpc3QuYWRkKFwiY3VzdG9tLXNlbGVjdFwiKVxyXG4gIHNlbGVjdC5zZWwuc2V0QXR0cmlidXRlKFwiY3VzdG9tLXNlbGVjdFwiLCcnKVxyXG4gIGlmKHNlbGVjdC5maWVsZClzZWxlY3Quc2VsLmRhdGFzZXRbJ2ZpZWxkJ10gPSBzZWxlY3QuZmllbGRcclxuICBzZWxlY3Quc2VsLmRhdGFzZXRbJ2lkJ10gPSBzZWxlY3Quc2VsZWN0ZWRPcHRpb24udmFsdWVcclxuICBzZWxlY3Quc2VsLmRhdGFzZXRbJ3ZhbHVlJ10gPSBzZWxlY3Quc2VsZWN0ZWRPcHRpb24udmFsdWVcclxuICBzZWxlY3Quc2VsLnRhYkluZGV4ID0gMFxyXG5cclxuICAvLyBzZWxlY3QubGFiZWwuY2xhc3NMaXN0LmFkZChcInZhbHVlXCIpXHJcbiAgc2VsZWN0LnNlbC5hcHBlbmQoc2VsZWN0LmxhYmVsKVxyXG5cclxuICBzZWxlY3Quc3BhY2UuY2xhc3NMaXN0LmFkZChcInNwYWNlXCIpXHJcbiAgc2VsZWN0LnNwYWNlLmlubmVyVGV4dCA9IHNlbGVjdC5zZWxlY3RlZE9wdGlvbi5sYWJlbFxyXG4gIHNlbGVjdC5sYWJlbC5hcHBlbmQoc2VsZWN0LnNwYWNlKVxyXG5cclxuICBzZWxlY3QuYXJyb3cuY2xhc3NMaXN0LmFkZChcImFycm93XCIpXHJcbiAgc2VsZWN0LmxhYmVsLmFwcGVuZChzZWxlY3QuYXJyb3cpXHJcblxyXG4gIHNlbGVjdC51bC5jbGFzc0xpc3QuYWRkKFwib3B0aW9uc1wiKVxyXG4gIHNlbGVjdC5vcHRpb25zLmZvckVhY2gob3B0aW9uID0+IHtcclxuICAgIHNldE9wdGlvbihvcHRpb24pXHJcbiAgfSlcclxuXHJcbiAgZnVuY3Rpb24gc2V0T3B0aW9uKG9wdGlvbikge1xyXG4gICAgY29uc3QgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIilcclxuICAgIGxpLmlubmVyVGV4dCA9IG9wdGlvbi5sYWJlbFxyXG4gICAgbGkuZGF0YXNldC52YWx1ZSA9IG9wdGlvbi52YWx1ZVxyXG4gICAgbGkuY2xhc3NMaXN0LnRvZ2dsZShcInNlbGVjdGVkXCIsIG9wdGlvbi5zZWxlY3RlZClcclxuICAgIGxpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XHJcbiAgICAgIHNlbGVjdC5zZWxlY3RWYWx1ZShvcHRpb24udmFsdWUpXHJcbiAgICAgIHNlbGVjdC51bC5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKVxyXG4gICAgfSlcclxuICAgIHNlbGVjdC51bC5hcHBlbmQobGkpXHJcbiAgfVxyXG5cclxuICBzZWxlY3Quc2VsLmFwcGVuZChzZWxlY3QudWwpXHJcblxyXG4gIHNlbGVjdC5sYWJlbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgc2VsZWN0LnVsLmNsYXNzTGlzdC50b2dnbGUoXCJzaG93XCIpXHJcbiAgfSlcclxuXHJcbiAgc2VsZWN0LnNlbC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCAoKSA9PiB7XHJcbiAgICBzZWxlY3QudWwuY2xhc3NMaXN0LnJlbW92ZShcInNob3dcIilcclxuICB9KVxyXG5cclxuICBsZXQgZGVib3VuY2VUaW1lb3V0XHJcbiAgbGV0IHNlYXJjaFRlcm0gPSBcIlwiXHJcbiAgc2VsZWN0LnNlbC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBlID0+IHtcclxuICAgIHN3aXRjaCAoZS5jb2RlKSB7XHJcbiAgICAgIGNhc2UgXCJTcGFjZVwiOlxyXG4gICAgICAgIHNlbGVjdC51bC5jbGFzc0xpc3QudG9nZ2xlKFwic2hvd1wiKVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgXCJBcnJvd1VwXCI6IHtcclxuICAgICAgICBjb25zdCBwcmV2T3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbc2VsZWN0LnNlbGVjdGVkT3B0aW9uSW5kZXggLSAxXVxyXG4gICAgICAgIGlmIChwcmV2T3B0aW9uKSB7XHJcbiAgICAgICAgICBzZWxlY3Quc2VsZWN0VmFsdWUocHJldk9wdGlvbi52YWx1ZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgfVxyXG4gICAgICBjYXNlIFwiQXJyb3dEb3duXCI6IHtcclxuICAgICAgICBjb25zdCBuZXh0T3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbc2VsZWN0LnNlbGVjdGVkT3B0aW9uSW5kZXggKyAxXVxyXG4gICAgICAgIGlmIChuZXh0T3B0aW9uKSB7XHJcbiAgICAgICAgICBzZWxlY3Quc2VsZWN0VmFsdWUobmV4dE9wdGlvbi52YWx1ZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgfVxyXG4gICAgICBjYXNlIFwiRW50ZXJcIjpcclxuICAgICAgY2FzZSBcIkVzY2FwZVwiOlxyXG4gICAgICAgIHNlbGVjdC51bC5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICBjbGVhclRpbWVvdXQoZGVib3VuY2VUaW1lb3V0KVxyXG4gICAgICAgIHNlYXJjaFRlcm0gKz0gZS5rZXlcclxuICAgICAgICBkZWJvdW5jZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIHNlYXJjaFRlcm0gPSBcIlwiXHJcbiAgICAgICAgfSwgNTAwKVxyXG5cclxuICAgICAgICBjb25zdCBzZWFyY2hlZE9wdGlvbiA9IHNlbGVjdC5vcHRpb25zLmZpbmQob3B0aW9uID0+IHtcclxuICAgICAgICAgIHJldHVybiBvcHRpb24ubGFiZWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKHNlYXJjaFRlcm0pXHJcbiAgICAgICAgfSlcclxuICAgICAgICBpZiAoc2VhcmNoZWRPcHRpb24pIHtcclxuICAgICAgICAgIHNlbGVjdC5zZWxlY3RWYWx1ZShzZWFyY2hlZE9wdGlvbi52YWx1ZSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRGb3JtYXR0ZWRPcHRpb25zKG9wdGlvbnMpIHtcclxuICByZXR1cm4gWy4uLm9wdGlvbnNdLm1hcChvcHRpb24gPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdmFsdWU6IG9wdGlvbi52YWx1ZSxcclxuICAgICAgbGFiZWw6IG9wdGlvbi5sYWJlbCxcclxuICAgICAgc2VsZWN0ZWQ6IG9wdGlvbi5zZWxlY3RlZCxcclxuICAgICAgZWxlbWVudDogb3B0aW9uLFxyXG4gICAgfVxyXG4gIH0pXHJcbn0iLCJpbXBvcnQgeyR9IGZyb20gXCIuLi9jb21tb25cIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFjY29yZGlvblNob3coKSB7XHJcblxyXG4gIGxldCBjdXJyZW50VGVzdElkID0gJChgW2RhdGEtdGVzdGlkXWApWzBdXHJcbiAgaWYgKGN1cnJlbnRUZXN0SWQpIHtcclxuICAgIGN1cnJlbnRUZXN0SWQgPSArY3VycmVudFRlc3RJZC5kYXRhc2V0Wyd0ZXN0aWQnXVxyXG4gICAgbGV0IG1lbnVJdGVtQ29sbGVjdGlvbiA9ICQoJy50ZXN0LWVkaXQuYWNjb3JkaW9uIGEnKVxyXG4gICAgQXJyYXkuZnJvbShtZW51SXRlbUNvbGxlY3Rpb24pLmZpbHRlcigoYSkgPT4ge1xyXG4gICAgICBpZiAoK2EuZGF0YXNldC5pZCA9PT0gY3VycmVudFRlc3RJZCkge1xyXG4gICAgICAgIGEuY2xhc3NMaXN0LmFkZCgnY3VycmVudCcpXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgfVxyXG5cclxuXHJcbiAgbGV0IGJ1dHRvbiA9ICQoJy5hY2NvcmRpb24tb3BlbicpWzBdXHJcbiAgaWYgKGJ1dHRvbikge1xyXG4gICAgJChidXR0b24pLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgbGV0IG1lbnUgPSAkKCcuYWNjb3JkaW9uX3dyYXAnKVswXVxyXG4gICAgICBtZW51LmNsYXNzTGlzdC50b2dnbGUoJ29wZW4nKVxyXG4gICAgfSlcclxuICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7JCwgcG9wdXAsIHBvc3R9IGZyb20gJy4uLy4uL2NvbW1vbidcclxuXHJcbmV4cG9ydCBjb25zdCBfdGVzdCA9IHtcclxuXHJcbiAgbmV4dFE6ICgpID0+IHtcclxuICAgIGxldCBjdXJyZW50ID0gX3Rlc3QuY3VycmVudFEoKVxyXG4gICAgaWYgKGN1cnJlbnQuaWQgPiBjdXJyZW50Lm5hdkxlbmd0aCAtIDIpIHJldHVybiBmYWxzZVxyXG5cclxuICAgIGxldCBhaW1OYXZJZCA9IF90ZXN0LmFpbU5hdklkRnVuY3Rpb24oY3VycmVudC5pZCwgJ25leHQnKVxyXG4gICAgbGV0IGFpbVFFbCA9IF90ZXN0LmFpbVFFbEZ1bmN0aW9uKGN1cnJlbnQsICduZXh0JylcclxuXHJcbiAgICBfdGVzdC5wdXNoTmF2KGN1cnJlbnQuaWQsIGFpbU5hdklkKVxyXG4gICAgX3Rlc3QucHVzaFEoY3VycmVudC5RRWwsIGFpbVFFbClcclxuICB9LFxyXG5cclxuICBwcmV2UTogKCkgPT4ge1xyXG4gICAgbGV0IGN1cnJlbnQgPSBfdGVzdC5jdXJyZW50USgpXHJcbiAgICBpZiAoY3VycmVudC5pZCA8IDEpIHJldHVybiBmYWxzZVxyXG5cclxuICAgIGxldCBhaW1OYXZJZCA9IF90ZXN0LmFpbU5hdklkRnVuY3Rpb24oY3VycmVudC5pZCwgJ2JhY2snKVxyXG4gICAgbGV0IGFpbVFFbCA9IF90ZXN0LmFpbVFFbEZ1bmN0aW9uKGN1cnJlbnQsICdiYWNrJylcclxuXHJcbiAgICBfdGVzdC5wdXNoTmF2KGN1cnJlbnQuaWQsIGFpbU5hdklkKVxyXG4gICAgX3Rlc3QucHVzaFEoY3VycmVudC5RRWwsIGFpbVFFbClcclxuICB9LFxyXG5cclxuICBwdXNoTmF2OiAoY3VycmVudElkLCBhaW1OYXZJZCkgPT4ge1xyXG4gICAgbGV0IGN1cnJOYXZFbCA9ICQoJ1tkYXRhLXBhZ2luYXRpb25dJylbY3VycmVudElkXVxyXG4gICAgY3Vyck5hdkVsLmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScpXHJcblxyXG4gICAgbGV0IE5hdkVsID0gJCgnW2RhdGEtcGFnaW5hdGlvbl0nKVthaW1OYXZJZF1cclxuICAgIE5hdkVsLmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScpXHJcbiAgfSxcclxuXHJcbiAgcHVzaFE6IChjdXJyZW50RWwsIGFpbVFFbCkgPT4ge1xyXG4gICAgY3VycmVudEVsLmNsYXNzTGlzdC50b2dnbGUoJ3Nob3cnKVxyXG4gICAgYWltUUVsLmNsYXNzTGlzdC50b2dnbGUoJ3Nob3cnKVxyXG4gIH0sXHJcblxyXG4gIGFpbU5hdklkRnVuY3Rpb246IChjdXJyZW50SWQsIGRpcmVjdGlvbikgPT4ge1xyXG4gICAgbGV0IGRpciA9IGN1cnJlbnRJZFxyXG4gICAgc3dpdGNoICh0cnVlKSB7XHJcbiAgICAgIGNhc2UgZGlyZWN0aW9uID09PSAnbmV4dCc6XHJcbiAgICAgICAgcmV0dXJuIGRpciArPSAxXHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgY2FzZSBkaXJlY3Rpb24gPT09ICdiYWNrJzpcclxuICAgICAgICByZXR1cm4gZGlyIC09IDFcclxuICAgICAgICBicmVha1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGFpbVFFbEZ1bmN0aW9uOiAoY3VycmVudCwgZGlyZWN0aW9uKSA9PiB7XHJcbiAgICBzd2l0Y2ggKHRydWUpIHtcclxuICAgICAgY2FzZSBkaXJlY3Rpb24gPT09ICduZXh0JzpcclxuICAgICAgICByZXR1cm4gY3VycmVudC5RTmV4dEVsXHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgY2FzZSBkaXJlY3Rpb24gPT09ICdiYWNrJzpcclxuICAgICAgICByZXR1cm4gY3VycmVudC5RUHJldkVsXHJcbiAgICAgICAgYnJlYWtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBjdXJyZW50UTogKCkgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaWQ6ICQoJy5hY3RpdmUnKVswXS5pbm5lclRleHQgLSAxLFxyXG4gICAgICBRRWw6ICQoJy5xdWVzdGlvbi5zaG93JylbMF0sXHJcbiAgICAgIG5hdkxlbmd0aDogJCgnW2RhdGEtcGFnaW5hdGlvbl0nKS5sZW5ndGgsXHJcbiAgICAgIFFQcmV2RWw6ICQoJy5xdWVzdGlvbi5zaG93JylbMF0ucHJldmlvdXNFbGVtZW50U2libGluZyxcclxuICAgICAgUU5leHRFbDogJCgnLnF1ZXN0aW9uLnNob3cnKVswXS5uZXh0RWxlbWVudFNpYmxpbmcsXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcblxyXG4gIHZpZXdNb2RlbDogKCkgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaWQ6ICt3aW5kb3cubG9jYXRpb24uaHJlZi5zcGxpdCgnLycpLnBvcCgpLFxyXG4gICAgICB0ZXN0X25hbWU6ICQoJyN0ZXN0X25hbWUnKS50ZXh0KCksXHJcbiAgICAgIGVuYWJsZTogJCgnI2VuYWJsZScpWzBdLFxyXG4gICAgICBwYXJlbnQ6ICQoJ3NlbGVjdCcpLnNlbGVjdGVkSW5kZXhWYWx1ZSgpLFxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGlkOiAoaWQpID0+IHtcclxuICAgIHJldHVybiBpZCA/PyAkKCcudGVzdC1uYW1lJylbMF0uZGF0YXNldC50ZXN0aWRcclxuICB9LFxyXG4gIGNoaWxkcmVuOiAoKSA9PiB7XHJcbiAgICBsZXQgY2hpbGRyZW5MZW5naHQgPSAkKCcuY2hpbGRyZW4nKS5sZW5ndGhcclxuICAgIGlmIChjaGlsZHJlbkxlbmdodClcclxuICAgICAgcmV0dXJuIGNoaWxkcmVuTGVuZ2h0XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9LFxyXG5cclxuICBwYXRoX2NyZWF0ZTogYXN5bmMgKCkgPT4ge1xyXG4gICAgbGV0IHRlc3RfcGF0aCA9IF90ZXN0LnNlcnZlck1vZGVsKClcclxuICAgIHRlc3RfcGF0aC5pZCA9IDBcclxuICAgIHRlc3RfcGF0aC5pc1Rlc3QgPSAwXHJcbiAgICBsZXQgdXJsID0gYC90ZXN0L2NyZWF0ZWBcclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KHVybCwgdGVzdF9wYXRoKVxyXG4gICAgcmVzID0gYXdhaXQgSlNPTi5wYXJzZShyZXMpXHJcbiAgICBpZiAocmVzKSB7XHJcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYC9hZG1pbnNjL3Rlc3QvZWRpdC8ke3Jlcy5pZCAtIDF9YFxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIG5hbWU6ICgpID0+IHtcclxuICAgIHJldHVybiAkKCcudGVzdC1uYW1lJylbMF0uaW5uZXJUZXh0XHJcbiAgfSxcclxuXHJcbiAgY3JlYXRlOiBhc3luYyAoKSA9PiB7XHJcbiAgICBsZXQgdGVzdCA9IF90ZXN0LnNlcnZlck1vZGVsKClcclxuICAgIHRlc3QuaWQgPSAwXHJcbiAgICB0ZXN0LmlzVGVzdCA9IDFcclxuICAgIGxldCB1cmwgPSBgL3Rlc3QvdXBkYXRlT3JDcmVhdGVgXHJcbiAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCh1cmwsIHRlc3QpXHJcbiAgICByZXMgPSBhd2FpdCBKU09OLnBhcnNlKHJlcylcclxuICAgIGRlYnVnZ2VyXHJcbiAgICBpZiAocmVzKSB7XHJcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYC9hZG1pbnNjL3Rlc3QvZWRpdC8ke3Jlcy5pZH1gXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgc2VsZWN0ZWRWYWx1ZUN1c3RvbVNlbGVjdChjbGFzc05hbWUpIHtcclxuICAgIGxldCBzZWxlY3QgPSAkKGBbZGF0YS1maWVsZD0ke2NsYXNzTmFtZX1dYClbMF1cclxuICAgIGxldCBzZWxlY3RlZCA9IFsuLi5zZWxlY3Qub3B0aW9uc10uZmlsdGVyKChvcHQpPT5vcHQuc2VsZWN0ZWQpXHJcbiAgICBpZiAoc2VsZWN0ZWQpIHtcclxuICAgICAgcmV0dXJuICtzZWxlY3RlZFswXS52YWx1ZVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHNlcnZlck1vZGVsOiAoKSA9PiB7XHJcblxyXG4gICAgbGV0IG1vZGVsID0ge1xyXG4gICAgICBpZDogK3dpbmRvdy5sb2NhdGlvbi5ocmVmLnNwbGl0KCcvJykucG9wKCksXHJcbiAgICAgIHRlc3RfbmFtZTogJCgnI3Rlc3RfbmFtZScpWzBdLnZhbHVlLFxyXG4gICAgICBpc1Rlc3Q6ICskKCdbaXNUZXN0XScpWzBdLmdldEF0dHJpYnV0ZSgnaXNUZXN0JyksXHJcbiAgICAgIC8vIGVuYWJsZTogX3Rlc3Quc2VsZWN0ZWRWYWx1ZUN1c3RvbVNlbGVjdCgnZW5hYmxlJyksXHJcbiAgICAgIC8vIHBhcmVudDogX3Rlc3Quc2VsZWN0ZWRWYWx1ZUN1c3RvbVNlbGVjdCgncGFyZW50JyksXHJcbiAgICB9XHJcbiAgICAvLyBkZWJ1Z2dlclxyXG4gICAgbGV0IGZpZWxkcyA9ICQoJy5jdXN0b20tc2VsZWN0Jyk7XHJcbiAgICBbXS5mb3JFYWNoLmNhbGwoZmllbGRzLGZ1bmN0aW9uIChmaWVsZCl7XHJcbiAgICAgIG1vZGVsW2ZpZWxkLmRhdGFzZXRbJ2ZpZWxkJ11dPWZpZWxkLmRhdGFzZXRbJ2lkJ11cclxuICAgIH0pXHJcbiAgICByZXR1cm4gbW9kZWxcclxuICB9LFxyXG5cclxuICB1cGRhdGU6IGFzeW5jICgpID0+IHtcclxuICAgIGxldCBtb2RlbCA9IF90ZXN0LnNlcnZlck1vZGVsKClcclxuICAgIGxldCB1cmwgPSBgL2FkbWluc2MvdGVzdC91cGRhdGUvJHttb2RlbC5pZH1gXHJcbiAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCh1cmwsIG1vZGVsKVxyXG4gICAgcmVzID0gYXdhaXQgSlNPTi5wYXJzZShyZXMpXHJcbiAgICBpZiAocmVzKSB7XHJcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYC9hZG1pbnNjL3Rlc3QvZWRpdC8ke21vZGVsLmlkfWBcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBkZWxldGU6IGFzeW5jIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBpZiAoX3Rlc3QuY2hpbGRyZW4oKSkge1xyXG4gICAgICBwb3B1cC5zaG93KCfQodC90LDRh9Cw0LvQsCDRg9C00LDQu9C40YLQtSDQstGB0LUg0YLQtdGB0YLRiyDQuNC3INC/0LDQv9C60LgnKVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuXHJcbiAgICBsZXQgaWQgPSBfdGVzdC5pZCgpXHJcbiAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCgnL2FkbWluc2MvdGVzdC9kZWxldGUnLCB7aWR9KVxyXG4gICAgcmVzID0gYXdhaXQgSlNPTi5wYXJzZShyZXMpXHJcbiAgICBpZiAocmVzLm5vdEFkbWluKSB7XHJcbiAgICAgIHBvcHVwLnNob3coJ9CS0LjQtNC40LzQvtGB0YLRjCDRgtC10YHRgtCwINGB0LrRgNGL0YLQsC4g0KfRgtC+0LHRiyDRg9C00LDQu9C40YLRjCDQv9C+0LvQvdC+0YHRgtGM0Y4gLSDQvtCx0YDQsNGC0LjRgtC10YHRjCDQuiDQk9CUJylcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uID0gJy9hZG1pbnNjL3Rlc3QvZWRpdC80MDAnXHJcbiAgICAgIH0sIDQwMDApXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3aW5kb3cubG9jYXRpb24gPSAnL2FkbWluc2MvdGVzdC9lZGl0LzQwMCdcclxuICAgIH1cclxuXHJcbiAgfSxcclxuXHJcbn0iLCJpbXBvcnQgJy4vdGVzdC1lZGl0LnNjc3MnXHJcbmltcG9ydCAnLi4vY29tcG9uZW50cy9mb290ZXIvZm9vdGVyLnNjc3MnXHJcblxyXG5pbXBvcnQgJy4vdGVzdC1lZGl0LW1lbnUuc2NzcydcclxuaW1wb3J0ICcuLi9jb21wb25lbnRzL3BvcHVwLnNjc3MnXHJcblxyXG5pbXBvcnQgJy4vdGVzdC11cGRhdGUnXHJcblxyXG5pbXBvcnQgJy4uL0FkbWluL2FkbWluJ1xyXG5cclxuaW1wb3J0IHskfSBmcm9tICcuLi9jb21tb24nXHJcblxyXG5pbXBvcnQge19xdWVzdGlvbn0gZnJvbSBcIi4vbW9kZWwvcXVlc3Rpb25cIlxyXG5pbXBvcnQgc29ydGFibGUgZnJvbSBcIi4uL2NvbXBvbmVudHMvc29ydGFibGVcIlxyXG5pbXBvcnQgV0RTU2VsZWN0IGZyb20gXCIuLi9jb21wb25lbnRzL3NlbGVjdC9XRFNTZWxlY3RcIlxyXG5pbXBvcnQgYWNjb3JkaW9uU2hvdyBmcm9tIFwiLi4vY29tcG9uZW50cy9hY2NvcmRpb24tc2hvd1wiO1xyXG5cclxuaW1wb3J0IHtfdGVzdH0gZnJvbSBcIi4vbW9kZWwvdGVzdFwiO1xyXG5pbXBvcnQge19hbnN3ZXJ9IGZyb20gXCIuL21vZGVsL2Fuc3dlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGVzdEVkaXQoKSB7XHJcblxyXG4gIGxldCB0ZXN0RWRpdCA9ICQoJy50ZXN0LWVkaXQtd3JhcHBlcicpWzBdXHJcblxyXG4gIGlmICh0ZXN0RWRpdCkge1xyXG5cclxuICAgIHNvcnRhYmxlKCcudGVzdC1lZGl0LXdyYXBwZXIucXVlc3Rpb25zJylcclxuXHJcbiAgICBjdXN0b21TZWxlY3QoKVxyXG5cclxuICAgICQodGVzdEVkaXQpLm9uKCdjaGFuZ2UnLCBoYW5kbGVLZXl1cClcclxuICAgICQodGVzdEVkaXQpLm9uKCdjbGljaycsIGhhbmRsZUNsaWNrKVxyXG5cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGN1c3RvbVNlbGVjdCgpIHtcclxuICBsZXQgY3VzdG9tU2VsZWN0cyA9ICQoJ1tjdXN0b20tc2VsZWN0XScpO1xyXG4gIFtdLmZvckVhY2guY2FsbChjdXN0b21TZWxlY3RzLCBmdW5jdGlvbiAoc2VsZWN0KSB7XHJcbiAgICBuZXcgV0RTU2VsZWN0KHNlbGVjdClcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlQ2xpY2soe3RhcmdldH0pIHtcclxuXHJcbiAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3Rlc3QtcGF0aF9fdXBkYXRlJykpIHtcclxuICAgIF90ZXN0LnVwZGF0ZSgpXHJcbiAgfSBlbHNlIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCd0ZXN0X191cGRhdGUnKSkge1xyXG4gICAgX3Rlc3QudXBkYXRlKClcclxuICB9IGVsc2UgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3Rlc3RfX3NhdmUnKSkge1xyXG4gICAgX3Rlc3QudXBkYXRlKClcclxuICB9IGVsc2UgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3Rlc3RfX2RlbGV0ZScpKSB7XHJcbiAgICBfdGVzdC5kZWxldGUoKVxyXG4gIH0gZWxzZSBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygndGVzdC1wYXRoX19jcmVhdGUnKSkge1xyXG4gICAgX3Rlc3QucGF0aF9jcmVhdGUoKVxyXG4gIH0gZWxzZSBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygndGVzdF9fY3JlYXRlJykpIHtcclxuICAgIF90ZXN0LmNyZWF0ZSgpXHJcbiAgfSBlbHNlIGlmICghIXRhcmdldC5jbG9zZXN0KCcucXVlc3Rpb25fX3NhdmUnKSkge1xyXG4gICAgX3F1ZXN0aW9uLnNhdmUodGFyZ2V0KVxyXG4gIH0gZWxzZSBpZiAoISF0YXJnZXQuY2xvc2VzdCgnLnF1ZXN0aW9uX19zaG93LWFuc3dlcnMnKSkge1xyXG4gICAgX3F1ZXN0aW9uLnNob3dBbnN3ZXJzKHRhcmdldClcclxuICB9IGVsc2UgaWYgKCEhdGFyZ2V0LmNsb3Nlc3QoJy5xdWVzdGlvbl9fZGVsZXRlJykpIHtcclxuICAgIF9xdWVzdGlvbi5kZWxldGUodGFyZ2V0KVxyXG4gIH0gZWxzZSBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygncXVlc3Rpb25fX2NyZWF0ZS1idXR0b24nKSkge1xyXG4gICAgX3F1ZXN0aW9uLmNyZWF0ZSgpXHJcbiAgfSBlbHNlIGlmICghIXRhcmdldC5jbG9zZXN0KCcuZGVsZXRlJykpIHtcclxuICAgIF9hbnN3ZXIuZGVsKHRhcmdldClcclxuICB9IGVsc2UgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2Fuc3dlcl9fY3JlYXRlLWJ1dHRvbicpKSB7XHJcbiAgICBfYW5zd2VyLmNyZWF0ZSh0YXJnZXQpXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVLZXl1cCh7dGFyZ2V0fSkge1xyXG4gIGlmICghIXRhcmdldC5jbG9zZXN0KCcucXVlc3Rpb24tZWRpdF9fcGFyZW50LXNlbGVjdCcpKSB7XHJcbiAgICBfcXVlc3Rpb24uY2hhbmdlUGFyZW50KHRhcmdldClcclxuICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbiIsImltcG9ydCAnLi90ZXN0LXBhZ2luYXRpb24uc2NzcydcclxuaW1wb3J0IHskfSBmcm9tIFwiLi4vLi4vY29tbW9uXCI7XHJcblxyXG5sZXQgcGFnaW5hdGlvbiA9ICQoJy5wYWdpbmF0aW9uJylbMF1cclxuXHJcbmlmIChwYWdpbmF0aW9uKSB7XHJcbiAgJChwYWdpbmF0aW9uKS5vbignY2xpY2snLCBoYW5kbGVDbGljaylcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUNsaWNrKHt0YXJnZXR9KSB7XHJcbiAgLy8gZGVidWdnZXJcclxuICBpZiAoIXRhcmdldC5kYXRhc2V0LnBhZ2luYXRpb24pIHJldHVybjtcclxuXHJcbi8vLyBnZXQgY2xpY2tlZCBidXR0b24gUmV0dXJuIGlmIGNsaWNrZWQgaXMgYWN0aXZlXHJcbiAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpKSByZXR1cm5cclxuXHJcbiAgbGV0IGFjdGl2ZV9idG4gPSAkKCcucGFnaW5hdGlvbiAuYWN0aXZlJylbMF1cclxuLy8vLyBjaGFuZ2UgYWN0aXZlIGJ1dHRvblxyXG4gIGFjdGl2ZV9idG4uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJylcclxuICB0YXJnZXQuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJylcclxuXHJcbiAgbGV0IGlkX3RvX2hpZGUgPSBhY3RpdmVfYnRuLmRhdGFzZXRbJ3BhZ2luYXRpb24nXVxyXG4gICQoYC5xdWVzdGlvbltkYXRhLWlkPVwiJHtpZF90b19oaWRlfVwiXWApLnJlbW92ZUNsYXNzKCdzaG93JylcclxuXHJcbiAgbGV0IGlkX3RvX3Nob3cgPSB0YXJnZXQuZGF0YXNldFsncGFnaW5hdGlvbiddXHJcbiAgJChgLnF1ZXN0aW9uW2RhdGEtaWQ9XCIke2lkX3RvX3Nob3d9XCJdYCkuYWRkQ2xhc3MoJ3Nob3cnKVxyXG59XHJcblxyXG5mdW5jdGlvbiBuYXZJbml0KCkge1xyXG4gIGxldCBuYXZfYnV0dG9ucyA9ICQoJ1tkYXRhLXBhZ2luYXRpb25dJylcclxuICBpZiAoIW5hdl9idXR0b25zWzBdKSByZXR1cm4gZmFsc2VcclxuICBBcnJheS5mcm9tKG5hdl9idXR0b25zKS5tYXAoKG5hdikgPT4ge1xyXG4gICAgbmF2LmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpXHJcbiAgfSlcclxuICBuYXZfYnV0dG9uc1swXS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKVxyXG59XHJcblxyXG5leHBvcnQge25hdkluaXR9XHJcblxyXG5cclxuIiwiaW1wb3J0ICcuL2RvLnNjc3MnXHJcblxyXG5pbXBvcnQge190ZXN0fSBmcm9tIFwiLi9tb2RlbC90ZXN0XCJcclxuaW1wb3J0IHtwb3N0LCAkfSBmcm9tICcuLi9jb21tb24nXHJcbmltcG9ydCB7bmF2SW5pdH0gZnJvbSAnLi4vY29tcG9uZW50cy90ZXN0LXBhZ2luYXRpb24vdGVzdC1wYWdpbmF0aW9uJ1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRlc3REbygpIHtcclxuXHJcbi8v0KHQutGA0YvRgtGMINCy0YHQtSDQstC+0L/RgNC+0YHRi1xyXG4gICQoJy5xdWVzdGlvbicpLnJlbW92ZUNsYXNzKFwic2hvd1wiKVxyXG5cclxuLy/Qn9C+0LrQsNC30YLRjCDQv9C10YDQstGL0Lkg0LLQvtC/0YDQvtGBXHJcbiAgJCgnLnF1ZXN0aW9uOmZpcnN0LWNoaWxkJykuYWRkQ2xhc3MoXCJzaG93XCIpXHJcbi8vINCd0LDQttCw0YLRjCDQv9C10YDQstGD0Y7QutC90L7Qv9C60YMgbmF2aWdhdGlvblxyXG4gIG5hdkluaXQoKVxyXG4gICQoJy50ZXN0LWRvIFt0eXBlPVwiY2hlY2tib3hcIl0nKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgbGV0IGEgPSBlLnRhcmdldC5sYWJlbHNbMF1cclxuICAgIGEuY2xhc3NMaXN0LnRvZ2dsZSgncHVzaGVkJylcclxuICB9KVxyXG5cclxuXHJcbiAgJCgnI3ByZXYnKS5vbignY2xpY2snLCBfdGVzdC5wcmV2USlcclxuICAkKCcjbmV4dCcpLm9uKCdjbGljaycsIF90ZXN0Lm5leHRRKVxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vLy8vLy8vLy8vICBSRVNVTFRTICBURVNUICDQl9Cw0LrQvtC90YfQuNGC0Ywg0YLQtdGB0YIvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLy8g0LXRgdC70Lgg0Y3RgtC+INGA0LXQt9GD0LvRjNGC0LDRgiDRgtC10YHRgtCwLCDQtNC10LDQutGC0LjQstC40YDRg9C60Lwg0LrQvdC+0L/QutGDINCX0LDQutC+0L3Rh9C40YLRjCDRgtC10YHRglxyXG4gIGxldCBidXR0b24gPSAkKCcudGVzdC1kb19fZmluaXNoLWJ0bicpWzBdXHJcbiAgaWYgKGJ1dHRvbikge1xyXG4gICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS5tYXRjaCgnXi90ZXN0L3Jlc3VsdC8uPycpKSB7XHJcbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdpbmFjdGl2ZScpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAkKCcudGVzdC1kb19fZmluaXNoLWJ0bicpLm9uKCdjbGljaycsIGFzeW5jIGZ1bmN0aW9uIChlKSB7XHJcblxyXG4gICAgbGV0IGJ1dHRvbiA9IGUudGFyZ2V0O1xyXG4gICAgaWYgKGJ1dHRvbi5jbGFzc0xpc3QuY29udGFpbnMoJ2luYWN0aXZlJykpIHJldHVybiBmYWxzZVxyXG4gICAgaWYgKGJ1dHRvbi5pZCAhPT0gJ2J0bm4nKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgnaW5hY3RpdmUnKVxyXG5cclxuICAgIGlmIChidXR0b24udGV4dCA9PSBcItCf0KDQntCZ0KLQmCDQotCV0KHQoiDQl9CQ0J3QntCS0J5cIikge1xyXG4gICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IGNvcnJBbnN3ZXJzID0gYXdhaXQgcG9zdCgnL3Rlc3QvZ2V0Q29ycmVjdEFuc3dlcnMnLCB7fSlcclxuICAgIGxldCBlcnJvckNudCA9IGNvbG9yVmlldyhjb3JyQW5zd2VycylcclxuXHJcbiAgICBsZXQgZGF0YSA9IG9ialRvU2VydmVyKGVycm9yQ250KVxyXG4gICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9hZG1pbnNjL3Rlc3RyZXN1bHQvY2FjaGVQYWdlU2VuZEVtYWlsJywgey4uLmRhdGF9KVxyXG4gICAgaWYgKHJlcz09PSdvaycpIHtcclxuICAgICAgJChcIiNidG5uXCIpWzBdLmhyZWYgPSBsb2NhdGlvbi5ocmVmXHJcbiAgICAgICQoXCIjYnRublwiKVswXS50ZXh0ID0gXCLQn9Cg0J7QmdCi0Jgg0KLQldCh0KIg0JfQkNCd0J7QktCeXCJcclxuICAgIH1cclxuICB9KVxyXG4gIGZ1bmN0aW9uIHJlcGxhY2VOYnNwcyhzdHIpIHtcclxuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoJyZuYnNwOz8nLCBcImdcIik7XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UocmUsIFwiIFwiKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcmVwbGFjZU5zKHN0cikge1xyXG4gICAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnXFxcXG4/JywgXCJnXCIpO1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlLCBcIlwiKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcmVwbGFjZVRzKHN0cikge1xyXG4gICAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnXFxcXHQ/JywgXCJnXCIpO1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlLCBcIlwiKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gY2FjaGVQYWdlKHJpZ2h0QW5zd2Vycykge1xyXG5cclxuICAgIGxldCB0ID0gJCgnLnRlc3QtZG8nKVswXVxyXG5cclxuICAgIHQgPSB0Lm91dGVySFRNTFxyXG4gICAgdCA9IHJlcGxhY2VOYnNwcyh0KVxyXG4gICAgdCA9IHJlcGxhY2VOcyh0KVxyXG4gICAgdCA9IHJlcGxhY2VUcyh0KVxyXG4gICAgcmV0dXJuIHRcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG9ialRvU2VydmVyKGVycm9yQ250KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBxdWVzdGlvbkNudDogJCgnLnF1ZXN0aW9uJykubGVuZ3RoLFxyXG4gICAgICBlcnJvckNudDogZXJyb3JDbnQsXHJcbiAgICAgIGh0bWw6IGNhY2hlUGFnZSgpLFxyXG4gICAgICB0ZXN0aWQ6ICQoJ1tkYXRhLXRlc3QtaWRdJylbMF0uZGF0YXNldC50ZXN0SWQsXHJcbiAgICAgIHRlc3RuYW1lOiAkKCcudGVzdC1uYW1lJylbMF0uaW5uZXJUZXh0LFxyXG4gICAgICB1c2VyOiAkKCcudXNlci1tZW51X19maW8nKVswXS5pbm5lclRleHQsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gY29sb3JWaWV3KGNvcnJlY3RBbnN3ZXJzKSB7XHJcbiAgICBsZXQgcSA9ICQoJy5xdWVzdGlvbicpO1xyXG4gICAgW10ubWFwLmNhbGwocSwgZnVuY3Rpb24gKHF1ZXN0aW9uKSB7XHJcbiAgICAgIGxldCBhbnN3ZXJzID0gcXVlc3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnLmEnKVxyXG4gICAgICBsZXQgZXJyb3JzID0gW107XHJcbiAgICAgIFtdLm1hcC5jYWxsKGFuc3dlcnMsIGZ1bmN0aW9uIChhbnN3ZXIpIHtcclxuICAgICAgICBsZXQgaW5wdXQgPSAkKGFuc3dlcikuZmluZCgnaW5wdXQnKVxyXG4gICAgICAgIGxldCBpZCA9IGFuc3dlci5kYXRhc2V0LmlkXHJcbiAgICAgICAgY2hlY2tDb3JyZWN0QW5zd2VycyhlcnJvcnMsIGlkLCBjb3JyZWN0QW5zd2VycywgaW5wdXQsIGFuc3dlcilcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGxldCBpZCA9IHF1ZXN0aW9uLmRhdGFzZXRbJ2lkJ10gLy8gaWQgcXVlc3Rpb25cclxuICAgICAgbGV0IHBhZ2luSXRlbSA9ICQoYC5wYWdpbmF0aW9uIFtkYXRhLXBhZ2luYXRpb249JyR7K2lkfSddYClbMF1cclxuICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcclxuICAgICAgICAkKHBhZ2luSXRlbSkuYWRkQ2xhc3MoJ3JlZFNoYWRvdycpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgJChwYWdpbkl0ZW0pLmFkZENsYXNzKCdncmVlblNoYWRvdycpXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgICByZXR1cm4gJCgnLnJlZFNoYWRvdycpLmxlbmd0aFxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2hlY2tDb3JyZWN0QW5zd2VycyhlcnJvcnMsIGlkLCBjb3JyZWN0QW5zd2VycywgaW5wdXQsIGFuc3dlcikge1xyXG4gICAgbGV0IGNvcnJlY3RBbnNlciA9IGNvcnJlY3RBbnN3ZXJzLmluZGV4T2YoaWQpICE9PSAtMVxyXG5cclxuICAgIGlmIChpbnB1dC5jaGVja2VkICYmIGNvcnJlY3RBbnNlcikgey8vIGNoZWNrYm94INC90LDQttCw0YIuINCwINCyIGNvcnJlY3QgYW5zd2VyINC90LXRgtGDLiDQsiBjb3JyZWN0X2Fuc3dlcnMg0LXRgdGC0YwsINC10LPQviDQstGB0LXQs9C00LAg0L/QvtC00YHQstC10YfQuNCy0LDQtdC8INC30LXQu9C10L3Ri9C8XHJcbiAgICAgIGFuc3dlci5jbGFzc0xpc3QuYWRkKCdkb25lJyk7IC8vZ3JlZW4gY2hlY2sg0LfQtdC70LXQvdGL0Lkg0LfQvdCw0YfQtdC6XHJcbiAgICB9IGVsc2UgaWYgKGlucHV0LmNoZWNrZWQgJiYgIWNvcnJlY3RBbnNlcikgey8vIGNoZWNrYm94INC90LDQttCw0YIs0Lgg0LXRgdGC0Ywg0LIgY29ycmVjdCBhbnN3ZXIuINCyIGNvcnJlY3RfYW5zd2VycyDQvdC10YIsINC60L3QvtC/0LrQsCDQvdC1INC90LDQttCw0YLQsFxyXG4gICAgICBlcnJvcnMucHVzaCh0cnVlKVxyXG4gICAgfSBlbHNlIGlmICghaW5wdXQuY2hlY2tlZCAmJiBjb3JyZWN0QW5zZXIpIHsvLyDQutC90L7Qv9C60LAg0L3QtSDQvdCw0LbQsNGC0LAsINCyIGNvcnJlY3RfYW5zd2VycyDQtdGB0YLRjFxyXG4gICAgICBhbnN3ZXIuY2xhc3NMaXN0LmFkZCgnZG9uZScpOyAvL2dyZWVuIGNoZWNrINC30LXQu9C10L3Ri9C5INC30L3QsNGH0LXQulxyXG4gICAgICBlcnJvcnMucHVzaCh0cnVlKVxyXG4gICAgfSBlbHNlIGlmICghaW5wdXQuY2hlY2tlZCAmJiAhY29ycmVjdEFuc2VyKSB7Ly8g0LrQvdC+0L/QutCwINC90LUg0L3QsNC20LDRgtCwLCDQsiBjb3JyZWN0X2Fuc3dlcnMg0L3QtdGCXHJcbiAgICB9XHJcbiAgfVxyXG5cclxufVxyXG5cclxuIiwiaW1wb3J0ICcuL3VzZXJzLnNjc3MnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5pdCgpe1xyXG5cclxufSIsIi8vIGltcG9ydCByaWdodHMgZnJvbSAnLi4vUmlnaHRzL3JpZ2h0cydcclxuaW1wb3J0IHVzZXJzIGZyb20gJy4vdXNlcnMnXHJcbi8vIGltcG9ydCByaWdodHMgZnJvbSBcIi4vcmlnaHRzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR0aW5ncygpe1xyXG5cclxuICAvLyByaWdodHMoKVxyXG4gIHVzZXJzKClcclxuXHJcbn0iLCJpbXBvcnQgJy4vbGlzdC5zY3NzJztcclxuaW1wb3J0IHskLCBwb3N0LCBwb3B1cH0gZnJvbSAnLi4vLi4vY29tbW9uJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxpc3QoKSB7XHJcbiAgLy8gZGVidWdnZXI7XHJcblxyXG4gIGNvbnN0IHRhYmxlcyA9ICQoJy5jdXN0b20tbGlzdF9fd3JhcHBlcicpXHJcbiAgaWYgKHRhYmxlcykge1xyXG4gICAgW10uZm9yRWFjaC5jYWxsKHRhYmxlcywgZnVuY3Rpb24gKHRhYmxlKSB7XHJcblxyXG4gICAgICBjb25zdCBjb250ZW50ZWRpdGFibGUgPSAkKCdbY29udGVudGVkaXRhYmxlXScpXHJcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB0YWJsZS5xdWVyeVNlbGVjdG9yQWxsKCcuaGVhZCcpXHJcbiAgICAgIGNvbnN0IHNvcnRhYmxlcyA9IHRhYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNvcnRdJylcclxuICAgICAgY29uc3QgaW5wdXRzID0gJCh0YWJsZSkuZmluZEFsbCgnLmhlYWQgaW5wdXQnKVxyXG4gICAgICBjb25zdCBpZHMgPSAkKHRhYmxlKVswXS5xdWVyeVNlbGVjdG9yQWxsKCcuaWQ6bm90KC5oZWFkJylcclxuICAgICAgY29uc3QgbW9kZWxOYW1lID0gdGFibGUuZGF0YXNldFsnbW9kZWwnXVxyXG4gICAgICBjb25zdCByb3dzID0gW11cclxuXHJcbiAgICAgICQodGFibGUpLm9uKCdjbGljaycsIGhhbmRsZUNsaWNrLmJpbmQodGhpcykpO1xyXG4gICAgICAkKHRhYmxlKS5vbigna2V5dXAnLCBoYW5kbGVLZXlVcC5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgIC8vLyBERUJPVU5DRVxyXG4gICAgICBjb25zdCBkZWJvdW5jZSA9IChmbiwgdGltZSA9IDcwMCkgPT4ge1xyXG4gICAgICAgIGxldCB0aW1lb3V0O1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGwgPSAoKSA9PiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG4gICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb25DYWxsLCB0aW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGRlYm91bmNlZElucHV0ID0gZGVib3VuY2UoaGFuZGxlSW5wdXQpXHJcblxyXG5cclxuICAgICAgZnVuY3Rpb24gaGFuZGxlS2V5VXAoe3RhcmdldH0pIHtcclxuXHJcbiAgICAgICAgLy8gY29udGVudGVkaXRhYmxlXHJcbiAgICAgICAgaWYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpKSB7XHJcbiAgICAgICAgICBkZWJvdW5jZWRJbnB1dCh0YWJsZSwgY29udGVudGVkaXRhYmxlLCB0YXJnZXQpXHJcblxyXG4gICAgICAgICAgLy8vIHNlYXJjaFxyXG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LmNsb3Nlc3QoJy5oZWFkJykpIHtcclxuICAgICAgICAgIGxldCBoZWFkZXIgPSB0YXJnZXQuY2xvc2VzdCgnLmhlYWQnKVxyXG4gICAgICAgICAgbGV0IGluZGV4ID0gW10uZmluZEluZGV4LmNhbGwoaGVhZGVycywgKGVsLCBpLCBpbnB1dHMpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsID09PSBoZWFkZXJcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICBzZWFyY2goaW5kZXgsIHRhcmdldClcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKHt0YXJnZXR9KSB7XHJcblxyXG4gICAgICAgIC8vLyBjcmVhdGVcclxuICAgICAgICBpZiAodGFyZ2V0LmNsYXNzTmFtZSA9PT0gJ2FkZC1tb2RlbCcpIHtcclxuICAgICAgICAgIG1vZGVsQ3JlYXRlKG1vZGVsTmFtZSlcclxuXHJcbiAgICAgICAgICAvLy8gZGVsZXRlXHJcbiAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgIHRhcmdldC5jbGFzc05hbWUgPT09ICcuZGVsOm5vdCguaGVhZCknIHx8XHJcbiAgICAgICAgICB0YXJnZXQuY2xvc2VzdCgnLmRlbDpub3QoLmhlYWQpJykpIHtcclxuICAgICAgICAgIG1vZGVsRGVsKHRhcmdldC5jbG9zZXN0KCcuZGVsOm5vdCguaGVhZCknKSlcclxuXHJcbiAgICAgICAgICAvLy8gZWRpdFxyXG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LmNsYXNzTmFtZSA9PT0gJy5lZGl0Om5vdCguaGVhZCknIHx8XHJcbiAgICAgICAgICB0YXJnZXQuY2xvc2VzdCgnLmVkaXQ6bm90KC5oZWFkKScpKSB7XHJcbiAgICAgICAgICBsZXQgaWQgPSB0YXJnZXQuY2xvc2VzdCgnLmVkaXQ6bm90KC5oZWFkKScpLmRhdGFzZXRbJ2lkJ11cclxuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IGAvYWRtaW5zYy8ke21vZGVsTmFtZX0vZWRpdC8ke2lkfWA7XHJcblxyXG4gICAgICAgICAgLy8vIHNvcnRcclxuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2hlYWQnKSkge1xyXG4gICAgICAgICAgbGV0IGhlYWRlciA9IHRhcmdldC5jbG9zZXN0KCcuaGVhZCcpXHJcbiAgICAgICAgICBsZXQgaW5kZXggPSBbXS5maW5kSW5kZXguY2FsbChoZWFkZXJzLCAoZWwsIGksIGlucHV0cykgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gZWwgPT09IGhlYWRlclxyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIHNvcnRDb2x1bW4oaW5kZXgpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBERUxFVEVcclxuICAgICAgYXN5bmMgZnVuY3Rpb24gbW9kZWxEZWwoZWwpIHtcclxuICAgICAgICAvLyBkZWJ1Z2dlclxyXG4gICAgICAgIGlmICghY29uZmlybSgn0KPQtNCw0LvQuNGC0Ywg0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GPPycpKSByZXR1cm5cclxuICAgICAgICBsZXQgaWQgPSBlbC5kYXRhc2V0WydpZCddXHJcbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoYC9hZG1pbnNjLyR7bW9kZWxOYW1lfS9kZWxldGVgLCB7aWR9KVxyXG4gICAgICAgIHJlcyA9IEpTT04ucGFyc2UocmVzKVxyXG4gICAgICAgIGlmIChyZXMubXNnID09PSAnb2snKSB7XHJcbiAgICAgICAgICBkZWxWaWV3KGlkKVxyXG4gICAgICAgICAgcG9wdXAuc2hvdyhgaWQgOiAke2lkfSDRg9C00LDQu9C10L3QvmApXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBkZWxWaWV3KGlkKSB7XHJcbiAgICAgICAgbGV0IGFyciA9ICQoYFtkYXRhLWlkPScke2lkfSddYCk7XHJcbiAgICAgICAgW10uZm9yRWFjaC5jYWxsKGFyciwgZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICBlbC5yZW1vdmUoKVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICAvLyBDUkVBVEVcclxuICAgICAgYXN5bmMgZnVuY3Rpb24gbW9kZWxDcmVhdGUobW9kZWxOYW1lLCBlKSB7XHJcbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoYC9hZG1pbnNjLyR7bW9kZWxOYW1lfS9jcmVhdGVgLCB7fSlcclxuICAgICAgICByZXMgPSBKU09OLnBhcnNlKHJlcylcclxuICAgICAgICBpZiAocmVzLmlkKSB7XHJcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGAvYWRtaW5zYy8ke21vZGVsTmFtZX0vc2hvd2BcclxuICAgICAgICAgIC8vIG5ld1JvdyhyZXMuaWQgLSAxKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gbmV3Um93KGlkKSB7XHJcbiAgICAgICAgbGV0IFJvdyA9IFsuLi5yb3dzWzBdXTtcclxuICAgICAgICBbXS5mb3JFYWNoLmNhbGwoUm93LCBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgIGxldCBuZXdFbCA9IGVsLmNsb25lTm9kZSh0cnVlKVxyXG4gICAgICAgICAgbGV0IHRhYmxlQ29udGVudCA9ICQodGFibGUpLmZpbmQoJy5jdXN0b20tbGlzdCcpXHJcbiAgICAgICAgICB0YWJsZUNvbnRlbnQuYXBwZW5kQ2hpbGQobmV3RWwpXHJcbiAgICAgICAgICBpZiAoWydpZCddLmluY2x1ZGVzKG5ld0VsLmNsYXNzTmFtZSkpIHtcclxuICAgICAgICAgICAgbmV3RWwuaW5uZXJUZXh0ID0gaWRcclxuICAgICAgICAgIH0gZWxzZSBpZiAoIVsnZGVsJywgJ2VkaXQnLCAnc2F2ZSddLmluY2x1ZGVzKG5ld0VsLmNsYXNzTmFtZSkpIHtcclxuICAgICAgICAgICAgbmV3RWwuaW5uZXJUZXh0ID0gJydcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG5ld0VsLmRhdGFzZXRbJ2lkJ10gPSBpZFxyXG5cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8vIFNFQVJDSFxyXG4gICAgICBmdW5jdGlvbiBzaG93QWxsUm93cygpIHtcclxuICAgICAgICBbXS5mb3JFYWNoLmNhbGwocm93cywgKHJvdykgPT4ge1xyXG4gICAgICAgICAgW10uZm9yRWFjaC5jYWxsKHJvdywgZWwgPT4ge1xyXG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHNlYXJjaChpbmRleCwgaW5wdXQpIHtcclxuICAgICAgICBzaG93QWxsUm93cygpXHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpbnB1dC52YWx1ZTtcclxuXHJcbiAgICAgICAgW10uZm9yRWFjaC5jYWxsKGlucHV0cywgKGlucCkgPT4ge1xyXG4gICAgICAgICAgaWYgKGlucCAhPT0gaW5wdXQpIGlucC52YWx1ZSA9ICcnXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIFtdLmZvckVhY2guY2FsbChyb3dzLCBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgICBjb25zdCBzdHIgPSByb3dbaW5kZXhdLmlubmVyVGV4dFxyXG4gICAgICAgICAgY29uc3QgcmVnZXhwID0gbmV3IFJlZ0V4cChgJHt2YWx1ZX1gLCAnZ2knKVxyXG4gICAgICAgICAgaWYgKCFzdHIubWF0Y2gocmVnZXhwKSkge1xyXG4gICAgICAgICAgICBbXS5mb3JFYWNoLmNhbGwocm93LCBlbCA9PiB7XHJcbiAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gU09SVFxyXG4gICAgICBmdW5jdGlvbiBzb3J0Q29sdW1uKGluZGV4KSB7XHJcbiAgICAgICAgLy8g0J/QvtC70YPRh9C40YLRjCDRgtC10LrRg9GJ0LXQtSDQvdCw0L/RgNCw0LLQu9C10L3QuNC1XHJcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gZGlyZWN0aW9uc1tpbmRleF0gfHwgJ2FzYydcclxuXHJcbiAgICAgICAgLy8g0KTQsNC60YLQvtGAINC/0L4g0L3QsNC/0YDQsNCy0LvQtdC90LjRjlxyXG4gICAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSAoZGlyZWN0aW9uID09PSAnYXNjJykgPyAxIDogLTFcclxuXHJcbiAgICAgICAgY29uc3QgbmV3Um93cyA9IEFycmF5LmZyb20ocm93cylcclxuXHJcbiAgICAgICAgbmV3Um93cy5zb3J0KGZ1bmN0aW9uIChyb3dBLCByb3dCKSB7XHJcbiAgICAgICAgICBjb25zdCBjZWxsQSA9IHJvd0FbaW5kZXhdLmlubmVySFRNTFxyXG4gICAgICAgICAgY29uc3QgY2VsbEIgPSByb3dCW2luZGV4XS5pbm5lckhUTUxcclxuXHJcbiAgICAgICAgICBjb25zdCBhID0gdHJhbnNmb3JtKGluZGV4LCBjZWxsQSlcclxuICAgICAgICAgIGNvbnN0IGIgPSB0cmFuc2Zvcm0oaW5kZXgsIGNlbGxCKVxyXG5cclxuICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xyXG4gICAgICAgICAgICBjYXNlIGEgPiBiOlxyXG4gICAgICAgICAgICAgIHJldHVybiAxICogbXVsdGlwbGllclxyXG4gICAgICAgICAgICBjYXNlIGEgPCBiOlxyXG4gICAgICAgICAgICAgIHJldHVybiAtMSAqIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgY2FzZSBhID09PSBiOlxyXG4gICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyDQo9C00LDQu9C40YLRjCDRgdGC0LDRgNGL0LUg0YHRgtGA0L7QutC4XHJcbiAgICAgICAgW10uZm9yRWFjaC5jYWxsKHJvd3MsIGZ1bmN0aW9uIChub2RlTGlzdCkge1xyXG4gICAgICAgICAgW10uZm9yRWFjaC5jYWxsKG5vZGVMaXN0LCBlbCA9PiB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZSgpXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyDQn9C+0LzQtdC90Y/RgtGMINC90LDQv9GA0LDQstC70LXQvdC40LVcclxuICAgICAgICBkaXJlY3Rpb25zW2luZGV4XSA9IGRpcmVjdGlvbiA9PT0gJ2FzYycgPyAnZGVzYycgOiAnYXNjJ1xyXG5cclxuICAgICAgICAvLyDQlNC+0LHQsNCy0LjRgtGMINC90L7QstGD0Y4g0YHRgtGA0L7QutGDXHJcbiAgICAgICAgbmV3Um93cy5mb3JFYWNoKGZ1bmN0aW9uIChuZXdSb3cpIHtcclxuICAgICAgICAgIG5ld1JvdyA9IEFycmF5LmZyb20obmV3Um93KTtcclxuICAgICAgICAgIG5ld1Jvdy5yZXZlcnNlKCk7XHJcbiAgICAgICAgICBbXS5mb3JFYWNoLmNhbGwobmV3Um93LCBlbCA9PiB7XHJcbiAgICAgICAgICAgIGhlYWRlcnNbaGVhZGVycy5sZW5ndGggLSAxXS5hZnRlcihlbClcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLy8gZ2V0IHRhYmxlIHJvd3MgYXJyYXlcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgaWQgPSBpZHNbaV0uZGF0YXNldC5pZFxyXG4gICAgICAgIGxldCByb3cgPSAkKHRhYmxlKVswXS5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS1pZD0nJHtpZH0nXWApXHJcbiAgICAgICAgcm93cy5wdXNoKHJvdylcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8g0J3QsNC/0YDQsNCy0LvQtdC90LjQtSDRgdC+0YDRgtC40YDQvtCy0LrQuFxyXG4gICAgICBjb25zdCBkaXJlY3Rpb25zID0gQXJyYXkuZnJvbShzb3J0YWJsZXMpLm1hcChmdW5jdGlvbiAoc29ydGFibGUpIHtcclxuICAgICAgICByZXR1cm4gJydcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyDQn9GA0LXQvtCx0YDQsNC30L7QstCw0YLRjCDRgdC+0LTQtdGA0LbQuNC80L7QtSDQtNCw0L3QvdC+0Lkg0Y/Rh9C10LnQutC4INCyINC30LDQtNCw0L3QvdC+0Lwg0YHRgtC+0LvQsdGG0LVcclxuICAgICAgZnVuY3Rpb24gdHJhbnNmb3JtKGluZGV4LCBjb250ZW50KSB7XHJcbiAgICAgICAgLy8g0J/QvtC70YPRh9C40YLRjCDRgtC40L8g0LTQsNC90L3Ri9GFINGB0YLQvtC70LHRhtCwXHJcbiAgICAgICAgY29uc3QgdHlwZSA9IHNvcnRhYmxlc1tpbmRleF0uZ2V0QXR0cmlidXRlKCdkYXRhLXR5cGUnKVxyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoY29udGVudClcclxuICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gY29udGVudFxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vLyBJTlBVVFxyXG4gICAgICBmdW5jdGlvbiBoYW5kbGVJbnB1dCh0YWJsZSwgY29udGVudGVkaXRhYmxlLCB0YXJnZXQpIHtcclxuICAgICAgICBpZiAoIXRhcmdldC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpKSByZXR1cm4gZmFsc2VcclxuICAgICAgICBsZXQgbW9kZWwgPSBtYWtlU2VydmVyTW9kZWwodGFyZ2V0LCBtb2RlbE5hbWUpXHJcbiAgICAgICAgc2F2ZShtb2RlbClcclxuICAgICAgfVxyXG5cclxuICAgICAgYXN5bmMgZnVuY3Rpb24gc2F2ZShtb2RlbCkge1xyXG4gICAgICAgIGxldCB1cmwgPSBgL2FkbWluc2MvJHttb2RlbC5tb2RlbE5hbWV9L3VwZGF0ZWBcclxuICAgICAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCh1cmwsIG1vZGVsLm1vZGVsKVxyXG4gICAgICAgIHJlcyA9IEpTT04ucGFyc2UocmVzKVxyXG4gICAgICAgIGlmIChyZXMubXNnID09PSAnb2snKSB7XHJcbiAgICAgICAgICBwb3B1cC5zaG93KCfQodC+0YXRgNCw0L3QtdC90L4hJylcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIG1ha2VTZXJ2ZXJNb2RlbChlbCwgbW9kZWxOYW1lKSB7XHJcbiAgICAgICAgbGV0IGZpZWxkID0gZWwuZGF0YXNldFsnZmllbGQnXVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBtb2RlbDoge1xyXG4gICAgICAgICAgICB0b2tlbjogJCgpLFxyXG4gICAgICAgICAgICBpZDogZWwuZGF0YXNldC5pZCxcclxuICAgICAgICAgICAgW2ZpZWxkXTogZWwuaW5uZXJUZXh0XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgbW9kZWxOYW1lXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgfSlcclxuICB9XHJcbiAgLy8gfSlcclxufVxyXG4iLCJpbXBvcnQgJy4vcmlnaHRzLnNjc3MnO1xyXG5pbXBvcnQgeyQsIHBvcHVwLCBwb3N0fSBmcm9tICcuLi8uLi9jb21tb24nO1xyXG5pbXBvcnQgbGlzdCBmcm9tICdAY29tcG9uZW50cy9saXN0L2xpc3QnXHJcbi8vIGltcG9ydCBjb250ZW50ZWRpdGFibGUgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9jb250ZW50ZWRpdGFibGUnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByaWdodHMoKSB7XHJcbiAgLy8gZGVidWdnZXJcclxuICAvLyBjb250ZW50ZWRpdGFibGUoKVxyXG5cclxuXHJcblxyXG4gICQoJy5yaWdodHMtdGFibGUnKS5vbignY2xpY2snLCBoYW5kbGUpXHJcblxyXG4gIGZ1bmN0aW9uIGhhbmRsZSh7dGFyZ2V0fSkge1xyXG4gICAgaWYgKHRhcmdldC5jbG9zZXN0KCcuZGVsJykpIGRlbCh0YXJnZXQuY2xvc2VzdCgnLmRlbCcpKVxyXG4gICAgaWYgKHRhcmdldC5jbG9zZXN0KCcuc2F2ZScpKSBzYXZlKHRhcmdldC5jbG9zZXN0KCcuc2F2ZScpKVxyXG5cclxuICAgIGZ1bmN0aW9uIG1vZGVsKGVsKSB7XHJcbiAgICAgIGxldCBkYXRhSWQgPSBlbC5kYXRhc2V0LmlkID8/ICduZXcnXHJcbiAgICAgIGxldCBmaWVsZHMgPSAkKGBbZGF0YS1pZD0nJHtkYXRhSWR9J11gKVxyXG4gICAgICBsZXQgbW9kZWwgPSB7fVxyXG4gICAgICBtb2RlbC50b1NlcnYgPSB7fVxyXG4gICAgICBtb2RlbC5lbXB0eSA9IHt9XHJcblxyXG4gICAgICBmaWVsZHMubWFwKChmKSA9PiB7XHJcbiAgICAgICAgaWYgKGYuY2xhc3NMaXN0LmNvbnRhaW5zKCdpZCcpKSB7XHJcbiAgICAgICAgICBtb2RlbC5pZCA9IGZcclxuICAgICAgICAgIG1vZGVsLnRvU2Vydi5pZCA9IGYuZGF0YXNldC5pZFxyXG4gICAgICAgIH0gZWxzZSBpZiAoZi5jbGFzc0xpc3QuY29udGFpbnMoJ25hbWUnKSkge1xyXG4gICAgICAgICAgbW9kZWwubmFtZSA9IGZcclxuICAgICAgICAgIG1vZGVsLnRvU2Vydi5uYW1lID0gZi5pbm5lclRleHQudHJpbSgpXHJcbiAgICAgICAgfSBlbHNlIGlmIChmLmNsYXNzTGlzdC5jb250YWlucygnZGVzY3JpcHRpb24nKSkge1xyXG4gICAgICAgICAgbW9kZWwuZGVzY3JpcHRpb24gPSBmXHJcbiAgICAgICAgICBtb2RlbC50b1NlcnYuZGVzY3JpcHRpb24gPSBmLmlubmVyVGV4dC50cmltKClcclxuICAgICAgICB9IGVsc2UgaWYgKGYuY2xhc3NMaXN0LmNvbnRhaW5zKCdzYXZlLnN2ZycpKSB7XHJcbiAgICAgICAgICBtb2RlbC5zYXZlID0gZlxyXG4gICAgICAgIH0gZWxzZSBpZiAoZi5jbGFzc0xpc3QuY29udGFpbnMoJ2RlbCcpKSB7XHJcbiAgICAgICAgICBtb2RlbC5kZWwgPSBmXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgbW9kZWwuZW1wdHkuZGVsID0gbW9kZWwuaWQucHJldmlvdXNFbGVtZW50U2libGluZy5jbG9uZU5vZGUodHJ1ZSlcclxuICAgICAgbW9kZWwuZW1wdHkuc2F2ZSA9IG1vZGVsLmlkLnByZXZpb3VzRWxlbWVudFNpYmxpbmcucHJldmlvdXNFbGVtZW50U2libGluZy5jbG9uZU5vZGUodHJ1ZSlcclxuICAgICAgbW9kZWwuZW1wdHkuZGVzY3JpcHRpb24gPSBtb2RlbC5pZC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnByZXZpb3VzRWxlbWVudFNpYmxpbmcucHJldmlvdXNFbGVtZW50U2libGluZy5jbG9uZU5vZGUodHJ1ZSlcclxuICAgICAgbW9kZWwuZW1wdHkubmFtZSA9IG1vZGVsLmlkLnByZXZpb3VzRWxlbWVudFNpYmxpbmcucHJldmlvdXNFbGVtZW50U2libGluZy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuY2xvbmVOb2RlKHRydWUpXHJcbiAgICAgIG1vZGVsLmVtcHR5LmlkID0gbW9kZWwuaWQucHJldmlvdXNFbGVtZW50U2libGluZy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnByZXZpb3VzRWxlbWVudFNpYmxpbmcucHJldmlvdXNFbGVtZW50U2libGluZy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmNsb25lTm9kZSh0cnVlKVxyXG5cclxuICAgICAgcmV0dXJuIG1vZGVsXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGRlbChlbCkge1xyXG4gICAgICBsZXQgbW9kID0gbW9kZWwoZWwpXHJcbiAgICAgIGlmIChtb2QudG9TZXJ2LmlkID09PSAnbmV3JykgcmV0dXJuXHJcbiAgICAgIGlmIChjb25maXJtKFwi0KPQtNCw0LvQuNGC0Ywg0L/RgNCw0LLQvj9cIikpIHtcclxuICAgICAgICBkZWxEb20obW9kKVxyXG4gICAgICAgIGRlbFNlcnZlcihtb2QpXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBmdW5jdGlvbiBkZWxTZXJ2ZXIobW9kZWwpIHtcclxuICAgICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9yaWdodC9kZWxldGUnLCB7aWQ6IG1vZGVsLnRvU2Vydi5pZH0pXHJcbiAgICAgIHJlcyA9IGF3YWl0IEpTT04ucGFyc2UocmVzKVxyXG4gICAgICBpZiAocmVzLm1zZyA9PT0gJ29rJykge1xyXG4gICAgICAgIHBvcHVwLnNob3coJ9Cj0LTQsNC70LXQvdC+JylcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRlbERvbShtb2RlbCkge1xyXG4gICAgICBtb2RlbC5pZC5yZW1vdmUoKVxyXG4gICAgICBtb2RlbC5uYW1lLnJlbW92ZSgpXHJcbiAgICAgIG1vZGVsLmRlc2NyaXB0aW9uLnJlbW92ZSgpXHJcbiAgICAgIG1vZGVsLnNhdmUucmVtb3ZlKClcclxuICAgICAgbW9kZWwuZGVsLnJlbW92ZSgpXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHNhdmUoZWwpIHtcclxuICAgICAgbGV0IG1vZCA9IG1vZGVsKGVsKVxyXG4gICAgICBpZiAobW9kLnRvU2Vydi5pZCAhPT0gJ25ldycpIHtcclxuICAgICAgICB1cGRhdGUobW9kLnRvU2VydilcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoIW1vZC50b1NlcnYubmFtZSB8fCAhbW9kLnRvU2Vydi5kZXNjcmlwdGlvbikgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgY3JlYXRlKG1vZClcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZSh0b1NlcnYpIHtcclxuICAgICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9yaWdodC91cGRhdGUnLCB0b1NlcnYpXHJcbiAgICAgIGlmIChhd2FpdCBKU09OLnBhcnNlKHJlcykudXBkYXRlZCkge1xyXG4gICAgICAgIHBvcHVwLnNob3coJ9Ce0LHQvdC+0LLQu9C10L3QvicpXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjbGVhck1vZGVsKG1vZGVsKXtcclxuICAgICAgbW9kZWwubmFtZS5pbm5lclRleHQgPSBcIlwiXHJcbiAgICAgIG1vZGVsLmRlc2NyaXB0aW9uLmlubmVyVGV4dCA9IFwiXCJcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVPbkRvbShtb2RlbCl7XHJcbiAgICAgIGxldCBsYXN0RWxlbWVudCA9ICQoXCIuaWRbZGF0YS1pZD0nbmV3J11cIilbMF1cclxuICAgICAgbGFzdEVsZW1lbnQuYmVmb3JlKG1vZGVsLmVtcHR5LmlkKVxyXG4gICAgICBsYXN0RWxlbWVudC5iZWZvcmUobW9kZWwuZW1wdHkubmFtZSlcclxuICAgICAgbGFzdEVsZW1lbnQuYmVmb3JlKG1vZGVsLmVtcHR5LmRlc2NyaXB0aW9uKVxyXG4gICAgICBsYXN0RWxlbWVudC5iZWZvcmUobW9kZWwuZW1wdHkuc2F2ZSlcclxuICAgICAgbGFzdEVsZW1lbnQuYmVmb3JlKG1vZGVsLmVtcHR5LmRlbClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhc3NpZ25OZXdWYWx1ZXNPbkNsb25lKG1vZGVsLCBpZCl7XHJcbiAgICAgIG1vZGVsLmVtcHR5LmlkLmRhdGFzZXQuaWQgPSBpZFxyXG4gICAgICBtb2RlbC5lbXB0eS5pZC5pbm5lclRleHQgPSBpZFxyXG4gICAgICBtb2RlbC5lbXB0eS5uYW1lLmRhdGFzZXQuaWQgPSBpZFxyXG4gICAgICBtb2RlbC5lbXB0eS5uYW1lLmlubmVyVGV4dCA9IG1vZGVsLm5hbWUuaW5uZXJUZXh0LnRyaW0oKVxyXG4gICAgICBtb2RlbC5lbXB0eS5kZXNjcmlwdGlvbi5kYXRhc2V0LmlkID0gaWRcclxuICAgICAgbW9kZWwuZW1wdHkuZGVzY3JpcHRpb24uaW5uZXJUZXh0ID0gbW9kZWwuZGVzY3JpcHRpb24uaW5uZXJUZXh0LnRyaW0oKVxyXG4gICAgICBtb2RlbC5lbXB0eS5zYXZlLmRhdGFzZXQuaWQgPSBpZFxyXG4gICAgICBtb2RlbC5lbXB0eS5kZWwuZGF0YXNldC5pZCA9IGlkXHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlKG1vZGVsKSB7XHJcbiAgICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KCcvcmlnaHQvY3JlYXRlJywgbW9kZWwudG9TZXJ2KVxyXG4gICAgICByZXMgPSBhd2FpdCBKU09OLnBhcnNlKHJlcylcclxuXHJcbiAgICAgIGlmIChyZXMuaWQpIHtcclxuXHJcbiAgICAgICAgYXNzaWduTmV3VmFsdWVzT25DbG9uZShtb2RlbCwgcmVzLmlkLTEpXHJcbiAgICAgICAgY3JlYXRlT25Eb20obW9kZWwpXHJcbiAgICAgICAgY2xlYXJNb2RlbChtb2RlbClcclxuXHJcbiAgICAgICAgcG9wdXAuc2hvdygn0KHQvtGF0YDQsNC90LXQvdC+JylcclxuICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcblxyXG4gIH1cclxufSIsImltcG9ydCAnLi9jcmVhdGUvY3JlYXRlJ1xyXG5cclxuaW1wb3J0ICcuL3BsYW5uaW5nLnNjc3MnXHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGxhbm5pbmcoKXtcclxuZGVidWdnZXJcclxuXHJcbn0iLCJpbXBvcnQgeyR9IGZyb20gJy4uL2NvbW1vbidcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFNleCgpIHtcclxuICBmdW5jdGlvbiBzZXgoKSB7XHJcbiAgICBjb25zdCBzID0gJCgnW25hbWU9XCJzZXhcIl0nKVxyXG4gICAgZm9yIChsZXQgZiBvZiBzKSB7XHJcbiAgICAgIGlmIChmLmNoZWNrZWQpIHtcclxuICAgICAgICByZXR1cm4gZi52YWx1ZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJ20nXHJcbiAgfVxyXG59IiwiaW1wb3J0ICcuL3VzZXJzLnNjc3MnXHJcblxyXG5pbXBvcnQgeyQsIHBvcHVwLCBwb3N0fSBmcm9tICcuLi8uLi9jb21tb24nXHJcbmltcG9ydCBnZXRTZXggZnJvbSAnLi4vLi4vQXV0aC9nZXRTZXgnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VyKCkge1xyXG5cclxuICBsZXQgaXRlbSA9ICQoJ1tkYXRhLW1vZGVsPVwidXNlclwiXScpWzBdXHJcbiAgaWYgKGl0ZW0pIHtcclxuICAgICQoaXRlbSkub24oJ2NsaWNrJywgaGFuZGxlQ2xpY2spXHJcbiAgfVxyXG5cclxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVDbGljayh7dGFyZ2V0fSkge1xyXG4gICAgaWYgKCEhdGFyZ2V0LmNsb3Nlc3QoJyNzYXZlJykpIHtcclxuXHJcbiAgICAgIGxldCB3cmFwcGVyID0gJCgnLnVzZXItaXRlbScpWzBdXHJcbiAgICAgIGxldCBkYXRhID0gZ2V0TW9kZWwod3JhcHBlcilcclxuXHJcbiAgICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KCcvYWRtaW5zYy91c2VyL3VwZGF0ZScsIGRhdGEpXHJcbiAgICAgIGlmIChyZXMgPT09ICdvaycpIHtcclxuICAgICAgICBwb3B1cC5zaG93KCfQodC+0YXRgNCw0L3QtdC90L4nKVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3JpZ2h0JykpIHtcclxuICAgICAgbGV0IHJpZ2h0cyA9ICQoJ2lucHV0LnJpZ2h0OmNoZWNrZWQnKVxyXG4gICAgICBsZXQgc3RyID0gJyc7XHJcbiAgICAgIFtdLm1hcC5jYWxsKHJpZ2h0cywgZnVuY3Rpb24gKHJpZ2h0KSB7XHJcbiAgICAgICAgbGV0IHMgPSByaWdodC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmlubmVyVGV4dFxyXG4gICAgICAgIHN0cis9cysnLCdcclxuICAgICAgfSlcclxuICAgICAgICBsZXQgdGFiID0gdGFyZ2V0LmNsb3Nlc3QoJ1t0YWJdJylcclxuICAgICAgICB0YWIuZGF0YXNldC52YWx1ZSA9IHN0clxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmlnaHRzKCkge1xyXG4gICAgbGV0IHJpZ2h0ID0gJCgnLnJpZ2h0OmNoZWNrZWQnKVxyXG4gICAgbGV0IHJpZ2h0cyA9ICcnO1xyXG4gICAgW10ubWFwLmNhbGwocmlnaHQsIChyKSA9PiB7XHJcbiAgICAgIGxldCBzdHIgPSByLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuaW5uZXJUZXh0ICsgJywnXHJcbiAgICAgIHJpZ2h0cyArPSBzdHJcclxuICAgIH0sIHJpZ2h0cylcclxuICAgIHJldHVybiByaWdodHNcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvbmZpcm0oKSB7XHJcbiAgICBjb25zdCBjb25maXJtID0gJCgnI2NvbmYgb3B0aW9uJylcclxuICAgIGZvciAobGV0IGYgb2YgY29uZmlybSkge1xyXG4gICAgICBpZiAoZi5zZWxlY3RlZCkge1xyXG4gICAgICAgIHJldHVybiBmLnZhbHVlXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAnMCdcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiBnZXRNb2RlbCh0YXJnZXQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOiAkKHRhcmdldCkuZmluZChcIiNpZFwiKS5pbm5lclRleHQsXHJcbiAgICAgIG5hbWU6ICQodGFyZ2V0KS5maW5kKCcjbmFtZScpLmlubmVyVGV4dCxcclxuICAgICAgc3VyTmFtZTogJCh0YXJnZXQpLmZpbmQoJyNzLW5hbWUnKS5pbm5lclRleHQsXHJcbiAgICAgIG1pZGRsZU5hbWU6ICQodGFyZ2V0KS5maW5kKCcjbS1uYW1lJykuaW5uZXJUZXh0LFxyXG4gICAgICBiaXJ0aERhdGU6ICQodGFyZ2V0KS5maW5kKCcjYmRheScpLmlubmVyVGV4dCxcclxuICAgICAgcGhvbmU6ICQodGFyZ2V0KS5maW5kKCcjcGhvbmUnKS5pbm5lclRleHQsXHJcbiAgICAgIGVtYWlsOiAkKHRhcmdldCkuZmluZCgnI2VtYWlsJykuaW5uZXJUZXh0LFxyXG4gICAgICBoaXJlZDogJCh0YXJnZXQpLmZpbmQoJyNoaXJlZCcpLmlubmVyVGV4dCxcclxuICAgICAgZmlyZWQ6ICQodGFyZ2V0KS5maW5kKCcjZmlyZWQnKS5pbm5lclRleHQsXHJcbiAgICAgIGNvbmZpcm06IGNvbmZpcm0oKSxcclxuICAgICAgc2V4OiBnZXRTZXgoKSxcclxuICAgICAgcmlnaHRzOiByaWdodHMoKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiIsImltcG9ydCAnLi9vcGVuX3Rlc3Quc2NzcydcclxuaW1wb3J0IHskLCBwb3B1cCwgcG9zdCwgZGVib3VuY2UsIElzSnNvbn0gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5cclxuaW1wb3J0ICcuLi9jb21wb25lbnRzL2FjY29yZGlvbi1zaG93JztcclxuXHJcbmxldCBvcGVuVGVzdCA9ICQoJy5vcGVudGVzdF93cmFwJylbMF1cclxuaWYgKG9wZW5UZXN0KSB7XHJcbiAgJChvcGVuVGVzdCkub24oJ2NsaWNrJywgaGFuZGxlQ2xpY2spXHJcblxyXG4gICQob3BlblRlc3QpLm9uKCdrZXl1cCcsIGhhbmRsZUtleXVwKVxyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVLZXl1cCh7dGFyZ2V0fSkge1xyXG4gIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCd0ZXh0YXJlYScpKSB7XHJcbiAgICBsZXQgYWN0aXZlUGFnaW5hdGlvbiA9ICQoJ1tkYXRhLXBhZ2luYXRpb25dLmFjdGl2ZScpWzBdXHJcbiAgICBpZiAoIXRhcmdldC5pbm5lclRleHQpIHtcclxuICAgICAgYWN0aXZlUGFnaW5hdGlvbi5jbGFzc0xpc3QucmVtb3ZlKCdmaWxsZWQnKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYWN0aXZlUGFnaW5hdGlvbi5jbGFzc0xpc3QuYWRkKCdmaWxsZWQnKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlQ2xpY2soe3RhcmdldH0pIHtcclxuICBsZXQgdGVzdGlkID0gdGFyZ2V0LmRhdGFzZXQuaWRcclxuICBsZXQgYWN0aXZlUXVlc3Rpb24gPSAkKCcucXVlc3Rpb24uc2hvdycpWzBdXHJcbiAgbGV0IHBhZ2luYXRpb25zID0gJCgnW2RhdGEtcGFnaW5hdGlvbl0nKVxyXG4gIGxldCBhY3RpdmVQYWdpbmF0aW9uID0gJCgnW2RhdGEtcGFnaW5hdGlvbl0uYWN0aXZlJylbMF1cclxuICBsZXQgaSA9IHBhZ2luYXRpb25zLmluZGV4T2YoYWN0aXZlUGFnaW5hdGlvbilcclxuXHJcbiAgaWYgKHRhcmdldC5pZCA9PT0gJ3ByZXYnKSB7XHJcbiAgICBwcmV2UXVlc3QoKVxyXG4gIH0gZWxzZSBpZiAodGFyZ2V0LmlkID09PSAnbmV4dCcpIHtcclxuICAgIG5leHRRdWVzdCgpXHJcbiAgfSBlbHNlIGlmICh0YXJnZXQuZGF0YXNldC5wYWdpbmF0aW9uKSB7XHJcbiAgICBwYWdpbmF0ZSgpXHJcbiAgfSBlbHNlIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdsZWQnKSkge1xyXG4gICAgYmxpbmsodGFyZ2V0KVxyXG4gIH0gZWxzZSBpZiAodGFyZ2V0LmlkID09PSAnZmluaXNoJykge1xyXG4gICAgZmluaXNoKClcclxuICB9XHJcblxyXG4gIGFzeW5jIGZ1bmN0aW9uIGZpbmlzaCgpIHtcclxuICAgIGxldCBxdWVzdGlvbnMgPSBhd2FpdCBnZXRBbnN3ZXJzKHRlc3RpZClcclxuICAgIGxldCBjb3JyZWN0QW5zd2VycyA9IGNvcnJlY3RDb3VudChxdWVzdGlvbnMpXHJcbiAgICBsZXQgb2JqID0gY2FjaGVQYWdlKGNvcnJlY3RBbnN3ZXJzKVxyXG4gICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9hZG1pbnNjL29wZW50ZXN0cmVzdWx0L2ZpbmlzaCcsIG9iailcclxuICAgIGlmIChJc0pzb24ocmVzKSkge1xyXG4gICAgICByZXMgPSBKU09OLnBhcnNlKHJlcylcclxuICAgICAgaWYgKHJlcy5tc2cgPT09ICdvaycpIHtcclxuICAgICAgICAvLyBwb3B1cC5zaG93KHJlcy5tc2cpXHJcbiAgICAgICAgbGV0IGNhbnYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpXHJcbiAgICAgICAgY2Fudi5pZCA9ICdjJ1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlcGxhY2VOYnNwcyhzdHIpIHtcclxuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoJyZuYnNwOz8nLCBcImdcIik7XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UocmUsIFwiIFwiKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcmVwbGFjZU5zKHN0cikge1xyXG4gICAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnXFxcXG4/JywgXCJnXCIpO1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlLCBcIlwiKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcmVwbGFjZVRzKHN0cikge1xyXG4gICAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnXFxcXHQ/JywgXCJnXCIpO1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlLCBcIlwiKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gY2FjaGVQYWdlKHJpZ2h0QW5zd2Vycykge1xyXG4gICAgbGV0IHQgPSAkKCcudGVzdCcpWzBdLm91dGVySFRNTFxyXG5cclxuICAgIHQgPSByZXBsYWNlTmJzcHModClcclxuICAgIHQgPSByZXBsYWNlTnModClcclxuICAgIHQgPSByZXBsYWNlVHModClcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0ZXN0SWQ6ICt0ZXN0aWQsXHJcbiAgICAgIHF1ZXN0aW9uQ250OiBwYWdpbmF0aW9ucy5sZW5ndGgsXHJcbiAgICAgIGh0bWw6IHQsXHJcbiAgICAgIC8vIGh0bWw6IGA8IURPQ1RZUEUgJHtkb2N1bWVudC5kb2N0eXBlLm5hbWV9PmAgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub3V0ZXJIVE1MLFxyXG4gICAgICB0ZXN0bmFtZTogJCgnLnRlc3QtbmFtZScpWzBdLmlubmVyVGV4dCxcclxuICAgICAgdXNlcm5hbWU6ICQoJy51c2VyLW1lbnVfX2ZpbycpWzBdLmlubmVyVGV4dCxcclxuICAgICAgcmlnaHRBbnN3ZXJzLFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGFnaW5hdGUoKSB7XHJcbiAgICBpZiAodGFyZ2V0ID09PSBhY3RpdmVQYWdpbmF0aW9uKSByZXR1cm4gZmFsc2VcclxuICAgIGxldCBhaW1QYWdpbmF0aW9uID0gdGFyZ2V0XHJcbiAgICB0b2dnbGVRdWVzdGlvbihhaW1QYWdpbmF0aW9uLCBhY3RpdmVRdWVzdGlvbilcclxuICAgIHRvZ2dsZU5hdihhaW1QYWdpbmF0aW9uLCBhY3RpdmVQYWdpbmF0aW9uKVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcHJldlF1ZXN0KCkge1xyXG4gICAgaWYgKGkgPCAxKSByZXR1cm4gZmFsc2VcclxuICAgIGxldCBhaW1QYWdpbmF0aW9uID0gcGFnaW5hdGlvbnNbaSAtIDFdXHJcbiAgICB0b2dnbGVRdWVzdGlvbihhaW1QYWdpbmF0aW9uLCBhY3RpdmVRdWVzdGlvbilcclxuICAgIHRvZ2dsZU5hdihhaW1QYWdpbmF0aW9uLCBhY3RpdmVQYWdpbmF0aW9uKVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbmV4dFF1ZXN0KCkge1xyXG4gICAgaWYgKGkgPiBwYWdpbmF0aW9ucy5sZW5ndGggLSAyKSByZXR1cm4gZmFsc2VcclxuICAgIGxldCBhaW1QYWdpbmF0aW9uID0gcGFnaW5hdGlvbnNbaSArIDFdXHJcbiAgICB0b2dnbGVRdWVzdGlvbihhaW1QYWdpbmF0aW9uLCBhY3RpdmVRdWVzdGlvbilcclxuICAgIHRvZ2dsZU5hdihhaW1QYWdpbmF0aW9uLCBhY3RpdmVQYWdpbmF0aW9uKVxyXG4gIH1cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGNvcnJlY3RDb3VudChxdWVzdGlvbnMpIHtcclxuICBsZXQgY29ycmVjdCA9IDBcclxuICBxdWVzdGlvbnMuZm9yRWFjaCgocSkgPT4ge1xyXG4gICAgbGV0IHFfaWQgPSBxLmlkXHJcbiAgICBsZXQgcV9lbCA9ICQoYC5xdWVzdGlvbltkYXRhLWlkPScke3FfaWR9J11gKVswXVxyXG4gICAgbGV0IHRleHRhcmVhID0gJChxX2VsKS5maW5kKCcudGV4dGFyZWEnKVxyXG4gICAgaWYgKCFxLk9wZW5hbnN3ZXIpIHJldHVyblxyXG4gICAgbGV0IHdvcmQgPSAnJ1xyXG4gICAgcS5PcGVuYW5zd2VyLmZvckVhY2goKGEpID0+IHtcclxuICAgICAgd29yZCArPSBgKCR7YS5hbnN3ZXJ9KT9gXHJcbiAgICB9KVxyXG4gICAgY29ycmVjdCArPSBoaWdobGlnaHQoYCR7d29yZH1gLCB0ZXh0YXJlYSwgdHJ1ZSlcclxuICB9KVxyXG4gIHJldHVybiBjb3JyZWN0XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhpbGl0ZXIod29yZCwgZWxlbWVudCwgYWRkRXZlbnRMaXMpIHtcclxuICBsZXQgdGV4dCA9IGVsZW1lbnQuaW5uZXJIVE1MXHJcbiAgbGV0IHJneHAgPSBuZXcgUmVnRXhwKHdvcmQsICdnJyk7XHJcbiAgbGV0IGFyciA9IHRleHQubWF0Y2gocmd4cClcclxuICBsZXQgY29ycmVjdCA9IDBcclxuXHJcbiAgYXJyLmZvckVhY2goKHcpID0+IHtcclxuICAgIGlmICghdykgcmV0dXJuXHJcbiAgICBjb3JyZWN0ID0gMVxyXG4gICAgbGV0IHIgPSBuZXcgUmVnRXhwKHcsICdnJylcclxuICAgIGxldCByZXBsID0gYDxzcGFuIHN0eWxlPSdjb2xvcjpyZWQ7Jz5gICsgdyArICc8L3NwYW4+JztcclxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gZWxlbWVudC5pbm5lckhUTUwucmVwbGFjZShyLCByZXBsKTtcclxuICB9KVxyXG4gIHJldHVybiBjb3JyZWN0XHJcblxyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBnZXRBbnN3ZXJzKGlkKSB7XHJcbiAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9hZG1pbnNjL29wZW50ZXN0cmVzdWx0L2dldGFuc3dlcnMnLCB7aWR9KVxyXG4gIHJlcyA9IEpTT04ucGFyc2UocmVzKVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuZnVuY3Rpb24gdG9nZ2xlTmF2KGFpbVBhZ2luYXRpb24sIGFjdGl2ZVBhZ2luYXRpb24pIHtcclxuICBhY3RpdmVQYWdpbmF0aW9uLmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScpXHJcbiAgYWltUGFnaW5hdGlvbi5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnKVxyXG59XHJcblxyXG5mdW5jdGlvbiB0b2dnbGVRdWVzdGlvbihhaW1QYWdpbmF0aW9uSWQsIGFjdGl2ZVF1ZXN0aW9uKSB7XHJcbiAgbGV0IGFpbVF1ZXN0aW9uSWQgPSBhaW1QYWdpbmF0aW9uSWQuZGF0YXNldC5wYWdpbmF0aW9uXHJcbiAgbGV0IGFpbVF1ZXN0aW9uID0gJChgLnF1ZXN0aW9uW2RhdGEtaWQ9JyR7YWltUXVlc3Rpb25JZH0nXWApWzBdXHJcbiAgYWltUXVlc3Rpb24uY2xhc3NMaXN0LnRvZ2dsZSgnc2hvdycpXHJcbiAgYWN0aXZlUXVlc3Rpb24uY2xhc3NMaXN0LnRvZ2dsZSgnc2hvdycpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhpZ2hsaWdodCh3b3JkLCBlbCwgYWRkRXZlbnRMaXMpIHtcclxuICByZXR1cm4gaGlsaXRlcih3b3JkLCBlbCwgYWRkRXZlbnRMaXMpO1xyXG59XHJcblxyXG4iLCJpbXBvcnQgJy4vcmFkaW8uc2NzcydcclxuaW1wb3J0IHskfSBmcm9tICcuLi8uLi9jb21tb24nXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByYWRpbygpe1xyXG4gIGxldCByYWRpb3MgPSAkKCdbY3VzdG9tLXJhZGlvXScpO1xyXG5cclxuICBbXS5tYXAuY2FsbChyYWRpb3MsIGZ1bmN0aW9uIChyYWRpbykge1xyXG4gICAgJChyYWRpbykub24oJ2NsaWNrJyxoYW5kbGVDbGljaylcclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVDbGljayh7dGFyZ2V0fSkge1xyXG4gICAgICBsZXQgdGFyZyA9IHRhcmdldC5jbG9zZXN0KFwibGFiZWxcIilcclxuICAgICAgcmFkaW8uZGF0YXNldC52YWx1ZSA9IHRhcmcuZGF0YXNldC52YWx1ZVxyXG4gICAgfVxyXG5cclxuICB9KVxyXG5cclxufSIsImltcG9ydCAnLi9tdWx0aXNlbGVjdC5zY3NzJ1xyXG5pbXBvcnQgeyR9IGZyb20gJy4uLy4uL2NvbW1vbidcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG11bHRpc2VsZWN0KCkge1xyXG5cclxuICBmdW5jdGlvbiBnZXRTZWxlY3RlZCgpe1xyXG4gICAgaWYgKG11bHRpKXtcclxuICAgICAgbGV0IHNlbGVjdGVkID0gW10ubWFwLmNhbGwobXVsdGksIGZ1bmN0aW9uIChzZWxlY3QpIHtcclxuICAgICAgICBsZXQgY2hpcHMgPSBzZWxlY3QucXVlcnlTZWxlY3RvckFsbCgnLmNoaXAtd3JhcCcpO1xyXG4gICAgICAgIGxldCBvYmpzID0gW10ubWFwLmNhbGwoY2hpcHMsIGZ1bmN0aW9uIChjaGlwKSB7XHJcbiAgICAgICAgICByZXR1cm4gY2hpcC5kYXRhc2V0LmlkO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgbGV0IG9iaiA9IHt9XHJcbiAgICAgICAgb2JqLmZpZWxkID0gIHNlbGVjdC5kYXRhc2V0LmZpZWxkXHJcbiAgICAgICAgb2JqLmlkcyA9IG9ianNcclxuICAgICAgICByZXR1cm4gb2JqXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgICAvLyBkZWJ1Z2dlclxyXG4gIH1cclxuXHJcbiAgbGV0IG11bHRpID0gJCgnW211bHRpLXNlbGVjdF0gJylcclxuICBpZiAobXVsdGkpIHtcclxuXHJcbiAgICBbXS5mb3JFYWNoLmNhbGwobXVsdGksIGZ1bmN0aW9uIChzZWxlY3QpIHtcclxuXHJcbiAgICAgIHNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUNsaWNrLCBmYWxzZSlcclxuICAgICAgc2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVCbHVyLCBmYWxzZSlcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUJsdXIoe3RhcmdldH0pIHtcclxuICAgICAgICBsZXQgc2hvdyA9ICQodGhpcykuZmluZCgnLnNob3cnKVxyXG4gICAgICAgIGlmIChzaG93KSB7XHJcbiAgICAgICAgICBzaG93LmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soe3RhcmdldH0pIHtcclxuICAgICAgICBsZXQgbXVsdGkgPSB0YXJnZXQuY2xvc2VzdCgnW211bHRpLXNlbGVjdF0nKVxyXG4vLyDQvtGC0LrRgNGL0YLRjCDQstGL0LHQvtGAINGN0LvQtdC80LXQvdGC0L7QslxyXG4gICAgICAgIGlmICh0YXJnZXQuY2xvc2VzdCgnLmFycm93Jyl8fFsnY2hpcC13cmFwJ10uaW5jbHVkZXModGFyZ2V0LmNsYXNzTmFtZSkpICB7XHJcbiAgICAgICAgICAvLyBsZXQgbXVsdGlzZWxlY3QgPSB0YXJnZXQuY2xvc2VzdCgnW211bHRpLXNlbGVjdF0gJylcclxuICAgICAgICAgIGxldCB1bCA9IG11bHRpLnF1ZXJ5U2VsZWN0b3IoJ3VsJylcclxuICAgICAgICAgIHVsLmNsYXNzTGlzdC50b2dnbGUoJ3Nob3cnKVxyXG5cclxuLy8g0L3QsNC20LDRgtC40LUg0L/QviDQutGA0LXRgdGC0LjQutGDINGH0LjQv9CwXHJcbiAgICAgICAgfSBlbHNlIGlmIChbJ2RlbCddLmluY2x1ZGVzKHRhcmdldC5jbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICBsZXQgaWQgPSB0YXJnZXQuY2xvc2VzdCgnLmNoaXAnKS5kYXRhc2V0LmlkXHJcbiAgICAgICAgICB0b2dnbGVCYWNrZ3JvdW5kKGlkKVxyXG4gICAgICAgICAgbGV0IGNoaXAgPSB0YXJnZXQuY2xvc2VzdCgnLmNoaXAnKVxyXG4gICAgICAgICAgY2hpcC5yZW1vdmUoKVxyXG5cclxuLy8g0LLRi9Cx0L7RgCDRjdC70LXQvNC10L3RgtCwLCDQv9GA0L7QstC10YDQutCwINGB0YPRidC10YHRgtCy0L7QstCw0L3QuNGPINGH0LjQv9CwINC4INC10LPQviDQtNC+0LHQsNCy0LvQtdC90LjQtVxyXG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2xhYmVsJykge1xyXG4gICAgICAgICAgbGV0IGlkID0gdGFyZ2V0LmRhdGFzZXQuaWQ7XHJcbiAgICAgICAgICAvLyBsZXQgbSA9IHRhcmdldC5jbG9zZXN0KCdbbXVsdGktc2VsZWN0XSAnKVxyXG4gICAgICAgICAgbGV0IGNoaXBzID0gbXVsdGkucXVlcnlTZWxlY3RvckFsbCgnLmNoaXAnKTtcclxuICAgICAgICAgIGxldCBleGlzdCA9IFtdLnNvbWUuY2FsbChjaGlwcywgKGNoaXApID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNoaXAuZGF0YXNldC5pZCA9PT0gaWRcclxuICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgbGV0IHdyYXAgPSAkKG11bHRpKS5maW5kKCcuY2hpcC13cmFwJylcclxuICAgICAgICAgIGlmICghZXhpc3QpIHtcclxuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC50b2dnbGUoJ3NlbGVjdGVkJylcclxuICAgICAgICAgICAgbGV0IGNoaXAgPSBjcmVhdGVDaGlwKGlkKVxyXG4gICAgICAgICAgICB3cmFwLmFwcGVuZChjaGlwKVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC50b2dnbGUoJ3NlbGVjdGVkJylcclxuICAgICAgICAgICAgd3JhcC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1pZD0nJHtpZH0nXWApLnJlbW92ZSgpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHRvZ2dsZUJhY2tncm91bmQoaWQpIHtcclxuICAgICAgICAgIC8vIGxldCBtdWx0aSA9IHRhcmdldC5jbG9zZXN0KCdbbXVsdGktc2VsZWN0XSAnKVxyXG4gICAgICAgICAgJChtdWx0aSkuZmluZChgbGFiZWxbZGF0YS1pZD0nJHtpZH0nXWApLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNoaXAoaWQpIHtcclxuICAgICAgICAgIGxldCBjaGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgICAgICAgIGNoaXAuY2xhc3NMaXN0LmFkZCgnY2hpcCcpXHJcbiAgICAgICAgICBjaGlwLmlubmVyVGV4dCA9IHRhcmdldC5pbm5lclRleHRcclxuICAgICAgICAgIGNoaXAuZGF0YXNldFsnaWQnXSA9IGlkXHJcblxyXG4gICAgICAgICAgbGV0IGRlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXHJcbiAgICAgICAgICBkZWwuY2xhc3NMaXN0LmFkZCgnZGVsJylcclxuICAgICAgICAgIGRlbC5pbm5lclRleHQgPSAnWCdcclxuXHJcbiAgICAgICAgICBjaGlwLmFwcGVuZChkZWwpXHJcblxyXG4gICAgICAgICAgcmV0dXJuIGNoaXBcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgfVxyXG59IiwiaW1wb3J0ICcuL2NhdGFsb2ctaXRlbS5zY3NzJztcclxuaW1wb3J0IHskLCBwb3N0LCBwb3B1cH0gZnJvbSAnLi4vLi4vY29tbW9uJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNhdGFsb2dJdGVtKCkge1xyXG4gIGxldCBjdXN0b21DYXRhbG9nSXRlbSA9ICQoJy5pdGVtX3dyYXAnKVswXVxyXG4gIGlmIChjdXN0b21DYXRhbG9nSXRlbSkge1xyXG4gICAgJChjdXN0b21DYXRhbG9nSXRlbSkub24oJ2NsaWNrJywgaGFuZGxlQ2xpY2suYmluZCh0aGlzKSlcclxuICB9XHJcblxyXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKHt0YXJnZXR9KSB7XHJcblxyXG4gICAgbGV0IGl0ZW0gPSBjdXN0b21DYXRhbG9nSXRlbVxyXG4gICAgbGV0IG1vZGVsTmFtZSA9IGl0ZW0uZGF0YXNldC5tb2RlbFxyXG4gICAgaWYgKHRhcmdldC5jbG9zZXN0KCcuc2F2ZScpKSB7XHJcbiAgICAgIHNhdmUobW9kZWxOYW1lKVxyXG4gICAgfSBlbHNlIGlmICh0YXJnZXQuY2xvc2VzdCgnLmRlbCcpXHJcbiAgICAgICYmdGFyZ2V0LmNsb3Nlc3QoJy5kZWwnKS5kYXRhc2V0Lm1vZGVsKSB7XHJcbiAgICAgIGRlbChpdGVtLHRhcmdldC5jbG9zZXN0KCcuZGVsJykuZGF0YXNldC5tb2RlbClcclxuICAgIH0gZWxzZSBpZiAoKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3RhYicpKSkge1xyXG4gICAgICBoYW5kbGVUYWIodGFyZ2V0LCBtb2RlbE5hbWUpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVUYWIodGFyZ2V0KSB7XHJcbiAgICBsZXQgdmlzaWJsZVNlY3Rpb24gPSAkKGBzZWN0aW9uLnNob3dgKVswXVxyXG4gICAgdmlzaWJsZVNlY3Rpb24uY2xhc3NMaXN0LnRvZ2dsZSgnc2hvdycpXHJcbiAgICBsZXQgc2VjdGlvbiA9ICQoYHNlY3Rpb25bZGF0YS1pZD0nJHt0YXJnZXQuZGF0YXNldC5pZH0nXWApWzBdXHJcbiAgICBzZWN0aW9uLmNsYXNzTGlzdC50b2dnbGUoJ3Nob3cnKVxyXG4gICAgbGV0IGFjdGl2ZVRhYiA9ICQoYC50YWIuYWN0aXZlYClbMF1cclxuICAgIGFjdGl2ZVRhYi5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnKVxyXG4gICAgdGFyZ2V0LmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScpXHJcbiAgfVxyXG5cclxuICBhc3luYyBmdW5jdGlvbiBkZWwoaXRlbSwgbW9kZWxOYW1lKSB7XHJcbiAgICBsZXQgaWQgPSBpdGVtLmRhdGFzZXQuaWRcclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KGAvYWRtaW5zYy8ke21vZGVsTmFtZX0vZGVsZXRlYCwge2lkfSlcclxuICAgIHJlcyA9IEpTT04ucGFyc2UocmVzKVxyXG4gICAgaWYgKHJlcy5tc2cgPT09ICdvaycpIHtcclxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBgL2FkbWluc2MvJHttb2RlbE5hbWV9YFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZnVuY3Rpb24gc2F2ZShtb2RlbE5hbWUpIHtcclxuICAgIGlmIChjaGVja1JlcXVpcmVkKCkpIHJldHVybiBmYWxzZVxyXG4gICAgbGV0IG1vZGVsID0gZ2V0TW9kZWwoKVxyXG4gICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoYC9hZG1pbnNjLyR7bW9kZWxOYW1lfS91cGRhdGVvcmNyZWF0ZWAsIHsuLi5tb2RlbH0pXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjaGVja1JlcXVpcmVkKCkge1xyXG4gICAgbGV0IHJlcXVpcmVkID0gJCgnW3JlcXVpcmVkXScpO1xyXG4gICAgbGV0IGVyckNvdW50ID0gMDtcclxuICAgIFtdLmZvckVhY2guY2FsbChyZXF1aXJlZCwgZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgIGlmICghZWwuaW5uZXJUZXh0KSB7XHJcbiAgICAgICAgZWwuc3R5bGUuYm9yZGVyQ29sb3IgPSAncmVkJ1xyXG4gICAgICAgIGlmICgkKGVsKS5maW5kKCcuZXJyb3InKSkgcmV0dXJuXHJcbiAgICAgICAgbGV0IGVycm9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgICAgICBlcnJvci5pbm5lclRleHQgPSAn0JfQsNC/0L7Qu9C90LjRgtC1INC/0L7Qu9C1J1xyXG4gICAgICAgIGVycm9yLmNsYXNzTGlzdC5hZGQoJ2Vycm9yJylcclxuICAgICAgICBlbC5jbG9zZXN0KCcudmFsdWUnKS5hcHBlbmRDaGlsZChlcnJvcilcclxuICAgICAgICBlcnJDb3VudCsrXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgICByZXR1cm4gZXJyQ291bnRcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldE1vZGVsKCkge1xyXG4gICAgbGV0IGZpZWxkcyA9ICQoJ1tkYXRhLWZpZWxkXScpO1xyXG4gICAgbGV0IG9iaiA9IHt9O1xyXG4gICAgLy8gZGVidWdnZXI7XHJcbiAgICBbXS5tYXAuY2FsbChmaWVsZHMsIChmaWVsZCkgPT4ge1xyXG4gICAgICBpZiAoZmllbGQuaGFzQXR0cmlidXRlKCdtdWx0aS1zZWxlY3QnKSkge1xyXG4gICAgICAgIGxldCBjaGlwcyA9IGZpZWxkLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jaGlwJyk7XHJcbiAgICAgICAgbGV0IGlkcyA9IFtdLm1hcC5jYWxsKGNoaXBzLCAoY2hpcCkgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIGNoaXAuZGF0YXNldC5pZFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgb2JqW2ZpZWxkLmRhdGFzZXQuZmllbGRdID0gaWRzLnRvU3RyaW5nKClcclxuICAgICAgfSBlbHNlIGlmIChmaWVsZC5oYXNBdHRyaWJ1dGUoJ2N1c3RvbS1zZWxlY3QnKSkge1xyXG4gICAgICAgIG9ialtmaWVsZC5kYXRhc2V0LmZpZWxkXSA9IGZpZWxkLmRhdGFzZXQudmFsdWVcclxuICAgICAgfSBlbHNlIGlmIChmaWVsZC5kYXRhc2V0LnR5cGUgPT09ICdpbnB1dHMnKSB7XHJcbiAgICAgICAgb2JqW2ZpZWxkLmRhdGFzZXQuZmllbGRdID0gZ2V0SW5wdXRzKGZpZWxkKVxyXG4gICAgICB9IGVsc2UgaWYgKGZpZWxkLmhhc0F0dHJpYnV0ZSgnY3VzdG9tLXJhZGlvJykpIHtcclxuICAgICAgICBvYmpbZmllbGQuZGF0YXNldC5maWVsZF0gPSBmaWVsZC5kYXRhc2V0LnZhbHVlXHJcbiAgICAgIH0gZWxzZSBpZiAoZmllbGQuaGFzQXR0cmlidXRlKCd0YWInKSkge1xyXG4gICAgICAgIG9ialtmaWVsZC5kYXRhc2V0LmZpZWxkXSA9IGZpZWxkLmRhdGFzZXQudmFsdWVcclxuICAgICAgfSBlbHNlIGlmIChmaWVsZC50eXBlID09PSAnZGF0ZScpIHtcclxuICAgICAgICBvYmpbZmllbGQuZGF0YXNldC5maWVsZF0gPSBmaWVsZC52YWx1ZVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG9ialtmaWVsZC5kYXRhc2V0LmZpZWxkXSA9IGZpZWxkLmlubmVyVGV4dFxyXG4gICAgICB9XHJcbiAgICB9LCBvYmopXHJcbiAgICBsZXQgaXNUZXN0ID0gJCgnW2RhdGEtaXNUZXN0XScpWzBdXHJcbiAgICBpZiAoaXNUZXN0KSB7XHJcbiAgICAgIG9iai5pc1Rlc3QgPSAraXNUZXN0LmRhdGFzZXQuaXN0ZXN0XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRJbnB1dHMoZmllbGQpIHtcclxuICAgIGxldCBpbnB1dHMgPSBmaWVsZC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCcpXHJcbiAgICBsZXQgbmFtZXMgPSBbXVxyXG4gICAgaW5wdXRzLmZvckVhY2goKGlucCkgPT4ge1xyXG4gICAgICBpZiAoIWlucC5jaGVja2VkKSByZXR1cm5cclxuICAgICAgbGV0IG5hbWUgPSBpbnAucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yKCcubmFtZScpLmlubmVyVGV4dFxyXG4gICAgICBpZiAoIW5hbWUpIHJldHVyblxyXG4gICAgICBuYW1lcy5wdXNoKG5hbWUpXHJcbiAgICB9KVxyXG4gICAgcmV0dXJuIG5hbWVzLmpvaW4oJywnKVxyXG5cclxuICB9XHJcbn1cclxuIiwiaW1wb3J0ICcuL3Rvb2x0aXAuc2NzcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvb2x0aXBzKCkge1xyXG5cclxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgc2hvd1RpcCwgdHJ1ZSlcclxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgaGlkZVRpcCwgdHJ1ZSlcclxuXHJcblxyXG4gIGZ1bmN0aW9uIHNob3dUaXAoe3RhcmdldH0pIHtcclxuLy8gZGVidWdnZXJcclxuICAgIC8vINC10YHQu9C4INGDINC90LDRgSDQtdGB0YLRjCDQv9C+0LTRgdC60LDQt9C60LAuLi5cclxuICAgIGlmICghdGFyZ2V0LmRhdGFzZXR8fCF0YXJnZXQuZGF0YXNldC50b29sdGlwKSByZXR1cm47XHJcblxyXG4gICAgbGV0IHRvb2x0aXBIdG1sID0gdGFyZ2V0LmRhdGFzZXQudG9vbHRpcFxyXG4gICAgLy8gLi4u0YHQvtC30LTQsNC00LjQvCDRjdC70LXQvNC10L3RgiDQtNC70Y8g0L/QvtC00YHQutCw0LfQutC4XHJcbiAgICBsZXQgdG9vbHRpcEVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIHRvb2x0aXBFbGVtLmNsYXNzTmFtZSA9ICd0b29sdGlwJztcclxuICAgIHRvb2x0aXBFbGVtLmlubmVySFRNTCA9IHRvb2x0aXBIdG1sO1xyXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmQodG9vbHRpcEVsZW0pO1xyXG5cclxuICAgIC8vINGB0L/QvtC30LjRhtC40L7QvdC40YDRg9C10Lwg0LXQs9C+INGB0LLQtdGA0YXRgyDQvtGCINCw0L3QvdC+0YLQuNGA0YPQtdC80L7Qs9C+INGN0LvQtdC80LXQvdGC0LAgKHRvcC1jZW50ZXIpXHJcbiAgICBsZXQgY29vcmRzID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuICAgIGxldCBsZWZ0ID0gY29vcmRzLmxlZnQgKyAodGFyZ2V0Lm9mZnNldFdpZHRoIC0gdG9vbHRpcEVsZW0ub2Zmc2V0V2lkdGgpIC8gMjtcclxuICAgIGlmIChsZWZ0IDwgMCkgbGVmdCA9IDA7IC8vINC90LUg0LfQsNC10LfQttCw0YLRjCDQt9CwINC70LXQstGL0Lkg0LrRgNCw0Lkg0L7QutC90LBcclxuXHJcbiAgICBsZXQgdG9wID0gY29vcmRzLnRvcCAtIHRvb2x0aXBFbGVtLm9mZnNldEhlaWdodCAtIDU7XHJcbiAgICBpZiAodG9wIDwgMCkgeyAvLyDQtdGB0LvQuCDQv9C+0LTRgdC60LDQt9C60LAg0L3QtSDQv9C+0LzQtdGJ0LDQtdGC0YHRjyDRgdCy0LXRgNGF0YMsINGC0L4g0L7RgtC+0LHRgNCw0LbQsNGC0Ywg0LXRkSDRgdC90LjQt9GDXHJcbiAgICAgIHRvcCA9IGNvb3Jkcy50b3AgKyB0YXJnZXQub2Zmc2V0SGVpZ2h0ICsgNTtcclxuICAgIH1cclxuXHJcbiAgICB0b29sdGlwRWxlbS5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XHJcbiAgICB0b29sdGlwRWxlbS5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGhpZGVUaXAoKSB7XHJcbiAgICBsZXQgdG9vbHRpcHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcudG9vbHRpcCcpXHJcbiAgICBpZiAodG9vbHRpcHMpIHtcclxuICAgICAgW10uZm9yRWFjaC5jYWxsKHRvb2x0aXBzLCAodGlwKSA9PiB7XHJcbiAgICAgICAgICB0aXAucmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICApXHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG4iLCJpbXBvcnQgJy4vYWRtaW4uc2NzcydcclxuXHJcbmltcG9ydCAnLi4vY29tcG9uZW50cy9oZWFkZXIvaGVhZGVyLWFkbSdcclxuaW1wb3J0ICcuLi9jb21wb25lbnRzL2FjY29yZGlvbi9hY2NvcmRpb24nXHJcbmltcG9ydCAnLi4vY29tcG9uZW50cy9hZG1pbl9zaWRlYmFyJ1xyXG5pbXBvcnQgXCIuL21vZGVsL2NhY2hlXCI7XHJcbmltcG9ydCB7JH0gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5cclxuaW1wb3J0ICcuLi9UZXN0L3Rlc3RfcmVzdWx0cy90ZXN0X3Jlc3VsdHMnXHJcbmltcG9ydCAnLi4vVGVzdC9vcGVudGVzdC1lZGl0J1xyXG5pbXBvcnQgdGVzdEVkaXQgZnJvbSAnLi4vVGVzdC90ZXN0LWVkaXQnXHJcbmltcG9ydCB0ZXN0RG8gZnJvbSAnLi4vVGVzdC9kbydcclxuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4vU2V0dGluZ3Mvc2V0dGluZ3MnXHJcbmltcG9ydCByaWdodHMgZnJvbSAnLi9SaWdodHMvcmlnaHRzJ1xyXG5pbXBvcnQgcGxhbm5pbmcgZnJvbSAnLi9QbGFubmluZy9wbGFubmluZydcclxuaW1wb3J0IHVzZXIgZnJvbSAnLi91c2VyL3VzZXInXHJcbmltcG9ydCAnLi4vVGVzdC9vcGVuX3Rlc3QnXHJcblxyXG5pbXBvcnQgcmFkaW8gZnJvbSAnQGNvbXBvbmVudHMvcmFkaW8vcmFkaW8nXHJcbmltcG9ydCBsaXN0IGZyb20gJ0Bjb21wb25lbnRzL2xpc3QvbGlzdCdcclxuaW1wb3J0IG11bHRpc2VsZWN0IGZyb20gJ0Bjb21wb25lbnRzL211bHRpc2VsZWN0L211bHRpc2VsZWN0J1xyXG5pbXBvcnQgY2F0YWxvZ0l0ZW0gZnJvbSAnQGNvbXBvbmVudHMvY2F0YWxvZy1pdGVtL2NhdGFsb2ctaXRlbSdcclxuaW1wb3J0IGNhdGFsb2dEYXRlIGZyb20gJ0Bjb21wb25lbnRzL2RhdGUvZGF0ZSdcclxuaW1wb3J0IHRvb2x0aXBzIGZyb20gXCIuLi9jb21wb25lbnRzL3Rvb2x0aXAvdG9vbHRpcFwiO1xyXG5pbXBvcnQgYWNjb3JkaW9uU2hvdyBmcm9tIFwiLi4vY29tcG9uZW50cy9hY2NvcmRpb24tc2hvd1wiO1xyXG5cclxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xyXG5cclxuICBuYXZpZ2F0ZSh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpXHJcbiAgcmFkaW8oKVxyXG4gIGxpc3QoKVxyXG4gIG11bHRpc2VsZWN0KClcclxuICBjYXRhbG9nSXRlbSgpXHJcbiAgdG9vbHRpcHMoKVxyXG5cclxuICBhY2NvcmRpb25TaG93KClcclxuXHJcbiAgdGVzdEVkaXQoKVxyXG5cclxuICAvLyBvcGVudGVzdEVkaXQoKVxyXG5cclxuICBmdW5jdGlvbiBuYXZpZ2F0ZShzdHIpIHtcclxuICAgIC8vIGRlYnVnZ2VyXHJcbiAgICBzd2l0Y2ggKHRydWUpIHtcclxuICAgICAgY2FzZSAvXFwvYWRtaW5zY1xcL3NldHRpbmdzLy50ZXN0KHN0cik6XHJcbiAgICAgIGNhc2UgL1xcL2FkbWluc2NcXC9yaWdodFxcL2xpc3QvLnRlc3Qoc3RyKTpcclxuICAgICAgY2FzZSAvXFwvYWRtaW5zY1xcL3Bvc3RcXC9saXN0Ly50ZXN0KHN0cik6XHJcbiAgICAgIGNhc2UgL1xcL2FkbWluc2NcXC90b2RvXFwvbGlzdC8udGVzdChzdHIpOlxyXG4gICAgICAgIHJpZ2h0cygpXHJcbiAgICAgICAgJChcIltocmVmPScvYWRtaW5zYy9zZXR0aW5ncyddXCIpLmFkZENsYXNzKCdjdXJyZW50JylcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgL1xcL2FkbWluc2NcXC90ZXN0cmVzdWx0XFwvcmVzdWx0cy8udGVzdChzdHIpOlxyXG4gICAgICAgICQoXCJbaHJlZj0nL2FkbWluc2MvdGVzdC9yZXN1bHRzJ11cIikuYWRkQ2xhc3MoJ2N1cnJlbnQnKVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAvXFwvYXV0aFxcL3Byb2ZpbGUvLnRlc3Qoc3RyKTpcclxuICAgICAgICB1c2VyKClcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgL1xcL2FkbWluc2NcXC9jcm0vLnRlc3Qoc3RyKTpcclxuICAgICAgICAkKFwiW2hyZWY9Jy9hZG1pbnNjL2NybSddXCIpLmFkZENsYXNzKCdjdXJyZW50JylcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgL1xcL2FkbWluc2NcXC9jYXRhbG9nLy50ZXN0KHN0cik6XHJcbiAgICAgICAgJChcIltocmVmPScvYWRtaW5zYy9jYXRhbG9nJ11cIikuYWRkQ2xhc3MoJ2N1cnJlbnQnKVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAvXFwvYWRtaW5zY1xcL3BsYW5uaW5nLy50ZXN0KHN0cik6XHJcbiAgICAgICAgcGxhbm5pbmcoKVxyXG4gICAgICAgICQoXCJbaHJlZj0nL2FkbWluc2MvcGxhbm5pbmcnXVwiKS5hZGRDbGFzcygnY3VycmVudCcpXHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIC9cXC9hZG1pbnNjXFwvdGVzdFxcL3BhdGhzaG93Ly50ZXN0KHN0cik6XHJcbiAgICAgIGNhc2UgL1xcL2FkbWluc2NcXC90ZXN0XFwvZWRpdC8udGVzdChzdHIpOlxyXG4gICAgICAgICQoXCJbaHJlZj0nL2FkbWluc2MvdGVzdC9lZGl0J11cIikuYWRkQ2xhc3MoJ2N1cnJlbnQnKVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAvXFwvdGVzdC8udGVzdChzdHIpIHx8IC9cXC90ZXN0XFwvcmVzdWx0Ly50ZXN0KHN0cik6XHJcbiAgICAgICAgdGVzdERvKClcclxuICAgICAgICAkKFwiW2hyZWY9Jy90ZXN0L2RvJ11cIikuYWRkQ2xhc3MoJ2N1cnJlbnQnKVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAvXFwvYWRtaW5zY1xcL1NpdGVtYXAvLnRlc3Qoc3RyKTpcclxuICAgICAgICBzZXR0aW5ncygpXHJcbiAgICAgICAgJChcIltocmVmPScvYWRtaW5zYy9zZXR0aW5ncyddXCIpLmFkZENsYXNzKCdjdXJyZW50JylcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgJChcIltocmVmPScvYWRtaW5zYyddXCIpLmFkZENsYXNzKCdjdXJyZW50JylcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG59KVxyXG5cclxuXHJcblxyXG4iXSwibmFtZXMiOlsiZGVib3VuY2UiLCJmbiIsInRpbWUiLCJ0aW1lb3V0IiwiZnVuY3Rpb25DYWxsIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiSXNKc29uIiwic3RyIiwiSlNPTiIsInBhcnNlIiwiZSIsImRyb3BEb3duIiwiZWxlbWVudElkIiwiZHJvcGRvd24iLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwic2hvd0Ryb3Bkb3duIiwiZWxlbWVudCIsImV2ZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0TW91c2VFdmVudCIsIndpbmRvdyIsImRpc3BhdGNoRXZlbnQiLCJ2YWxpZGF0ZSIsInNvcnQiLCJlcnJvciIsIm5leHRFbGVtZW50U2libGluZyIsImFyIiwidmFsdWUiLCJtYXRjaCIsImlubmVyVGV4dCIsInN0eWxlIiwib3BhY2l0eSIsImVtYWlsIiwidGV4dCIsInJlIiwicmVzIiwidGVzdCIsIlN0cmluZyIsInRvTG93ZXJDYXNlIiwicGFzc3dvcmQiLCJwb3B1cCIsInNob3ciLCJ0eHQiLCJjYWxsYmFjayIsImNsb3NlIiwiZWwiLCJwb3B1cF9faXRlbSIsImFwcGVuZCIsIiQiLCJhZGRFdmVudExpc3RlbmVyIiwiYm9keSIsImhpZGVEZWxheSIsImNsYXNzTGlzdCIsInJlbW92ZSIsImFkZCIsInJlbW92ZURlbGF5IiwidGFyZ2V0IiwiY29udGFpbnMiLCJjbG9zZXN0IiwidGFnTmFtZSIsImNsYXNzTmFtZSIsImNyZWF0ZUVsZW1lbnQiLCJ1bmlxIiwiYXJyYXkiLCJBcnJheSIsImZyb20iLCJTZXQiLCJnZXQiLCJrZXkiLCJwIiwibG9jYXRpb24iLCJzZWFyY2giLCJSZWdFeHAiLCJwb3N0IiwidXJsIiwiZGF0YSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwidG9rZW4iLCJxdWVyeVNlbGVjdG9yIiwiZ2V0QXR0cmlidXRlIiwicmVxIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwic2V0UmVxdWVzdEhlYWRlciIsIkZvcm1EYXRhIiwic2VuZCIsInN0cmluZ2lmeSIsIm9uZXJyb3IiLCJFcnJvciIsIm9ubG9hZCIsInJlc3BvbnNlIiwibXNnIiwiaW5uZXJIVE1MIiwicmVtb3ZlQ2xhc3MiLCJzdWNjZXNzIiwiYWRkQ2xhc3MiLCJFbGVtZW50Q29sbGVjdGlvbiIsImF0dHJOYW1lIiwiYXR0clZhbCIsInNldEF0dHJpYnV0ZSIsImxlbmd0aCIsInNlbGVjdGVkT3B0aW9ucyIsIm9wdGlvbnMiLCJjaGVja2VkIiwiYXR0ciIsInZhbCIsImFyciIsImZvckVhY2giLCJzIiwicHVzaCIsImFwcGVuZENoaWxkIiwiaXRlbSIsImZpbHRlcmVkIiwiZmlsdGVyIiwicXVlcnlTZWxlY3RvckFsbCIsIm9uIiwiY2JPclNlbGVjdG9yIiwiY2IiLCJlbGVtIiwicmVhZHkiLCJpc1JlYWR5Iiwic29tZSIsInJlYWR5U3RhdGUiLCJzZWxlY3RvciIsImFkZFRvb2x0aXAiLCJhcmdzIiwiY2FsbCIsIm9ubW91c2VlbnRlciIsInRpcCIsIm1lc3NhZ2UiLCJiaW5kIiwib25tb3VzZWxlYXZlIiwiYWNjb3JkaW9ucyIsImNoZWNrYm94ZXMiLCJjaCIsImhhbmRsZSIsImxpIiwidWwiLCJmaW5kIiwicm90YXRlQXJyb3ciLCJzbGlkZVVwIiwicGFyZW50IiwiY2xvc2VTaWJsaW5ncyIsInNsaWRlRG93biIsIm1heEhlaWdodCIsInNjcm9sbEhlaWdodCIsInRvZ2dsZSIsImluY3JlYXNlUGFyZW50IiwidWxIZWlnaHQiLCJwYXJlbnRIZWlnaHQiLCJwYXJzZUludCIsInNpZGViYXIiLCJhY2NvcmRpb24iLCJfY2FjaGUiLCJjbGVhckNhY2hlIiwiY2FjaGUiLCJfdGVzdFJlc3VsdCIsImRlbFNlcnZlciIsImlkIiwiZGVsRG9tIiwibWFwIiwiaSIsImRlbGV0ZSIsImNvbmZpcm0iLCJ0ZXN0UmVzdWx0cyIsImhhbmRsZUNsaWNrIiwiZGF0YXNldCIsInJvdyIsIm9wZW5xdWVzdGlvbiIsInRlc3RJZCIsImNyZWF0ZSIsIm9wZW50ZXN0X2lkIiwicXVlc3Rpb25DbnQiLCJtb2RlbCIsImNsb25lIiwiY2xvbmVFbXB0eU1vZGVsIiwiYWRkQnRuIiwiYmVmb3JlIiwicXVlc3Rpb24iLCJxIiwiY2xvbmVOb2RlIiwiYW5zIiwiYW5zd2VyIiwidXBUb1Flc3Rpb25OdW1iZXIiLCJxdWVzdGlvbnNFbHMiLCJxdWVzdGlvbnMiLCJ0b0NoYW5nZSIsImNoYW5nZVBhcmVudCIsInRlc3RfaWQiLCJ0ZXN0X25hbWUiLCJzaG93QW5zd2VycyIsImFuc3dlcnMiLCJkZWwiLCJfb3BlbnF1ZXN0aW9uIiwiU29ydGFibGUiLCJzb3J0YWJsZSIsImNvbnRhaW5lclNlbGVjdG9yIiwiZWxTZWxlY3RvciIsImNvbnRhaW5lciIsImFuaW1hdGlvbiIsIm9uRW5kIiwiZXZ0Iiwib2xkSSIsIm9sZEluZGV4IiwibmV3SSIsIm5ld0luZGV4IiwiZWxzIiwiX3Rlc3QiLCJjb25zdHJ1Y3RvciIsInNlcnZlck1vZGVsIiwiaXNUZXN0IiwiaHJlZiIsImN1cnJlbnRRIiwiUUVsIiwibmF2TGVuZ3RoIiwiUVByZXZjIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsIlFOZXh0RWwiLCJ2aWV3TW9kZWwiLCJzcGxpdCIsInBvcCIsImVuYWJsZSIsInNlbGVjdGVkSW5kZXhWYWx1ZSIsInRlc3RpZCIsImNoaWxkcmVuIiwiY2hpbGRyZW5MZW5naHQiLCJwYXRoX2NyZWF0ZSIsInRlc3RfcGF0aCIsIm5hbWUiLCJzZWxlY3RlZFZhbHVlQ3VzdG9tU2VsZWN0Iiwic2VsZWN0Iiwic2VsZWN0ZWQiLCJvcHQiLCJmaWVsZHMiLCJmaWVsZCIsInVwZGF0ZSIsIm5vdEFkbWluIiwiX2Fuc3dlciIsImJ1dHRvbiIsIm9wZW5xdWVzdGlvbl9pZCIsImh0bWwiLCJpbnNlcnRBZGphY2VudEhUTUwiLCJkZWxfYnV0dG9uIiwib3BlbnRlc3RFZGl0IiwiaGFuZGxlQ2hhbmdlIiwiaGFuZGxlS2V5dXAiLCJzYXZlQW5zd2VyIiwiZGVib3VuY2VkSW5wdXQiLCJhbnN3ZXJFbCIsImFuc3dlcklkIiwiaXNfY29ycmVjdCIsImFkZF9idXR0b24iLCJwYXJlbnROb2RlIiwicHJldl9zb3J0IiwicV9pZCIsInByZXZpb3VzX3NvcnQiLCJhbnN3ZXJDbnQiLCJnZXRNb2RlbEZvclNlcnZlciIsInBhcmVudF9xdWVzdGlvbiIsImNvcnJlY3RfYW5zd2VyIiwicGljYSIsImFfaWQiLCJjcmVhdGVPblNlcnZlciIsIm5ld0VsIiwiZGlzcGxheSIsImRlbGV0ZUZyb21TZXJ2ZXIiLCJfcXVlc3Rpb24iLCJzZWxlY3RlZEluZGV4Iiwic2hvd1RpcCIsImFjdGlvbiIsInNhdmUiLCJjcmVhdGVBbnN3ZXJCdXR0b24iLCJhZGRCdXR0b24iLCJxdXN0aW9uIiwibGFzdFNvcnQiLCJxdWVzdGlvbnNDb3VudCIsInFzIiwibGFzdCIsImNyZWF0ZU9uVmlldyIsImdldEFuc3dlcnMiLCJkZWxldGVkIiwiZGVsZXRlRnJvbVZpZXciLCJwaWNxIiwiYW5zd2VyQmxvY2tzIiwiYSIsIldEU1NlbGVjdCIsIm11bHRpcGxlIiwidGl0bGUiLCJnZXRGb3JtYXR0ZWRPcHRpb25zIiwic2VsIiwibGFiZWwiLCJhcnJvdyIsInNwYWNlIiwic2V0dXAiLCJhZnRlciIsInNlbGVjdGVkT3B0aW9uIiwib3B0aW9uIiwic2VsZWN0ZWRPcHRpb25JbmRleCIsImluZGV4T2YiLCJzZWxlY3RWYWx1ZSIsIm5leHQiLCJwcmV2IiwibmV3Q3VzdG9tRWxlbWVudCIsInNjcm9sbEludG9WaWV3IiwiYmxvY2siLCJ0aXRsZUVsZW1lbnQiLCJ0YWJJbmRleCIsInNldE9wdGlvbiIsImRlYm91bmNlVGltZW91dCIsInNlYXJjaFRlcm0iLCJjb2RlIiwicHJldk9wdGlvbiIsIm5leHRPcHRpb24iLCJzZWFyY2hlZE9wdGlvbiIsInN0YXJ0c1dpdGgiLCJhY2NvcmRpb25TaG93IiwiY3VycmVudFRlc3RJZCIsIm1lbnVJdGVtQ29sbGVjdGlvbiIsIm1lbnUiLCJuZXh0USIsImN1cnJlbnQiLCJhaW1OYXZJZCIsImFpbU5hdklkRnVuY3Rpb24iLCJhaW1RRWwiLCJhaW1RRWxGdW5jdGlvbiIsInB1c2hOYXYiLCJwdXNoUSIsInByZXZRIiwiY3VycmVudElkIiwiY3Vyck5hdkVsIiwiTmF2RWwiLCJjdXJyZW50RWwiLCJkaXJlY3Rpb24iLCJkaXIiLCJRUHJldkVsIiwidGVzdEVkaXQiLCJjdXN0b21TZWxlY3QiLCJjdXN0b21TZWxlY3RzIiwicGFnaW5hdGlvbiIsImFjdGl2ZV9idG4iLCJpZF90b19oaWRlIiwiaWRfdG9fc2hvdyIsIm5hdkluaXQiLCJuYXZfYnV0dG9ucyIsIm5hdiIsInRlc3REbyIsImxhYmVscyIsInBhdGhuYW1lIiwicmVsb2FkIiwiY29yckFuc3dlcnMiLCJlcnJvckNudCIsImNvbG9yVmlldyIsIm9ialRvU2VydmVyIiwicmVwbGFjZU5ic3BzIiwicmVwbGFjZSIsInJlcGxhY2VOcyIsInJlcGxhY2VUcyIsImNhY2hlUGFnZSIsInJpZ2h0QW5zd2VycyIsInQiLCJvdXRlckhUTUwiLCJ0ZXN0bmFtZSIsInVzZXIiLCJjb3JyZWN0QW5zd2VycyIsImVycm9ycyIsImlucHV0IiwiY2hlY2tDb3JyZWN0QW5zd2VycyIsInBhZ2luSXRlbSIsImNvcnJlY3RBbnNlciIsImluaXQiLCJ1c2VycyIsInNldHRpbmdzIiwibGlzdCIsInRhYmxlcyIsInRhYmxlIiwiY29udGVudGVkaXRhYmxlIiwiaGVhZGVycyIsInNvcnRhYmxlcyIsImlucHV0cyIsImZpbmRBbGwiLCJpZHMiLCJtb2RlbE5hbWUiLCJyb3dzIiwiaGFuZGxlS2V5VXAiLCJoYW5kbGVJbnB1dCIsImhhc0F0dHJpYnV0ZSIsImhlYWRlciIsImluZGV4IiwiZmluZEluZGV4IiwibW9kZWxDcmVhdGUiLCJtb2RlbERlbCIsInNvcnRDb2x1bW4iLCJkZWxWaWV3IiwibmV3Um93IiwiUm93IiwidGFibGVDb250ZW50IiwiaW5jbHVkZXMiLCJzaG93QWxsUm93cyIsImlucCIsInJlZ2V4cCIsImRpcmVjdGlvbnMiLCJtdWx0aXBsaWVyIiwibmV3Um93cyIsInJvd0EiLCJyb3dCIiwiY2VsbEEiLCJjZWxsQiIsInRyYW5zZm9ybSIsImIiLCJub2RlTGlzdCIsInJldmVyc2UiLCJjb250ZW50IiwidHlwZSIsInBhcnNlRmxvYXQiLCJtYWtlU2VydmVyTW9kZWwiLCJyaWdodHMiLCJkYXRhSWQiLCJ0b1NlcnYiLCJlbXB0eSIsImYiLCJ0cmltIiwiZGVzY3JpcHRpb24iLCJtb2QiLCJ1cGRhdGVkIiwiY2xlYXJNb2RlbCIsImNyZWF0ZU9uRG9tIiwibGFzdEVsZW1lbnQiLCJhc3NpZ25OZXdWYWx1ZXNPbkNsb25lIiwicGxhbm5pbmciLCJnZXRTZXgiLCJzZXgiLCJ3cmFwcGVyIiwiZ2V0TW9kZWwiLCJyaWdodCIsInRhYiIsInIiLCJzdXJOYW1lIiwibWlkZGxlTmFtZSIsImJpcnRoRGF0ZSIsInBob25lIiwiaGlyZWQiLCJmaXJlZCIsIm9wZW5UZXN0IiwiYWN0aXZlUGFnaW5hdGlvbiIsImFjdGl2ZVF1ZXN0aW9uIiwicGFnaW5hdGlvbnMiLCJwcmV2UXVlc3QiLCJuZXh0UXVlc3QiLCJwYWdpbmF0ZSIsImJsaW5rIiwiZmluaXNoIiwiY29ycmVjdENvdW50Iiwib2JqIiwiY2FudiIsInVzZXJuYW1lIiwiYWltUGFnaW5hdGlvbiIsInRvZ2dsZVF1ZXN0aW9uIiwidG9nZ2xlTmF2IiwiY29ycmVjdCIsInFfZWwiLCJ0ZXh0YXJlYSIsIk9wZW5hbnN3ZXIiLCJ3b3JkIiwiaGlnaGxpZ2h0IiwiaGlsaXRlciIsImFkZEV2ZW50TGlzIiwicmd4cCIsInciLCJyZXBsIiwiYWltUGFnaW5hdGlvbklkIiwiYWltUXVlc3Rpb25JZCIsImFpbVF1ZXN0aW9uIiwicmFkaW8iLCJyYWRpb3MiLCJ0YXJnIiwibXVsdGlzZWxlY3QiLCJnZXRTZWxlY3RlZCIsIm11bHRpIiwiY2hpcHMiLCJvYmpzIiwiY2hpcCIsImhhbmRsZUJsdXIiLCJ0b2dnbGVCYWNrZ3JvdW5kIiwiZXhpc3QiLCJ3cmFwIiwiY3JlYXRlQ2hpcCIsImNhdGFsb2dJdGVtIiwiY3VzdG9tQ2F0YWxvZ0l0ZW0iLCJoYW5kbGVUYWIiLCJ2aXNpYmxlU2VjdGlvbiIsInNlY3Rpb24iLCJhY3RpdmVUYWIiLCJjaGVja1JlcXVpcmVkIiwicmVxdWlyZWQiLCJlcnJDb3VudCIsImJvcmRlckNvbG9yIiwidG9TdHJpbmciLCJnZXRJbnB1dHMiLCJpc3Rlc3QiLCJuYW1lcyIsImpvaW4iLCJ0b29sdGlwcyIsImhpZGVUaXAiLCJ0b29sdGlwIiwidG9vbHRpcEh0bWwiLCJ0b29sdGlwRWxlbSIsImNvb3JkcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImxlZnQiLCJvZmZzZXRXaWR0aCIsInRvcCIsIm9mZnNldEhlaWdodCIsImNhdGFsb2dEYXRlIiwibmF2aWdhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///99\n")}},__webpack_exports__={};__webpack_modules__[99]()})();