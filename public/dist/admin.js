(function(){"use strict";var __webpack_modules__={637:function(){eval("\n;// CONCATENATED MODULE: ./public/src/common.js\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nfunction dropDown(elementId) {\n  var dropdown = document.getElementById(elementId);\n\n  try {\n    showDropdown(dropdown);\n  } catch (e) {}\n\n  return false;\n}\n\n;\n\nfunction showDropdown(element) {\n  var event;\n  event = document.createEvent('MouseEvents');\n  event.initMouseEvent('mousedown', true, true, window);\n  element.dispatchEvent(event);\n}\n\n;\nlet validate = {\n  sort: () => {\n    let error = undefined.nextElementSibling;\n    let ar = undefined.value.match(/\\D+/);\n\n    if (ar) {\n      error.innerText = 'Только цифры';\n      error.style.opacity = '1';\n    } else {\n      if (error.style.opacity === \"1\") {\n        error.style.opacity = '0';\n      }\n    }\n  },\n  email: email => {\n    if (!email) return false;\n    let re = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n    return re.test(String(email).toLowerCase());\n  },\n  password: password => {\n    if (!password) return false;\n    let re = /^[a-zA-Z\\-0-9]{6,20}$/;\n    return re.test(password);\n  }\n}; // function up() {\n//    var top = Math.max(document.body.scrollTop, document.documentElement.scrollTop);\n//    if (top > 0) {\n//       window.scrollBy(0, -100);\n//       var t = setTimeout('up()', 20);\n//    }\n//    else\n//       clearTimeout(t);\n//    return false;\n// }\n\nlet popup = {\n  show: function (txt, callback) {\n    let close = this.el('div', 'popup__close');\n    close.innerText = 'X';\n    let popup__item = this.el('div', 'popup__item');\n    popup__item.innerText = txt;\n    popup__item.append(close);\n    let popup = common_$('.popup').el[0];\n\n    if (!popup) {\n      popup = this.el('div', 'popup');\n    }\n\n    popup.append(popup__item);\n    popup.addEventListener('click', this.close, true);\n    document.body.append(popup);\n    let hideDelay = 5000;\n    setTimeout(() => {\n      popup__item.classList.remove('popup__item');\n      popup__item.classList.add('popup-hide');\n    }, hideDelay);\n    let removeDelay = hideDelay + 950;\n    setTimeout(() => {\n      popup__item.remove();\n\n      if (callback) {\n        callback();\n      }\n    }, removeDelay);\n  },\n  close: function (e) {\n    if (e.target.classList.contains('popup__close')) {\n      let popup = this.closest('.popup').remove();\n    }\n  },\n  el: function (tagName, className) {\n    let el = document.createElement(tagName);\n    el.classList.add(className);\n    return el;\n  }\n};\n\nconst uniq = array => Array.from(new Set(array));\n\nasync function get(key) {\n  let p = window.location.search;\n  p = p.match(new RegExp(key + '=([^&=]+)'));\n  return p ? p[1] : false;\n}\n\nasync function post(url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new Promise(function (resolve, reject) {\n    data.token = document.querySelector('meta[name=\"token\"]').getAttribute('content');\n    let req = new XMLHttpRequest();\n    req.open('POST', url, true);\n    req.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n\n    if (data instanceof FormData) {\n      req.send(data);\n    } else {\n      req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n      req.send('param=' + JSON.stringify(data));\n    }\n\n    req.onerror = function (e) {\n      reject(Error(\"Network Error\" + e));\n    };\n\n    req.onload = async function () {\n      resolve(req.response);\n    };\n  });\n}\n\nclass ElementCollection extends Array {\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"el\", this);\n\n    _defineProperty(this, \"elType\", function () {\n      return {}.toString.call(this);\n    });\n\n    _defineProperty(this, \"value\", function () {\n      return this[0].getAttribute('value');\n    });\n\n    _defineProperty(this, \"attr\", function (attrName, attrVal) {\n      if (attrVal) {\n        this[0].setAttribute(attrName, attrVal);\n      }\n\n      return this[0].getAttribute(attrName);\n    });\n\n    _defineProperty(this, \"selectedIndexValue\", function () {\n      if (this.length) return this[0].selectedOptions[0].value;\n    });\n\n    _defineProperty(this, \"options\", function () {\n      if (this.length) return this[0].options;\n    });\n\n    _defineProperty(this, \"count\", function () {\n      return this.length;\n    });\n\n    _defineProperty(this, \"text\", function () {\n      if (this.length) return this[0].innerText;\n    });\n\n    _defineProperty(this, \"checked\", function () {\n      if (this.length) return this[0].checked;\n    });\n\n    _defineProperty(this, \"getWithStyle\", function (attr, val) {\n      let arr = [];\n      this.forEach(s => {\n        if (s.style[attr] === val) {\n          arr.push(s);\n        }\n      });\n      return arr;\n    });\n\n    _defineProperty(this, \"addClass\", function (className) {\n      this.forEach(s => {\n        s.classList.add(className);\n      });\n    });\n\n    _defineProperty(this, \"removeClass\", function (className) {\n      this.forEach(s => {\n        s.classList.remove(className);\n      });\n    });\n\n    _defineProperty(this, \"hasClass\", function (className) {\n      if (this.classList.contains(className)) return true;\n    });\n\n    _defineProperty(this, \"append\", function (el) {\n      this[0].appendChild(el);\n    });\n\n    _defineProperty(this, \"find\", function (item) {\n      if (typeof item === 'string') {\n        return this[0].querySelector(item);\n      } else {\n        let filtered = this[0].filter(el => {\n          return el === item;\n        });\n        return filtered[0];\n      }\n    });\n\n    _defineProperty(this, \"css\", function (attr, val) {\n      if (!val) {\n        return this[0].style[attr];\n      }\n\n      this.forEach(s => {\n        s.style[attr] = val;\n      });\n    });\n  }\n\n  on(event, cbOrSelector, cb) {\n    if (typeof cbOrSelector === 'function') {\n      this.forEach(e => e.addEventListener(event, cbOrSelector));\n    } else {\n      this.forEach(elem => {\n        elem.addEventListener(event, e => {\n          if (e.target.matches(cbOrSelector)) cb(e);\n        });\n      });\n    }\n  }\n\n  ready(cb) {\n    const isReady = this.some(e => {\n      return e.readyState != null && e.readyState != 'loading';\n    });\n\n    if (isReady) {\n      cb();\n    } else {\n      document.addEventListener('DOMContentLoaded', cb);\n    }\n  }\n\n}\n\nfunction common_$(selector) {\n  if (typeof selector === 'string' || selector instanceof String) {\n    return new ElementCollection(...document.querySelectorAll(selector));\n  } else {\n    return new ElementCollection(selector);\n  }\n}\n\nfunction addTooltip(args) {\n  let ar = [...args.els];\n  ar.map(el => {\n    el.onmouseenter = function () {\n      let tip = document.createElement('div');\n      common_$(tip).addClass('tip');\n      tip.innerText = args.message;\n      el.append(tip);\n\n      let remove = () => tip.remove();\n\n      tip.addEventListener('mousemove', remove.bind(tip), true);\n    }.bind(args);\n\n    el.onmouseleave = () => {\n      let tip = el.querySelector('.tip');\n      tip.remove();\n    };\n  }, [args]);\n}\n\nclass test_delete_button {\n  constructor(elem) {\n    if (!elem) return;\n    this._elem = common_$(elem).el[0];\n    this._elem.onclick = this.delete;\n    this._elem.onmouseenter = this.showToolip;\n    this._elem.onmouseleave = this.hideTooltip;\n    this._elem.onmousemove = this.changeTooltipPos;\n  }\n\n  async delete() {\n    if (confirm('Удалить тест?')) {\n      let res = test.del();\n\n      if (res.msg === 'ok') {\n        window.location = '/test/edit';\n      }\n    }\n  }\n\n  showToolip(e) {\n    let x = e.clientX;\n    let y = e.clientY;\n    let tip = document.createElement('div');\n    common_$(tip).addClass('tip');\n    tip.style.top = y + 70 + 'px';\n    tip.style.left = x - 170 + 'px';\n    tip.innerText = this.getAttribute('tip');\n    this.tip = tip;\n    document.body.append(tip);\n  }\n\n  hideTooltip() {\n    this.tip.remove();\n  }\n\n  changeTooltipPos(e) {\n    this.tip.style.top = e.pageY + 35 + 'px';\n    this.tip.style.left = e.pageX - 170 + 'px';\n  }\n\n}\n\n\n;// CONCATENATED MODULE: ./public/src/components/accordion/accordion.js\n\n\ncommon_$('.accordion label').on('click', handleToggle);\n\nwindow.onload = function () {\n  // debugger\n  let checkboxes = common_$('.admin-layout__sidebar.accordion input[type=checkbox]').el;\n\n  if (checkboxes) {\n    [...checkboxes].filter(ch => {\n      ch.checked = false;\n    });\n  }\n};\n\nfunction handleToggle(e) {\n  let checkbox = e.target.previousElementSibling;\n  let parent = checkbox.closest('ul');\n  let ul = common_$(checkbox.parentNode).find('ul');\n\n  if (checkbox.checked) {\n    slideUp(ul, 0);\n  } else {\n    parent.style.height = \"auto\";\n    slideDown(ul);\n    let ulHeight = ul.scrollHeight;\n    increaseParent(parent, ulHeight); // debugger\n\n    closeSiblings(parent);\n  }\n}\n\nfunction increaseParent(parent, ulHeight) {\n  if (!parent.classList.contains('accordion')) {\n    let parentHeight = parseInt(parent.style.maxHeight) + ulHeight;\n    parent.style.maxHeight = parentHeight + \"px\";\n  }\n}\n\nfunction slideDown(ul, callback) {\n  ul.style.maxHeight = ul.scrollHeight + \"px\";\n\n  if (callback) {\n    callback();\n  }\n}\n\nfunction closeSiblings(parent) {\n  Array.from(parent.children).map(el => {\n    let elArr = Array.from(el.children);\n    elArr.map(ch => {\n      if (ch.type && ch.type === 'checkbox' && ch.checked) {\n        let ul = common_$(ch.parentNode).find('ul');\n        slideUp(ul, 0, function () {\n          ch.checked = false;\n        });\n      }\n    });\n  });\n}\n\nfunction slideUp(ul, interval, callback) {\n  ul.style.maxHeight = 0 + \"px\";\n\n  if (callback) {\n    callback();\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Admin/model/cache.js\n\n\nlet _cache = {\n  clearCache: async function () {\n    let res = await post('/adminsc/clearCache', {});\n\n    if (res === 'Успешно') {\n      popup.show(res);\n    }\n  }\n};\nfunction cache() {\n  $('.clearCache').on('click', _cache.clearCache);\n}\n;// CONCATENATED MODULE: ./public/src/Test/model/_testResult.js\n\nconst _testResult = {\n  delServer: async id => {\n    let res = await post('/test/resultdelete', {\n      id\n    });\n\n    if (res) {\n      popup.show('Удалено');\n    }\n  },\n  delDom: e => {\n    let id = e.target.dataset.row;\n    Array.from(common_$(`[data-row = \"${id}\"]`).el).map(i => {\n      i.remove();\n    });\n    return id;\n  },\n  delete: e => {\n    if (confirm(\"Удалить результат теста?\")) {\n      let id = _testResult.delDom(e);\n\n      _testResult.delServer(id);\n    }\n  }\n};\n;// CONCATENATED MODULE: ./public/src/Test/test_results/test_results.js\n\n\n\nfunction testResults() {\n  common_$('.test-results__table .del').on('click', _testResult[\"delete\"]);\n}\n;// CONCATENATED MODULE: ./public/src/Test/model/test.js\n\nconst _test = {\n  markCurrentInMenu: () => {\n    let currentTestId = common_$('.test-name').el[0];\n\n    if (currentTestId) {\n      currentTestId = +currentTestId.getAttribute('value');\n      let menuItemCollection = common_$('.accordion a').el;\n      Array.from(menuItemCollection).filter(a => {\n        if (+a.dataset.id === currentTestId) {\n          a.classList.add('current');\n        }\n      });\n    }\n  },\n  nextQ: () => {\n    let current = _test.currentQ();\n\n    if (current.id > current.navLength - 2) return false;\n\n    let aimNavId = _test.aimNavIdFunction(current.id, 'next');\n\n    let aimQEl = _test.aimQElFunction(current, 'next');\n\n    _test.pushNav(current.id, aimNavId);\n\n    _test.pushQ(current.QEl, aimQEl);\n  },\n  prevQ: () => {\n    let current = _test.currentQ();\n\n    if (current.id < 1) return false;\n\n    let aimNavId = _test.aimNavIdFunction(current.id, 'back');\n\n    let aimQEl = _test.aimQElFunction(current, 'back');\n\n    _test.pushNav(current.id, aimNavId);\n\n    _test.pushQ(current.QEl, aimQEl);\n  },\n  pushNav: (currentId, aimNavId) => {\n    let currNavEl = common_$('[data-pagination]').el[currentId];\n    currNavEl.classList.toggle('nav-active');\n    let NavEl = common_$('[data-pagination]').el[aimNavId];\n    NavEl.classList.toggle('nav-active');\n  },\n  pushQ: (currentEl, aimQEl) => {\n    currentEl.classList.toggle('flex1');\n    aimQEl.classList.toggle('flex1');\n  },\n  aimNavIdFunction: (currentId, direction) => {\n    let dir = currentId;\n\n    switch (true) {\n      case direction === 'next':\n        return dir += 1;\n        break;\n\n      case direction === 'back':\n        return dir -= 1;\n        break;\n    }\n  },\n  aimQElFunction: (current, direction) => {\n    switch (true) {\n      case direction === 'next':\n        return current.QNextEl;\n        break;\n\n      case direction === 'back':\n        return current.QPrevc;\n        break;\n    }\n  },\n  currentQ: () => {\n    return {\n      id: common_$('.nav-active').el[0].innerText - 1,\n      QEl: common_$('.question.flex1').el[0],\n      navLength: common_$('[data-pagination]').length,\n      QPrevc: common_$('.question.flex1').el[0].previousElementSibling,\n      QNextEl: common_$('.question.flex1').el[0].nextElementSibling\n    };\n  },\n  viewModel: () => {\n    return {\n      id: +window.location.href.split('/').pop(),\n      test_name: common_$('#test_name').text(),\n      enable: common_$('#enable')[0],\n      parent: common_$('select').selectedIndexValue()\n    };\n  },\n  id: id => {\n    return id ?? common_$('.test-name').value();\n  },\n  children: () => {\n    let childrenLenght = common_$('.children').length;\n    if (childrenLenght) return childrenLenght;\n    return false;\n  },\n  path_create: async () => {\n    let test_path = _test.serverModel();\n\n    test_path.id = 0;\n    test_path.isTest = 0;\n    let url = `/test/create`;\n    let res = await post(url, test_path);\n    res = await JSON.parse(res);\n\n    if (res) {\n      window.location.href = `/adminsc/test/edit/${res.id - 1}`;\n    }\n  },\n  name: () => {\n    return common_$('.test-name').el[0].innerText;\n  },\n  create: async () => {\n    debugger;\n\n    let test = _test.serverModel();\n\n    test.id = 0;\n    test.isTest = 1;\n    let url = `/test/updateOrCreate`;\n    let res = await post(url, test);\n    res = await JSON.parse(res);\n\n    if (res) {\n      window.location.href = `/adminsc/test/edit/${res.id - 1}`;\n    }\n  },\n\n  selectedValueCustomSelect(className) {\n    let select = common_$(`[data-custom-${className}]`)[0];\n    let selected = [...select.options].filter(opt => opt.selected);\n\n    if (selected) {\n      return +selected[0].value;\n    }\n  },\n\n  serverModel: () => {\n    return {\n      id: +window.location.href.split('/').pop(),\n      test_name: common_$('#test_name').el[0].value,\n      isTest: +common_$('[isTest]').el[0].getAttribute('isTest'),\n      enable: _test.selectedValueCustomSelect('enable'),\n      parent: _test.selectedValueCustomSelect('parent')\n    };\n  },\n  update: async (parent, enable) => {\n    debugger;\n\n    let model = _test.serverModel(parent, enable);\n\n    let url = `/adminsc/test/update/${model.id}`;\n    let res = await post(url, model);\n    res = await JSON.parse(res); // if (res) {\n    //   window.location.href = `/adminsc/test/edit/${model.id}`\n    // }\n  },\n  delete: async function () {\n    if (_test.children()) {\n      popup.show('Сначала удалите все тесты из папки');\n      return false;\n    }\n\n    let viewModel = _test.viewModel(); // viewModel.enable.checked = false\n\n\n    let serverModel = _test.serverModel();\n\n    let res = await post('/test/delete', {\n      test: serverModel\n    });\n    res = await JSON.parse(res);\n\n    if (res.notAdmin) {\n      popup.show('Видимость теста скрыта. Чтобы удалить полностью - обратитесь к ГД');\n      setTimeout(() => {\n        window.location = '/adminsc/test/edit/400';\n      }, 4000);\n    } else {\n      window.location = '/adminsc/test/edit/400';\n    }\n  }\n};\n;// CONCATENATED MODULE: ./public/src/components/select/WDSSelect.js\n\nclass WDSSelect {\n  constructor(props) {\n    if (!props.element) return false;\n    this.element = props.element;\n    this.title = props.title;\n    this.options = getFormattedOptions(this.element.querySelectorAll(\"option\"));\n    this.sel = document.createElement(\"div\");\n    this.sel.classList.add(props.class);\n    this.label = document.createElement(\"span\");\n    this.titleElement = document.createElement(\"div\");\n    this.ul = document.createElement(\"ul\");\n    setup(this);\n    this.element.style.display = \"none\";\n    this.element.after(this.sel);\n  }\n\n  get selectedOption() {\n    return this.options.find(option => option.selected);\n  }\n\n  get selectedOptionIndex() {\n    return this.options.indexOf(this.selectedOption);\n  }\n\n  selectValue(value) {\n    const newSelectedOption = this.options.find(option => {\n      return option.value === value;\n    });\n    const prevSelectedOption = this.selectedOption;\n    prevSelectedOption.selected = false;\n    prevSelectedOption.element.selected = false;\n    newSelectedOption.selected = true;\n    newSelectedOption.element.selected = true;\n    this.label.innerText = newSelectedOption.label;\n    this.ul.querySelector(`[data-value=\"${prevSelectedOption.value}\"]`).classList.remove(\"selected\");\n    const newCustomElement = this.ul.querySelector(`[data-value=\"${newSelectedOption.value}\"]`);\n    newCustomElement.classList.add(\"selected\");\n    newCustomElement.scrollIntoView({\n      block: \"nearest\"\n    });\n  }\n\n}\n\nfunction setup(select) {\n  select.sel.classList.add(\"custom-select-container\");\n  select.sel.tabIndex = 0;\n  select.titleElement.classList.add(\"custom-select-title\");\n  select.titleElement.innerText = select.title;\n  select.sel.append(select.titleElement); // debugger\n\n  select.label.classList.add(\"custom-select-value\");\n  select.label.innerText = select.selectedOption.label;\n  select.sel.append(select.label);\n  select.ul.classList.add(\"custom-select-options\");\n  select.options.forEach(option => {\n    setOption(option);\n  });\n\n  function setOption(option) {\n    const li = document.createElement(\"li\");\n    li.classList.add(\"custom-select-option\");\n    li.classList.toggle(\"selected\", option.selected);\n    li.innerText = option.label;\n    li.dataset.value = option.value;\n    li.addEventListener(\"click\", () => {\n      select.selectValue(option.value);\n      select.ul.classList.remove(\"show\");\n    });\n    select.ul.append(li);\n  }\n\n  select.sel.append(select.ul);\n  select.label.addEventListener(\"click\", () => {\n    select.ul.classList.toggle(\"show\");\n  });\n  select.sel.addEventListener(\"blur\", () => {\n    select.ul.classList.remove(\"show\");\n  });\n  let debounceTimeout;\n  let searchTerm = \"\";\n  select.sel.addEventListener(\"keydown\", e => {\n    switch (e.code) {\n      case \"Space\":\n        select.ul.classList.toggle(\"show\");\n        break;\n\n      case \"ArrowUp\":\n        {\n          const prevOption = select.options[select.selectedOptionIndex - 1];\n\n          if (prevOption) {\n            select.selectValue(prevOption.value);\n          }\n\n          break;\n        }\n\n      case \"ArrowDown\":\n        {\n          const nextOption = select.options[select.selectedOptionIndex + 1];\n\n          if (nextOption) {\n            select.selectValue(nextOption.value);\n          }\n\n          break;\n        }\n\n      case \"Enter\":\n      case \"Escape\":\n        select.ul.classList.remove(\"show\");\n        break;\n\n      default:\n        {\n          clearTimeout(debounceTimeout);\n          searchTerm += e.key;\n          debounceTimeout = setTimeout(() => {\n            searchTerm = \"\";\n          }, 500);\n          const searchedOption = select.options.find(option => {\n            return option.label.toLowerCase().startsWith(searchTerm);\n          });\n\n          if (searchedOption) {\n            select.selectValue(searchedOption.value);\n          }\n        }\n    }\n  });\n}\n\nfunction getFormattedOptions(options) {\n  return [...options].map(option => {\n    return {\n      value: option.value,\n      label: option.label,\n      selected: option.selected,\n      element: option\n    };\n  });\n}\n;// CONCATENATED MODULE: ./public/src/Test/accordion-show.js\n\nfunction accordionShow() {\n  let button = common_$('.test-edit__menu-toggle')[0];\n\n  if (button) {\n    common_$(button).on('click', function () {\n      let menu = common_$('.test-edit__accordion')[0];\n      menu.classList.toggle('open');\n    });\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Test/test-update.js\n\n\n\n\n\nfunction testUpdate() {\n  debugger;\n  accordionShow();\n  let parentSelect = new WDSSelect({\n    element: common_$(\"[data-custom-parent]\")[0],\n    title: 'Лежит в папке',\n    class: 'parent'\n  });\n  let enableSelect = new WDSSelect({\n    element: common_$(\"[data-custom-enable]\")[0],\n    title: 'Показывать пользователям',\n    class: 'enable'\n  });\n  common_$(\".test__save\").on('click', _test.update);\n  common_$(\".test__delete\").on('click', _test[\"delete\"]);\n  common_$(\".test-path__create\").on('click', _test.path_create);\n  common_$(\".test__create\").on('click', _test.create);\n}\n;// CONCATENATED MODULE: ./public/src/Test/model/answer.js\n\nlet answer_answer = {\n  el: add_button => {\n    let answers = add_button.parentNode.querySelectorAll('.answer');\n    let prev_sort = 0;\n\n    if (answers.length) {\n      prev_sort = +common_$(answers[answers.length - 1]).find('.answer__sort').innerText;\n    }\n\n    let el = common_$('.answer__create').find('.answer').cloneNode(true);\n    el.classList.add('answer');\n    el.classList.remove('answer__create'); // let delBtn = $(el).find('.answer__delete')\n    // $(delBtn).on('click', _answer.del)\n\n    return {\n      el: el,\n      id: 'new',\n      q_id: +add_button.closest('.question-edit').id,\n      previous_sort: prev_sort,\n      answerCnt: answers.length,\n      sort: common_$(el).find('.answer__sort'),\n      checked: common_$(el).find('input'),\n      text: common_$(el).find('.answer__text'),\n      delete: common_$(common_$(el).find('.answer__delete')).on('click', function () {\n        answer_answer.del(this);\n      })\n    };\n  },\n\n  getModelForServer(el) {\n    return {\n      answer: '',\n      parent_question: el.q_id,\n      correct_answer: 0,\n      pica: ''\n    };\n  },\n\n  async create(e) {\n    let button = e.target; // debugger\n\n    let a_id = await createOnServer(button);\n    show(a_id);\n\n    async function createOnServer(button) {\n      let newEl = answer_answer.getModelForServer(answer_answer.el(button));\n\n      let res = await post('/answer/create', newEl);\n      res = JSON.parse(res);\n      return res.id;\n    }\n\n    function show(a_id) {\n      let el = answer_answer.el(button);\n\n      el.checked.checked = false;\n      el.el.dataset['answerId'] = a_id;\n      el.text.innerText = '';\n      el.sort.innerText = el.answerCnt + 1;\n      el.el.style.display = 'flex';\n      button.before(el.el);\n      el.el.style.opacity = 1;\n    }\n  },\n\n  async del(e) {\n    let del_button = e.type === \"click\" ? e.target : e;\n\n    if (confirm(\"Удалить этот ответ?\")) {\n      let res = await deleteFromServer(del_button);\n      deleteFromView(del_button);\n    }\n\n    function deleteFromView(del_button) {\n      del_button.closest('.answer').remove();\n    }\n\n    async function deleteFromServer(del_button) {\n      let a_id = +del_button.closest('.answer').dataset['answerId'];\n      let res = await post('/answer/delete', {\n        a_id\n      });\n      res = JSON.parse(res);\n\n      if (res.msg === 'ok') {\n        popup.show('Ответ удален');\n      }\n    }\n  }\n\n};\n;// CONCATENATED MODULE: ./public/src/Test/model/question.js\n\n\nlet question_question = {\n  sort: async function (upToQestionNumber) {\n    let questions = [...question_question.questions()];\n    let questionsEls = questions.filter(function (el, i) {\n      if (i + 1 < upToQestionNumber) return el;\n    });\n    let toChange = questionsEls.map(el => {\n      return el.id;\n    });\n    let res = await post('/question/sort', {\n      toChange\n    });\n    res = JSON.parse(res);\n\n    if (res.msg) {\n      popup.show(res.msg);\n    }\n\n    questionsEls.map((el, i) => {\n      common_$(el).find('.question__sort').innerText = i + 1;\n    });\n  },\n  changeParent: async function (e) {\n    let sel = e.target;\n    let opt = sel.options[sel.selectedIndex];\n    let id = sel.closest('.question-edit').id;\n    let test_id = opt.dataset['questionParentId'];\n    let test_name = opt.value;\n    let res = await post('/question/changeParent', {\n      id,\n      test_id\n    });\n    res = JSON.parse(res);\n    if (res.msg !== 'ok') throw e;\n    let question = sel.closest('.question-edit');\n    question.remove();\n    popup.show('Перемещен в ' + test_name); // debugger\n  },\n  showTip: (action, event) => {\n    let el = event.target;\n    let tip = document.createElement(\"div\");\n\n    if (action === 'save.svg') {\n      addTooltip(el, 'сохранить');\n    }\n  },\n  showFirst: () => {\n    let question = question_question.cloneEmptyModel();\n\n    if (!question) return;\n\n    let model = question_question.viewModel(question);\n\n    model.sort.innerText = '1';\n    common_$(model.save).on('click', question_question.save);\n    common_$(model.del).on('click', question_question.delete);\n    common_$(question).addClass('question-edit');\n    common_$(question).removeClass('question__create');\n    let questions = common_$('.questions').el[0];\n    questions.prepend(question);\n  },\n  cloneEmptyModel: () => {\n    let question = common_$('.questions .question__create .question-edit').el[0];\n    if (question) return question.cloneNode(true);\n  },\n  showAnswers: e => {\n    let text = e.target;\n    let parent = text.parentNode.parentNode;\n    let answers = common_$(parent).find('.question__answers');\n    answers.classList.toggle('height');\n    answers.classList.toggle('scale');\n    text.classList.toggle('rotate');\n  },\n  viewModel: el => {\n    return {\n      id: +el.id,\n      el: el,\n      sort: el.querySelector('.question__sort'),\n      save: el.querySelector('.question__save'),\n      text: el.querySelector('.question__text'),\n      del: el.querySelector('.question__delete'),\n      createAnswerButton: el.querySelector('.answer__create-button'),\n      addButton: common_$(common_$('.questions').el[0]).find('.question__create-button')\n    };\n  },\n  serverModel: () => {\n    return {\n      question: {\n        id: null,\n        qustion: '',\n        parent: +window.location.href.split('/').pop(),\n        sort: question_question.lastSort()\n      }\n    };\n  },\n  questions: () => {\n    let qs = common_$('.questions>.question-edit'); // debugger\n\n    return common_$('.questions>.question-edit'); // return $('.questions>.question-edit').el\n  },\n  questionsCount: () => {\n    return common_$('.questions>.question-edit').el.length;\n  },\n  lastSort: () => {\n    let qs = question_question.questions();\n\n    let length = qs.length - 1;\n    let last = +question_question.viewModel(qs[length]).sort.innerText;\n    return last + 1;\n  },\n  create: async e => {\n    let q_id = await question_question.createOnServer(e);\n\n    if (q_id) {\n      question_question.createOnView(q_id);\n    }\n  },\n  createOnServer: async () => {\n    let question = question_question.serverModel();\n\n    let res = await post('/question/updateOrCreate', {\n      question: question.question,\n      answers: {}\n    });\n    res = await JSON.parse(res);\n    return res.id;\n  },\n  createOnView: q_id => {\n    let clone = question_question.cloneEmptyModel();\n\n    let model = question_question.viewModel(clone);\n\n    common_$(model.save).on('click', question_question.save);\n    common_$(model.del).on('click', question_question.delete);\n    common_$(model.text).on('click', question_question.showAnswers);\n    common_$(model.createAnswerButton).on('click', answer_answer.create);\n    model.sort.innerText = question_question.lastSort();\n    model.text.innerText = '';\n    model.el.id = q_id;\n    model.addButton.before(clone);\n  },\n  save: async e => {\n    let question = e.target.closest('.question-edit');\n    let res = await post('/question/UpdateOrCreate', {\n      question: question_question.getModelForServer(question),\n      answers: question_question.getAnswers(question)\n    });\n    res = await JSON.parse(res);\n    popup.show(res.msg);\n  },\n  delete: async e => {\n    if (confirm(\"Удалить вопрос со всеми его ответами?\")) {\n      let viewModel = question_question.viewModel(e.target.closest('.question-edit'));\n\n      let id = viewModel.id;\n      let deleted = await question_question.deleteFromServer(id);\n\n      if (deleted) {\n        question_question.deleteFromView(viewModel);\n\n        popup.show(deleted.msg);\n      }\n    }\n  },\n  deleteFromView: async viewModel => {\n    viewModel.el.remove();\n  },\n  deleteFromServer: async q_id => {\n    let res = await post('/question/delete', {\n      q_id\n    });\n    return JSON.parse(res);\n  },\n  getModelForServer: question => {\n    return {\n      id: +question.id,\n      parent: +common_$('.test-name').el[0].getAttribute('value'),\n      picq: '',\n      qustion: common_$(question).find('.question__text').innerText,\n      sort: +common_$(question).find('.question__sort').innerText\n    };\n  },\n  getAnswers: question => {\n    let answerBlocks = question.querySelectorAll('.answer');\n    return [...answerBlocks].map(a => {\n      return {\n        id: +a.dataset['answerId'],\n        answer: a.querySelector('.answer__text').innerText,\n        correct_answer: +a.querySelector('[type=\"checkbox\"]').checked,\n        parent_question: +question.id,\n        pica: ''\n      };\n    }, question);\n  }\n};\n;// CONCATENATED MODULE: ./node_modules/sortablejs/modular/sortable.esm.js\n/**!\n * Sortable 1.14.0\n * @author\tRubaXa   <trash@rubaxa.org>\n * @author\towenm    <owen23355@gmail.com>\n * @license MIT\n */\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        sortable_esm_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction sortable_esm_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar version = \"1.14.0\";\n\nfunction userAgent(pattern) {\n  if (typeof window !== 'undefined' && window.navigator) {\n    return !! /*@__PURE__*/navigator.userAgent.match(pattern);\n  }\n}\n\nvar IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\\.|msie|iemobile|Windows Phone)/i);\nvar Edge = userAgent(/Edge/i);\nvar FireFox = userAgent(/firefox/i);\nvar Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);\nvar IOS = userAgent(/iP(ad|od|hone)/i);\nvar ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);\n\nvar captureMode = {\n  capture: false,\n  passive: false\n};\n\nfunction on(el, event, fn) {\n  el.addEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction off(el, event, fn) {\n  el.removeEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction matches(\n/**HTMLElement*/\nel,\n/**String*/\nselector) {\n  if (!selector) return;\n  selector[0] === '>' && (selector = selector.substring(1));\n\n  if (el) {\n    try {\n      if (el.matches) {\n        return el.matches(selector);\n      } else if (el.msMatchesSelector) {\n        return el.msMatchesSelector(selector);\n      } else if (el.webkitMatchesSelector) {\n        return el.webkitMatchesSelector(selector);\n      }\n    } catch (_) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction getParentOrHost(el) {\n  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;\n}\n\nfunction closest(\n/**HTMLElement*/\nel,\n/**String*/\nselector,\n/**HTMLElement*/\nctx, includeCTX) {\n  if (el) {\n    ctx = ctx || document;\n\n    do {\n      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {\n        return el;\n      }\n\n      if (el === ctx) break;\n      /* jshint boss:true */\n    } while (el = getParentOrHost(el));\n  }\n\n  return null;\n}\n\nvar R_SPACE = /\\s+/g;\n\nfunction toggleClass(el, name, state) {\n  if (el && name) {\n    if (el.classList) {\n      el.classList[state ? 'add' : 'remove'](name);\n    } else {\n      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');\n      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');\n    }\n  }\n}\n\nfunction css(el, prop, val) {\n  var style = el && el.style;\n\n  if (style) {\n    if (val === void 0) {\n      if (document.defaultView && document.defaultView.getComputedStyle) {\n        val = document.defaultView.getComputedStyle(el, '');\n      } else if (el.currentStyle) {\n        val = el.currentStyle;\n      }\n\n      return prop === void 0 ? val : val[prop];\n    } else {\n      if (!(prop in style) && prop.indexOf('webkit') === -1) {\n        prop = '-webkit-' + prop;\n      }\n\n      style[prop] = val + (typeof val === 'string' ? '' : 'px');\n    }\n  }\n}\n\nfunction matrix(el, selfOnly) {\n  var appliedTransforms = '';\n\n  if (typeof el === 'string') {\n    appliedTransforms = el;\n  } else {\n    do {\n      var transform = css(el, 'transform');\n\n      if (transform && transform !== 'none') {\n        appliedTransforms = transform + ' ' + appliedTransforms;\n      }\n      /* jshint boss:true */\n\n    } while (!selfOnly && (el = el.parentNode));\n  }\n\n  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;\n  /*jshint -W056 */\n\n  return matrixFn && new matrixFn(appliedTransforms);\n}\n\nfunction find(ctx, tagName, iterator) {\n  if (ctx) {\n    var list = ctx.getElementsByTagName(tagName),\n        i = 0,\n        n = list.length;\n\n    if (iterator) {\n      for (; i < n; i++) {\n        iterator(list[i], i);\n      }\n    }\n\n    return list;\n  }\n\n  return [];\n}\n\nfunction getWindowScrollingElement() {\n  var scrollingElement = document.scrollingElement;\n\n  if (scrollingElement) {\n    return scrollingElement;\n  } else {\n    return document.documentElement;\n  }\n}\n/**\n * Returns the \"bounding client rect\" of given element\n * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted\n * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container\n * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr\n * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone\n * @param  {[HTMLElement]} container              The parent the element will be placed in\n * @return {Object}                               The boundingClientRect of el, with specified adjustments\n */\n\n\nfunction getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {\n  if (!el.getBoundingClientRect && el !== window) return;\n  var elRect, top, left, bottom, right, height, width;\n\n  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {\n    elRect = el.getBoundingClientRect();\n    top = elRect.top;\n    left = elRect.left;\n    bottom = elRect.bottom;\n    right = elRect.right;\n    height = elRect.height;\n    width = elRect.width;\n  } else {\n    top = 0;\n    left = 0;\n    bottom = window.innerHeight;\n    right = window.innerWidth;\n    height = window.innerHeight;\n    width = window.innerWidth;\n  }\n\n  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {\n    // Adjust for translate()\n    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)\n    // Not needed on <= IE11\n\n    if (!IE11OrLess) {\n      do {\n        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {\n          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container\n\n          top -= containerRect.top + parseInt(css(container, 'border-top-width'));\n          left -= containerRect.left + parseInt(css(container, 'border-left-width'));\n          bottom = top + elRect.height;\n          right = left + elRect.width;\n          break;\n        }\n        /* jshint boss:true */\n\n      } while (container = container.parentNode);\n    }\n  }\n\n  if (undoScale && el !== window) {\n    // Adjust for scale()\n    var elMatrix = matrix(container || el),\n        scaleX = elMatrix && elMatrix.a,\n        scaleY = elMatrix && elMatrix.d;\n\n    if (elMatrix) {\n      top /= scaleY;\n      left /= scaleX;\n      width /= scaleX;\n      height /= scaleY;\n      bottom = top + height;\n      right = left + width;\n    }\n  }\n\n  return {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    width: width,\n    height: height\n  };\n}\n/**\n * Checks if a side of an element is scrolled past a side of its parents\n * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question\n * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')\n * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')\n * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element\n */\n\n\nfunction isScrolledPast(el, elSide, parentSide) {\n  var parent = getParentAutoScrollElement(el, true),\n      elSideVal = getRect(el)[elSide];\n  /* jshint boss:true */\n\n  while (parent) {\n    var parentSideVal = getRect(parent)[parentSide],\n        visible = void 0;\n\n    if (parentSide === 'top' || parentSide === 'left') {\n      visible = elSideVal >= parentSideVal;\n    } else {\n      visible = elSideVal <= parentSideVal;\n    }\n\n    if (!visible) return parent;\n    if (parent === getWindowScrollingElement()) break;\n    parent = getParentAutoScrollElement(parent, false);\n  }\n\n  return false;\n}\n/**\n * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\n * and non-draggable elements\n * @param  {HTMLElement} el       The parent element\n * @param  {Number} childNum      The index of the child\n * @param  {Object} options       Parent Sortable's options\n * @return {HTMLElement}          The child at index childNum, or null if not found\n */\n\n\nfunction getChild(el, childNum, options, includeDragEl) {\n  var currentChild = 0,\n      i = 0,\n      children = el.children;\n\n  while (i < children.length) {\n    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {\n      if (currentChild === childNum) {\n        return children[i];\n      }\n\n      currentChild++;\n    }\n\n    i++;\n  }\n\n  return null;\n}\n/**\n * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\n * @param  {HTMLElement} el       Parent element\n * @param  {selector} selector    Any other elements that should be ignored\n * @return {HTMLElement}          The last child, ignoring ghostEl\n */\n\n\nfunction lastChild(el, selector) {\n  var last = el.lastElementChild;\n\n  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {\n    last = last.previousElementSibling;\n  }\n\n  return last || null;\n}\n/**\n * Returns the index of an element within its parent for a selected set of\n * elements\n * @param  {HTMLElement} el\n * @param  {selector} selector\n * @return {number}\n */\n\n\nfunction index(el, selector) {\n  var index = 0;\n\n  if (!el || !el.parentNode) {\n    return -1;\n  }\n  /* jshint boss:true */\n\n\n  while (el = el.previousElementSibling) {\n    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {\n      index++;\n    }\n  }\n\n  return index;\n}\n/**\n * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\n * The value is returned in real pixels.\n * @param  {HTMLElement} el\n * @return {Array}             Offsets in the format of [left, top]\n */\n\n\nfunction getRelativeScrollOffset(el) {\n  var offsetLeft = 0,\n      offsetTop = 0,\n      winScroller = getWindowScrollingElement();\n\n  if (el) {\n    do {\n      var elMatrix = matrix(el),\n          scaleX = elMatrix.a,\n          scaleY = elMatrix.d;\n      offsetLeft += el.scrollLeft * scaleX;\n      offsetTop += el.scrollTop * scaleY;\n    } while (el !== winScroller && (el = el.parentNode));\n  }\n\n  return [offsetLeft, offsetTop];\n}\n/**\n * Returns the index of the object within the given array\n * @param  {Array} arr   Array that may or may not hold the object\n * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find\n * @return {Number}      The index of the object in the array, or -1\n */\n\n\nfunction indexOfObject(arr, obj) {\n  for (var i in arr) {\n    if (!arr.hasOwnProperty(i)) continue;\n\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);\n    }\n  }\n\n  return -1;\n}\n\nfunction getParentAutoScrollElement(el, includeSelf) {\n  // skip to window\n  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();\n  var elem = el;\n  var gotSelf = false;\n\n  do {\n    // we don't need to get elem css if it isn't even overflowing in the first place (performance)\n    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {\n      var elemCSS = css(elem);\n\n      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {\n        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();\n        if (gotSelf || includeSelf) return elem;\n        gotSelf = true;\n      }\n    }\n    /* jshint boss:true */\n\n  } while (elem = elem.parentNode);\n\n  return getWindowScrollingElement();\n}\n\nfunction extend(dst, src) {\n  if (dst && src) {\n    for (var key in src) {\n      if (src.hasOwnProperty(key)) {\n        dst[key] = src[key];\n      }\n    }\n  }\n\n  return dst;\n}\n\nfunction isRectEqual(rect1, rect2) {\n  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);\n}\n\nvar _throttleTimeout;\n\nfunction throttle(callback, ms) {\n  return function () {\n    if (!_throttleTimeout) {\n      var args = arguments,\n          _this = this;\n\n      if (args.length === 1) {\n        callback.call(_this, args[0]);\n      } else {\n        callback.apply(_this, args);\n      }\n\n      _throttleTimeout = setTimeout(function () {\n        _throttleTimeout = void 0;\n      }, ms);\n    }\n  };\n}\n\nfunction cancelThrottle() {\n  clearTimeout(_throttleTimeout);\n  _throttleTimeout = void 0;\n}\n\nfunction scrollBy(el, x, y) {\n  el.scrollLeft += x;\n  el.scrollTop += y;\n}\n\nfunction clone(el) {\n  var Polymer = window.Polymer;\n  var $ = window.jQuery || window.Zepto;\n\n  if (Polymer && Polymer.dom) {\n    return Polymer.dom(el).cloneNode(true);\n  } else if ($) {\n    return $(el).clone(true)[0];\n  } else {\n    return el.cloneNode(true);\n  }\n}\n\nfunction setRect(el, rect) {\n  css(el, 'position', 'absolute');\n  css(el, 'top', rect.top);\n  css(el, 'left', rect.left);\n  css(el, 'width', rect.width);\n  css(el, 'height', rect.height);\n}\n\nfunction unsetRect(el) {\n  css(el, 'position', '');\n  css(el, 'top', '');\n  css(el, 'left', '');\n  css(el, 'width', '');\n  css(el, 'height', '');\n}\n\nvar expando = 'Sortable' + new Date().getTime();\n\nfunction AnimationStateManager() {\n  var animationStates = [],\n      animationCallbackId;\n  return {\n    captureAnimationState: function captureAnimationState() {\n      animationStates = [];\n      if (!this.options.animation) return;\n      var children = [].slice.call(this.el.children);\n      children.forEach(function (child) {\n        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;\n        animationStates.push({\n          target: child,\n          rect: getRect(child)\n        });\n\n        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation\n\n\n        if (child.thisAnimationDuration) {\n          var childMatrix = matrix(child, true);\n\n          if (childMatrix) {\n            fromRect.top -= childMatrix.f;\n            fromRect.left -= childMatrix.e;\n          }\n        }\n\n        child.fromRect = fromRect;\n      });\n    },\n    addAnimationState: function addAnimationState(state) {\n      animationStates.push(state);\n    },\n    removeAnimationState: function removeAnimationState(target) {\n      animationStates.splice(indexOfObject(animationStates, {\n        target: target\n      }), 1);\n    },\n    animateAll: function animateAll(callback) {\n      var _this = this;\n\n      if (!this.options.animation) {\n        clearTimeout(animationCallbackId);\n        if (typeof callback === 'function') callback();\n        return;\n      }\n\n      var animating = false,\n          animationTime = 0;\n      animationStates.forEach(function (state) {\n        var time = 0,\n            target = state.target,\n            fromRect = target.fromRect,\n            toRect = getRect(target),\n            prevFromRect = target.prevFromRect,\n            prevToRect = target.prevToRect,\n            animatingRect = state.rect,\n            targetMatrix = matrix(target, true);\n\n        if (targetMatrix) {\n          // Compensate for current animation\n          toRect.top -= targetMatrix.f;\n          toRect.left -= targetMatrix.e;\n        }\n\n        target.toRect = toRect;\n\n        if (target.thisAnimationDuration) {\n          // Could also check if animatingRect is between fromRect and toRect\n          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect\n          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {\n            // If returning to same place as started from animation and on same axis\n            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);\n          }\n        } // if fromRect != toRect: animate\n\n\n        if (!isRectEqual(toRect, fromRect)) {\n          target.prevFromRect = fromRect;\n          target.prevToRect = toRect;\n\n          if (!time) {\n            time = _this.options.animation;\n          }\n\n          _this.animate(target, animatingRect, toRect, time);\n        }\n\n        if (time) {\n          animating = true;\n          animationTime = Math.max(animationTime, time);\n          clearTimeout(target.animationResetTimer);\n          target.animationResetTimer = setTimeout(function () {\n            target.animationTime = 0;\n            target.prevFromRect = null;\n            target.fromRect = null;\n            target.prevToRect = null;\n            target.thisAnimationDuration = null;\n          }, time);\n          target.thisAnimationDuration = time;\n        }\n      });\n      clearTimeout(animationCallbackId);\n\n      if (!animating) {\n        if (typeof callback === 'function') callback();\n      } else {\n        animationCallbackId = setTimeout(function () {\n          if (typeof callback === 'function') callback();\n        }, animationTime);\n      }\n\n      animationStates = [];\n    },\n    animate: function animate(target, currentRect, toRect, duration) {\n      if (duration) {\n        css(target, 'transition', '');\n        css(target, 'transform', '');\n        var elMatrix = matrix(this.el),\n            scaleX = elMatrix && elMatrix.a,\n            scaleY = elMatrix && elMatrix.d,\n            translateX = (currentRect.left - toRect.left) / (scaleX || 1),\n            translateY = (currentRect.top - toRect.top) / (scaleY || 1);\n        target.animatingX = !!translateX;\n        target.animatingY = !!translateY;\n        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');\n        this.forRepaintDummy = repaint(target); // repaint\n\n        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));\n        css(target, 'transform', 'translate3d(0,0,0)');\n        typeof target.animated === 'number' && clearTimeout(target.animated);\n        target.animated = setTimeout(function () {\n          css(target, 'transition', '');\n          css(target, 'transform', '');\n          target.animated = false;\n          target.animatingX = false;\n          target.animatingY = false;\n        }, duration);\n      }\n    }\n  };\n}\n\nfunction repaint(target) {\n  return target.offsetWidth;\n}\n\nfunction calculateRealTime(animatingRect, fromRect, toRect, options) {\n  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;\n}\n\nvar plugins = [];\nvar defaults = {\n  initializeByDefault: true\n};\nvar PluginManager = {\n  mount: function mount(plugin) {\n    // Set default static properties\n    for (var option in defaults) {\n      if (defaults.hasOwnProperty(option) && !(option in plugin)) {\n        plugin[option] = defaults[option];\n      }\n    }\n\n    plugins.forEach(function (p) {\n      if (p.pluginName === plugin.pluginName) {\n        throw \"Sortable: Cannot mount plugin \".concat(plugin.pluginName, \" more than once\");\n      }\n    });\n    plugins.push(plugin);\n  },\n  pluginEvent: function pluginEvent(eventName, sortable, evt) {\n    var _this = this;\n\n    this.eventCanceled = false;\n\n    evt.cancel = function () {\n      _this.eventCanceled = true;\n    };\n\n    var eventNameGlobal = eventName + 'Global';\n    plugins.forEach(function (plugin) {\n      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable\n\n      if (sortable[plugin.pluginName][eventNameGlobal]) {\n        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({\n          sortable: sortable\n        }, evt));\n      } // Only fire plugin event if plugin is enabled in this sortable,\n      // and plugin has event defined\n\n\n      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {\n        sortable[plugin.pluginName][eventName](_objectSpread2({\n          sortable: sortable\n        }, evt));\n      }\n    });\n  },\n  initializePlugins: function initializePlugins(sortable, el, defaults, options) {\n    plugins.forEach(function (plugin) {\n      var pluginName = plugin.pluginName;\n      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;\n      var initialized = new plugin(sortable, el, sortable.options);\n      initialized.sortable = sortable;\n      initialized.options = sortable.options;\n      sortable[pluginName] = initialized; // Add default options from plugin\n\n      _extends(defaults, initialized.defaults);\n    });\n\n    for (var option in sortable.options) {\n      if (!sortable.options.hasOwnProperty(option)) continue;\n      var modified = this.modifyOption(sortable, option, sortable.options[option]);\n\n      if (typeof modified !== 'undefined') {\n        sortable.options[option] = modified;\n      }\n    }\n  },\n  getEventProperties: function getEventProperties(name, sortable) {\n    var eventProperties = {};\n    plugins.forEach(function (plugin) {\n      if (typeof plugin.eventProperties !== 'function') return;\n\n      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));\n    });\n    return eventProperties;\n  },\n  modifyOption: function modifyOption(sortable, name, value) {\n    var modifiedValue;\n    plugins.forEach(function (plugin) {\n      // Plugin must exist on the Sortable\n      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin\n\n      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {\n        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);\n      }\n    });\n    return modifiedValue;\n  }\n};\n\nfunction dispatchEvent(_ref) {\n  var sortable = _ref.sortable,\n      rootEl = _ref.rootEl,\n      name = _ref.name,\n      targetEl = _ref.targetEl,\n      cloneEl = _ref.cloneEl,\n      toEl = _ref.toEl,\n      fromEl = _ref.fromEl,\n      oldIndex = _ref.oldIndex,\n      newIndex = _ref.newIndex,\n      oldDraggableIndex = _ref.oldDraggableIndex,\n      newDraggableIndex = _ref.newDraggableIndex,\n      originalEvent = _ref.originalEvent,\n      putSortable = _ref.putSortable,\n      extraEventProperties = _ref.extraEventProperties;\n  sortable = sortable || rootEl && rootEl[expando];\n  if (!sortable) return;\n  var evt,\n      options = sortable.options,\n      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature\n\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent(name, {\n      bubbles: true,\n      cancelable: true\n    });\n  } else {\n    evt = document.createEvent('Event');\n    evt.initEvent(name, true, true);\n  }\n\n  evt.to = toEl || rootEl;\n  evt.from = fromEl || rootEl;\n  evt.item = targetEl || rootEl;\n  evt.clone = cloneEl;\n  evt.oldIndex = oldIndex;\n  evt.newIndex = newIndex;\n  evt.oldDraggableIndex = oldDraggableIndex;\n  evt.newDraggableIndex = newDraggableIndex;\n  evt.originalEvent = originalEvent;\n  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;\n\n  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));\n\n  for (var option in allEventProperties) {\n    evt[option] = allEventProperties[option];\n  }\n\n  if (rootEl) {\n    rootEl.dispatchEvent(evt);\n  }\n\n  if (options[onName]) {\n    options[onName].call(sortable, evt);\n  }\n}\n\nvar _excluded = [\"evt\"];\n\nvar pluginEvent = function pluginEvent(eventName, sortable) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      originalEvent = _ref.evt,\n      data = _objectWithoutProperties(_ref, _excluded);\n\n  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({\n    dragEl: dragEl,\n    parentEl: parentEl,\n    ghostEl: ghostEl,\n    rootEl: rootEl,\n    nextEl: nextEl,\n    lastDownEl: lastDownEl,\n    cloneEl: cloneEl,\n    cloneHidden: cloneHidden,\n    dragStarted: moved,\n    putSortable: putSortable,\n    activeSortable: Sortable.active,\n    originalEvent: originalEvent,\n    oldIndex: oldIndex,\n    oldDraggableIndex: oldDraggableIndex,\n    newIndex: newIndex,\n    newDraggableIndex: newDraggableIndex,\n    hideGhostForTarget: _hideGhostForTarget,\n    unhideGhostForTarget: _unhideGhostForTarget,\n    cloneNowHidden: function cloneNowHidden() {\n      cloneHidden = true;\n    },\n    cloneNowShown: function cloneNowShown() {\n      cloneHidden = false;\n    },\n    dispatchSortableEvent: function dispatchSortableEvent(name) {\n      _dispatchEvent({\n        sortable: sortable,\n        name: name,\n        originalEvent: originalEvent\n      });\n    }\n  }, data));\n};\n\nfunction _dispatchEvent(info) {\n  dispatchEvent(_objectSpread2({\n    putSortable: putSortable,\n    cloneEl: cloneEl,\n    targetEl: dragEl,\n    rootEl: rootEl,\n    oldIndex: oldIndex,\n    oldDraggableIndex: oldDraggableIndex,\n    newIndex: newIndex,\n    newDraggableIndex: newDraggableIndex\n  }, info));\n}\n\nvar dragEl,\n    parentEl,\n    ghostEl,\n    rootEl,\n    nextEl,\n    lastDownEl,\n    cloneEl,\n    cloneHidden,\n    oldIndex,\n    newIndex,\n    oldDraggableIndex,\n    newDraggableIndex,\n    activeGroup,\n    putSortable,\n    awaitingDragStarted = false,\n    ignoreNextClick = false,\n    sortables = [],\n    tapEvt,\n    touchEvt,\n    lastDx,\n    lastDy,\n    tapDistanceLeft,\n    tapDistanceTop,\n    moved,\n    lastTarget,\n    lastDirection,\n    pastFirstInvertThresh = false,\n    isCircumstantialInvert = false,\n    targetMoveDistance,\n    // For positioning ghost absolutely\nghostRelativeParent,\n    ghostRelativeParentInitialScroll = [],\n    // (left, top)\n_silent = false,\n    savedInputChecked = [];\n/** @const */\n\nvar documentExists = typeof document !== 'undefined',\n    PositionGhostAbsolutely = IOS,\n    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',\n    // This will not pass for IE9, because IE9 DnD only works on anchors\nsupportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),\n    supportCssPointerEvents = function () {\n  if (!documentExists) return; // false when <= IE11\n\n  if (IE11OrLess) {\n    return false;\n  }\n\n  var el = document.createElement('x');\n  el.style.cssText = 'pointer-events:auto';\n  return el.style.pointerEvents === 'auto';\n}(),\n    _detectDirection = function _detectDirection(el, options) {\n  var elCSS = css(el),\n      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),\n      child1 = getChild(el, 0, options),\n      child2 = getChild(el, 1, options),\n      firstChildCSS = child1 && css(child1),\n      secondChildCSS = child2 && css(child2),\n      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,\n      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;\n\n  if (elCSS.display === 'flex') {\n    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';\n  }\n\n  if (elCSS.display === 'grid') {\n    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';\n  }\n\n  if (child1 && firstChildCSS[\"float\"] && firstChildCSS[\"float\"] !== 'none') {\n    var touchingSideChild2 = firstChildCSS[\"float\"] === 'left' ? 'left' : 'right';\n    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';\n  }\n\n  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';\n},\n    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {\n  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,\n      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,\n      dragElOppLength = vertical ? dragRect.width : dragRect.height,\n      targetS1Opp = vertical ? targetRect.left : targetRect.top,\n      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,\n      targetOppLength = vertical ? targetRect.width : targetRect.height;\n  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;\n},\n\n/**\n * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\n * @param  {Number} x      X position\n * @param  {Number} y      Y position\n * @return {HTMLElement}   Element of the first found nearest Sortable\n */\n_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {\n  var ret;\n  sortables.some(function (sortable) {\n    var threshold = sortable[expando].options.emptyInsertThreshold;\n    if (!threshold || lastChild(sortable)) return;\n    var rect = getRect(sortable),\n        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,\n        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;\n\n    if (insideHorizontally && insideVertically) {\n      return ret = sortable;\n    }\n  });\n  return ret;\n},\n    _prepareGroup = function _prepareGroup(options) {\n  function toFn(value, pull) {\n    return function (to, from, dragEl, evt) {\n      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;\n\n      if (value == null && (pull || sameGroup)) {\n        // Default pull value\n        // Default pull and put value if same group\n        return true;\n      } else if (value == null || value === false) {\n        return false;\n      } else if (pull && value === 'clone') {\n        return value;\n      } else if (typeof value === 'function') {\n        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);\n      } else {\n        var otherGroup = (pull ? to : from).options.group.name;\n        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;\n      }\n    };\n  }\n\n  var group = {};\n  var originalGroup = options.group;\n\n  if (!originalGroup || _typeof(originalGroup) != 'object') {\n    originalGroup = {\n      name: originalGroup\n    };\n  }\n\n  group.name = originalGroup.name;\n  group.checkPull = toFn(originalGroup.pull, true);\n  group.checkPut = toFn(originalGroup.put);\n  group.revertClone = originalGroup.revertClone;\n  options.group = group;\n},\n    _hideGhostForTarget = function _hideGhostForTarget() {\n  if (!supportCssPointerEvents && ghostEl) {\n    css(ghostEl, 'display', 'none');\n  }\n},\n    _unhideGhostForTarget = function _unhideGhostForTarget() {\n  if (!supportCssPointerEvents && ghostEl) {\n    css(ghostEl, 'display', '');\n  }\n}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position\n\n\nif (documentExists) {\n  document.addEventListener('click', function (evt) {\n    if (ignoreNextClick) {\n      evt.preventDefault();\n      evt.stopPropagation && evt.stopPropagation();\n      evt.stopImmediatePropagation && evt.stopImmediatePropagation();\n      ignoreNextClick = false;\n      return false;\n    }\n  }, true);\n}\n\nvar nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {\n  if (dragEl) {\n    evt = evt.touches ? evt.touches[0] : evt;\n\n    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);\n\n    if (nearest) {\n      // Create imitation event\n      var event = {};\n\n      for (var i in evt) {\n        if (evt.hasOwnProperty(i)) {\n          event[i] = evt[i];\n        }\n      }\n\n      event.target = event.rootEl = nearest;\n      event.preventDefault = void 0;\n      event.stopPropagation = void 0;\n\n      nearest[expando]._onDragOver(event);\n    }\n  }\n};\n\nvar _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {\n  if (dragEl) {\n    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n  }\n};\n/**\n * @class  Sortable\n * @param  {HTMLElement}  el\n * @param  {Object}       [options]\n */\n\n\nfunction Sortable(el, options) {\n  if (!(el && el.nodeType && el.nodeType === 1)) {\n    throw \"Sortable: `el` must be an HTMLElement, not \".concat({}.toString.call(el));\n  }\n\n  this.el = el; // root element\n\n  this.options = options = _extends({}, options); // Export instance\n\n  el[expando] = this;\n  var defaults = {\n    group: null,\n    sort: true,\n    disabled: false,\n    store: null,\n    handle: null,\n    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',\n    swapThreshold: 1,\n    // percentage; 0 <= x <= 1\n    invertSwap: false,\n    // invert always\n    invertedSwapThreshold: null,\n    // will be set to same as swapThreshold if default\n    removeCloneOnHide: true,\n    direction: function direction() {\n      return _detectDirection(el, this.options);\n    },\n    ghostClass: 'sortable-ghost',\n    chosenClass: 'sortable-chosen',\n    dragClass: 'sortable-drag',\n    ignore: 'a, img',\n    filter: null,\n    preventOnFilter: true,\n    animation: 0,\n    easing: null,\n    setData: function setData(dataTransfer, dragEl) {\n      dataTransfer.setData('Text', dragEl.textContent);\n    },\n    dropBubble: false,\n    dragoverBubble: false,\n    dataIdAttr: 'data-id',\n    delay: 0,\n    delayOnTouchOnly: false,\n    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,\n    forceFallback: false,\n    fallbackClass: 'sortable-fallback',\n    fallbackOnBody: false,\n    fallbackTolerance: 0,\n    fallbackOffset: {\n      x: 0,\n      y: 0\n    },\n    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,\n    emptyInsertThreshold: 5\n  };\n  PluginManager.initializePlugins(this, el, defaults); // Set default options\n\n  for (var name in defaults) {\n    !(name in options) && (options[name] = defaults[name]);\n  }\n\n  _prepareGroup(options); // Bind all private methods\n\n\n  for (var fn in this) {\n    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n      this[fn] = this[fn].bind(this);\n    }\n  } // Setup drag mode\n\n\n  this.nativeDraggable = options.forceFallback ? false : supportDraggable;\n\n  if (this.nativeDraggable) {\n    // Touch start threshold cannot be greater than the native dragstart threshold\n    this.options.touchStartThreshold = 1;\n  } // Bind events\n\n\n  if (options.supportPointer) {\n    on(el, 'pointerdown', this._onTapStart);\n  } else {\n    on(el, 'mousedown', this._onTapStart);\n    on(el, 'touchstart', this._onTapStart);\n  }\n\n  if (this.nativeDraggable) {\n    on(el, 'dragover', this);\n    on(el, 'dragenter', this);\n  }\n\n  sortables.push(this.el); // Restore sorting\n\n  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager\n\n  _extends(this, AnimationStateManager());\n}\n\nSortable.prototype =\n/** @lends Sortable.prototype */\n{\n  constructor: Sortable,\n  _isOutsideThisEl: function _isOutsideThisEl(target) {\n    if (!this.el.contains(target) && target !== this.el) {\n      lastTarget = null;\n    }\n  },\n  _getDirection: function _getDirection(evt, target) {\n    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;\n  },\n  _onTapStart: function _onTapStart(\n  /** Event|TouchEvent */\n  evt) {\n    if (!evt.cancelable) return;\n\n    var _this = this,\n        el = this.el,\n        options = this.options,\n        preventOnFilter = options.preventOnFilter,\n        type = evt.type,\n        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,\n        target = (touch || evt).target,\n        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,\n        filter = options.filter;\n\n    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.\n\n\n    if (dragEl) {\n      return;\n    }\n\n    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {\n      return; // only left button and enabled\n    } // cancel dnd if original target is content editable\n\n\n    if (originalTarget.isContentEditable) {\n      return;\n    } // Safari ignores further event handling after mousedown\n\n\n    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {\n      return;\n    }\n\n    target = closest(target, options.draggable, el, false);\n\n    if (target && target.animated) {\n      return;\n    }\n\n    if (lastDownEl === target) {\n      // Ignoring duplicate `down`\n      return;\n    } // Get the index of the dragged element within its parent\n\n\n    oldIndex = index(target);\n    oldDraggableIndex = index(target, options.draggable); // Check filter\n\n    if (typeof filter === 'function') {\n      if (filter.call(this, evt, target, this)) {\n        _dispatchEvent({\n          sortable: _this,\n          rootEl: originalTarget,\n          name: 'filter',\n          targetEl: target,\n          toEl: el,\n          fromEl: el\n        });\n\n        pluginEvent('filter', _this, {\n          evt: evt\n        });\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    } else if (filter) {\n      filter = filter.split(',').some(function (criteria) {\n        criteria = closest(originalTarget, criteria.trim(), el, false);\n\n        if (criteria) {\n          _dispatchEvent({\n            sortable: _this,\n            rootEl: criteria,\n            name: 'filter',\n            targetEl: target,\n            fromEl: el,\n            toEl: el\n          });\n\n          pluginEvent('filter', _this, {\n            evt: evt\n          });\n          return true;\n        }\n      });\n\n      if (filter) {\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    }\n\n    if (options.handle && !closest(originalTarget, options.handle, el, false)) {\n      return;\n    } // Prepare `dragstart`\n\n\n    this._prepareDragStart(evt, touch, target);\n  },\n  _prepareDragStart: function _prepareDragStart(\n  /** Event */\n  evt,\n  /** Touch */\n  touch,\n  /** HTMLElement */\n  target) {\n    var _this = this,\n        el = _this.el,\n        options = _this.options,\n        ownerDocument = el.ownerDocument,\n        dragStartFn;\n\n    if (target && !dragEl && target.parentNode === el) {\n      var dragRect = getRect(target);\n      rootEl = el;\n      dragEl = target;\n      parentEl = dragEl.parentNode;\n      nextEl = dragEl.nextSibling;\n      lastDownEl = target;\n      activeGroup = options.group;\n      Sortable.dragged = dragEl;\n      tapEvt = {\n        target: dragEl,\n        clientX: (touch || evt).clientX,\n        clientY: (touch || evt).clientY\n      };\n      tapDistanceLeft = tapEvt.clientX - dragRect.left;\n      tapDistanceTop = tapEvt.clientY - dragRect.top;\n      this._lastX = (touch || evt).clientX;\n      this._lastY = (touch || evt).clientY;\n      dragEl.style['will-change'] = 'all';\n\n      dragStartFn = function dragStartFn() {\n        pluginEvent('delayEnded', _this, {\n          evt: evt\n        });\n\n        if (Sortable.eventCanceled) {\n          _this._onDrop();\n\n          return;\n        } // Delayed drag has been triggered\n        // we can re-enable the events: touchmove/mousemove\n\n\n        _this._disableDelayedDragEvents();\n\n        if (!FireFox && _this.nativeDraggable) {\n          dragEl.draggable = true;\n        } // Bind the events: dragstart/dragend\n\n\n        _this._triggerDragStart(evt, touch); // Drag start event\n\n\n        _dispatchEvent({\n          sortable: _this,\n          name: 'choose',\n          originalEvent: evt\n        }); // Chosen item\n\n\n        toggleClass(dragEl, options.chosenClass, true);\n      }; // Disable \"draggable\"\n\n\n      options.ignore.split(',').forEach(function (criteria) {\n        find(dragEl, criteria.trim(), _disableDraggable);\n      });\n      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'mouseup', _this._onDrop);\n      on(ownerDocument, 'touchend', _this._onDrop);\n      on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)\n\n      if (FireFox && this.nativeDraggable) {\n        this.options.touchStartThreshold = 4;\n        dragEl.draggable = true;\n      }\n\n      pluginEvent('delayStart', this, {\n        evt: evt\n      }); // Delay is impossible for native DnD in Edge or IE\n\n      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {\n        if (Sortable.eventCanceled) {\n          this._onDrop();\n\n          return;\n        } // If the user moves the pointer or let go the click or touch\n        // before the delay has been reached:\n        // disable the delayed drag\n\n\n        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);\n        on(ownerDocument, 'touchend', _this._disableDelayedDrag);\n        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);\n        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);\n        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);\n        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);\n        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);\n      } else {\n        dragStartFn();\n      }\n    }\n  },\n  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(\n  /** TouchEvent|PointerEvent **/\n  e) {\n    var touch = e.touches ? e.touches[0] : e;\n\n    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {\n      this._disableDelayedDrag();\n    }\n  },\n  _disableDelayedDrag: function _disableDelayedDrag() {\n    dragEl && _disableDraggable(dragEl);\n    clearTimeout(this._dragStartTimer);\n\n    this._disableDelayedDragEvents();\n  },\n  _disableDelayedDragEvents: function _disableDelayedDragEvents() {\n    var ownerDocument = this.el.ownerDocument;\n    off(ownerDocument, 'mouseup', this._disableDelayedDrag);\n    off(ownerDocument, 'touchend', this._disableDelayedDrag);\n    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);\n    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);\n    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);\n    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);\n  },\n  _triggerDragStart: function _triggerDragStart(\n  /** Event */\n  evt,\n  /** Touch */\n  touch) {\n    touch = touch || evt.pointerType == 'touch' && evt;\n\n    if (!this.nativeDraggable || touch) {\n      if (this.options.supportPointer) {\n        on(document, 'pointermove', this._onTouchMove);\n      } else if (touch) {\n        on(document, 'touchmove', this._onTouchMove);\n      } else {\n        on(document, 'mousemove', this._onTouchMove);\n      }\n    } else {\n      on(dragEl, 'dragend', this);\n      on(rootEl, 'dragstart', this._onDragStart);\n    }\n\n    try {\n      if (document.selection) {\n        // Timeout neccessary for IE9\n        _nextTick(function () {\n          document.selection.empty();\n        });\n      } else {\n        window.getSelection().removeAllRanges();\n      }\n    } catch (err) {}\n  },\n  _dragStarted: function _dragStarted(fallback, evt) {\n\n    awaitingDragStarted = false;\n\n    if (rootEl && dragEl) {\n      pluginEvent('dragStarted', this, {\n        evt: evt\n      });\n\n      if (this.nativeDraggable) {\n        on(document, 'dragover', _checkOutsideTargetEl);\n      }\n\n      var options = this.options; // Apply effect\n\n      !fallback && toggleClass(dragEl, options.dragClass, false);\n      toggleClass(dragEl, options.ghostClass, true);\n      Sortable.active = this;\n      fallback && this._appendGhost(); // Drag start event\n\n      _dispatchEvent({\n        sortable: this,\n        name: 'start',\n        originalEvent: evt\n      });\n    } else {\n      this._nulling();\n    }\n  },\n  _emulateDragOver: function _emulateDragOver() {\n    if (touchEvt) {\n      this._lastX = touchEvt.clientX;\n      this._lastY = touchEvt.clientY;\n\n      _hideGhostForTarget();\n\n      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n      var parent = target;\n\n      while (target && target.shadowRoot) {\n        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n        if (target === parent) break;\n        parent = target;\n      }\n\n      dragEl.parentNode[expando]._isOutsideThisEl(target);\n\n      if (parent) {\n        do {\n          if (parent[expando]) {\n            var inserted = void 0;\n            inserted = parent[expando]._onDragOver({\n              clientX: touchEvt.clientX,\n              clientY: touchEvt.clientY,\n              target: target,\n              rootEl: parent\n            });\n\n            if (inserted && !this.options.dragoverBubble) {\n              break;\n            }\n          }\n\n          target = parent; // store last element\n        }\n        /* jshint boss:true */\n        while (parent = parent.parentNode);\n      }\n\n      _unhideGhostForTarget();\n    }\n  },\n  _onTouchMove: function _onTouchMove(\n  /**TouchEvent*/\n  evt) {\n    if (tapEvt) {\n      var options = this.options,\n          fallbackTolerance = options.fallbackTolerance,\n          fallbackOffset = options.fallbackOffset,\n          touch = evt.touches ? evt.touches[0] : evt,\n          ghostMatrix = ghostEl && matrix(ghostEl, true),\n          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,\n          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,\n          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),\n          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),\n          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging\n\n      if (!Sortable.active && !awaitingDragStarted) {\n        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {\n          return;\n        }\n\n        this._onDragStart(evt, true);\n      }\n\n      if (ghostEl) {\n        if (ghostMatrix) {\n          ghostMatrix.e += dx - (lastDx || 0);\n          ghostMatrix.f += dy - (lastDy || 0);\n        } else {\n          ghostMatrix = {\n            a: 1,\n            b: 0,\n            c: 0,\n            d: 1,\n            e: dx,\n            f: dy\n          };\n        }\n\n        var cssMatrix = \"matrix(\".concat(ghostMatrix.a, \",\").concat(ghostMatrix.b, \",\").concat(ghostMatrix.c, \",\").concat(ghostMatrix.d, \",\").concat(ghostMatrix.e, \",\").concat(ghostMatrix.f, \")\");\n        css(ghostEl, 'webkitTransform', cssMatrix);\n        css(ghostEl, 'mozTransform', cssMatrix);\n        css(ghostEl, 'msTransform', cssMatrix);\n        css(ghostEl, 'transform', cssMatrix);\n        lastDx = dx;\n        lastDy = dy;\n        touchEvt = touch;\n      }\n\n      evt.cancelable && evt.preventDefault();\n    }\n  },\n  _appendGhost: function _appendGhost() {\n    // Bug if using scale(): https://stackoverflow.com/questions/2637058\n    // Not being adjusted for\n    if (!ghostEl) {\n      var container = this.options.fallbackOnBody ? document.body : rootEl,\n          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),\n          options = this.options; // Position absolutely\n\n      if (PositionGhostAbsolutely) {\n        // Get relatively positioned parent\n        ghostRelativeParent = container;\n\n        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {\n          ghostRelativeParent = ghostRelativeParent.parentNode;\n        }\n\n        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {\n          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();\n          rect.top += ghostRelativeParent.scrollTop;\n          rect.left += ghostRelativeParent.scrollLeft;\n        } else {\n          ghostRelativeParent = getWindowScrollingElement();\n        }\n\n        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);\n      }\n\n      ghostEl = dragEl.cloneNode(true);\n      toggleClass(ghostEl, options.ghostClass, false);\n      toggleClass(ghostEl, options.fallbackClass, true);\n      toggleClass(ghostEl, options.dragClass, true);\n      css(ghostEl, 'transition', '');\n      css(ghostEl, 'transform', '');\n      css(ghostEl, 'box-sizing', 'border-box');\n      css(ghostEl, 'margin', 0);\n      css(ghostEl, 'top', rect.top);\n      css(ghostEl, 'left', rect.left);\n      css(ghostEl, 'width', rect.width);\n      css(ghostEl, 'height', rect.height);\n      css(ghostEl, 'opacity', '0.8');\n      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');\n      css(ghostEl, 'zIndex', '100000');\n      css(ghostEl, 'pointerEvents', 'none');\n      Sortable.ghost = ghostEl;\n      container.appendChild(ghostEl); // Set transform-origin\n\n      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');\n    }\n  },\n  _onDragStart: function _onDragStart(\n  /**Event*/\n  evt,\n  /**boolean*/\n  fallback) {\n    var _this = this;\n\n    var dataTransfer = evt.dataTransfer;\n    var options = _this.options;\n    pluginEvent('dragStart', this, {\n      evt: evt\n    });\n\n    if (Sortable.eventCanceled) {\n      this._onDrop();\n\n      return;\n    }\n\n    pluginEvent('setupClone', this);\n\n    if (!Sortable.eventCanceled) {\n      cloneEl = clone(dragEl);\n      cloneEl.draggable = false;\n      cloneEl.style['will-change'] = '';\n\n      this._hideClone();\n\n      toggleClass(cloneEl, this.options.chosenClass, false);\n      Sortable.clone = cloneEl;\n    } // #1143: IFrame support workaround\n\n\n    _this.cloneId = _nextTick(function () {\n      pluginEvent('clone', _this);\n      if (Sortable.eventCanceled) return;\n\n      if (!_this.options.removeCloneOnHide) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      }\n\n      _this._hideClone();\n\n      _dispatchEvent({\n        sortable: _this,\n        name: 'clone'\n      });\n    });\n    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events\n\n    if (fallback) {\n      ignoreNextClick = true;\n      _this._loopId = setInterval(_this._emulateDragOver, 50);\n    } else {\n      // Undo what was set in _prepareDragStart before drag started\n      off(document, 'mouseup', _this._onDrop);\n      off(document, 'touchend', _this._onDrop);\n      off(document, 'touchcancel', _this._onDrop);\n\n      if (dataTransfer) {\n        dataTransfer.effectAllowed = 'move';\n        options.setData && options.setData.call(_this, dataTransfer, dragEl);\n      }\n\n      on(document, 'drop', _this); // #1276 fix:\n\n      css(dragEl, 'transform', 'translateZ(0)');\n    }\n\n    awaitingDragStarted = true;\n    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));\n    on(document, 'selectstart', _this);\n    moved = true;\n\n    if (Safari) {\n      css(document.body, 'user-select', 'none');\n    }\n  },\n  // Returns true - if no further action is needed (either inserted or another condition)\n  _onDragOver: function _onDragOver(\n  /**Event*/\n  evt) {\n    var el = this.el,\n        target = evt.target,\n        dragRect,\n        targetRect,\n        revert,\n        options = this.options,\n        group = options.group,\n        activeSortable = Sortable.active,\n        isOwner = activeGroup === group,\n        canSort = options.sort,\n        fromSortable = putSortable || activeSortable,\n        vertical,\n        _this = this,\n        completedFired = false;\n\n    if (_silent) return;\n\n    function dragOverEvent(name, extra) {\n      pluginEvent(name, _this, _objectSpread2({\n        evt: evt,\n        isOwner: isOwner,\n        axis: vertical ? 'vertical' : 'horizontal',\n        revert: revert,\n        dragRect: dragRect,\n        targetRect: targetRect,\n        canSort: canSort,\n        fromSortable: fromSortable,\n        target: target,\n        completed: completed,\n        onMove: function onMove(target, after) {\n          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);\n        },\n        changed: changed\n      }, extra));\n    } // Capture animation state\n\n\n    function capture() {\n      dragOverEvent('dragOverAnimationCapture');\n\n      _this.captureAnimationState();\n\n      if (_this !== fromSortable) {\n        fromSortable.captureAnimationState();\n      }\n    } // Return invocation when dragEl is inserted (or completed)\n\n\n    function completed(insertion) {\n      dragOverEvent('dragOverCompleted', {\n        insertion: insertion\n      });\n\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        } else {\n          activeSortable._showClone(_this);\n        }\n\n        if (_this !== fromSortable) {\n          // Set ghost class to new sortable's ghost class\n          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);\n          toggleClass(dragEl, options.ghostClass, true);\n        }\n\n        if (putSortable !== _this && _this !== Sortable.active) {\n          putSortable = _this;\n        } else if (_this === Sortable.active && putSortable) {\n          putSortable = null;\n        } // Animation\n\n\n        if (fromSortable === _this) {\n          _this._ignoreWhileAnimating = target;\n        }\n\n        _this.animateAll(function () {\n          dragOverEvent('dragOverAnimationComplete');\n          _this._ignoreWhileAnimating = null;\n        });\n\n        if (_this !== fromSortable) {\n          fromSortable.animateAll();\n          fromSortable._ignoreWhileAnimating = null;\n        }\n      } // Null lastTarget if it is not inside a previously swapped element\n\n\n      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {\n        lastTarget = null;\n      } // no bubbling and not fallback\n\n\n      if (!options.dragoverBubble && !evt.rootEl && target !== document) {\n        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted\n\n\n        !insertion && nearestEmptyInsertDetectEvent(evt);\n      }\n\n      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\n      return completedFired = true;\n    } // Call when dragEl has been inserted\n\n\n    function changed() {\n      newIndex = index(dragEl);\n      newDraggableIndex = index(dragEl, options.draggable);\n\n      _dispatchEvent({\n        sortable: _this,\n        name: 'change',\n        toEl: el,\n        newIndex: newIndex,\n        newDraggableIndex: newDraggableIndex,\n        originalEvent: evt\n      });\n    }\n\n    if (evt.preventDefault !== void 0) {\n      evt.cancelable && evt.preventDefault();\n    }\n\n    target = closest(target, options.draggable, el, true);\n    dragOverEvent('dragOver');\n    if (Sortable.eventCanceled) return completedFired;\n\n    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {\n      return completed(false);\n    }\n\n    ignoreNextClick = false;\n\n    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list\n    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {\n      vertical = this._getDirection(evt, target) === 'vertical';\n      dragRect = getRect(dragEl);\n      dragOverEvent('dragOverValid');\n      if (Sortable.eventCanceled) return completedFired;\n\n      if (revert) {\n        parentEl = rootEl; // actualization\n\n        capture();\n\n        this._hideClone();\n\n        dragOverEvent('revert');\n\n        if (!Sortable.eventCanceled) {\n          if (nextEl) {\n            rootEl.insertBefore(dragEl, nextEl);\n          } else {\n            rootEl.appendChild(dragEl);\n          }\n        }\n\n        return completed(true);\n      }\n\n      var elLastChild = lastChild(el, options.draggable);\n\n      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {\n        // Insert to end of list\n        // If already at end of list: Do not insert\n        if (elLastChild === dragEl) {\n          return completed(false);\n        } // if there is a last element, it is the target\n\n\n        if (elLastChild && el === evt.target) {\n          target = elLastChild;\n        }\n\n        if (target) {\n          targetRect = getRect(target);\n        }\n\n        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {\n          capture();\n          el.appendChild(dragEl);\n          parentEl = el; // actualization\n\n          changed();\n          return completed(true);\n        }\n      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {\n        // Insert to start of list\n        var firstChild = getChild(el, 0, options, true);\n\n        if (firstChild === dragEl) {\n          return completed(false);\n        }\n\n        target = firstChild;\n        targetRect = getRect(target);\n\n        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {\n          capture();\n          el.insertBefore(dragEl, firstChild);\n          parentEl = el; // actualization\n\n          changed();\n          return completed(true);\n        }\n      } else if (target.parentNode === el) {\n        targetRect = getRect(target);\n        var direction = 0,\n            targetBeforeFirstSwap,\n            differentLevel = dragEl.parentNode !== el,\n            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),\n            side1 = vertical ? 'top' : 'left',\n            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),\n            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\n\n        if (lastTarget !== target) {\n          targetBeforeFirstSwap = targetRect[side1];\n          pastFirstInvertThresh = false;\n          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;\n        }\n\n        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);\n        var sibling;\n\n        if (direction !== 0) {\n          // Check if target is beside dragEl in respective direction (ignoring hidden elements)\n          var dragIndex = index(dragEl);\n\n          do {\n            dragIndex -= direction;\n            sibling = parentEl.children[dragIndex];\n          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));\n        } // If dragEl is already beside target: Do not insert\n\n\n        if (direction === 0 || sibling === target) {\n          return completed(false);\n        }\n\n        lastTarget = target;\n        lastDirection = direction;\n        var nextSibling = target.nextElementSibling,\n            after = false;\n        after = direction === 1;\n\n        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);\n\n        if (moveVector !== false) {\n          if (moveVector === 1 || moveVector === -1) {\n            after = moveVector === 1;\n          }\n\n          _silent = true;\n          setTimeout(_unsilent, 30);\n          capture();\n\n          if (after && !nextSibling) {\n            el.appendChild(dragEl);\n          } else {\n            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);\n          } // Undo chrome's scroll adjustment (has no effect on other browsers)\n\n\n          if (scrolledPastTop) {\n            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);\n          }\n\n          parentEl = dragEl.parentNode; // actualization\n          // must be done before animation\n\n          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\n            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);\n          }\n\n          changed();\n          return completed(true);\n        }\n      }\n\n      if (el.contains(dragEl)) {\n        return completed(false);\n      }\n    }\n\n    return false;\n  },\n  _ignoreWhileAnimating: null,\n  _offMoveEvents: function _offMoveEvents() {\n    off(document, 'mousemove', this._onTouchMove);\n    off(document, 'touchmove', this._onTouchMove);\n    off(document, 'pointermove', this._onTouchMove);\n    off(document, 'dragover', nearestEmptyInsertDetectEvent);\n    off(document, 'mousemove', nearestEmptyInsertDetectEvent);\n    off(document, 'touchmove', nearestEmptyInsertDetectEvent);\n  },\n  _offUpEvents: function _offUpEvents() {\n    var ownerDocument = this.el.ownerDocument;\n    off(ownerDocument, 'mouseup', this._onDrop);\n    off(ownerDocument, 'touchend', this._onDrop);\n    off(ownerDocument, 'pointerup', this._onDrop);\n    off(ownerDocument, 'touchcancel', this._onDrop);\n    off(document, 'selectstart', this);\n  },\n  _onDrop: function _onDrop(\n  /**Event*/\n  evt) {\n    var el = this.el,\n        options = this.options; // Get the index of the dragged element within its parent\n\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n    pluginEvent('drop', this, {\n      evt: evt\n    });\n    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event\n\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n\n    if (Sortable.eventCanceled) {\n      this._nulling();\n\n      return;\n    }\n\n    awaitingDragStarted = false;\n    isCircumstantialInvert = false;\n    pastFirstInvertThresh = false;\n    clearInterval(this._loopId);\n    clearTimeout(this._dragStartTimer);\n\n    _cancelNextTick(this.cloneId);\n\n    _cancelNextTick(this._dragStartId); // Unbind events\n\n\n    if (this.nativeDraggable) {\n      off(document, 'drop', this);\n      off(el, 'dragstart', this._onDragStart);\n    }\n\n    this._offMoveEvents();\n\n    this._offUpEvents();\n\n    if (Safari) {\n      css(document.body, 'user-select', '');\n    }\n\n    css(dragEl, 'transform', '');\n\n    if (evt) {\n      if (moved) {\n        evt.cancelable && evt.preventDefault();\n        !options.dropBubble && evt.stopPropagation();\n      }\n\n      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);\n\n      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n        // Remove clone(s)\n        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);\n      }\n\n      if (dragEl) {\n        if (this.nativeDraggable) {\n          off(dragEl, 'dragend', this);\n        }\n\n        _disableDraggable(dragEl);\n\n        dragEl.style['will-change'] = ''; // Remove classes\n        // ghostClass is added in dragStarted\n\n        if (moved && !awaitingDragStarted) {\n          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);\n        }\n\n        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event\n\n        _dispatchEvent({\n          sortable: this,\n          name: 'unchoose',\n          toEl: parentEl,\n          newIndex: null,\n          newDraggableIndex: null,\n          originalEvent: evt\n        });\n\n        if (rootEl !== parentEl) {\n          if (newIndex >= 0) {\n            // Add event\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: 'add',\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt\n            }); // Remove event\n\n\n            _dispatchEvent({\n              sortable: this,\n              name: 'remove',\n              toEl: parentEl,\n              originalEvent: evt\n            }); // drag from one list and drop into another\n\n\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: 'sort',\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt\n            });\n\n            _dispatchEvent({\n              sortable: this,\n              name: 'sort',\n              toEl: parentEl,\n              originalEvent: evt\n            });\n          }\n\n          putSortable && putSortable.save();\n        } else {\n          if (newIndex !== oldIndex) {\n            if (newIndex >= 0) {\n              // drag & drop within the same list\n              _dispatchEvent({\n                sortable: this,\n                name: 'update',\n                toEl: parentEl,\n                originalEvent: evt\n              });\n\n              _dispatchEvent({\n                sortable: this,\n                name: 'sort',\n                toEl: parentEl,\n                originalEvent: evt\n              });\n            }\n          }\n        }\n\n        if (Sortable.active) {\n          /* jshint eqnull:true */\n          if (newIndex == null || newIndex === -1) {\n            newIndex = oldIndex;\n            newDraggableIndex = oldDraggableIndex;\n          }\n\n          _dispatchEvent({\n            sortable: this,\n            name: 'end',\n            toEl: parentEl,\n            originalEvent: evt\n          }); // Save sorting\n\n\n          this.save();\n        }\n      }\n    }\n\n    this._nulling();\n  },\n  _nulling: function _nulling() {\n    pluginEvent('nulling', this);\n    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;\n    savedInputChecked.forEach(function (el) {\n      el.checked = true;\n    });\n    savedInputChecked.length = lastDx = lastDy = 0;\n  },\n  handleEvent: function handleEvent(\n  /**Event*/\n  evt) {\n    switch (evt.type) {\n      case 'drop':\n      case 'dragend':\n        this._onDrop(evt);\n\n        break;\n\n      case 'dragenter':\n      case 'dragover':\n        if (dragEl) {\n          this._onDragOver(evt);\n\n          _globalDragOver(evt);\n        }\n\n        break;\n\n      case 'selectstart':\n        evt.preventDefault();\n        break;\n    }\n  },\n\n  /**\n   * Serializes the item into an array of string.\n   * @returns {String[]}\n   */\n  toArray: function toArray() {\n    var order = [],\n        el,\n        children = this.el.children,\n        i = 0,\n        n = children.length,\n        options = this.options;\n\n    for (; i < n; i++) {\n      el = children[i];\n\n      if (closest(el, options.draggable, this.el, false)) {\n        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\n      }\n    }\n\n    return order;\n  },\n\n  /**\n   * Sorts the elements according to the array.\n   * @param  {String[]}  order  order of the items\n   */\n  sort: function sort(order, useAnimation) {\n    var items = {},\n        rootEl = this.el;\n    this.toArray().forEach(function (id, i) {\n      var el = rootEl.children[i];\n\n      if (closest(el, this.options.draggable, rootEl, false)) {\n        items[id] = el;\n      }\n    }, this);\n    useAnimation && this.captureAnimationState();\n    order.forEach(function (id) {\n      if (items[id]) {\n        rootEl.removeChild(items[id]);\n        rootEl.appendChild(items[id]);\n      }\n    });\n    useAnimation && this.animateAll();\n  },\n\n  /**\n   * Save the current sorting\n   */\n  save: function save() {\n    var store = this.options.store;\n    store && store.set && store.set(this);\n  },\n\n  /**\n   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.\n   * @param   {HTMLElement}  el\n   * @param   {String}       [selector]  default: `options.draggable`\n   * @returns {HTMLElement|null}\n   */\n  closest: function closest$1(el, selector) {\n    return closest(el, selector || this.options.draggable, this.el, false);\n  },\n\n  /**\n   * Set/get option\n   * @param   {string} name\n   * @param   {*}      [value]\n   * @returns {*}\n   */\n  option: function option(name, value) {\n    var options = this.options;\n\n    if (value === void 0) {\n      return options[name];\n    } else {\n      var modifiedValue = PluginManager.modifyOption(this, name, value);\n\n      if (typeof modifiedValue !== 'undefined') {\n        options[name] = modifiedValue;\n      } else {\n        options[name] = value;\n      }\n\n      if (name === 'group') {\n        _prepareGroup(options);\n      }\n    }\n  },\n\n  /**\n   * Destroy\n   */\n  destroy: function destroy() {\n    pluginEvent('destroy', this);\n    var el = this.el;\n    el[expando] = null;\n    off(el, 'mousedown', this._onTapStart);\n    off(el, 'touchstart', this._onTapStart);\n    off(el, 'pointerdown', this._onTapStart);\n\n    if (this.nativeDraggable) {\n      off(el, 'dragover', this);\n      off(el, 'dragenter', this);\n    } // Remove draggable attributes\n\n\n    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {\n      el.removeAttribute('draggable');\n    });\n\n    this._onDrop();\n\n    this._disableDelayedDragEvents();\n\n    sortables.splice(sortables.indexOf(this.el), 1);\n    this.el = el = null;\n  },\n  _hideClone: function _hideClone() {\n    if (!cloneHidden) {\n      pluginEvent('hideClone', this);\n      if (Sortable.eventCanceled) return;\n      css(cloneEl, 'display', 'none');\n\n      if (this.options.removeCloneOnHide && cloneEl.parentNode) {\n        cloneEl.parentNode.removeChild(cloneEl);\n      }\n\n      cloneHidden = true;\n    }\n  },\n  _showClone: function _showClone(putSortable) {\n    if (putSortable.lastPutMode !== 'clone') {\n      this._hideClone();\n\n      return;\n    }\n\n    if (cloneHidden) {\n      pluginEvent('showClone', this);\n      if (Sortable.eventCanceled) return; // show clone at dragEl or original position\n\n      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      } else if (nextEl) {\n        rootEl.insertBefore(cloneEl, nextEl);\n      } else {\n        rootEl.appendChild(cloneEl);\n      }\n\n      if (this.options.group.revertClone) {\n        this.animate(dragEl, cloneEl);\n      }\n\n      css(cloneEl, 'display', '');\n      cloneHidden = false;\n    }\n  }\n};\n\nfunction _globalDragOver(\n/**Event*/\nevt) {\n  if (evt.dataTransfer) {\n    evt.dataTransfer.dropEffect = 'move';\n  }\n\n  evt.cancelable && evt.preventDefault();\n}\n\nfunction _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {\n  var evt,\n      sortable = fromEl[expando],\n      onMoveFn = sortable.options.onMove,\n      retVal; // Support for new CustomEvent feature\n\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent('move', {\n      bubbles: true,\n      cancelable: true\n    });\n  } else {\n    evt = document.createEvent('Event');\n    evt.initEvent('move', true, true);\n  }\n\n  evt.to = toEl;\n  evt.from = fromEl;\n  evt.dragged = dragEl;\n  evt.draggedRect = dragRect;\n  evt.related = targetEl || toEl;\n  evt.relatedRect = targetRect || getRect(toEl);\n  evt.willInsertAfter = willInsertAfter;\n  evt.originalEvent = originalEvent;\n  fromEl.dispatchEvent(evt);\n\n  if (onMoveFn) {\n    retVal = onMoveFn.call(sortable, evt, originalEvent);\n  }\n\n  return retVal;\n}\n\nfunction _disableDraggable(el) {\n  el.draggable = false;\n}\n\nfunction _unsilent() {\n  _silent = false;\n}\n\nfunction _ghostIsFirst(evt, vertical, sortable) {\n  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));\n  var spacer = 10;\n  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;\n}\n\nfunction _ghostIsLast(evt, vertical, sortable) {\n  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));\n  var spacer = 10;\n  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;\n}\n\nfunction _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {\n  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,\n      targetLength = vertical ? targetRect.height : targetRect.width,\n      targetS1 = vertical ? targetRect.top : targetRect.left,\n      targetS2 = vertical ? targetRect.bottom : targetRect.right,\n      invert = false;\n\n  if (!invertSwap) {\n    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\n    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {\n      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\n      // check if past first invert threshold on side opposite of lastDirection\n      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {\n        // past first invert threshold, do not restrict inverted threshold to dragEl shadow\n        pastFirstInvertThresh = true;\n      }\n\n      if (!pastFirstInvertThresh) {\n        // dragEl shadow (target move distance shadow)\n        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\n        : mouseOnAxis > targetS2 - targetMoveDistance) {\n          return -lastDirection;\n        }\n      } else {\n        invert = true;\n      }\n    } else {\n      // Regular\n      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {\n        return _getInsertDirection(target);\n      }\n    }\n  }\n\n  invert = invert || invertSwap;\n\n  if (invert) {\n    // Invert of regular\n    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {\n      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;\n    }\n  }\n\n  return 0;\n}\n/**\n * Gets the direction dragEl must be swapped relative to target in order to make it\n * seem that dragEl has been \"inserted\" into that element's position\n * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\n * @return {Number}                   Direction dragEl must be swapped\n */\n\n\nfunction _getInsertDirection(target) {\n  if (index(dragEl) < index(target)) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n/**\n * Generate id\n * @param   {HTMLElement} el\n * @returns {String}\n * @private\n */\n\n\nfunction _generateId(el) {\n  var str = el.tagName + el.className + el.src + el.href + el.textContent,\n      i = str.length,\n      sum = 0;\n\n  while (i--) {\n    sum += str.charCodeAt(i);\n  }\n\n  return sum.toString(36);\n}\n\nfunction _saveInputCheckedState(root) {\n  savedInputChecked.length = 0;\n  var inputs = root.getElementsByTagName('input');\n  var idx = inputs.length;\n\n  while (idx--) {\n    var el = inputs[idx];\n    el.checked && savedInputChecked.push(el);\n  }\n}\n\nfunction _nextTick(fn) {\n  return setTimeout(fn, 0);\n}\n\nfunction _cancelNextTick(id) {\n  return clearTimeout(id);\n} // Fixed #973:\n\n\nif (documentExists) {\n  on(document, 'touchmove', function (evt) {\n    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {\n      evt.preventDefault();\n    }\n  });\n} // Export utils\n\n\nSortable.utils = {\n  on: on,\n  off: off,\n  css: css,\n  find: find,\n  is: function is(el, selector) {\n    return !!closest(el, selector, el, false);\n  },\n  extend: extend,\n  throttle: throttle,\n  closest: closest,\n  toggleClass: toggleClass,\n  clone: clone,\n  index: index,\n  nextTick: _nextTick,\n  cancelNextTick: _cancelNextTick,\n  detectDirection: _detectDirection,\n  getChild: getChild\n};\n/**\n * Get the Sortable instance of an element\n * @param  {HTMLElement} element The element\n * @return {Sortable|undefined}         The instance of Sortable\n */\n\nSortable.get = function (element) {\n  return element[expando];\n};\n/**\n * Mount a plugin to Sortable\n * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted\n */\n\n\nSortable.mount = function () {\n  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {\n    plugins[_key] = arguments[_key];\n  }\n\n  if (plugins[0].constructor === Array) plugins = plugins[0];\n  plugins.forEach(function (plugin) {\n    if (!plugin.prototype || !plugin.prototype.constructor) {\n      throw \"Sortable: Mounted plugin must be a constructor function, not \".concat({}.toString.call(plugin));\n    }\n\n    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);\n    PluginManager.mount(plugin);\n  });\n};\n/**\n * Create sortable instance\n * @param {HTMLElement}  el\n * @param {Object}      [options]\n */\n\n\nSortable.create = function (el, options) {\n  return new Sortable(el, options);\n}; // Export\n\n\nSortable.version = version;\n\nvar autoScrolls = [],\n    scrollEl,\n    scrollRootEl,\n    scrolling = false,\n    lastAutoScrollX,\n    lastAutoScrollY,\n    touchEvt$1,\n    pointerElemChangedInterval;\n\nfunction AutoScrollPlugin() {\n  function AutoScroll() {\n    this.defaults = {\n      scroll: true,\n      forceAutoScrollFallback: false,\n      scrollSensitivity: 30,\n      scrollSpeed: 10,\n      bubbleScroll: true\n    }; // Bind all private methods\n\n    for (var fn in this) {\n      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n  }\n\n  AutoScroll.prototype = {\n    dragStarted: function dragStarted(_ref) {\n      var originalEvent = _ref.originalEvent;\n\n      if (this.sortable.nativeDraggable) {\n        on(document, 'dragover', this._handleAutoScroll);\n      } else {\n        if (this.options.supportPointer) {\n          on(document, 'pointermove', this._handleFallbackAutoScroll);\n        } else if (originalEvent.touches) {\n          on(document, 'touchmove', this._handleFallbackAutoScroll);\n        } else {\n          on(document, 'mousemove', this._handleFallbackAutoScroll);\n        }\n      }\n    },\n    dragOverCompleted: function dragOverCompleted(_ref2) {\n      var originalEvent = _ref2.originalEvent;\n\n      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)\n      if (!this.options.dragOverBubble && !originalEvent.rootEl) {\n        this._handleAutoScroll(originalEvent);\n      }\n    },\n    drop: function drop() {\n      if (this.sortable.nativeDraggable) {\n        off(document, 'dragover', this._handleAutoScroll);\n      } else {\n        off(document, 'pointermove', this._handleFallbackAutoScroll);\n        off(document, 'touchmove', this._handleFallbackAutoScroll);\n        off(document, 'mousemove', this._handleFallbackAutoScroll);\n      }\n\n      clearPointerElemChangedInterval();\n      clearAutoScrolls();\n      cancelThrottle();\n    },\n    nulling: function nulling() {\n      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;\n      autoScrolls.length = 0;\n    },\n    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {\n      this._handleAutoScroll(evt, true);\n    },\n    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {\n      var _this = this;\n\n      var x = (evt.touches ? evt.touches[0] : evt).clientX,\n          y = (evt.touches ? evt.touches[0] : evt).clientY,\n          elem = document.elementFromPoint(x, y);\n      touchEvt$1 = evt; // IE does not seem to have native autoscroll,\n      // Edge's autoscroll seems too conditional,\n      // MACOS Safari does not have autoscroll,\n      // Firefox and Chrome are good\n\n      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {\n        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change\n\n        var ogElemScroller = getParentAutoScrollElement(elem, true);\n\n        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {\n          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour\n\n          pointerElemChangedInterval = setInterval(function () {\n            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);\n\n            if (newElem !== ogElemScroller) {\n              ogElemScroller = newElem;\n              clearAutoScrolls();\n            }\n\n            autoScroll(evt, _this.options, newElem, fallback);\n          }, 10);\n          lastAutoScrollX = x;\n          lastAutoScrollY = y;\n        }\n      } else {\n        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll\n        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {\n          clearAutoScrolls();\n          return;\n        }\n\n        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);\n      }\n    }\n  };\n  return _extends(AutoScroll, {\n    pluginName: 'scroll',\n    initializeByDefault: true\n  });\n}\n\nfunction clearAutoScrolls() {\n  autoScrolls.forEach(function (autoScroll) {\n    clearInterval(autoScroll.pid);\n  });\n  autoScrolls = [];\n}\n\nfunction clearPointerElemChangedInterval() {\n  clearInterval(pointerElemChangedInterval);\n}\n\nvar autoScroll = throttle(function (evt, options, rootEl, isFallback) {\n  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521\n  if (!options.scroll) return;\n  var x = (evt.touches ? evt.touches[0] : evt).clientX,\n      y = (evt.touches ? evt.touches[0] : evt).clientY,\n      sens = options.scrollSensitivity,\n      speed = options.scrollSpeed,\n      winScroller = getWindowScrollingElement();\n  var scrollThisInstance = false,\n      scrollCustomFn; // New scroll root, set scrollEl\n\n  if (scrollRootEl !== rootEl) {\n    scrollRootEl = rootEl;\n    clearAutoScrolls();\n    scrollEl = options.scroll;\n    scrollCustomFn = options.scrollFn;\n\n    if (scrollEl === true) {\n      scrollEl = getParentAutoScrollElement(rootEl, true);\n    }\n  }\n\n  var layersOut = 0;\n  var currentParent = scrollEl;\n\n  do {\n    var el = currentParent,\n        rect = getRect(el),\n        top = rect.top,\n        bottom = rect.bottom,\n        left = rect.left,\n        right = rect.right,\n        width = rect.width,\n        height = rect.height,\n        canScrollX = void 0,\n        canScrollY = void 0,\n        scrollWidth = el.scrollWidth,\n        scrollHeight = el.scrollHeight,\n        elCSS = css(el),\n        scrollPosX = el.scrollLeft,\n        scrollPosY = el.scrollTop;\n\n    if (el === winScroller) {\n      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');\n      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');\n    } else {\n      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');\n      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');\n    }\n\n    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);\n    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);\n\n    if (!autoScrolls[layersOut]) {\n      for (var i = 0; i <= layersOut; i++) {\n        if (!autoScrolls[i]) {\n          autoScrolls[i] = {};\n        }\n      }\n    }\n\n    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {\n      autoScrolls[layersOut].el = el;\n      autoScrolls[layersOut].vx = vx;\n      autoScrolls[layersOut].vy = vy;\n      clearInterval(autoScrolls[layersOut].pid);\n\n      if (vx != 0 || vy != 0) {\n        scrollThisInstance = true;\n        /* jshint loopfunc:true */\n\n        autoScrolls[layersOut].pid = setInterval(function () {\n          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour\n          if (isFallback && this.layer === 0) {\n            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely\n\n          }\n\n          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;\n          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;\n\n          if (typeof scrollCustomFn === 'function') {\n            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {\n              return;\n            }\n          }\n\n          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);\n        }.bind({\n          layer: layersOut\n        }), 24);\n      }\n    }\n\n    layersOut++;\n  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));\n\n  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not\n}, 30);\n\nvar drop = function drop(_ref) {\n  var originalEvent = _ref.originalEvent,\n      putSortable = _ref.putSortable,\n      dragEl = _ref.dragEl,\n      activeSortable = _ref.activeSortable,\n      dispatchSortableEvent = _ref.dispatchSortableEvent,\n      hideGhostForTarget = _ref.hideGhostForTarget,\n      unhideGhostForTarget = _ref.unhideGhostForTarget;\n  if (!originalEvent) return;\n  var toSortable = putSortable || activeSortable;\n  hideGhostForTarget();\n  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;\n  var target = document.elementFromPoint(touch.clientX, touch.clientY);\n  unhideGhostForTarget();\n\n  if (toSortable && !toSortable.el.contains(target)) {\n    dispatchSortableEvent('spill');\n    this.onSpill({\n      dragEl: dragEl,\n      putSortable: putSortable\n    });\n  }\n};\n\nfunction Revert() {}\n\nRevert.prototype = {\n  startIndex: null,\n  dragStart: function dragStart(_ref2) {\n    var oldDraggableIndex = _ref2.oldDraggableIndex;\n    this.startIndex = oldDraggableIndex;\n  },\n  onSpill: function onSpill(_ref3) {\n    var dragEl = _ref3.dragEl,\n        putSortable = _ref3.putSortable;\n    this.sortable.captureAnimationState();\n\n    if (putSortable) {\n      putSortable.captureAnimationState();\n    }\n\n    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);\n\n    if (nextSibling) {\n      this.sortable.el.insertBefore(dragEl, nextSibling);\n    } else {\n      this.sortable.el.appendChild(dragEl);\n    }\n\n    this.sortable.animateAll();\n\n    if (putSortable) {\n      putSortable.animateAll();\n    }\n  },\n  drop: drop\n};\n\n_extends(Revert, {\n  pluginName: 'revertOnSpill'\n});\n\nfunction Remove() {}\n\nRemove.prototype = {\n  onSpill: function onSpill(_ref4) {\n    var dragEl = _ref4.dragEl,\n        putSortable = _ref4.putSortable;\n    var parentSortable = putSortable || this.sortable;\n    parentSortable.captureAnimationState();\n    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);\n    parentSortable.animateAll();\n  },\n  drop: drop\n};\n\n_extends(Remove, {\n  pluginName: 'removeOnSpill'\n});\n\nvar lastSwapEl;\n\nfunction SwapPlugin() {\n  function Swap() {\n    this.defaults = {\n      swapClass: 'sortable-swap-highlight'\n    };\n  }\n\n  Swap.prototype = {\n    dragStart: function dragStart(_ref) {\n      var dragEl = _ref.dragEl;\n      lastSwapEl = dragEl;\n    },\n    dragOverValid: function dragOverValid(_ref2) {\n      var completed = _ref2.completed,\n          target = _ref2.target,\n          onMove = _ref2.onMove,\n          activeSortable = _ref2.activeSortable,\n          changed = _ref2.changed,\n          cancel = _ref2.cancel;\n      if (!activeSortable.options.swap) return;\n      var el = this.sortable.el,\n          options = this.options;\n\n      if (target && target !== el) {\n        var prevSwapEl = lastSwapEl;\n\n        if (onMove(target) !== false) {\n          toggleClass(target, options.swapClass, true);\n          lastSwapEl = target;\n        } else {\n          lastSwapEl = null;\n        }\n\n        if (prevSwapEl && prevSwapEl !== lastSwapEl) {\n          toggleClass(prevSwapEl, options.swapClass, false);\n        }\n      }\n\n      changed();\n      completed(true);\n      cancel();\n    },\n    drop: function drop(_ref3) {\n      var activeSortable = _ref3.activeSortable,\n          putSortable = _ref3.putSortable,\n          dragEl = _ref3.dragEl;\n      var toSortable = putSortable || this.sortable;\n      var options = this.options;\n      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);\n\n      if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {\n        if (dragEl !== lastSwapEl) {\n          toSortable.captureAnimationState();\n          if (toSortable !== activeSortable) activeSortable.captureAnimationState();\n          swapNodes(dragEl, lastSwapEl);\n          toSortable.animateAll();\n          if (toSortable !== activeSortable) activeSortable.animateAll();\n        }\n      }\n    },\n    nulling: function nulling() {\n      lastSwapEl = null;\n    }\n  };\n  return _extends(Swap, {\n    pluginName: 'swap',\n    eventProperties: function eventProperties() {\n      return {\n        swapItem: lastSwapEl\n      };\n    }\n  });\n}\n\nfunction swapNodes(n1, n2) {\n  var p1 = n1.parentNode,\n      p2 = n2.parentNode,\n      i1,\n      i2;\n  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;\n  i1 = index(n1);\n  i2 = index(n2);\n\n  if (p1.isEqualNode(p2) && i1 < i2) {\n    i2++;\n  }\n\n  p1.insertBefore(n2, p1.children[i1]);\n  p2.insertBefore(n1, p2.children[i2]);\n}\n\nvar multiDragElements = (/* unused pure expression or super */ null && ([])),\n    multiDragClones = (/* unused pure expression or super */ null && ([])),\n    lastMultiDragSelect,\n    // for selection with modifier key down (SHIFT)\nmultiDragSortable,\n    initialFolding = false,\n    // Initial multi-drag fold when drag started\nfolding = false,\n    // Folding any other time\ndragStarted = false,\n    dragEl$1,\n    clonesFromRect,\n    clonesHidden;\n\nfunction MultiDragPlugin() {\n  function MultiDrag(sortable) {\n    // Bind all private methods\n    for (var fn in this) {\n      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n\n    if (sortable.options.supportPointer) {\n      on(document, 'pointerup', this._deselectMultiDrag);\n    } else {\n      on(document, 'mouseup', this._deselectMultiDrag);\n      on(document, 'touchend', this._deselectMultiDrag);\n    }\n\n    on(document, 'keydown', this._checkKeyDown);\n    on(document, 'keyup', this._checkKeyUp);\n    this.defaults = {\n      selectedClass: 'sortable-selected',\n      multiDragKey: null,\n      setData: function setData(dataTransfer, dragEl) {\n        var data = '';\n\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          multiDragElements.forEach(function (multiDragElement, i) {\n            data += (!i ? '' : ', ') + multiDragElement.textContent;\n          });\n        } else {\n          data = dragEl.textContent;\n        }\n\n        dataTransfer.setData('Text', data);\n      }\n    };\n  }\n\n  MultiDrag.prototype = {\n    multiDragKeyDown: false,\n    isMultiDrag: false,\n    delayStartGlobal: function delayStartGlobal(_ref) {\n      var dragged = _ref.dragEl;\n      dragEl$1 = dragged;\n    },\n    delayEnded: function delayEnded() {\n      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);\n    },\n    setupClone: function setupClone(_ref2) {\n      var sortable = _ref2.sortable,\n          cancel = _ref2.cancel;\n      if (!this.isMultiDrag) return;\n\n      for (var i = 0; i < multiDragElements.length; i++) {\n        multiDragClones.push(clone(multiDragElements[i]));\n        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;\n        multiDragClones[i].draggable = false;\n        multiDragClones[i].style['will-change'] = '';\n        toggleClass(multiDragClones[i], this.options.selectedClass, false);\n        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);\n      }\n\n      sortable._hideClone();\n\n      cancel();\n    },\n    clone: function clone(_ref3) {\n      var sortable = _ref3.sortable,\n          rootEl = _ref3.rootEl,\n          dispatchSortableEvent = _ref3.dispatchSortableEvent,\n          cancel = _ref3.cancel;\n      if (!this.isMultiDrag) return;\n\n      if (!this.options.removeCloneOnHide) {\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          insertMultiDragClones(true, rootEl);\n          dispatchSortableEvent('clone');\n          cancel();\n        }\n      }\n    },\n    showClone: function showClone(_ref4) {\n      var cloneNowShown = _ref4.cloneNowShown,\n          rootEl = _ref4.rootEl,\n          cancel = _ref4.cancel;\n      if (!this.isMultiDrag) return;\n      insertMultiDragClones(false, rootEl);\n      multiDragClones.forEach(function (clone) {\n        css(clone, 'display', '');\n      });\n      cloneNowShown();\n      clonesHidden = false;\n      cancel();\n    },\n    hideClone: function hideClone(_ref5) {\n      var _this = this;\n\n      var sortable = _ref5.sortable,\n          cloneNowHidden = _ref5.cloneNowHidden,\n          cancel = _ref5.cancel;\n      if (!this.isMultiDrag) return;\n      multiDragClones.forEach(function (clone) {\n        css(clone, 'display', 'none');\n\n        if (_this.options.removeCloneOnHide && clone.parentNode) {\n          clone.parentNode.removeChild(clone);\n        }\n      });\n      cloneNowHidden();\n      clonesHidden = true;\n      cancel();\n    },\n    dragStartGlobal: function dragStartGlobal(_ref6) {\n      var sortable = _ref6.sortable;\n\n      if (!this.isMultiDrag && multiDragSortable) {\n        multiDragSortable.multiDrag._deselectMultiDrag();\n      }\n\n      multiDragElements.forEach(function (multiDragElement) {\n        multiDragElement.sortableIndex = index(multiDragElement);\n      }); // Sort multi-drag elements\n\n      multiDragElements = multiDragElements.sort(function (a, b) {\n        return a.sortableIndex - b.sortableIndex;\n      });\n      dragStarted = true;\n    },\n    dragStarted: function dragStarted(_ref7) {\n      var _this2 = this;\n\n      var sortable = _ref7.sortable;\n      if (!this.isMultiDrag) return;\n\n      if (this.options.sort) {\n        // Capture rects,\n        // hide multi drag elements (by positioning them absolute),\n        // set multi drag elements rects to dragRect,\n        // show multi drag elements,\n        // animate to rects,\n        // unset rects & remove from DOM\n        sortable.captureAnimationState();\n\n        if (this.options.animation) {\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            css(multiDragElement, 'position', 'absolute');\n          });\n          var dragRect = getRect(dragEl$1, false, true, true);\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            setRect(multiDragElement, dragRect);\n          });\n          folding = true;\n          initialFolding = true;\n        }\n      }\n\n      sortable.animateAll(function () {\n        folding = false;\n        initialFolding = false;\n\n        if (_this2.options.animation) {\n          multiDragElements.forEach(function (multiDragElement) {\n            unsetRect(multiDragElement);\n          });\n        } // Remove all auxiliary multidrag items from el, if sorting enabled\n\n\n        if (_this2.options.sort) {\n          removeMultiDragElements();\n        }\n      });\n    },\n    dragOver: function dragOver(_ref8) {\n      var target = _ref8.target,\n          completed = _ref8.completed,\n          cancel = _ref8.cancel;\n\n      if (folding && ~multiDragElements.indexOf(target)) {\n        completed(false);\n        cancel();\n      }\n    },\n    revert: function revert(_ref9) {\n      var fromSortable = _ref9.fromSortable,\n          rootEl = _ref9.rootEl,\n          sortable = _ref9.sortable,\n          dragRect = _ref9.dragRect;\n\n      if (multiDragElements.length > 1) {\n        // Setup unfold animation\n        multiDragElements.forEach(function (multiDragElement) {\n          sortable.addAnimationState({\n            target: multiDragElement,\n            rect: folding ? getRect(multiDragElement) : dragRect\n          });\n          unsetRect(multiDragElement);\n          multiDragElement.fromRect = dragRect;\n          fromSortable.removeAnimationState(multiDragElement);\n        });\n        folding = false;\n        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);\n      }\n    },\n    dragOverCompleted: function dragOverCompleted(_ref10) {\n      var sortable = _ref10.sortable,\n          isOwner = _ref10.isOwner,\n          insertion = _ref10.insertion,\n          activeSortable = _ref10.activeSortable,\n          parentEl = _ref10.parentEl,\n          putSortable = _ref10.putSortable;\n      var options = this.options;\n\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        }\n\n        initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location\n\n        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {\n          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible\n          var dragRectAbsolute = getRect(dragEl$1, false, true, true);\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted\n            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable\n\n            parentEl.appendChild(multiDragElement);\n          });\n          folding = true;\n        } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out\n\n\n        if (!isOwner) {\n          // Only remove if not folding (folding will remove them anyways)\n          if (!folding) {\n            removeMultiDragElements();\n          }\n\n          if (multiDragElements.length > 1) {\n            var clonesHiddenBefore = clonesHidden;\n\n            activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden\n\n\n            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {\n              multiDragClones.forEach(function (clone) {\n                activeSortable.addAnimationState({\n                  target: clone,\n                  rect: clonesFromRect\n                });\n                clone.fromRect = clonesFromRect;\n                clone.thisAnimationDuration = null;\n              });\n            }\n          } else {\n            activeSortable._showClone(sortable);\n          }\n        }\n      }\n    },\n    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {\n      var dragRect = _ref11.dragRect,\n          isOwner = _ref11.isOwner,\n          activeSortable = _ref11.activeSortable;\n      multiDragElements.forEach(function (multiDragElement) {\n        multiDragElement.thisAnimationDuration = null;\n      });\n\n      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {\n        clonesFromRect = _extends({}, dragRect);\n        var dragMatrix = matrix(dragEl$1, true);\n        clonesFromRect.top -= dragMatrix.f;\n        clonesFromRect.left -= dragMatrix.e;\n      }\n    },\n    dragOverAnimationComplete: function dragOverAnimationComplete() {\n      if (folding) {\n        folding = false;\n        removeMultiDragElements();\n      }\n    },\n    drop: function drop(_ref12) {\n      var evt = _ref12.originalEvent,\n          rootEl = _ref12.rootEl,\n          parentEl = _ref12.parentEl,\n          sortable = _ref12.sortable,\n          dispatchSortableEvent = _ref12.dispatchSortableEvent,\n          oldIndex = _ref12.oldIndex,\n          putSortable = _ref12.putSortable;\n      var toSortable = putSortable || this.sortable;\n      if (!evt) return;\n      var options = this.options,\n          children = parentEl.children; // Multi-drag selection\n\n      if (!dragStarted) {\n        if (options.multiDragKey && !this.multiDragKeyDown) {\n          this._deselectMultiDrag();\n        }\n\n        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));\n\n        if (!~multiDragElements.indexOf(dragEl$1)) {\n          multiDragElements.push(dragEl$1);\n          dispatchEvent({\n            sortable: sortable,\n            rootEl: rootEl,\n            name: 'select',\n            targetEl: dragEl$1,\n            originalEvt: evt\n          }); // Modifier activated, select from last to dragEl\n\n          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {\n            var lastIndex = index(lastMultiDragSelect),\n                currentIndex = index(dragEl$1);\n\n            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {\n              // Must include lastMultiDragSelect (select it), in case modified selection from no selection\n              // (but previous selection existed)\n              var n, i;\n\n              if (currentIndex > lastIndex) {\n                i = lastIndex;\n                n = currentIndex;\n              } else {\n                i = currentIndex;\n                n = lastIndex + 1;\n              }\n\n              for (; i < n; i++) {\n                if (~multiDragElements.indexOf(children[i])) continue;\n                toggleClass(children[i], options.selectedClass, true);\n                multiDragElements.push(children[i]);\n                dispatchEvent({\n                  sortable: sortable,\n                  rootEl: rootEl,\n                  name: 'select',\n                  targetEl: children[i],\n                  originalEvt: evt\n                });\n              }\n            }\n          } else {\n            lastMultiDragSelect = dragEl$1;\n          }\n\n          multiDragSortable = toSortable;\n        } else {\n          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);\n          lastMultiDragSelect = null;\n          dispatchEvent({\n            sortable: sortable,\n            rootEl: rootEl,\n            name: 'deselect',\n            targetEl: dragEl$1,\n            originalEvt: evt\n          });\n        }\n      } // Multi-drag drop\n\n\n      if (dragStarted && this.isMultiDrag) {\n        folding = false; // Do not \"unfold\" after around dragEl if reverted\n\n        if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {\n          var dragRect = getRect(dragEl$1),\n              multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');\n          if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;\n          toSortable.captureAnimationState();\n\n          if (!initialFolding) {\n            if (options.animation) {\n              dragEl$1.fromRect = dragRect;\n              multiDragElements.forEach(function (multiDragElement) {\n                multiDragElement.thisAnimationDuration = null;\n\n                if (multiDragElement !== dragEl$1) {\n                  var rect = folding ? getRect(multiDragElement) : dragRect;\n                  multiDragElement.fromRect = rect; // Prepare unfold animation\n\n                  toSortable.addAnimationState({\n                    target: multiDragElement,\n                    rect: rect\n                  });\n                }\n              });\n            } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert\n            // properly they must all be removed\n\n\n            removeMultiDragElements();\n            multiDragElements.forEach(function (multiDragElement) {\n              if (children[multiDragIndex]) {\n                parentEl.insertBefore(multiDragElement, children[multiDragIndex]);\n              } else {\n                parentEl.appendChild(multiDragElement);\n              }\n\n              multiDragIndex++;\n            }); // If initial folding is done, the elements may have changed position because they are now\n            // unfolding around dragEl, even though dragEl may not have his index changed, so update event\n            // must be fired here as Sortable will not.\n\n            if (oldIndex === index(dragEl$1)) {\n              var update = false;\n              multiDragElements.forEach(function (multiDragElement) {\n                if (multiDragElement.sortableIndex !== index(multiDragElement)) {\n                  update = true;\n                  return;\n                }\n              });\n\n              if (update) {\n                dispatchSortableEvent('update');\n              }\n            }\n          } // Must be done after capturing individual rects (scroll bar)\n\n\n          multiDragElements.forEach(function (multiDragElement) {\n            unsetRect(multiDragElement);\n          });\n          toSortable.animateAll();\n        }\n\n        multiDragSortable = toSortable;\n      } // Remove clones if necessary\n\n\n      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n        multiDragClones.forEach(function (clone) {\n          clone.parentNode && clone.parentNode.removeChild(clone);\n        });\n      }\n    },\n    nullingGlobal: function nullingGlobal() {\n      this.isMultiDrag = dragStarted = false;\n      multiDragClones.length = 0;\n    },\n    destroyGlobal: function destroyGlobal() {\n      this._deselectMultiDrag();\n\n      off(document, 'pointerup', this._deselectMultiDrag);\n      off(document, 'mouseup', this._deselectMultiDrag);\n      off(document, 'touchend', this._deselectMultiDrag);\n      off(document, 'keydown', this._checkKeyDown);\n      off(document, 'keyup', this._checkKeyUp);\n    },\n    _deselectMultiDrag: function _deselectMultiDrag(evt) {\n      if (typeof dragStarted !== \"undefined\" && dragStarted) return; // Only deselect if selection is in this sortable\n\n      if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable\n\n      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click\n\n      if (evt && evt.button !== 0) return;\n\n      while (multiDragElements.length) {\n        var el = multiDragElements[0];\n        toggleClass(el, this.options.selectedClass, false);\n        multiDragElements.shift();\n        dispatchEvent({\n          sortable: this.sortable,\n          rootEl: this.sortable.el,\n          name: 'deselect',\n          targetEl: el,\n          originalEvt: evt\n        });\n      }\n    },\n    _checkKeyDown: function _checkKeyDown(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = true;\n      }\n    },\n    _checkKeyUp: function _checkKeyUp(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = false;\n      }\n    }\n  };\n  return _extends(MultiDrag, {\n    // Static methods & properties\n    pluginName: 'multiDrag',\n    utils: {\n      /**\n       * Selects the provided multi-drag item\n       * @param  {HTMLElement} el    The element to be selected\n       */\n      select: function select(el) {\n        var sortable = el.parentNode[expando];\n        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;\n\n        if (multiDragSortable && multiDragSortable !== sortable) {\n          multiDragSortable.multiDrag._deselectMultiDrag();\n\n          multiDragSortable = sortable;\n        }\n\n        toggleClass(el, sortable.options.selectedClass, true);\n        multiDragElements.push(el);\n      },\n\n      /**\n       * Deselects the provided multi-drag item\n       * @param  {HTMLElement} el    The element to be deselected\n       */\n      deselect: function deselect(el) {\n        var sortable = el.parentNode[expando],\n            index = multiDragElements.indexOf(el);\n        if (!sortable || !sortable.options.multiDrag || !~index) return;\n        toggleClass(el, sortable.options.selectedClass, false);\n        multiDragElements.splice(index, 1);\n      }\n    },\n    eventProperties: function eventProperties() {\n      var _this3 = this;\n\n      var oldIndicies = [],\n          newIndicies = [];\n      multiDragElements.forEach(function (multiDragElement) {\n        oldIndicies.push({\n          multiDragElement: multiDragElement,\n          index: multiDragElement.sortableIndex\n        }); // multiDragElements will already be sorted if folding\n\n        var newIndex;\n\n        if (folding && multiDragElement !== dragEl$1) {\n          newIndex = -1;\n        } else if (folding) {\n          newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');\n        } else {\n          newIndex = index(multiDragElement);\n        }\n\n        newIndicies.push({\n          multiDragElement: multiDragElement,\n          index: newIndex\n        });\n      });\n      return {\n        items: _toConsumableArray(multiDragElements),\n        clones: [].concat(multiDragClones),\n        oldIndicies: oldIndicies,\n        newIndicies: newIndicies\n      };\n    },\n    optionListeners: {\n      multiDragKey: function multiDragKey(key) {\n        key = key.toLowerCase();\n\n        if (key === 'ctrl') {\n          key = 'Control';\n        } else if (key.length > 1) {\n          key = key.charAt(0).toUpperCase() + key.substr(1);\n        }\n\n        return key;\n      }\n    }\n  });\n}\n\nfunction insertMultiDragElements(clonesInserted, rootEl) {\n  multiDragElements.forEach(function (multiDragElement, i) {\n    var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];\n\n    if (target) {\n      rootEl.insertBefore(multiDragElement, target);\n    } else {\n      rootEl.appendChild(multiDragElement);\n    }\n  });\n}\n/**\n * Insert multi-drag clones\n * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted\n * @param  {HTMLElement} rootEl\n */\n\n\nfunction insertMultiDragClones(elementsInserted, rootEl) {\n  multiDragClones.forEach(function (clone, i) {\n    var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];\n\n    if (target) {\n      rootEl.insertBefore(clone, target);\n    } else {\n      rootEl.appendChild(clone);\n    }\n  });\n}\n\nfunction removeMultiDragElements() {\n  multiDragElements.forEach(function (multiDragElement) {\n    if (multiDragElement === dragEl$1) return;\n    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);\n  });\n}\n\nSortable.mount(new AutoScrollPlugin());\nSortable.mount(Remove, Revert);\n\n/* harmony default export */ var sortable_esm = (Sortable);\n\n\n;// CONCATENATED MODULE: ./public/src/components/sortable.js\n\n\n\nlet sortable = {\n  connect: selector => {\n    let el = common_$(selector).el[0];\n\n    if (el) {\n      let sortable = sortable_esm.create(el, {\n        animation: 150,\n        onEnd: function (evt) {\n          let oldI = evt.oldIndex;\n          let newI = evt.newIndex;\n\n          if (oldI > newI) {\n            let questions = question_question.questions();\n\n            question_question.sort(oldI);\n          } else {\n            let questions = question_question.questions();\n\n            question_question.sort(newI);\n          }\n        }\n      });\n    }\n  }\n};\n;// CONCATENATED MODULE: ./public/src/Test/test-edit.js\n\n\n\n // import './test'\n\n\n\n\n\n\n\n\n\n\nfunction testEdit() {\n  accordionShow();\n  let parentSelect = new WDSSelect({\n    element: common_$(\"[data-custom-parent]\")[0],\n    title: 'Папка',\n    class: 'parent'\n  });\n  let enableSelect = new WDSSelect({\n    element: common_$(\"[data-custom-enable]\")[0],\n    title: 'Показывать пользователям',\n    class: 'enable'\n  });\n\n  if (common_$(\"[data-question-parent-id]\")) {\n    common_$(\".select__wrap select\").on('change', question_question.changeParent);\n  } // подсветка текущего теста\n\n\n  _test.markCurrentInMenu();\n\n  sortable.connect('.questions'); // при создании нового теста показать пустой вопрос\n\n  if (!question_question.questions().length && /\\/adminsc\\/test\\/edit/.test(window.location.pathname)) {\n    question_question.showFirst();\n  } // $('.test__update').on('click', _test.update.bind(null, parentSelect.selectedOption, enableSelect.selectedOption))\n\n\n  common_$('.test-path__update').on('click', _test.update); // $('.question__sort').on('change', validate.sort)\n\n  common_$('.question__save').on('click', question_question.save);\n  common_$('.question__show-answers').on('click', question_question.showAnswers);\n  common_$('.question__delete').on('click', question_question[\"delete\"]);\n  common_$('.question__create-button').on('click', question_question.create);\n  common_$('.answer__delete').on('click', answer_answer.del);\n  common_$('.answer__create-button').on('click', answer_answer.create);\n  addTooltip({\n    els: common_$('.question__save').el,\n    message: 'Сохранить вопросы и ответы'\n  });\n  addTooltip({\n    els: common_$('.question__menu').el,\n    message: 'Переложить в другой тест'\n  });\n  addTooltip({\n    els: common_$('.question__delete').el,\n    message: 'Удалить вопросы и ответы'\n  });\n  addTooltip({\n    els: common_$('.question__show-answers').el,\n    message: 'Показать ответы'\n  });\n  addTooltip({\n    els: common_$('.test-edit-menu__params').el,\n    message: 'Редактировать'\n  });\n  addTooltip({\n    els: common_$('.question__menu').el,\n    message: 'Перенести в другой тест'\n  });\n}\n;// CONCATENATED MODULE: ./public/src/components/test-pagination/test-pagination.js\n\n\n\n // Показать первую кнопку\n\ncommon_$('[data-pagination]:first-child').addClass('nav-active'); // $('.test-edit__content').addClass('flex1')\n//// add question\n\ncommon_$('.pagination').on('click', function (e) {\n  if (e.target.classList.contains('add-question')) {\n    debugger;\n    show();\n    return;\n  } //// paginate\n\n\n  if (e.target.getAttribute('data-pagination')) {\n    paginate(e.target);\n    return;\n  }\n});\n\nfunction paginate(self) {\n  /// get clicked button Return if clicked is active\n  if (self.classList.contains('nav-active')) return;\n  let active_btn = common_$('.pagination .nav-active').el[0]; //// change active button\n\n  active_btn.classList.remove('nav-active');\n  self.classList.add('nav-active'); //// hide the card\n\n  let id_to_hide = active_btn.dataset['pagination'];\n  common_$(`#question-${id_to_hide}`).removeClass('flex1'); //// show the card\n\n  let id_to_show = self.dataset['pagination'];\n  common_$(`#question-${id_to_show}`).addClass('flex1');\n} //// добавление вопроса\n\n\nasync function show(e) {\n  let testid = +common_$('.test-name').value();\n  let questCount = common_$(\"[data-pagination]\").count();\n  let res = await post('/question/show', {\n    testid,\n    questCount\n  });\n  res = JSON.parse(res);\n  let Block = res.block;\n  let blocks = common_$('.blocks').el[0];\n  blocks.insertAdjacentHTML('afterBegin', Block);\n  let newBlock = common_$('.blocks .block:first-child').el[0];\n  document.querySelector('.flex1').classList.remove('flex1');\n  common_$(newBlock).addClass('flex1');\n  let save_button = common_$(newBlock).find('.question__save');\n  common_$(save_button).on('click', question_question().save);\n}\n\nfunction showHidePaginBtn(pagItem) {\n  let activePaginBtn = $('.pagination .nav-active').el[0];\n\n  if (activePaginBtn) {\n    activePaginBtn.classList.remove('nav-active');\n  }\n\n  $('.add-question').el[0].insertAdjacentHTML('beforeBegin', pagItem);\n}\n\nfunction appendBlock() {\n  let block = $('.overlay').find('.block');\n  $('.blocks').append(block);\n  $(block).addClass('flex1');\n  $('.a-add').on('click', _answer.create);\n  $('.q-delete').on('click', _question().delete());\n  $('.a-del').on('click', _answer.delete());\n}\n\nfunction navInit() {\n  let nav_buttons = common_$('[data-pagination]');\n  if (!nav_buttons[0]) return false;\n  Array.from(nav_buttons).map(el => {\n    el.classList.remove('nav-active');\n  });\n  nav_buttons[0].classList.add('nav-active');\n}\n\n\n;// CONCATENATED MODULE: ./public/src/Test/do.js\n\n\n\n\n\nfunction testDo() {\n  accordionShow(); //Скрыть все вопросы\n\n  common_$('.question').removeClass(\"flex1\"); //Показть первый вопрос\n\n  common_$('.question:first-child').addClass(\"flex1\"); // Нажать первуюкнопку navigation\n\n  navInit();\n  common_$('.test-do__content [type=\"checkbox\"]').on('click', function (e) {\n    let a = e.target.labels[0];\n    a.classList.toggle('pushed');\n  });\n  common_$('#prev').on('click', _test.prevQ);\n  common_$('#next').on('click', _test.nextQ); /////////////////////////////////////////////////////////////////////////////\n  ///////////  RESULTS  TEST  Закончить тест/////////////////////////////\n  /////////////////////////////////////////////////////////////////////////////\n  // если это результат теста, деактивирукм кнопку Закончить тест\n\n  let button = common_$('.test-do__finish-btn').el[0];\n\n  if (button) {\n    if (window.location.pathname.match('^/test/result/.?')) {\n      button.classList.add('inactive');\n    }\n  }\n\n  common_$('.test-do__finish-btn').on('click', async function (e) {\n    let button = e.target;\n    if (button.classList.contains('inactive')) return false;\n    if (button.id !== 'btnn') return false;\n\n    if (button.text == \"ПРОЙТИ ТЕСТ ЗАНОВО\") {\n      location.reload();\n      return;\n    }\n\n    let corrAnswers = await post('/test/getCorrectAnswers', {});\n    corrAnswers = JSON.parse(corrAnswers);\n    let errorCnt = colorView(corrAnswers);\n    let data = objToServer(errorCnt);\n    let res = await post('/test/cachePageSendEmail', data);\n\n    if (res) {\n      common_$(\"#btnn\").el[0].href = location.href;\n      common_$(\"#btnn\").el[0].text = \"ПРОЙТИ ТЕСТ ЗАНОВО\";\n    }\n  });\n\n  function objToServer(errorCnt) {\n    let obj = {\n      token: document.querySelector('meta[name=\"token\"]').getAttribute('content'),\n      questionCnt: common_$('.question').el.length,\n      errorCnt: errorCnt,\n      pageCache: `<!DOCTYPE ${document.doctype.name}>` + document.documentElement.outerHTML,\n      testId: common_$('[data-test-id]').el[0].dataset.testId,\n      test_name: common_$('.test-name').el[0].innerText,\n      userName: common_$('.user-menu__fio').el[0].innerText\n    };\n    let formData = new FormData();\n    formData.append('token', obj.token);\n    formData.append('questionCnt', obj.questionCnt);\n    formData.append('errorCnt', obj.errorCnt);\n    formData.append('pageCache', obj.pageCache);\n    formData.append('testId', obj.testId);\n    formData.append('test_name', obj.test_name);\n    formData.append('userName', obj.userName);\n    return formData;\n    return obj;\n  }\n\n  function colorView(correctAnswers) {\n    let q = common_$('.question').el;\n    Array.from(q).map((question, i) => {\n      let answers = question.querySelectorAll('.a'),\n          errors = [];\n      Array.from(answers).map(answer => {\n        let input = answer.getElementsByTagName('input')[0],\n            answerId = input.id.replace(\"answer-\", \"\"),\n            // id question\n        label = answer.getElementsByTagName('label')[0],\n            // Чтобы прикрепить зеленый значек к этому элементу\n        correctAnser = correctAnswers.indexOf(answerId) !== -1;\n\n        if (!checkCorrectAnswers(correctAnser, input, label)) {\n          errors.push(true);\n        }\n      });\n      let questId = +question.dataset['id'],\n          // id question\n      paginItem = common_$('.pagination [data-pagination=\"' + questId + '\"]').el[0];\n\n      if (errors.length) {\n        common_$(paginItem).addClass('redShadow');\n      } else {\n        common_$(paginItem).addClass('greenShadow');\n      }\n    });\n    return common_$('.redShadow').el.length;\n  }\n\n  function checkCorrectAnswers(correctAnser, input, label) {\n    if (input.checked && correctAnser) {\n      // checkbox нажат. а в correct answer нету. в correct_answers есть, его всегда подсвечиваем зеленым\n      label.classList.add('done'); //green check зеленый значек\n\n      return true;\n    } else if (input.checked && !correctAnser) {\n      // checkbox нажат,и есть в correct answer. в correct_answers нет, кнопка не нажата\n      return false;\n    } else if (!input.checked && correctAnser) {\n      // кнопка не нажата, в correct_answers есть\n      label.classList.add('done'); //green check зеленый значек\n\n      label.classList.add('done'); // green check зеленый значек\n\n      return false;\n    } else if (!input.checked && !correctAnser) {\n      // кнопка не нажата, в correct_answers нет\n      return true;\n    }\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Admin/Settings/users.js\n\nfunction init() {}\n;// CONCATENATED MODULE: ./public/src/Admin/Settings/settings.js\n// import rights from '../Rights/rights'\n // import rights from \"./rights\";\n\nfunction settings() {\n  // rights()\n  init();\n}\n;// CONCATENATED MODULE: ./public/src/components/list/list.js\n\n\nfunction list(selector) {\n  // debugger;\n  common_$('html').ready(function () {\n    const table = common_$('.custom-list')[0];\n    const headers = table.querySelectorAll('.head');\n    const inputs = table.querySelectorAll('.head input');\n    const tableBody = table.querySelectorAll('[data-id]');\n    const ids = common_$(table)[0].querySelectorAll('.id:not(.head');\n    const rows = [];\n\n    for (let i = 0; i < ids.length; i++) {\n      let id = ids[i].dataset.id;\n      let row = common_$(table)[0].querySelectorAll(`[data-id='${id}']`);\n      rows.push(row);\n    } // const rows = table.querySelectorAll('td')\n    // Направление сортировки\n\n\n    const directions = Array.from(headers).map(function (header) {\n      return '';\n    }); // Преобразовать содержимое данной ячейки в заданном столбце\n\n    function transform(index, content) {\n      // Получить тип данных столбца\n      const type = headers[index].getAttribute('data-type');\n\n      switch (type) {\n        case 'number':\n          return parseFloat(content);\n\n        case 'string':\n        default:\n          return content;\n      }\n    }\n\n    ;\n\n    function showAllRows() {\n      [].forEach.call(rows, row => {\n        [].forEach.call(row, el => {\n          el.style.display = 'flex';\n        });\n      });\n    }\n\n    function search(index, input) {\n      showAllRows();\n      const value = input.value;\n      [].forEach.call(inputs, inp => {\n        if (inp !== input) inp.value = '';\n      });\n      [].forEach.call(rows, function (row) {\n        const str = row[index].innerText;\n        const regexp = new RegExp(`${value}`, 'gi');\n\n        if (!str.match(regexp)) {\n          [].forEach.call(row, el => {\n            el.style.display = 'none';\n          });\n        }\n      });\n    }\n\n    ;\n\n    function sortColumn(index) {\n      // Получить текущее направление\n      const direction = directions[index] || 'asc'; // Фактор по направлению\n\n      const multiplier = direction === 'asc' ? 1 : -1;\n      const newRows = Array.from(rows);\n      newRows.sort(function (rowA, rowB) {\n        const cellA = rowA[index].innerHTML;\n        const cellB = rowB[index].innerHTML;\n        const a = transform(index, cellA);\n        const b = transform(index, cellB);\n\n        switch (true) {\n          case a > b:\n            return 1 * multiplier;\n\n          case a < b:\n            return -1 * multiplier;\n\n          case a === b:\n            return 0;\n        }\n      }); // Удалить старые строки\n\n      [].forEach.call(rows, function (nodeList) {\n        [].forEach.call(nodeList, el => {\n          el.remove();\n        });\n      }); // Поменять направление\n\n      directions[index] = direction === 'asc' ? 'desc' : 'asc'; // Добавить новую строку\n\n      newRows.forEach(function (newRow) {\n        newRow = Array.from(newRow);\n        newRow.reverse();\n        [].forEach.call(newRow, el => {\n          headers[headers.length - 1].after(el);\n        });\n      });\n    }\n\n    ;\n    [].forEach.call(headers, function (header, index) {\n      const className = header.className;\n      header.addEventListener('click', function (e) {\n        if (e.target.classList.contains('head')) {\n          sortColumn(index);\n        }\n      });\n      const input = header.querySelector('input');\n\n      if (input) {\n        input.addEventListener('keyup', function (e) {\n          e.stopPropagation();\n          search(index, input);\n        });\n      }\n    });\n  });\n}\n;// CONCATENATED MODULE: ./public/src/components/contenteditable.js\n\nfunction contenteditable() {\n  let contenteditable = common_$('[contenteditable]');\n  let model = common_$('.custom-list')[0];\n  let debounceTimer;\n\n  if (model && contenteditable) {\n    common_$(model).on('keyup', handle.bind(model, contenteditable));\n  }\n\n  function handle(e) {\n    if (['NumpadEnter', 'Enter'].includes(e.code)) {\n      save();\n    } else {\n      let text = e.target; // inputed(e.target, contenteditable)\n      // debugger\n\n      if (debounceTimer) {\n        clearTimeout(debounceTimer);\n      }\n\n      debounceTimer = setTimeout(inputed.bind(model, contenteditable), 3000);\n    }\n  }\n\n  function inputed(target, contenteditable) {\n    let el = common_$(contenteditable).find(target);\n\n    if (el) {\n      save(); // alert(el.innerText)\n    }\n  }\n\n  function save() {\n    alert('dd');\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Admin/Rights/rights.js\n\n\n\n\nfunction rights() {\n  // debugger\n  contenteditable();\n  list();\n  common_$('.rights-table').on('click', handle);\n\n  function handle(_ref) {\n    let {\n      target\n    } = _ref;\n    if (target.closest('.del')) del(target.closest('.del'));\n    if (target.closest('.save')) save(target.closest('.save'));\n\n    function model(el) {\n      let dataId = el.dataset.id ?? 'new';\n      let fields = common_$(`[data-id='${dataId}']`);\n      let model = {};\n      model.toServ = {};\n      model.empty = {};\n      fields.map(f => {\n        if (f.classList.contains('id')) {\n          model.id = f;\n          model.toServ.id = f.dataset.id;\n        } else if (f.classList.contains('name')) {\n          model.name = f;\n          model.toServ.name = f.innerText.trim();\n        } else if (f.classList.contains('description')) {\n          model.description = f;\n          model.toServ.description = f.innerText.trim();\n        } else if (f.classList.contains('save.svg')) {\n          model.save = f;\n        } else if (f.classList.contains('del')) {\n          model.del = f;\n        }\n      });\n      model.empty.del = model.id.previousElementSibling.cloneNode(true);\n      model.empty.save = model.id.previousElementSibling.previousElementSibling.cloneNode(true);\n      model.empty.description = model.id.previousElementSibling.previousElementSibling.previousElementSibling.cloneNode(true);\n      model.empty.name = model.id.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.cloneNode(true);\n      model.empty.id = model.id.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.cloneNode(true);\n      return model;\n    }\n\n    function del(el) {\n      let mod = model(el);\n      if (mod.toServ.id === 'new') return;\n\n      if (confirm(\"Удалить право?\")) {\n        delDom(mod);\n        delServer(mod);\n      }\n    }\n\n    async function delServer(model) {\n      let res = await post('/right/delete', {\n        id: model.toServ.id\n      });\n      res = await JSON.parse(res);\n\n      if (res.msg === 'ok') {\n        popup.show('Удалено');\n      }\n    }\n\n    function delDom(model) {\n      model.id.remove();\n      model.name.remove();\n      model.description.remove();\n      model.save.remove();\n      model.del.remove();\n    }\n\n    function save(el) {\n      let mod = model(el);\n\n      if (mod.toServ.id !== 'new') {\n        update(mod.toServ);\n      } else {\n        if (!mod.toServ.name || !mod.toServ.description) return false;\n        create(mod);\n      }\n    }\n\n    async function update(toServ) {\n      let res = await post('/right/update', toServ);\n\n      if (await JSON.parse(res).updated) {\n        popup.show('Обновлено');\n      }\n    }\n\n    function clearModel(model) {\n      model.name.innerText = \"\";\n      model.description.innerText = \"\";\n    }\n\n    function createOnDom(model) {\n      let lastElement = common_$(\".id[data-id='new']\")[0];\n      lastElement.before(model.empty.id);\n      lastElement.before(model.empty.name);\n      lastElement.before(model.empty.description);\n      lastElement.before(model.empty.save);\n      lastElement.before(model.empty.del);\n    }\n\n    function assignNewValuesOnClone(model, id) {\n      model.empty.id.dataset.id = id;\n      model.empty.id.innerText = id;\n      model.empty.name.dataset.id = id;\n      model.empty.name.innerText = model.name.innerText.trim();\n      model.empty.description.dataset.id = id;\n      model.empty.description.innerText = model.description.innerText.trim();\n      model.empty.save.dataset.id = id;\n      model.empty.del.dataset.id = id;\n    }\n\n    async function create(model) {\n      let res = await post('/right/create', model.toServ);\n      res = await JSON.parse(res);\n\n      if (res.id) {\n        assignNewValuesOnClone(model, res.id - 1);\n        createOnDom(model);\n        clearModel(model);\n        popup.show('Сохранено');\n      }\n    }\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Admin/Planning/planning.js\n\n\nfunction planning() {\n  debugger;\n}\n;// CONCATENATED MODULE: ./public/src/Admin/CRM/user.js\n\n\nfunction user() {\n  list();\n  common_$('#user-update-btn').on('click', save);\n\n  async function save(e) {\n    let rights = common_$('input.right:checked');\n    rights = rights.map(r => r.previousElementSibling.innerHTML);\n    rights = rights.join(',');\n    let sel = common_$('.tabs').find('#conf');\n    let conf = sel.options[sel.options.selectedIndex].value;\n\n    function sex() {\n      const f = common_$('[name=\"sex\"]:checked')[0];\n      const s = common_$('[name=\"sex\"]').el;\n\n      for (let f of s) {\n        if (f.checked) {\n          return f.value;\n        }\n      }\n\n      return 'm';\n    }\n\n    const model = {\n      id: common_$('.tabs').find('#id').innerText.trim(),\n      confirm: conf,\n      name: common_$('.tabs').find('#name').innerText,\n      surName: common_$('.tabs').find('#s-name').innerText,\n      email: common_$('.tabs').find('#email').innerText.trim(),\n      middleName: common_$('.tabs').find('#m-name').innerText,\n      phone: common_$('.tabs').find('#phone').innerText,\n      birthDate: common_$('.tabs').find('#bday').value,\n      hired: common_$('.tabs').find('#hired').value,\n      fired: common_$('.tabs').find('#fired').value,\n      rights: rights,\n      sex: sex()\n    };\n    let res = await post('/user/update', model);\n\n    if (res === 'ok') {\n      popup.show('Сохранено');\n    }\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Admin/CRM/users.js\n\n\nfunction users() {\n  list();\n  common_$('#users div[data-id]').on('change', function () {\n    crudUser('UPDATE', common_$(this));\n  });\n\n  function crudUser(crud, target) {\n    var data = {\n      name: common_$(target).find('.name').val(),\n      sName: common_$(target).find('.s-name').val(),\n      mName: common_$(target).find('.m-name').val(),\n      bday: common_$(target).find('.bday').val(),\n      phone: common_$(target).find('.phone').val(),\n      conf: common_$(target).find('.confirm').val(),\n      email: common_$(target).find('.email').val(),\n      hired: common_$(target).find('.hired').val(),\n      fired: common_$(target).find('.fired').val(),\n      userId: common_$(target).data('id'),\n      table: 'users',\n      crud: crud\n    };\n    var param = JSON.stringify(data);\n  }\n\n  ;\n  common_$('.wrap').on('click', '.save.svg', function () {\n    var self = common_$(this)[0];\n\n    if (self.classList.contains('new')) {\n      crudUser('INSERT', common_$(this));\n    } else {\n      crudUser('UPDATE', common_$(this));\n    }\n  });\n  common_$('.wrap').on('click', '.btnadd-user', function () {\n    var data = {\n      action: 'addUser'\n    };\n    post('/adminsc/users', data).then(function (str) {\n      common_$('tbody').append(str);\n    });\n  });\n\n  async function post(url, data) {\n    //      debugger;\n    return new Promise(function (resolve, reject) {\n      var req = new XMLHttpRequest();\n      req.open('POST', url);\n      req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n      req.setRequestHeader('Content-Type', 'application/json');\n      req.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n      req.send('param=' + JSON.stringify(data));\n\n      req.onerror = function () {\n        reject(Error(\"Network Error\"));\n      };\n\n      req.onload = function () {\n        resolve(req.response);\n      };\n    });\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Admin/admin.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n // let p = $('.page-name')[0]\n\nadmin_navigate(window.location.pathname);\n\nfunction admin_navigate(str) {\n  // debugger\n  switch (true) {\n    case /\\/adminsc\\/settings/.test(str):\n    case /\\/adminsc\\/right\\/list/.test(str):\n      // debugger\n      rights();\n      common_$(\"[href='/adminsc/settings']\").addClass('current');\n      break;\n\n    case /\\/adminsc\\/Sitemap/.test(str):\n      settings();\n      common_$(\"[href='/adminsc/settings']\").addClass('current');\n      break;\n\n    case /\\/adminsc\\/crm\\/testresults/.test(str):\n      testResults();\n      common_$(\"[href='/adminsc/crm/testresults']\").addClass('current');\n      break;\n\n    case /\\/adminsc\\/user/.test(str):\n      user();\n      break;\n\n    case /\\/adminsc\\/user\\/list/.test(str):\n      users();\n      break;\n\n    case /\\/adminsc\\/crm/.test(str):\n      common_$(\"[href='/adminsc/crm']\").addClass('current');\n      break;\n\n    case /\\/adminsc\\/catalog/.test(str):\n      common_$(\"[href='/adminsc/catalog']\").addClass('current');\n      break;\n\n    case /\\/adminsc\\/planning/.test(str):\n      planning();\n      common_$(\"[href='/adminsc/planning']\").addClass('current');\n      break;\n\n    case /\\/adminsc\\/test\\/update/.test(str):\n    case /\\/adminsc\\/test\\/show/.test(str):\n      testUpdate();\n      break;\n\n    case /\\/adminsc\\/test\\/pathshow/.test(str):\n    case /\\/adminsc\\/test\\/edit/.test(str):\n      // debugger\n      testEdit();\n      common_$(\"[href='/adminsc/test/edit']\").addClass('current');\n      break;\n\n    case /\\/test/.test(str) || /\\/test\\/result/.test(str):\n      testDo();\n      common_$(\"[href='/test/do']\").addClass('current');\n      break;\n\n    default:\n      common_$(\"[href='/house']\").addClass('current');\n      break;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0EsTUFBTTtBQUNOLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpTUFBaU07O0FBRWpNO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQzs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7O0FBR047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQSxpRUFBaUU7OztBQUdqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIsWUFBWSwwQkFBMEI7QUFDdEM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWE7QUFDYjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QixZQUFZLDRCQUE0QjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7OztBQUdBO0FBQ0EseUVBQXlFLGFBQWE7QUFDdEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7O0FBRUEsdUVBQXVFO0FBQ3ZFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGFBQWE7QUFDeEI7OztBQUdBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVEOztBQUV2RDs7QUFFQTtBQUNBLDJFQUEyRTs7QUFFM0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKLGtDQUFrQztBQUNsQyxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isa0RBQUU7QUFDMUIsc0JBQXNCLGtEQUFFO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLDhC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LEtBQXNCLGlCQUFpQmhYLElBQWpCLENBQXNCZ1gsR0FBdEIsQ0FBM0I7QUFDRTdDLE1BQUFBLE1BQU07QUFDTnZULE1BQUFBLFFBQUMsQ0FBQyxtQkFBRCxDQUFELENBQXVCb0YsUUFBdkIsQ0FBZ0MsU0FBaEM7QUFDQTs7QUFFRjtBQUNFcEYsTUFBQUEsUUFBQyxDQUFDLGlCQUFELENBQUQsQ0FBcUJvRixRQUFyQixDQUE4QixTQUE5QjtBQUNBO0FBekRKO0FBMkREIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9jb21tb24uanM/NTkyMSIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL2NvbXBvbmVudHMvYWNjb3JkaW9uL2FjY29yZGlvbi5qcz8yNWI1Iiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvQWRtaW4vbW9kZWwvY2FjaGUuanM/MWUxNyIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL1Rlc3QvbW9kZWwvX3Rlc3RSZXN1bHQuanM/MTY2OCIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL1Rlc3QvdGVzdF9yZXN1bHRzL3Rlc3RfcmVzdWx0cy5qcz81MzRhIiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvVGVzdC9tb2RlbC90ZXN0LmpzPzlhNmEiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9jb21wb25lbnRzL3NlbGVjdC9XRFNTZWxlY3QuanM/YzQwZCIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL1Rlc3QvYWNjb3JkaW9uLXNob3cuanM/NDAxZSIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL1Rlc3QvdGVzdC11cGRhdGUuanM/NmZmZCIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL1Rlc3QvbW9kZWwvYW5zd2VyLmpzPzk5YWQiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9UZXN0L21vZGVsL3F1ZXN0aW9uLmpzPzIzZDkiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3NvcnRhYmxlanMvbW9kdWxhci9zb3J0YWJsZS5lc20uanM/YWE0NyIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL2NvbXBvbmVudHMvc29ydGFibGUuanM/ZGNmNSIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL1Rlc3QvdGVzdC1lZGl0LmpzP2FkNWEiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9jb21wb25lbnRzL3Rlc3QtcGFnaW5hdGlvbi90ZXN0LXBhZ2luYXRpb24uanM/NGFlMiIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL1Rlc3QvZG8uanM/NGMzNSIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL0FkbWluL1NldHRpbmdzL3VzZXJzLmpzPzY5ZmYiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9BZG1pbi9TZXR0aW5ncy9zZXR0aW5ncy5qcz83OWU1Iiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvY29tcG9uZW50cy9saXN0L2xpc3QuanM/ZjAyMyIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL2NvbXBvbmVudHMvY29udGVudGVkaXRhYmxlLmpzPzkxZWUiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9BZG1pbi9SaWdodHMvcmlnaHRzLmpzPzZlZTMiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9BZG1pbi9QbGFubmluZy9wbGFubmluZy5qcz9iZTZmIiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvQWRtaW4vQ1JNL3VzZXIuanM/NGQxOSIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL0FkbWluL0NSTS91c2Vycy5qcz84NmM1Iiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvQWRtaW4vYWRtaW4uanM/MjVjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4vY29tbW9uLnNjc3MnXHJcblxyXG5mdW5jdGlvbiBkcm9wRG93biAoZWxlbWVudElkKSB7XHJcbiAgdmFyIGRyb3Bkb3duID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudElkKTtcclxuICB0cnkge1xyXG4gICAgc2hvd0Ryb3Bkb3duKGRyb3Bkb3duKTtcclxuICB9IGNhdGNoIChlKSB7XHJcblxyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBzaG93RHJvcGRvd24oZWxlbWVudCkge1xyXG4gIHZhciBldmVudDtcclxuICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xyXG4gIGV2ZW50LmluaXRNb3VzZUV2ZW50KCdtb3VzZWRvd24nLCB0cnVlLCB0cnVlLCB3aW5kb3cpO1xyXG4gIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbn07XHJcblxyXG5cclxubGV0IHZhbGlkYXRlID0ge1xyXG4gIHNvcnQ6ICgpID0+IHtcclxuICAgIGxldCBlcnJvciA9IHRoaXMubmV4dEVsZW1lbnRTaWJsaW5nXHJcbiAgICBsZXQgYXIgPSB0aGlzLnZhbHVlLm1hdGNoKC9cXEQrLylcclxuICAgIGlmIChhcikge1xyXG4gICAgICBlcnJvci5pbm5lclRleHQgPSAn0KLQvtC70YzQutC+INGG0LjRhNGA0YsnXHJcbiAgICAgIGVycm9yLnN0eWxlLm9wYWNpdHkgPSAnMSdcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChlcnJvci5zdHlsZS5vcGFjaXR5ID09PSBcIjFcIikge1xyXG4gICAgICAgIGVycm9yLnN0eWxlLm9wYWNpdHkgPSAnMCdcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgZW1haWw6IChlbWFpbCkgPT4ge1xyXG4gICAgaWYgKCFlbWFpbCkgcmV0dXJuIGZhbHNlXHJcbiAgICBsZXQgcmUgPSAvXigoW148PigpW1xcXVxcXFwuLDs6XFxzQFwiXSsoXFwuW148PigpW1xcXVxcXFwuLDs6XFxzQFwiXSspKil8KFwiLitcIikpQCgoXFxbWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcXSl8KChbYS16QS1aXFwtMC05XStcXC4pK1thLXpBLVpdezIsfSkpJC87XHJcbiAgICByZXR1cm4gcmUudGVzdChTdHJpbmcoZW1haWwpLnRvTG93ZXJDYXNlKCkpO1xyXG4gIH0sXHJcbiAgcGFzc3dvcmQ6IChwYXNzd29yZCkgPT4ge1xyXG4gICAgaWYgKCFwYXNzd29yZCkgcmV0dXJuIGZhbHNlXHJcbiAgICBsZXQgcmUgPSAvXlthLXpBLVpcXC0wLTldezYsMjB9JC9cclxuICAgIHJldHVybiByZS50ZXN0KHBhc3N3b3JkKVxyXG4gIH1cclxufVxyXG5cclxuXHJcbi8vIGZ1bmN0aW9uIHVwKCkge1xyXG4vLyAgICB2YXIgdG9wID0gTWF0aC5tYXgoZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApO1xyXG4vLyAgICBpZiAodG9wID4gMCkge1xyXG4vLyAgICAgICB3aW5kb3cuc2Nyb2xsQnkoMCwgLTEwMCk7XHJcbi8vICAgICAgIHZhciB0ID0gc2V0VGltZW91dCgndXAoKScsIDIwKTtcclxuLy8gICAgfVxyXG4vLyAgICBlbHNlXHJcbi8vICAgICAgIGNsZWFyVGltZW91dCh0KTtcclxuLy8gICAgcmV0dXJuIGZhbHNlO1xyXG4vLyB9XHJcblxyXG5sZXQgcG9wdXAgPSB7XHJcblxyXG4gIHNob3c6IGZ1bmN0aW9uICh0eHQsIGNhbGxiYWNrKSB7XHJcbiAgICBsZXQgY2xvc2UgPSB0aGlzLmVsKCdkaXYnLCAncG9wdXBfX2Nsb3NlJylcclxuICAgIGNsb3NlLmlubmVyVGV4dCA9ICdYJ1xyXG4gICAgbGV0IHBvcHVwX19pdGVtID0gdGhpcy5lbCgnZGl2JywgJ3BvcHVwX19pdGVtJylcclxuXHJcbiAgICBwb3B1cF9faXRlbS5pbm5lclRleHQgPSB0eHRcclxuICAgIHBvcHVwX19pdGVtLmFwcGVuZChjbG9zZSlcclxuICAgIGxldCBwb3B1cCA9ICQoJy5wb3B1cCcpLmVsWzBdXHJcbiAgICBpZiAoIXBvcHVwKSB7XHJcbiAgICAgIHBvcHVwID0gdGhpcy5lbCgnZGl2JywgJ3BvcHVwJylcclxuICAgIH1cclxuICAgIHBvcHVwLmFwcGVuZChwb3B1cF9faXRlbSlcclxuICAgIHBvcHVwLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5jbG9zZSwgdHJ1ZSlcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKHBvcHVwKVxyXG4gICAgbGV0IGhpZGVEZWxheSA9IDUwMDA7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgcG9wdXBfX2l0ZW0uY2xhc3NMaXN0LnJlbW92ZSgncG9wdXBfX2l0ZW0nKVxyXG4gICAgICBwb3B1cF9faXRlbS5jbGFzc0xpc3QuYWRkKCdwb3B1cC1oaWRlJylcclxuICAgIH0sIGhpZGVEZWxheSlcclxuICAgIGxldCByZW1vdmVEZWxheSA9IGhpZGVEZWxheSArIDk1MDtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBwb3B1cF9faXRlbS5yZW1vdmUoKVxyXG4gICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICBjYWxsYmFjaygpXHJcbiAgICAgIH1cclxuICAgIH0sIHJlbW92ZURlbGF5KVxyXG4gIH0sXHJcblxyXG4gIGNsb3NlOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgaWYgKGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygncG9wdXBfX2Nsb3NlJykpIHtcclxuICAgICAgbGV0IHBvcHVwID0gdGhpcy5jbG9zZXN0KCcucG9wdXAnKS5yZW1vdmUoKVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgZWw6IGZ1bmN0aW9uICh0YWdOYW1lLCBjbGFzc05hbWUpIHtcclxuICAgIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSlcclxuICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKVxyXG4gICAgcmV0dXJuIGVsXHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCB1bmlxID0gKGFycmF5KSA9PiBBcnJheS5mcm9tKG5ldyBTZXQoYXJyYXkpKTtcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdldChrZXkpIHtcclxuICBsZXQgcCA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7XHJcbiAgcCA9IHAubWF0Y2gobmV3IFJlZ0V4cChrZXkgKyAnPShbXiY9XSspJykpO1xyXG4gIHJldHVybiBwID8gcFsxXSA6IGZhbHNlO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBwb3N0KHVybCwgZGF0YSA9IHt9KSB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgIGRhdGEudG9rZW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9XCJ0b2tlblwiXScpLmdldEF0dHJpYnV0ZSgnY29udGVudCcpXHJcbiAgICBsZXQgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICByZXEub3BlbignUE9TVCcsIHVybCwgdHJ1ZSk7XHJcbiAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihcIlgtUmVxdWVzdGVkLVdpdGhcIiwgXCJYTUxIdHRwUmVxdWVzdFwiKTtcclxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRm9ybURhdGEpIHtcclxuICAgICAgcmVxLnNlbmQoZGF0YSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xyXG4gICAgICByZXEuc2VuZCgncGFyYW09JyArIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgcmVqZWN0KEVycm9yKFwiTmV0d29yayBFcnJvclwiICsgZSkpO1xyXG4gICAgfTtcclxuICAgIHJlcS5vbmxvYWQgPSBhc3luYyBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJlc29sdmUocmVxLnJlc3BvbnNlKTtcclxuICAgIH07XHJcbiAgfSk7XHJcbn1cclxuXHJcbmNsYXNzIEVsZW1lbnRDb2xsZWN0aW9uIGV4dGVuZHMgQXJyYXkgIHtcclxuXHJcbiAgZWwgPSB0aGlzXHJcbiAgZWxUeXBlID0gZnVuY3Rpb24oKXtyZXR1cm4ge30udG9TdHJpbmcuY2FsbCh0aGlzKX1cclxuXHJcbiAgb24oZXZlbnQsIGNiT3JTZWxlY3RvciwgY2IpIHtcclxuICAgIGlmICh0eXBlb2YgY2JPclNlbGVjdG9yID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRoaXMuZm9yRWFjaChlID0+IGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2JPclNlbGVjdG9yKSlcclxuICAgIH1lbHNle1xyXG4gICAgICB0aGlzLmZvckVhY2goZWxlbT0+e1xyXG4gICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZSA9PntcclxuICAgICAgICAgIGlmIChlLnRhcmdldC5tYXRjaGVzKGNiT3JTZWxlY3RvcikpIGNiKGUpXHJcbiAgICAgICAgfSl9KVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpc1swXS5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJylcclxuICB9XHJcblxyXG4gIGF0dHIgPSBmdW5jdGlvbiAoYXR0ck5hbWUsIGF0dHJWYWwpIHtcclxuICAgIGlmIChhdHRyVmFsKSB7XHJcbiAgICAgIHRoaXNbMF0uc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXNbMF0uZ2V0QXR0cmlidXRlKGF0dHJOYW1lKVxyXG4gIH1cclxuXHJcbiAgc2VsZWN0ZWRJbmRleFZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMubGVuZ3RoKVxyXG4gICAgICByZXR1cm4gdGhpc1swXS5zZWxlY3RlZE9wdGlvbnNbMF0udmFsdWVcclxuICB9XHJcbiAgb3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLmxlbmd0aCkgcmV0dXJuIHRoaXNbMF0ub3B0aW9uc1xyXG4gIH1cclxuICBjb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLmxlbmd0aFxyXG4gIH1cclxuICB0ZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMubGVuZ3RoKSByZXR1cm4gdGhpc1swXS5pbm5lclRleHRcclxuICB9XHJcbiAgY2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLmxlbmd0aCkgcmV0dXJuIHRoaXNbMF0uY2hlY2tlZFxyXG4gIH1cclxuXHJcbiAgZ2V0V2l0aFN0eWxlID0gZnVuY3Rpb24gKGF0dHIsIHZhbCkge1xyXG4gICAgbGV0IGFyciA9IFtdXHJcbiAgICB0aGlzLmZvckVhY2goKHMpID0+IHtcclxuICAgICAgaWYgKHMuc3R5bGVbYXR0cl0gPT09IHZhbCkge1xyXG4gICAgICAgIGFyci5wdXNoKHMpXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgICByZXR1cm4gYXJyXHJcbiAgfVxyXG4gIGFkZENsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xyXG4gICAgICB0aGlzLmZvckVhY2goKHMpID0+IHtcclxuICAgICAgICBzLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKVxyXG4gICAgICB9KVxyXG4gIH1cclxuICByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcclxuICAgICAgdGhpcy5mb3JFYWNoKChzKSA9PiB7XHJcbiAgICAgICAgcy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSlcclxuICAgICAgfSlcclxuICB9XHJcbiAgaGFzQ2xhc3MgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XHJcbiAgICBpZiAodGhpcy5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSkgcmV0dXJuIHRydWVcclxuICB9XHJcbiAgYXBwZW5kID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICB0aGlzWzBdLmFwcGVuZENoaWxkKGVsKVxyXG4gIH1cclxuXHJcbiAgZmluZCA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKXtcclxuICAgICAgcmV0dXJuIHRoaXNbMF0ucXVlcnlTZWxlY3RvcihpdGVtKVxyXG4gICAgfWVsc2V7XHJcbiAgICAgIGxldCBmaWx0ZXJlZCA9ICB0aGlzWzBdLmZpbHRlcigoZWwpPT57XHJcbiAgICAgICAgcmV0dXJuIGVsID09PSBpdGVtXHJcbiAgICAgIH0pXHJcbiAgICAgIHJldHVybiBmaWx0ZXJlZFswXVxyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIGNzcyA9IGZ1bmN0aW9uIChhdHRyLCB2YWwpIHtcclxuICAgIGlmICghdmFsKSB7XHJcbiAgICAgIHJldHVybiB0aGlzWzBdLnN0eWxlW2F0dHJdXHJcbiAgICB9XHJcbiAgICAgIHRoaXMuZm9yRWFjaCgocykgPT4ge1xyXG4gICAgICAgIHMuc3R5bGVbYXR0cl0gPSB2YWxcclxuICAgICAgfSlcclxuICB9XHJcblxyXG4gIHJlYWR5KGNiKSB7XHJcbiAgICBjb25zdCBpc1JlYWR5ID0gdGhpcy5zb21lKGUgPT4ge1xyXG4gICAgICByZXR1cm4gZS5yZWFkeVN0YXRlICE9IG51bGwgJiYgZS5yZWFkeVN0YXRlICE9ICdsb2FkaW5nJ1xyXG4gICAgfSlcclxuICAgIGlmIChpc1JlYWR5KSB7XHJcbiAgICAgIGNiKClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBjYilcclxuICAgIH1cclxuICB9XHJcblxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gJChzZWxlY3Rvcikge1xyXG4gIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnIHx8IHNlbGVjdG9yIGluc3RhbmNlb2YgU3RyaW5nKSB7XHJcbiAgICByZXR1cm4gbmV3IEVsZW1lbnRDb2xsZWN0aW9uKC4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gbmV3IEVsZW1lbnRDb2xsZWN0aW9uKHNlbGVjdG9yKVxyXG4gIH1cclxufVxyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gYWRkVG9vbHRpcChhcmdzKSB7XHJcbiAgbGV0IGFyID0gWy4uLmFyZ3MuZWxzXVxyXG4gIGFyLm1hcCgoZWwpID0+IHtcclxuICAgIGVsLm9ubW91c2VlbnRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgbGV0IHRpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXHJcbiAgICAgICQodGlwKS5hZGRDbGFzcygndGlwJylcclxuICAgICAgdGlwLmlubmVyVGV4dCA9IGFyZ3MubWVzc2FnZVxyXG4gICAgICBlbC5hcHBlbmQodGlwKVxyXG4gICAgICBsZXQgcmVtb3ZlID0gKCkgPT4gdGlwLnJlbW92ZSgpXHJcbiAgICAgIHRpcC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCByZW1vdmUuYmluZCh0aXApLCB0cnVlKVxyXG4gICAgfS5iaW5kKGFyZ3MpXHJcblxyXG4gICAgZWwub25tb3VzZWxlYXZlID0gKCkgPT4ge1xyXG4gICAgICBsZXQgdGlwID0gZWwucXVlcnlTZWxlY3RvcignLnRpcCcpXHJcbiAgICAgIHRpcC5yZW1vdmUoKVxyXG4gICAgfVxyXG4gIH0sIFthcmdzXSlcclxufVxyXG5cclxuY2xhc3MgdGVzdF9kZWxldGVfYnV0dG9uIHtcclxuICBjb25zdHJ1Y3RvcihlbGVtKSB7XHJcbiAgICBpZiAoIWVsZW0pIHJldHVyblxyXG4gICAgdGhpcy5fZWxlbSA9ICQoZWxlbSkuZWxbMF07XHJcbiAgICB0aGlzLl9lbGVtLm9uY2xpY2sgPSB0aGlzLmRlbGV0ZVxyXG4gICAgdGhpcy5fZWxlbS5vbm1vdXNlZW50ZXIgPSB0aGlzLnNob3dUb29saXBcclxuICAgIHRoaXMuX2VsZW0ub25tb3VzZWxlYXZlID0gdGhpcy5oaWRlVG9vbHRpcFxyXG4gICAgdGhpcy5fZWxlbS5vbm1vdXNlbW92ZSA9IHRoaXMuY2hhbmdlVG9vbHRpcFBvc1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZGVsZXRlKCkge1xyXG4gICAgaWYgKGNvbmZpcm0oJ9Cj0LTQsNC70LjRgtGMINGC0LXRgdGCPycpKSB7XHJcbiAgICAgIGxldCByZXMgPSB0ZXN0LmRlbCgpXHJcbiAgICAgIGlmIChyZXMubXNnID09PSAnb2snKSB7XHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uID0gJy90ZXN0L2VkaXQnXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNob3dUb29saXAoZSkge1xyXG4gICAgbGV0IHggPSBlLmNsaWVudFhcclxuICAgIGxldCB5ID0gZS5jbGllbnRZXHJcbiAgICBsZXQgdGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgICQodGlwKS5hZGRDbGFzcygndGlwJylcclxuICAgIHRpcC5zdHlsZS50b3AgPSB5ICsgNzAgKyAncHgnXHJcbiAgICB0aXAuc3R5bGUubGVmdCA9IHggLSAxNzAgKyAncHgnXHJcbiAgICB0aXAuaW5uZXJUZXh0ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RpcCcpXHJcbiAgICB0aGlzLnRpcCA9IHRpcFxyXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmQodGlwKVxyXG4gIH1cclxuXHJcbiAgaGlkZVRvb2x0aXAoKSB7XHJcbiAgICB0aGlzLnRpcC5yZW1vdmUoKVxyXG4gIH1cclxuXHJcbiAgY2hhbmdlVG9vbHRpcFBvcyhlKSB7XHJcbiAgICB0aGlzLnRpcC5zdHlsZS50b3AgPSBlLnBhZ2VZICsgMzUgKyAncHgnXHJcbiAgICB0aGlzLnRpcC5zdHlsZS5sZWZ0ID0gZS5wYWdlWCAtIDE3MCArICdweCdcclxuICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCB7ZHJvcERvd24sXHJcbiAgYWRkVG9vbHRpcCxcclxuICBwb3B1cCxcclxuICB0ZXN0X2RlbGV0ZV9idXR0b24sXHJcbiAgcG9zdCwgZ2V0LCB1bmlxLFxyXG4gIHZhbGlkYXRlLCAkfVxyXG4iLCJpbXBvcnQgJy4vYWNjb3JkaW9uLnNjc3MnXHJcbmltcG9ydCB7JH0gZnJvbSAnLi4vLi4vY29tbW9uJ1xyXG5cclxuXHJcbiQoJy5hY2NvcmRpb24gbGFiZWwnKS5vbignY2xpY2snLCBoYW5kbGVUb2dnbGUpXHJcblxyXG53aW5kb3cub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4vLyBkZWJ1Z2dlclxyXG5sZXQgY2hlY2tib3hlcyA9ICQoJy5hZG1pbi1sYXlvdXRfX3NpZGViYXIuYWNjb3JkaW9uIGlucHV0W3R5cGU9Y2hlY2tib3hdJykuZWxcclxuICBpZiAoY2hlY2tib3hlcyl7XHJcbiAgICBbLi4uY2hlY2tib3hlc10uZmlsdGVyKGNoPT57XHJcbiAgICAgIGNoLmNoZWNrZWQgPSBmYWxzZVxyXG4gICAgfSlcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZVRvZ2dsZShlKSB7XHJcblxyXG4gIGxldCBjaGVja2JveCA9IGUudGFyZ2V0LnByZXZpb3VzRWxlbWVudFNpYmxpbmdcclxuICBsZXQgcGFyZW50ID0gY2hlY2tib3guY2xvc2VzdCgndWwnKVxyXG4gIGxldCB1bCA9ICQoY2hlY2tib3gucGFyZW50Tm9kZSkuZmluZCgndWwnKVxyXG5cclxuXHJcbiAgaWYgKGNoZWNrYm94LmNoZWNrZWQpIHtcclxuICAgIHNsaWRlVXAodWwsIDAsKVxyXG4gIH0gZWxzZSB7XHJcbiAgICBwYXJlbnQuc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCJcclxuICAgIHNsaWRlRG93bih1bClcclxuICAgIGxldCB1bEhlaWdodCA9IHVsLnNjcm9sbEhlaWdodFxyXG4gICAgaW5jcmVhc2VQYXJlbnQocGFyZW50LCB1bEhlaWdodClcclxuICAgIC8vIGRlYnVnZ2VyXHJcbiAgICBjbG9zZVNpYmxpbmdzKHBhcmVudClcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluY3JlYXNlUGFyZW50KHBhcmVudCwgdWxIZWlnaHQpIHtcclxuICBpZiAoIXBhcmVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2FjY29yZGlvbicpKSB7XHJcbiAgICBsZXQgcGFyZW50SGVpZ2h0ID0gcGFyc2VJbnQocGFyZW50LnN0eWxlLm1heEhlaWdodCkgKyB1bEhlaWdodFxyXG4gICAgcGFyZW50LnN0eWxlLm1heEhlaWdodCA9IHBhcmVudEhlaWdodCArIFwicHhcIjtcclxuICB9XHJcbn1cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gc2xpZGVEb3duKHVsLCBjYWxsYmFjaykge1xyXG4gIHVsLnN0eWxlLm1heEhlaWdodCA9IHVsLnNjcm9sbEhlaWdodCArIFwicHhcIjtcclxuICBpZiAoY2FsbGJhY2spIHtcclxuICAgIGNhbGxiYWNrKClcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsb3NlU2libGluZ3MocGFyZW50KSB7XHJcbiAgQXJyYXkuZnJvbShwYXJlbnQuY2hpbGRyZW4pLm1hcCgoZWwpID0+IHtcclxuICAgICAgbGV0IGVsQXJyID0gQXJyYXkuZnJvbShlbC5jaGlsZHJlbilcclxuICAgICAgZWxBcnIubWFwKChjaCkgPT4ge1xyXG4gICAgICAgIGlmIChjaC50eXBlICYmIGNoLnR5cGUgPT09ICdjaGVja2JveCcgJiYgY2guY2hlY2tlZCkge1xyXG4gICAgICAgICAgbGV0IHVsID0gJChjaC5wYXJlbnROb2RlKS5maW5kKCd1bCcpXHJcbiAgICAgICAgICBzbGlkZVVwKHVsLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNoLmNoZWNrZWQgPSBmYWxzZVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgKVxyXG59XHJcblxyXG5mdW5jdGlvbiBzbGlkZVVwKHVsLCBpbnRlcnZhbCwgY2FsbGJhY2spIHtcclxuICB1bC5zdHlsZS5tYXhIZWlnaHQgPSAwICsgXCJweFwiO1xyXG4gIGlmIChjYWxsYmFjaykge1xyXG4gICAgY2FsbGJhY2soKVxyXG4gIH1cclxufVxyXG5cclxuXHJcblxyXG5cclxuXHJcbiIsImltcG9ydCB7JCwgcG9wdXAsIHBvc3R9IGZyb20gXCIuLi8uLi9jb21tb25cIjtcclxuaW1wb3J0IFwiLi4vLi4vY29tcG9uZW50cy9wb3B1cC5zY3NzXCI7XHJcblxyXG5cclxubGV0IF9jYWNoZSA9IHtcclxuICAgIGNsZWFyQ2FjaGU6IGFzeW5jIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCgnL2FkbWluc2MvY2xlYXJDYWNoZScsIHt9KVxyXG4gICAgICAgIGlmIChyZXM9PT0n0KPRgdC/0LXRiNC90L4nKSB7XHJcbiAgICAgICAgICAgIHBvcHVwLnNob3cocmVzKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2FjaGUoKSB7XHJcbiAgICAkKCcuY2xlYXJDYWNoZScpLm9uKCdjbGljaycsIF9jYWNoZS5jbGVhckNhY2hlKVxyXG59IiwiaW1wb3J0IHskLCBwb3N0LCBwb3B1cH0gZnJvbSBcIi4uLy4uL2NvbW1vblwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IF90ZXN0UmVzdWx0ID0ge1xyXG5cclxuICBkZWxTZXJ2ZXI6IGFzeW5jIChpZCkgPT4ge1xyXG4gICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy90ZXN0L3Jlc3VsdGRlbGV0ZScsIHtpZH0pXHJcbiAgICBpZiAocmVzKSB7XHJcbiAgICAgIHBvcHVwLnNob3coJ9Cj0LTQsNC70LXQvdC+JylcclxuXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZGVsRG9tOiAoZSkgPT4ge1xyXG4gICAgbGV0IGlkID0gZS50YXJnZXQuZGF0YXNldC5yb3dcclxuICAgIEFycmF5XHJcbiAgICAgIC5mcm9tKCQoYFtkYXRhLXJvdyA9IFwiJHtpZH1cIl1gKS5lbClcclxuICAgICAgLm1hcCgoaSkgPT4ge1xyXG4gICAgICAgIGkucmVtb3ZlKClcclxuICAgICAgfSlcclxuICAgIHJldHVybiBpZFxyXG5cclxuICB9LFxyXG5cclxuICBkZWxldGU6IChlKSA9PiB7XHJcblxyXG4gICAgaWYgKGNvbmZpcm0oXCLQo9C00LDQu9C40YLRjCDRgNC10LfRg9C70YzRgtCw0YIg0YLQtdGB0YLQsD9cIikpIHtcclxuICAgICAgbGV0IGlkID0gX3Rlc3RSZXN1bHQuZGVsRG9tKGUpXHJcbiAgICAgIF90ZXN0UmVzdWx0LmRlbFNlcnZlcihpZClcclxuICAgIH1cclxuICB9LFxyXG5cclxuXHJcbn0iLCJpbXBvcnQgeyR9IGZyb20gJy4uLy4uL2NvbW1vbidcclxuaW1wb3J0IHtfdGVzdFJlc3VsdH0gZnJvbSAnLi4vbW9kZWwvX3Rlc3RSZXN1bHQnXHJcbmltcG9ydCAnLi90ZXN0LXJlc3VsdHNfX3RhYmxlLnNjc3MnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0ZXN0UmVzdWx0cygpIHtcclxuICAkKCcudGVzdC1yZXN1bHRzX190YWJsZSAuZGVsJykub24oJ2NsaWNrJywgX3Rlc3RSZXN1bHQuZGVsZXRlKVxyXG59XHJcblxyXG4iLCJpbXBvcnQgeyQsIHBvcHVwLCBwb3N0fSBmcm9tICcuLi8uLi9jb21tb24nXHJcblxyXG5leHBvcnQgY29uc3QgX3Rlc3QgPSB7XHJcblxyXG4gIG1hcmtDdXJyZW50SW5NZW51OiAoKSA9PiB7XHJcbiAgICBsZXQgY3VycmVudFRlc3RJZCA9ICQoJy50ZXN0LW5hbWUnKS5lbFswXVxyXG4gICAgaWYgKGN1cnJlbnRUZXN0SWQpIHtcclxuICAgICAgY3VycmVudFRlc3RJZCA9ICtjdXJyZW50VGVzdElkLmdldEF0dHJpYnV0ZSgndmFsdWUnKVxyXG4gICAgICBsZXQgbWVudUl0ZW1Db2xsZWN0aW9uID0gJCgnLmFjY29yZGlvbiBhJykuZWxcclxuICAgICAgQXJyYXkuZnJvbShtZW51SXRlbUNvbGxlY3Rpb24pLmZpbHRlcigoYSkgPT4ge1xyXG4gICAgICAgIGlmICgrYS5kYXRhc2V0LmlkID09PSBjdXJyZW50VGVzdElkKSB7XHJcbiAgICAgICAgICBhLmNsYXNzTGlzdC5hZGQoJ2N1cnJlbnQnKVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBuZXh0UTogKCkgPT4ge1xyXG4gICAgbGV0IGN1cnJlbnQgPSBfdGVzdC5jdXJyZW50USgpXHJcbiAgICBpZiAoY3VycmVudC5pZCA+IGN1cnJlbnQubmF2TGVuZ3RoIC0gMikgcmV0dXJuIGZhbHNlXHJcblxyXG4gICAgbGV0IGFpbU5hdklkID0gX3Rlc3QuYWltTmF2SWRGdW5jdGlvbihjdXJyZW50LmlkLCAnbmV4dCcpXHJcbiAgICBsZXQgYWltUUVsID0gX3Rlc3QuYWltUUVsRnVuY3Rpb24oY3VycmVudCwgJ25leHQnKVxyXG5cclxuICAgIF90ZXN0LnB1c2hOYXYoY3VycmVudC5pZCwgYWltTmF2SWQpXHJcbiAgICBfdGVzdC5wdXNoUShjdXJyZW50LlFFbCwgYWltUUVsKVxyXG4gIH0sXHJcblxyXG4gIHByZXZROiAoKSA9PiB7XHJcbiAgICBsZXQgY3VycmVudCA9IF90ZXN0LmN1cnJlbnRRKClcclxuICAgIGlmIChjdXJyZW50LmlkIDwgMSkgcmV0dXJuIGZhbHNlXHJcblxyXG4gICAgbGV0IGFpbU5hdklkID0gX3Rlc3QuYWltTmF2SWRGdW5jdGlvbihjdXJyZW50LmlkLCAnYmFjaycpXHJcbiAgICBsZXQgYWltUUVsID0gX3Rlc3QuYWltUUVsRnVuY3Rpb24oY3VycmVudCwgJ2JhY2snKVxyXG5cclxuICAgIF90ZXN0LnB1c2hOYXYoY3VycmVudC5pZCwgYWltTmF2SWQpXHJcbiAgICBfdGVzdC5wdXNoUShjdXJyZW50LlFFbCwgYWltUUVsKVxyXG4gIH0sXHJcblxyXG4gIHB1c2hOYXY6IChjdXJyZW50SWQsIGFpbU5hdklkKSA9PiB7XHJcbiAgICBsZXQgY3Vyck5hdkVsID0gJCgnW2RhdGEtcGFnaW5hdGlvbl0nKVxyXG4gICAgICAuZWxbY3VycmVudElkXVxyXG4gICAgY3Vyck5hdkVsLmNsYXNzTGlzdC50b2dnbGUoJ25hdi1hY3RpdmUnKVxyXG5cclxuICAgIGxldCBOYXZFbCA9ICQoJ1tkYXRhLXBhZ2luYXRpb25dJylcclxuICAgICAgLmVsW2FpbU5hdklkXVxyXG4gICAgTmF2RWwuY2xhc3NMaXN0LnRvZ2dsZSgnbmF2LWFjdGl2ZScpXHJcbiAgfSxcclxuXHJcbiAgcHVzaFE6IChjdXJyZW50RWwsIGFpbVFFbCkgPT4ge1xyXG4gICAgY3VycmVudEVsLmNsYXNzTGlzdC50b2dnbGUoJ2ZsZXgxJylcclxuICAgIGFpbVFFbC5jbGFzc0xpc3QudG9nZ2xlKCdmbGV4MScpXHJcbiAgfSxcclxuXHJcbiAgYWltTmF2SWRGdW5jdGlvbjogKGN1cnJlbnRJZCwgZGlyZWN0aW9uKSA9PiB7XHJcbiAgICBsZXQgZGlyID0gY3VycmVudElkXHJcbiAgICBzd2l0Y2ggKHRydWUpIHtcclxuICAgICAgY2FzZSBkaXJlY3Rpb24gPT09ICduZXh0JzpcclxuICAgICAgICByZXR1cm4gZGlyICs9IDFcclxuICAgICAgICBicmVha1xyXG4gICAgICBjYXNlIGRpcmVjdGlvbiA9PT0gJ2JhY2snOlxyXG4gICAgICAgIHJldHVybiBkaXIgLT0gMVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgYWltUUVsRnVuY3Rpb246IChjdXJyZW50LCBkaXJlY3Rpb24pID0+IHtcclxuICAgIHN3aXRjaCAodHJ1ZSkge1xyXG4gICAgICBjYXNlIGRpcmVjdGlvbiA9PT0gJ25leHQnOlxyXG4gICAgICAgIHJldHVybiBjdXJyZW50LlFOZXh0RWxcclxuICAgICAgICBicmVha1xyXG4gICAgICBjYXNlIGRpcmVjdGlvbiA9PT0gJ2JhY2snOlxyXG4gICAgICAgIHJldHVybiBjdXJyZW50LlFQcmV2Y1xyXG4gICAgICAgIGJyZWFrXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgY3VycmVudFE6ICgpID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOiAkKCcubmF2LWFjdGl2ZScpLmVsWzBdLmlubmVyVGV4dCAtIDEsXHJcbiAgICAgIFFFbDogJCgnLnF1ZXN0aW9uLmZsZXgxJykuZWxbMF0sXHJcbiAgICAgIG5hdkxlbmd0aDogJCgnW2RhdGEtcGFnaW5hdGlvbl0nKS5sZW5ndGgsXHJcbiAgICAgIFFQcmV2YzogJCgnLnF1ZXN0aW9uLmZsZXgxJykuZWxbMF0ucHJldmlvdXNFbGVtZW50U2libGluZyxcclxuICAgICAgUU5leHRFbDogJCgnLnF1ZXN0aW9uLmZsZXgxJykuZWxbMF0ubmV4dEVsZW1lbnRTaWJsaW5nLFxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG5cclxuICB2aWV3TW9kZWw6ICgpID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOiArd2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoJy8nKS5wb3AoKSxcclxuICAgICAgdGVzdF9uYW1lOiAkKCcjdGVzdF9uYW1lJykudGV4dCgpLFxyXG4gICAgICBlbmFibGU6ICQoJyNlbmFibGUnKVswXSxcclxuICAgICAgcGFyZW50OiAkKCdzZWxlY3QnKS5zZWxlY3RlZEluZGV4VmFsdWUoKSxcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBpZDogKGlkKSA9PiB7XHJcbiAgICByZXR1cm4gaWQgPz8gJCgnLnRlc3QtbmFtZScpLnZhbHVlKClcclxuICB9LFxyXG4gIGNoaWxkcmVuOiAoKSA9PiB7XHJcbiAgICBsZXQgY2hpbGRyZW5MZW5naHQgPSAkKCcuY2hpbGRyZW4nKS5sZW5ndGhcclxuICAgIGlmIChjaGlsZHJlbkxlbmdodClcclxuICAgICAgcmV0dXJuIGNoaWxkcmVuTGVuZ2h0XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9LFxyXG5cclxuICBwYXRoX2NyZWF0ZTogYXN5bmMgKCkgPT4ge1xyXG4gICAgbGV0IHRlc3RfcGF0aCA9IF90ZXN0LnNlcnZlck1vZGVsKClcclxuICAgIHRlc3RfcGF0aC5pZCA9IDBcclxuICAgIHRlc3RfcGF0aC5pc1Rlc3QgPSAwXHJcbiAgICBsZXQgdXJsID0gYC90ZXN0L2NyZWF0ZWBcclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KHVybCwgdGVzdF9wYXRoKVxyXG4gICAgcmVzID0gYXdhaXQgSlNPTi5wYXJzZShyZXMpXHJcbiAgICBpZiAocmVzKSB7XHJcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYC9hZG1pbnNjL3Rlc3QvZWRpdC8ke3Jlcy5pZCAtIDF9YFxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIG5hbWU6ICgpID0+IHtcclxuICAgIHJldHVybiAkKCcudGVzdC1uYW1lJykuZWxbMF0uaW5uZXJUZXh0XHJcbiAgfSxcclxuXHJcbiAgY3JlYXRlOiBhc3luYyAoKSA9PiB7XHJcbiAgICBkZWJ1Z2dlclxyXG4gICAgbGV0IHRlc3QgPSBfdGVzdC5zZXJ2ZXJNb2RlbCgpXHJcbiAgICB0ZXN0LmlkID0gMFxyXG4gICAgdGVzdC5pc1Rlc3QgPSAxXHJcbiAgICBsZXQgdXJsID0gYC90ZXN0L3VwZGF0ZU9yQ3JlYXRlYFxyXG4gICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QodXJsLCB0ZXN0KVxyXG4gICAgcmVzID0gYXdhaXQgSlNPTi5wYXJzZShyZXMpXHJcbiAgICBpZiAocmVzKSB7XHJcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYC9hZG1pbnNjL3Rlc3QvZWRpdC8ke3Jlcy5pZCAtIDF9YFxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHNlbGVjdGVkVmFsdWVDdXN0b21TZWxlY3QoY2xhc3NOYW1lKSB7XHJcbiAgICBsZXQgc2VsZWN0ID0gJChgW2RhdGEtY3VzdG9tLSR7Y2xhc3NOYW1lfV1gKVswXVxyXG4gICAgbGV0IHNlbGVjdGVkID0gWy4uLnNlbGVjdC5vcHRpb25zXS5maWx0ZXIoKG9wdCk9Pm9wdC5zZWxlY3RlZClcclxuICAgIGlmIChzZWxlY3RlZCkge1xyXG4gICAgICByZXR1cm4gK3NlbGVjdGVkWzBdLnZhbHVlXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgc2VydmVyTW9kZWw6ICgpID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOiArd2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoJy8nKS5wb3AoKSxcclxuICAgICAgdGVzdF9uYW1lOiAkKCcjdGVzdF9uYW1lJykuZWxbMF0udmFsdWUsXHJcbiAgICAgIGlzVGVzdDogKyQoJ1tpc1Rlc3RdJykuZWxbMF0uZ2V0QXR0cmlidXRlKCdpc1Rlc3QnKSxcclxuICAgICAgZW5hYmxlOiBfdGVzdC5zZWxlY3RlZFZhbHVlQ3VzdG9tU2VsZWN0KCdlbmFibGUnKSxcclxuICAgICAgcGFyZW50OiBfdGVzdC5zZWxlY3RlZFZhbHVlQ3VzdG9tU2VsZWN0KCdwYXJlbnQnKSxcclxuICAgIH1cclxuICB9LFxyXG5cclxuICB1cGRhdGU6IGFzeW5jIChwYXJlbnQsIGVuYWJsZSkgPT4ge1xyXG4gICAgZGVidWdnZXJcclxuICAgIGxldCBtb2RlbCA9IF90ZXN0LnNlcnZlck1vZGVsKHBhcmVudCwgZW5hYmxlKVxyXG4gICAgbGV0IHVybCA9IGAvYWRtaW5zYy90ZXN0L3VwZGF0ZS8ke21vZGVsLmlkfWBcclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KHVybCwgbW9kZWwpXHJcbiAgICByZXMgPSBhd2FpdCBKU09OLnBhcnNlKHJlcylcclxuICAgIC8vIGlmIChyZXMpIHtcclxuICAgIC8vICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBgL2FkbWluc2MvdGVzdC9lZGl0LyR7bW9kZWwuaWR9YFxyXG4gICAgLy8gfVxyXG4gIH0sXHJcblxyXG4gIGRlbGV0ZTogYXN5bmMgZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIGlmIChfdGVzdC5jaGlsZHJlbigpKSB7XHJcbiAgICAgIHBvcHVwLnNob3coJ9Ch0L3QsNGH0LDQu9CwINGD0LTQsNC70LjRgtC1INCy0YHQtSDRgtC10YHRgtGLINC40Lcg0L/QsNC/0LrQuCcpXHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG5cclxuICAgIGxldCB2aWV3TW9kZWwgPSBfdGVzdC52aWV3TW9kZWwoKVxyXG4gICAgLy8gdmlld01vZGVsLmVuYWJsZS5jaGVja2VkID0gZmFsc2VcclxuICAgIGxldCBzZXJ2ZXJNb2RlbCA9IF90ZXN0LnNlcnZlck1vZGVsKClcclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KCcvdGVzdC9kZWxldGUnLCB7XHJcbiAgICAgIHRlc3Q6IHNlcnZlck1vZGVsXHJcbiAgICB9KVxyXG4gICAgcmVzID0gYXdhaXQgSlNPTi5wYXJzZShyZXMpXHJcbiAgICBpZiAocmVzLm5vdEFkbWluKSB7XHJcbiAgICAgIHBvcHVwLnNob3coJ9CS0LjQtNC40LzQvtGB0YLRjCDRgtC10YHRgtCwINGB0LrRgNGL0YLQsC4g0KfRgtC+0LHRiyDRg9C00LDQu9C40YLRjCDQv9C+0LvQvdC+0YHRgtGM0Y4gLSDQvtCx0YDQsNGC0LjRgtC10YHRjCDQuiDQk9CUJylcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uID0gJy9hZG1pbnNjL3Rlc3QvZWRpdC80MDAnXHJcbiAgICAgIH0sIDQwMDApXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3aW5kb3cubG9jYXRpb24gPSAnL2FkbWluc2MvdGVzdC9lZGl0LzQwMCdcclxuICAgIH1cclxuXHJcblxyXG4gIH0sXHJcblxyXG59IiwiaW1wb3J0ICcuL1dEU1NlbGVjdC5zY3NzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV0RTU2VsZWN0IHtcclxuXHJcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuXHJcbiAgICBpZiAoIXByb3BzLmVsZW1lbnQpIHJldHVybiBmYWxzZVxyXG4gICAgdGhpcy5lbGVtZW50ID0gcHJvcHMuZWxlbWVudFxyXG4gICAgdGhpcy50aXRsZSA9IHByb3BzLnRpdGxlXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBnZXRGb3JtYXR0ZWRPcHRpb25zKHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwib3B0aW9uXCIpKVxyXG4gICAgdGhpcy5zZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXHJcbiAgICB0aGlzLnNlbC5jbGFzc0xpc3QuYWRkKHByb3BzLmNsYXNzKVxyXG4gICAgdGhpcy5sYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpXHJcbiAgICB0aGlzLnRpdGxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcclxuICAgIHRoaXMudWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIilcclxuICAgIHNldHVwKHRoaXMpXHJcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiXHJcbiAgICB0aGlzLmVsZW1lbnQuYWZ0ZXIodGhpcy5zZWwpXHJcbiAgfVxyXG5cclxuICBnZXQgc2VsZWN0ZWRPcHRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZpbmQob3B0aW9uID0+IG9wdGlvbi5zZWxlY3RlZClcclxuICB9XHJcblxyXG4gIGdldCBzZWxlY3RlZE9wdGlvbkluZGV4KCkge1xyXG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pbmRleE9mKHRoaXMuc2VsZWN0ZWRPcHRpb24pXHJcbiAgfVxyXG5cclxuICBzZWxlY3RWYWx1ZSh2YWx1ZSkge1xyXG4gICAgY29uc3QgbmV3U2VsZWN0ZWRPcHRpb24gPSB0aGlzLm9wdGlvbnMuZmluZChvcHRpb24gPT4ge1xyXG4gICAgICByZXR1cm4gb3B0aW9uLnZhbHVlID09PSB2YWx1ZVxyXG4gICAgfSlcclxuICAgIGNvbnN0IHByZXZTZWxlY3RlZE9wdGlvbiA9IHRoaXMuc2VsZWN0ZWRPcHRpb25cclxuICAgIHByZXZTZWxlY3RlZE9wdGlvbi5zZWxlY3RlZCA9IGZhbHNlXHJcbiAgICBwcmV2U2VsZWN0ZWRPcHRpb24uZWxlbWVudC5zZWxlY3RlZCA9IGZhbHNlXHJcblxyXG4gICAgbmV3U2VsZWN0ZWRPcHRpb24uc2VsZWN0ZWQgPSB0cnVlXHJcbiAgICBuZXdTZWxlY3RlZE9wdGlvbi5lbGVtZW50LnNlbGVjdGVkID0gdHJ1ZVxyXG5cclxuICAgIHRoaXMubGFiZWwuaW5uZXJUZXh0ID0gbmV3U2VsZWN0ZWRPcHRpb24ubGFiZWxcclxuICAgIHRoaXMudWxcclxuICAgICAgLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXZhbHVlPVwiJHtwcmV2U2VsZWN0ZWRPcHRpb24udmFsdWV9XCJdYClcclxuICAgICAgLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKVxyXG4gICAgY29uc3QgbmV3Q3VzdG9tRWxlbWVudCA9IHRoaXMudWwucXVlcnlTZWxlY3RvcihcclxuICAgICAgYFtkYXRhLXZhbHVlPVwiJHtuZXdTZWxlY3RlZE9wdGlvbi52YWx1ZX1cIl1gXHJcbiAgICApXHJcbiAgICBuZXdDdXN0b21FbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKVxyXG4gICAgbmV3Q3VzdG9tRWxlbWVudC5zY3JvbGxJbnRvVmlldyh7IGJsb2NrOiBcIm5lYXJlc3RcIiB9KVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2V0dXAoc2VsZWN0KSB7XHJcbiAgc2VsZWN0LnNlbC5jbGFzc0xpc3QuYWRkKFwiY3VzdG9tLXNlbGVjdC1jb250YWluZXJcIilcclxuICBzZWxlY3Quc2VsLnRhYkluZGV4ID0gMFxyXG5cclxuICBzZWxlY3QudGl0bGVFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjdXN0b20tc2VsZWN0LXRpdGxlXCIpXHJcbiAgc2VsZWN0LnRpdGxlRWxlbWVudC5pbm5lclRleHQgPSBzZWxlY3QudGl0bGVcclxuICBzZWxlY3Quc2VsLmFwcGVuZChzZWxlY3QudGl0bGVFbGVtZW50KVxyXG4gIC8vIGRlYnVnZ2VyXHJcbiAgc2VsZWN0LmxhYmVsLmNsYXNzTGlzdC5hZGQoXCJjdXN0b20tc2VsZWN0LXZhbHVlXCIpXHJcbiAgc2VsZWN0LmxhYmVsLmlubmVyVGV4dCA9IHNlbGVjdC5zZWxlY3RlZE9wdGlvbi5sYWJlbFxyXG4gIHNlbGVjdC5zZWwuYXBwZW5kKHNlbGVjdC5sYWJlbClcclxuXHJcbiAgc2VsZWN0LnVsLmNsYXNzTGlzdC5hZGQoXCJjdXN0b20tc2VsZWN0LW9wdGlvbnNcIilcclxuICBzZWxlY3Qub3B0aW9ucy5mb3JFYWNoKG9wdGlvbiA9PiB7XHJcbiAgICBzZXRPcHRpb24ob3B0aW9uKVxyXG4gIH0pXHJcblxyXG4gIGZ1bmN0aW9uIHNldE9wdGlvbihvcHRpb24pe1xyXG4gICAgY29uc3QgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIilcclxuICAgIGxpLmNsYXNzTGlzdC5hZGQoXCJjdXN0b20tc2VsZWN0LW9wdGlvblwiKVxyXG4gICAgbGkuY2xhc3NMaXN0LnRvZ2dsZShcInNlbGVjdGVkXCIsIG9wdGlvbi5zZWxlY3RlZClcclxuICAgIGxpLmlubmVyVGV4dCA9IG9wdGlvbi5sYWJlbFxyXG4gICAgbGkuZGF0YXNldC52YWx1ZSA9IG9wdGlvbi52YWx1ZVxyXG4gICAgbGkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcclxuICAgICAgc2VsZWN0LnNlbGVjdFZhbHVlKG9wdGlvbi52YWx1ZSlcclxuICAgICAgc2VsZWN0LnVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93XCIpXHJcbiAgICB9KVxyXG4gICAgc2VsZWN0LnVsLmFwcGVuZChsaSlcclxuICB9XHJcblxyXG4gIHNlbGVjdC5zZWwuYXBwZW5kKHNlbGVjdC51bClcclxuXHJcbiAgc2VsZWN0LmxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XHJcbiAgICBzZWxlY3QudWwuY2xhc3NMaXN0LnRvZ2dsZShcInNob3dcIilcclxuICB9KVxyXG5cclxuICBzZWxlY3Quc2VsLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICgpID0+IHtcclxuICAgIHNlbGVjdC51bC5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKVxyXG4gIH0pXHJcblxyXG4gIGxldCBkZWJvdW5jZVRpbWVvdXRcclxuICBsZXQgc2VhcmNoVGVybSA9IFwiXCJcclxuICBzZWxlY3Quc2VsLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGUgPT4ge1xyXG4gICAgc3dpdGNoIChlLmNvZGUpIHtcclxuICAgICAgY2FzZSBcIlNwYWNlXCI6XHJcbiAgICAgICAgc2VsZWN0LnVsLmNsYXNzTGlzdC50b2dnbGUoXCJzaG93XCIpXHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgY2FzZSBcIkFycm93VXBcIjoge1xyXG4gICAgICAgIGNvbnN0IHByZXZPcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tzZWxlY3Quc2VsZWN0ZWRPcHRpb25JbmRleCAtIDFdXHJcbiAgICAgICAgaWYgKHByZXZPcHRpb24pIHtcclxuICAgICAgICAgIHNlbGVjdC5zZWxlY3RWYWx1ZShwcmV2T3B0aW9uLnZhbHVlKVxyXG4gICAgICAgIH1cclxuICAgICAgICBicmVha1xyXG4gICAgICB9XHJcbiAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjoge1xyXG4gICAgICAgIGNvbnN0IG5leHRPcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tzZWxlY3Quc2VsZWN0ZWRPcHRpb25JbmRleCArIDFdXHJcbiAgICAgICAgaWYgKG5leHRPcHRpb24pIHtcclxuICAgICAgICAgIHNlbGVjdC5zZWxlY3RWYWx1ZShuZXh0T3B0aW9uLnZhbHVlKVxyXG4gICAgICAgIH1cclxuICAgICAgICBicmVha1xyXG4gICAgICB9XHJcbiAgICAgIGNhc2UgXCJFbnRlclwiOlxyXG4gICAgICBjYXNlIFwiRXNjYXBlXCI6XHJcbiAgICAgICAgc2VsZWN0LnVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93XCIpXHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgIGNsZWFyVGltZW91dChkZWJvdW5jZVRpbWVvdXQpXHJcbiAgICAgICAgc2VhcmNoVGVybSArPSBlLmtleVxyXG4gICAgICAgIGRlYm91bmNlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgc2VhcmNoVGVybSA9IFwiXCJcclxuICAgICAgICB9LCA1MDApXHJcblxyXG4gICAgICAgIGNvbnN0IHNlYXJjaGVkT3B0aW9uID0gc2VsZWN0Lm9wdGlvbnMuZmluZChvcHRpb24gPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIG9wdGlvbi5sYWJlbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoc2VhcmNoVGVybSlcclxuICAgICAgICB9KVxyXG4gICAgICAgIGlmIChzZWFyY2hlZE9wdGlvbikge1xyXG4gICAgICAgICAgc2VsZWN0LnNlbGVjdFZhbHVlKHNlYXJjaGVkT3B0aW9uLnZhbHVlKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEZvcm1hdHRlZE9wdGlvbnMob3B0aW9ucykge1xyXG4gIHJldHVybiBbLi4ub3B0aW9uc10ubWFwKG9wdGlvbiA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB2YWx1ZTogb3B0aW9uLnZhbHVlLFxyXG4gICAgICBsYWJlbDogb3B0aW9uLmxhYmVsLFxyXG4gICAgICBzZWxlY3RlZDogb3B0aW9uLnNlbGVjdGVkLFxyXG4gICAgICBlbGVtZW50OiBvcHRpb24sXHJcbiAgICB9XHJcbiAgfSlcclxufSIsImltcG9ydCB7JH0gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWNjb3JkaW9uU2hvdygpIHtcclxuXHJcbiAgbGV0IGJ1dHRvbiA9ICQoJy50ZXN0LWVkaXRfX21lbnUtdG9nZ2xlJylbMF1cclxuICBpZiAoYnV0dG9uKXtcclxuICAgICQoYnV0dG9uKS5vbignY2xpY2snLCBmdW5jdGlvbigpe1xyXG4gICAgICBsZXQgbWVudSA9ICQoJy50ZXN0LWVkaXRfX2FjY29yZGlvbicpWzBdXHJcbiAgICAgIG1lbnUuY2xhc3NMaXN0LnRvZ2dsZSgnb3BlbicpXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0ICcuL3Rlc3QtdXBkYXRlLnNjc3MnXHJcbmltcG9ydCB7JH0gZnJvbSAnLi4vY29tbW9uJ1xyXG5pbXBvcnQge190ZXN0fSBmcm9tICcuL21vZGVsL3Rlc3QnXHJcbmltcG9ydCBXRFNTZWxlY3QgZnJvbSBcIi4uL2NvbXBvbmVudHMvc2VsZWN0L1dEU1NlbGVjdFwiXHJcbmltcG9ydCBhY2NvcmRpb25TaG93IGZyb20gXCIuL2FjY29yZGlvbi1zaG93XCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0ZXN0VXBkYXRlKCkge1xyXG5kZWJ1Z2dlclxyXG4gIGFjY29yZGlvblNob3coKVxyXG5cclxuICBsZXQgcGFyZW50U2VsZWN0ID0gbmV3IFdEU1NlbGVjdCh7XHJcbiAgICBlbGVtZW50OiAkKFwiW2RhdGEtY3VzdG9tLXBhcmVudF1cIilbMF0sXHJcbiAgICB0aXRsZTogJ9Cb0LXQttC40YIg0LIg0L/QsNC/0LrQtScsXHJcbiAgICBjbGFzczogJ3BhcmVudCdcclxuICB9KVxyXG5cclxuXHJcbiAgbGV0IGVuYWJsZVNlbGVjdCA9IG5ldyBXRFNTZWxlY3Qoe1xyXG4gICAgZWxlbWVudDogJChcIltkYXRhLWN1c3RvbS1lbmFibGVdXCIpWzBdLFxyXG4gICAgdGl0bGU6ICfQn9C+0LrQsNC30YvQstCw0YLRjCDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y/QvCcsXHJcbiAgICBjbGFzczogJ2VuYWJsZSdcclxuICB9KVxyXG5cclxuICAkKFwiLnRlc3RfX3NhdmVcIikub24oJ2NsaWNrJywgX3Rlc3QudXBkYXRlKVxyXG4gICQoXCIudGVzdF9fZGVsZXRlXCIpLm9uKCdjbGljaycsIF90ZXN0LmRlbGV0ZSlcclxuICAkKFwiLnRlc3QtcGF0aF9fY3JlYXRlXCIpLm9uKCdjbGljaycsIF90ZXN0LnBhdGhfY3JlYXRlKVxyXG4gICQoXCIudGVzdF9fY3JlYXRlXCIpLm9uKCdjbGljaycsIF90ZXN0LmNyZWF0ZSlcclxufVxyXG4iLCJpbXBvcnQgeyQsIHBvcHVwLCBwb3N0fSBmcm9tICcuLi8uLi9jb21tb24nXHJcblxyXG5leHBvcnQgbGV0IF9hbnN3ZXIgPSB7XHJcblxyXG4gICAgZWw6IChhZGRfYnV0dG9uKSA9PiB7XHJcbiAgICAgICAgbGV0IGFuc3dlcnMgPSBhZGRfYnV0dG9uLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbCgnLmFuc3dlcicpXHJcbiAgICAgICAgbGV0IHByZXZfc29ydCA9IDBcclxuICAgICAgICBpZiAoYW5zd2Vycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcHJldl9zb3J0ID0gKyQoYW5zd2Vyc1thbnN3ZXJzLmxlbmd0aCAtIDFdKS5maW5kKCcuYW5zd2VyX19zb3J0JykuaW5uZXJUZXh0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBlbCA9ICQoJy5hbnN3ZXJfX2NyZWF0ZScpLmZpbmQoJy5hbnN3ZXInKS5jbG9uZU5vZGUodHJ1ZSlcclxuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdhbnN3ZXInKVxyXG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2Fuc3dlcl9fY3JlYXRlJylcclxuICAgICAgICAvLyBsZXQgZGVsQnRuID0gJChlbCkuZmluZCgnLmFuc3dlcl9fZGVsZXRlJylcclxuICAgICAgICAvLyAkKGRlbEJ0bikub24oJ2NsaWNrJywgX2Fuc3dlci5kZWwpXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZWw6IGVsLFxyXG4gICAgICAgICAgICBpZDogJ25ldycsXHJcbiAgICAgICAgICAgIHFfaWQ6ICthZGRfYnV0dG9uLmNsb3Nlc3QoJy5xdWVzdGlvbi1lZGl0JykuaWQsXHJcbiAgICAgICAgICAgIHByZXZpb3VzX3NvcnQ6IHByZXZfc29ydCxcclxuICAgICAgICAgICAgYW5zd2VyQ250OiBhbnN3ZXJzLmxlbmd0aCxcclxuICAgICAgICAgICAgc29ydDogJChlbCkuZmluZCgnLmFuc3dlcl9fc29ydCcpLFxyXG4gICAgICAgICAgICBjaGVja2VkOiAkKGVsKS5maW5kKCdpbnB1dCcpLFxyXG4gICAgICAgICAgICB0ZXh0OiAkKGVsKS5maW5kKCcuYW5zd2VyX190ZXh0JyksXHJcbiAgICAgICAgICAgIGRlbGV0ZTogJCgkKGVsKS5maW5kKCcuYW5zd2VyX19kZWxldGUnKSkub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX2Fuc3dlci5kZWwodGhpcylcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZ2V0TW9kZWxGb3JTZXJ2ZXIoZWwpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBhbnN3ZXI6ICcnLFxyXG4gICAgICAgICAgICBwYXJlbnRfcXVlc3Rpb246IGVsLnFfaWQsXHJcbiAgICAgICAgICAgIGNvcnJlY3RfYW5zd2VyOiAwLFxyXG4gICAgICAgICAgICBwaWNhOiAnJ1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgYXN5bmMgY3JlYXRlKGUpIHtcclxuICAgICAgICBsZXQgYnV0dG9uID0gZS50YXJnZXRcclxuICAgICAgICAvLyBkZWJ1Z2dlclxyXG4gICAgICAgIGxldCBhX2lkID0gYXdhaXQgY3JlYXRlT25TZXJ2ZXIoYnV0dG9uKVxyXG4gICAgICAgIHNob3coYV9pZClcclxuXHJcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlT25TZXJ2ZXIoYnV0dG9uKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXdFbCA9IF9hbnN3ZXIuZ2V0TW9kZWxGb3JTZXJ2ZXIoX2Fuc3dlci5lbChidXR0b24pKVxyXG5cclxuICAgICAgICAgICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9hbnN3ZXIvY3JlYXRlJywgbmV3RWwpXHJcbiAgICAgICAgICAgIHJlcyA9IEpTT04ucGFyc2UocmVzKVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlcy5pZFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc2hvdyhhX2lkKSB7XHJcbiAgICAgICAgICAgIGxldCBlbCA9IF9hbnN3ZXIuZWwoYnV0dG9uKVxyXG5cclxuICAgICAgICAgICAgZWwuY2hlY2tlZC5jaGVja2VkID0gZmFsc2VcclxuICAgICAgICAgICAgZWwuZWwuZGF0YXNldFsnYW5zd2VySWQnXSA9IGFfaWRcclxuICAgICAgICAgICAgZWwudGV4dC5pbm5lclRleHQgPSAnJ1xyXG4gICAgICAgICAgICBlbC5zb3J0LmlubmVyVGV4dCA9IGVsLmFuc3dlckNudCArIDFcclxuXHJcbiAgICAgICAgICAgIGVsLmVsLnN0eWxlLmRpc3BsYXkgPSAnZmxleCdcclxuICAgICAgICAgICAgYnV0dG9uLmJlZm9yZShlbC5lbClcclxuICAgICAgICAgICAgZWwuZWwuc3R5bGUub3BhY2l0eSA9IDFcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGFzeW5jIGRlbChlKSB7XHJcbiAgICAgICAgbGV0IGRlbF9idXR0b24gPSAoZS50eXBlID09PSBcImNsaWNrXCIpP2UudGFyZ2V0OmVcclxuICAgICAgICBpZiAoY29uZmlybShcItCj0LTQsNC70LjRgtGMINGN0YLQvtGCINC+0YLQstC10YI/XCIpKSB7XHJcbiAgICAgICAgICAgIGxldCByZXMgPSBhd2FpdCBkZWxldGVGcm9tU2VydmVyKGRlbF9idXR0b24pXHJcbiAgICAgICAgICAgIGRlbGV0ZUZyb21WaWV3KGRlbF9idXR0b24pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBkZWxldGVGcm9tVmlldyhkZWxfYnV0dG9uKSB7XHJcbiAgICAgICAgICAgIGRlbF9idXR0b24uY2xvc2VzdCgnLmFuc3dlcicpLnJlbW92ZSgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhc3luYyBmdW5jdGlvbiBkZWxldGVGcm9tU2VydmVyKGRlbF9idXR0b24pIHtcclxuXHJcbiAgICAgICAgICAgIGxldCBhX2lkID0gK2RlbF9idXR0b24uY2xvc2VzdCgnLmFuc3dlcicpLmRhdGFzZXRbJ2Fuc3dlcklkJ11cclxuICAgICAgICAgICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9hbnN3ZXIvZGVsZXRlJywge2FfaWR9KVxyXG4gICAgICAgICAgICByZXMgPSBKU09OLnBhcnNlKHJlcylcclxuICAgICAgICAgICAgaWYgKHJlcy5tc2cgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgICAgIHBvcHVwLnNob3coJ9Ce0YLQstC10YIg0YPQtNCw0LvQtdC9JylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbn1cclxuIiwiaW1wb3J0IHskLCBwb3B1cCwgcG9zdCwgYWRkVG9vbHRpcH0gZnJvbSBcIi4uLy4uL2NvbW1vblwiXHJcbmltcG9ydCB7X2Fuc3dlcn0gZnJvbSBcIi4vYW5zd2VyXCI7XHJcblxyXG5leHBvcnQgbGV0IF9xdWVzdGlvbiA9IHtcclxuXHJcbiAgc29ydDogYXN5bmMgZnVuY3Rpb24gKHVwVG9RZXN0aW9uTnVtYmVyKSB7XHJcbiAgICBsZXQgcXVlc3Rpb25zID0gWy4uLl9xdWVzdGlvbi5xdWVzdGlvbnMoKV1cclxuICAgIGxldCBxdWVzdGlvbnNFbHMgPSBxdWVzdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChlbCwgaSkge1xyXG4gICAgICAgIGlmIChpICsgMSA8IHVwVG9RZXN0aW9uTnVtYmVyKSByZXR1cm4gZWxcclxuICAgICAgfVxyXG4gICAgKVxyXG4gICAgbGV0IHRvQ2hhbmdlID0gcXVlc3Rpb25zRWxzLm1hcCgoZWwpID0+IHtcclxuICAgICAgcmV0dXJuIGVsLmlkXHJcbiAgICB9KVxyXG4gICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9xdWVzdGlvbi9zb3J0Jywge3RvQ2hhbmdlfSlcclxuICAgIHJlcyA9IEpTT04ucGFyc2UocmVzKVxyXG4gICAgaWYgKHJlcy5tc2cpIHtcclxuICAgICAgcG9wdXAuc2hvdyhyZXMubXNnKVxyXG4gICAgfVxyXG4gICAgcXVlc3Rpb25zRWxzLm1hcCgoZWwsIGkpID0+IHtcclxuICAgICAgJChlbCkuZmluZCgnLnF1ZXN0aW9uX19zb3J0JykuaW5uZXJUZXh0ID0gaSArIDFcclxuXHJcbiAgICB9KVxyXG4gIH0sXHJcblxyXG5cclxuICBjaGFuZ2VQYXJlbnQ6IGFzeW5jIGZ1bmN0aW9uIChlKSB7XHJcbiAgICBsZXQgc2VsID0gZS50YXJnZXRcclxuICAgIGxldCBvcHQgPSBzZWwub3B0aW9uc1tzZWwuc2VsZWN0ZWRJbmRleF1cclxuICAgIGxldCBpZCA9IHNlbC5jbG9zZXN0KCcucXVlc3Rpb24tZWRpdCcpLmlkXHJcbiAgICBsZXQgdGVzdF9pZCA9IG9wdC5kYXRhc2V0WydxdWVzdGlvblBhcmVudElkJ11cclxuICAgIGxldCB0ZXN0X25hbWUgPSBvcHQudmFsdWVcclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KCcvcXVlc3Rpb24vY2hhbmdlUGFyZW50Jyx7aWQsIHRlc3RfaWR9KVxyXG4gICAgcmVzID0gSlNPTi5wYXJzZShyZXMpXHJcbiAgICBpZiAocmVzLm1zZyAhPT0nb2snKSB0aHJvdyAoZSk7XHJcbiAgICBsZXQgcXVlc3Rpb24gPSBzZWwuY2xvc2VzdCgnLnF1ZXN0aW9uLWVkaXQnKVxyXG4gICAgcXVlc3Rpb24ucmVtb3ZlKClcclxuICAgIHBvcHVwLnNob3coJ9Cf0LXRgNC10LzQtdGJ0LXQvSDQsiAnK3Rlc3RfbmFtZSlcclxuICAgIC8vIGRlYnVnZ2VyXHJcbiAgfSxcclxuXHJcblxyXG4gIHNob3dUaXA6IChhY3Rpb24sIGV2ZW50KSA9PiB7XHJcbiAgICBsZXQgZWwgPSBldmVudC50YXJnZXRcclxuICAgIGxldCB0aXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXHJcblxyXG4gICAgaWYgKGFjdGlvbiA9PT0gJ3NhdmUuc3ZnJykge1xyXG4gICAgICBhZGRUb29sdGlwKGVsLCAn0YHQvtGF0YDQsNC90LjRgtGMJylcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBzaG93Rmlyc3Q6ICgpID0+IHtcclxuICAgIGxldCBxdWVzdGlvbiA9IF9xdWVzdGlvbi5jbG9uZUVtcHR5TW9kZWwoKVxyXG4gICAgaWYgKCFxdWVzdGlvbikgcmV0dXJuXHJcblxyXG4gICAgbGV0IG1vZGVsID0gX3F1ZXN0aW9uLnZpZXdNb2RlbChxdWVzdGlvbilcclxuICAgIG1vZGVsLnNvcnQuaW5uZXJUZXh0ID0gJzEnXHJcbiAgICAkKG1vZGVsLnNhdmUpLm9uKCdjbGljaycsIF9xdWVzdGlvbi5zYXZlKVxyXG4gICAgJChtb2RlbC5kZWwpLm9uKCdjbGljaycsIF9xdWVzdGlvbi5kZWxldGUpXHJcblxyXG4gICAgJChxdWVzdGlvbikuYWRkQ2xhc3MoJ3F1ZXN0aW9uLWVkaXQnKVxyXG4gICAgJChxdWVzdGlvbikucmVtb3ZlQ2xhc3MoJ3F1ZXN0aW9uX19jcmVhdGUnKVxyXG5cclxuICAgIGxldCBxdWVzdGlvbnMgPSAkKCcucXVlc3Rpb25zJykuZWxbMF1cclxuICAgIHF1ZXN0aW9ucy5wcmVwZW5kKHF1ZXN0aW9uKVxyXG4gIH0sXHJcblxyXG4gIGNsb25lRW1wdHlNb2RlbDogKCkgPT4ge1xyXG4gICAgbGV0IHF1ZXN0aW9uID0gJCgnLnF1ZXN0aW9ucyAucXVlc3Rpb25fX2NyZWF0ZSAucXVlc3Rpb24tZWRpdCcpLmVsWzBdXHJcbiAgICBpZiAocXVlc3Rpb24pIHJldHVybiBxdWVzdGlvbi5jbG9uZU5vZGUodHJ1ZSlcclxuICB9LFxyXG5cclxuICBzaG93QW5zd2VyczogKGUpID0+IHtcclxuICAgIGxldCB0ZXh0ID0gZS50YXJnZXRcclxuICAgIGxldCBwYXJlbnQgPSB0ZXh0LnBhcmVudE5vZGUucGFyZW50Tm9kZVxyXG4gICAgbGV0IGFuc3dlcnMgPSAkKHBhcmVudCkuZmluZCgnLnF1ZXN0aW9uX19hbnN3ZXJzJylcclxuICAgIGFuc3dlcnMuY2xhc3NMaXN0LnRvZ2dsZSgnaGVpZ2h0JylcclxuICAgIGFuc3dlcnMuY2xhc3NMaXN0LnRvZ2dsZSgnc2NhbGUnKVxyXG4gICAgdGV4dC5jbGFzc0xpc3QudG9nZ2xlKCdyb3RhdGUnKVxyXG4gIH0sXHJcblxyXG4gIHZpZXdNb2RlbDogKGVsKSA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpZDogK2VsLmlkLFxyXG4gICAgICBlbDogZWwsXHJcbiAgICAgIHNvcnQ6IGVsLnF1ZXJ5U2VsZWN0b3IoJy5xdWVzdGlvbl9fc29ydCcpLFxyXG4gICAgICBzYXZlOiBlbC5xdWVyeVNlbGVjdG9yKCcucXVlc3Rpb25fX3NhdmUnKSxcclxuICAgICAgdGV4dDogZWwucXVlcnlTZWxlY3RvcignLnF1ZXN0aW9uX190ZXh0JyksXHJcbiAgICAgIGRlbDogZWwucXVlcnlTZWxlY3RvcignLnF1ZXN0aW9uX19kZWxldGUnKSxcclxuICAgICAgY3JlYXRlQW5zd2VyQnV0dG9uOiBlbC5xdWVyeVNlbGVjdG9yKCcuYW5zd2VyX19jcmVhdGUtYnV0dG9uJyksXHJcbiAgICAgIGFkZEJ1dHRvbjogJCgkKCcucXVlc3Rpb25zJykuZWxbMF0pLmZpbmQoJy5xdWVzdGlvbl9fY3JlYXRlLWJ1dHRvbicpLFxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHNlcnZlck1vZGVsOiAoKSA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBxdWVzdGlvbjoge1xyXG4gICAgICAgIGlkOiBudWxsLFxyXG4gICAgICAgIHF1c3Rpb246ICcnLFxyXG4gICAgICAgIHBhcmVudDogK3dpbmRvdy5sb2NhdGlvbi5ocmVmLnNwbGl0KCcvJykucG9wKCksXHJcbiAgICAgICAgc29ydDogX3F1ZXN0aW9uLmxhc3RTb3J0KCksXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICBxdWVzdGlvbnM6ICgpID0+IHtcclxuICAgIGxldCBxcyA9ICQoJy5xdWVzdGlvbnM+LnF1ZXN0aW9uLWVkaXQnKVxyXG4gICAgLy8gZGVidWdnZXJcclxuICAgIHJldHVybiAkKCcucXVlc3Rpb25zPi5xdWVzdGlvbi1lZGl0JylcclxuICAgIC8vIHJldHVybiAkKCcucXVlc3Rpb25zPi5xdWVzdGlvbi1lZGl0JykuZWxcclxuICB9LFxyXG5cclxuICBxdWVzdGlvbnNDb3VudDogKCkgPT4ge1xyXG4gICAgcmV0dXJuICQoJy5xdWVzdGlvbnM+LnF1ZXN0aW9uLWVkaXQnKS5lbC5sZW5ndGhcclxuICB9LFxyXG5cclxuICBsYXN0U29ydDogKCkgPT4ge1xyXG4gICAgbGV0IHFzID0gX3F1ZXN0aW9uLnF1ZXN0aW9ucygpXHJcbiAgICBsZXQgbGVuZ3RoID0gcXMubGVuZ3RoLTFcclxuICAgIGxldCBsYXN0ID0gICtfcXVlc3Rpb24udmlld01vZGVsKHFzW2xlbmd0aF0pLnNvcnQuaW5uZXJUZXh0XHJcbiAgICByZXR1cm4gbGFzdCsxXHJcbiAgfSxcclxuXHJcbiAgY3JlYXRlOlxyXG4gICAgYXN5bmMgKGUpID0+IHtcclxuICAgICAgbGV0IHFfaWQgPSBhd2FpdCBfcXVlc3Rpb24uY3JlYXRlT25TZXJ2ZXIoZSlcclxuICAgICAgaWYgKHFfaWQpIHtcclxuICAgICAgICBfcXVlc3Rpb24uY3JlYXRlT25WaWV3KHFfaWQpXHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gIGNyZWF0ZU9uU2VydmVyOlxyXG4gICAgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBsZXQgcXVlc3Rpb24gPSBfcXVlc3Rpb24uc2VydmVyTW9kZWwoKVxyXG4gICAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCgnL3F1ZXN0aW9uL3VwZGF0ZU9yQ3JlYXRlJywge3F1ZXN0aW9uOiBxdWVzdGlvbi5xdWVzdGlvbiwgYW5zd2Vyczoge319KVxyXG4gICAgICByZXMgPSBhd2FpdCBKU09OLnBhcnNlKHJlcylcclxuXHJcbiAgICAgIHJldHVybiByZXMuaWRcclxuICAgIH0sXHJcblxyXG4gIGNyZWF0ZU9uVmlldzpcclxuICAgIChxX2lkKSA9PiB7XHJcbiAgICAgIGxldCBjbG9uZSA9IF9xdWVzdGlvbi5jbG9uZUVtcHR5TW9kZWwoKVxyXG5cclxuICAgICAgbGV0IG1vZGVsID0gX3F1ZXN0aW9uLnZpZXdNb2RlbChjbG9uZSlcclxuICAgICAgJChtb2RlbC5zYXZlKS5vbignY2xpY2snLCBfcXVlc3Rpb24uc2F2ZSlcclxuICAgICAgJChtb2RlbC5kZWwpLm9uKCdjbGljaycsIF9xdWVzdGlvbi5kZWxldGUpXHJcbiAgICAgICQobW9kZWwudGV4dCkub24oJ2NsaWNrJywgX3F1ZXN0aW9uLnNob3dBbnN3ZXJzKVxyXG4gICAgICAkKG1vZGVsLmNyZWF0ZUFuc3dlckJ1dHRvbikub24oJ2NsaWNrJywgX2Fuc3dlci5jcmVhdGUpXHJcblxyXG4gICAgICBtb2RlbC5zb3J0LmlubmVyVGV4dCA9IF9xdWVzdGlvbi5sYXN0U29ydCgpXHJcbiAgICAgIG1vZGVsLnRleHQuaW5uZXJUZXh0ID0gJydcclxuICAgICAgbW9kZWwuZWwuaWQgPSBxX2lkXHJcblxyXG4gICAgICBtb2RlbC5hZGRCdXR0b24uYmVmb3JlKGNsb25lKVxyXG4gICAgfSxcclxuXHJcblxyXG4gIHNhdmU6XHJcbiAgICBhc3luYyAoZSkgPT4ge1xyXG4gICAgICBsZXQgcXVlc3Rpb24gPSBlLnRhcmdldC5jbG9zZXN0KCcucXVlc3Rpb24tZWRpdCcpXHJcbiAgICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KFxyXG4gICAgICAgICcvcXVlc3Rpb24vVXBkYXRlT3JDcmVhdGUnLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHF1ZXN0aW9uOiBfcXVlc3Rpb24uZ2V0TW9kZWxGb3JTZXJ2ZXIocXVlc3Rpb24pLFxyXG4gICAgICAgICAgYW5zd2VyczogX3F1ZXN0aW9uLmdldEFuc3dlcnMocXVlc3Rpb24pLFxyXG4gICAgICAgIH0pXHJcbiAgICAgIHJlcyA9IGF3YWl0IEpTT04ucGFyc2UocmVzKVxyXG4gICAgICBwb3B1cC5zaG93KHJlcy5tc2cpXHJcbiAgICB9LFxyXG5cclxuICBkZWxldGU6XHJcbiAgICBhc3luYyAoZSkgPT4ge1xyXG4gICAgICBpZiAoY29uZmlybShcItCj0LTQsNC70LjRgtGMINCy0L7Qv9GA0L7RgSDRgdC+INCy0YHQtdC80Lgg0LXQs9C+INC+0YLQstC10YLQsNC80Lg/XCIpKSB7XHJcbiAgICAgICAgbGV0IHZpZXdNb2RlbCA9IF9xdWVzdGlvbi52aWV3TW9kZWwoZS50YXJnZXQuY2xvc2VzdCgnLnF1ZXN0aW9uLWVkaXQnKSlcclxuICAgICAgICBsZXQgaWQgPSB2aWV3TW9kZWwuaWRcclxuXHJcbiAgICAgICAgbGV0IGRlbGV0ZWQgPSBhd2FpdCBfcXVlc3Rpb24uZGVsZXRlRnJvbVNlcnZlcihpZClcclxuICAgICAgICBpZiAoZGVsZXRlZCkge1xyXG4gICAgICAgICAgX3F1ZXN0aW9uLmRlbGV0ZUZyb21WaWV3KHZpZXdNb2RlbClcclxuICAgICAgICAgIHBvcHVwLnNob3coZGVsZXRlZC5tc2cpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICBkZWxldGVGcm9tVmlldzpcclxuICAgIGFzeW5jICh2aWV3TW9kZWwpID0+IHtcclxuICAgICAgdmlld01vZGVsLmVsLnJlbW92ZSgpXHJcbiAgICB9LFxyXG5cclxuICBkZWxldGVGcm9tU2VydmVyOlxyXG4gICAgYXN5bmMgKHFfaWQpID0+IHtcclxuICAgICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9xdWVzdGlvbi9kZWxldGUnLCB7cV9pZH0pXHJcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlcylcclxuICAgIH0sXHJcblxyXG4gIGdldE1vZGVsRm9yU2VydmVyOlxyXG4gICAgKHF1ZXN0aW9uKSA9PiB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6ICtxdWVzdGlvbi5pZCxcclxuICAgICAgICBwYXJlbnQ6ICskKCcudGVzdC1uYW1lJykuZWxbMF0uZ2V0QXR0cmlidXRlKCd2YWx1ZScpLFxyXG4gICAgICAgIHBpY3E6ICcnLFxyXG4gICAgICAgIHF1c3Rpb246ICQocXVlc3Rpb24pLmZpbmQoJy5xdWVzdGlvbl9fdGV4dCcpLmlubmVyVGV4dCxcclxuICAgICAgICBzb3J0OiArJChxdWVzdGlvbikuZmluZCgnLnF1ZXN0aW9uX19zb3J0JykuaW5uZXJUZXh0LFxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gIGdldEFuc3dlcnM6XHJcbiAgICAocXVlc3Rpb24pID0+IHtcclxuICAgICAgbGV0IGFuc3dlckJsb2NrcyA9IHF1ZXN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hbnN3ZXInKVxyXG4gICAgICByZXR1cm4gWy4uLmFuc3dlckJsb2Nrc10ubWFwKChhKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGlkOiArYS5kYXRhc2V0WydhbnN3ZXJJZCddLFxyXG4gICAgICAgICAgYW5zd2VyOiBhLnF1ZXJ5U2VsZWN0b3IoJy5hbnN3ZXJfX3RleHQnKS5pbm5lclRleHQsXHJcbiAgICAgICAgICBjb3JyZWN0X2Fuc3dlcjogK2EucXVlcnlTZWxlY3RvcignW3R5cGU9XCJjaGVja2JveFwiXScpLmNoZWNrZWQsXHJcbiAgICAgICAgICBwYXJlbnRfcXVlc3Rpb246ICtxdWVzdGlvbi5pZCxcclxuICAgICAgICAgIHBpY2E6ICcnLFxyXG4gICAgICAgIH1cclxuICAgICAgfSwgcXVlc3Rpb24pXHJcbiAgICB9LFxyXG59XHJcblxyXG4iLCIvKiohXG4gKiBTb3J0YWJsZSAxLjE0LjBcbiAqIEBhdXRob3JcdFJ1YmFYYSAgIDx0cmFzaEBydWJheGEub3JnPlxuICogQGF1dGhvclx0b3dlbm0gICAgPG93ZW4yMzM1NUBnbWFpbC5jb20+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuXG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSB7XG4gICAgICBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcblxuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG5cbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG52YXIgdmVyc2lvbiA9IFwiMS4xNC4wXCI7XG5cbmZ1bmN0aW9uIHVzZXJBZ2VudChwYXR0ZXJuKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmF2aWdhdG9yKSB7XG4gICAgcmV0dXJuICEhIC8qQF9fUFVSRV9fKi9uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKHBhdHRlcm4pO1xuICB9XG59XG5cbnZhciBJRTExT3JMZXNzID0gdXNlckFnZW50KC8oPzpUcmlkZW50LipydlsgOl0/MTFcXC58bXNpZXxpZW1vYmlsZXxXaW5kb3dzIFBob25lKS9pKTtcbnZhciBFZGdlID0gdXNlckFnZW50KC9FZGdlL2kpO1xudmFyIEZpcmVGb3ggPSB1c2VyQWdlbnQoL2ZpcmVmb3gvaSk7XG52YXIgU2FmYXJpID0gdXNlckFnZW50KC9zYWZhcmkvaSkgJiYgIXVzZXJBZ2VudCgvY2hyb21lL2kpICYmICF1c2VyQWdlbnQoL2FuZHJvaWQvaSk7XG52YXIgSU9TID0gdXNlckFnZW50KC9pUChhZHxvZHxob25lKS9pKTtcbnZhciBDaHJvbWVGb3JBbmRyb2lkID0gdXNlckFnZW50KC9jaHJvbWUvaSkgJiYgdXNlckFnZW50KC9hbmRyb2lkL2kpO1xuXG52YXIgY2FwdHVyZU1vZGUgPSB7XG4gIGNhcHR1cmU6IGZhbHNlLFxuICBwYXNzaXZlOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gb24oZWwsIGV2ZW50LCBmbikge1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmbiwgIUlFMTFPckxlc3MgJiYgY2FwdHVyZU1vZGUpO1xufVxuXG5mdW5jdGlvbiBvZmYoZWwsIGV2ZW50LCBmbikge1xuICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBmbiwgIUlFMTFPckxlc3MgJiYgY2FwdHVyZU1vZGUpO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVzKFxuLyoqSFRNTEVsZW1lbnQqL1xuZWwsXG4vKipTdHJpbmcqL1xuc2VsZWN0b3IpIHtcbiAgaWYgKCFzZWxlY3RvcikgcmV0dXJuO1xuICBzZWxlY3RvclswXSA9PT0gJz4nICYmIChzZWxlY3RvciA9IHNlbGVjdG9yLnN1YnN0cmluZygxKSk7XG5cbiAgaWYgKGVsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChlbC5tYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiBlbC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoZWwubXNNYXRjaGVzU2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGVsLm1zTWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoZWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudE9ySG9zdChlbCkge1xuICByZXR1cm4gZWwuaG9zdCAmJiBlbCAhPT0gZG9jdW1lbnQgJiYgZWwuaG9zdC5ub2RlVHlwZSA/IGVsLmhvc3QgOiBlbC5wYXJlbnROb2RlO1xufVxuXG5mdW5jdGlvbiBjbG9zZXN0KFxuLyoqSFRNTEVsZW1lbnQqL1xuZWwsXG4vKipTdHJpbmcqL1xuc2VsZWN0b3IsXG4vKipIVE1MRWxlbWVudCovXG5jdHgsIGluY2x1ZGVDVFgpIHtcbiAgaWYgKGVsKSB7XG4gICAgY3R4ID0gY3R4IHx8IGRvY3VtZW50O1xuXG4gICAgZG8ge1xuICAgICAgaWYgKHNlbGVjdG9yICE9IG51bGwgJiYgKHNlbGVjdG9yWzBdID09PSAnPicgPyBlbC5wYXJlbnROb2RlID09PSBjdHggJiYgbWF0Y2hlcyhlbCwgc2VsZWN0b3IpIDogbWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSB8fCBpbmNsdWRlQ1RYICYmIGVsID09PSBjdHgpIHtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWwgPT09IGN0eCkgYnJlYWs7XG4gICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG4gICAgfSB3aGlsZSAoZWwgPSBnZXRQYXJlbnRPckhvc3QoZWwpKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUl9TUEFDRSA9IC9cXHMrL2c7XG5cbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsLCBuYW1lLCBzdGF0ZSkge1xuICBpZiAoZWwgJiYgbmFtZSkge1xuICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICAgIGVsLmNsYXNzTGlzdFtzdGF0ZSA/ICdhZGQnIDogJ3JlbW92ZSddKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gKCcgJyArIGVsLmNsYXNzTmFtZSArICcgJykucmVwbGFjZShSX1NQQUNFLCAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKTtcbiAgICAgIGVsLmNsYXNzTmFtZSA9IChjbGFzc05hbWUgKyAoc3RhdGUgPyAnICcgKyBuYW1lIDogJycpKS5yZXBsYWNlKFJfU1BBQ0UsICcgJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNzcyhlbCwgcHJvcCwgdmFsKSB7XG4gIHZhciBzdHlsZSA9IGVsICYmIGVsLnN0eWxlO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKGRvY3VtZW50LmRlZmF1bHRWaWV3ICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgdmFsID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgJycpO1xuICAgICAgfSBlbHNlIGlmIChlbC5jdXJyZW50U3R5bGUpIHtcbiAgICAgICAgdmFsID0gZWwuY3VycmVudFN0eWxlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvcCA9PT0gdm9pZCAwID8gdmFsIDogdmFsW3Byb3BdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIShwcm9wIGluIHN0eWxlKSAmJiBwcm9wLmluZGV4T2YoJ3dlYmtpdCcpID09PSAtMSkge1xuICAgICAgICBwcm9wID0gJy13ZWJraXQtJyArIHByb3A7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlW3Byb3BdID0gdmFsICsgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gJycgOiAncHgnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0cml4KGVsLCBzZWxmT25seSkge1xuICB2YXIgYXBwbGllZFRyYW5zZm9ybXMgPSAnJztcblxuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIGFwcGxpZWRUcmFuc2Zvcm1zID0gZWw7XG4gIH0gZWxzZSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGNzcyhlbCwgJ3RyYW5zZm9ybScpO1xuXG4gICAgICBpZiAodHJhbnNmb3JtICYmIHRyYW5zZm9ybSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGFwcGxpZWRUcmFuc2Zvcm1zID0gdHJhbnNmb3JtICsgJyAnICsgYXBwbGllZFRyYW5zZm9ybXM7XG4gICAgICB9XG4gICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cbiAgICB9IHdoaWxlICghc2VsZk9ubHkgJiYgKGVsID0gZWwucGFyZW50Tm9kZSkpO1xuICB9XG5cbiAgdmFyIG1hdHJpeEZuID0gd2luZG93LkRPTU1hdHJpeCB8fCB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4IHx8IHdpbmRvdy5DU1NNYXRyaXggfHwgd2luZG93Lk1TQ1NTTWF0cml4O1xuICAvKmpzaGludCAtVzA1NiAqL1xuXG4gIHJldHVybiBtYXRyaXhGbiAmJiBuZXcgbWF0cml4Rm4oYXBwbGllZFRyYW5zZm9ybXMpO1xufVxuXG5mdW5jdGlvbiBmaW5kKGN0eCwgdGFnTmFtZSwgaXRlcmF0b3IpIHtcbiAgaWYgKGN0eCkge1xuICAgIHZhciBsaXN0ID0gY3R4LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgbiA9IGxpc3QubGVuZ3RoO1xuXG4gICAgaWYgKGl0ZXJhdG9yKSB7XG4gICAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgICBpdGVyYXRvcihsaXN0W2ldLCBpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpIHtcbiAgdmFyIHNjcm9sbGluZ0VsZW1lbnQgPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50O1xuXG4gIGlmIChzY3JvbGxpbmdFbGVtZW50KSB7XG4gICAgcmV0dXJuIHNjcm9sbGluZ0VsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBcImJvdW5kaW5nIGNsaWVudCByZWN0XCIgb2YgZ2l2ZW4gZWxlbWVudFxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgICAgICAgICAgICAgICAgICAgICBUaGUgZWxlbWVudCB3aG9zZSBib3VuZGluZ0NsaWVudFJlY3QgaXMgd2FudGVkXG4gKiBAcGFyYW0gIHtbQm9vbGVhbl19IHJlbGF0aXZlVG9Db250YWluaW5nQmxvY2sgIFdoZXRoZXIgdGhlIHJlY3Qgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBjb250YWluaW5nIGJsb2NrIG9mIChpbmNsdWRpbmcpIHRoZSBjb250YWluZXJcbiAqIEBwYXJhbSAge1tCb29sZWFuXX0gcmVsYXRpdmVUb05vblN0YXRpY1BhcmVudCAgV2hldGhlciB0aGUgcmVjdCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIHJlbGF0aXZlIHBhcmVudCBvZiAoaW5jbHVkaW5nKSB0aGUgY29udGFpZW5yXG4gKiBAcGFyYW0gIHtbQm9vbGVhbl19IHVuZG9TY2FsZSAgICAgICAgICAgICAgICAgIFdoZXRoZXIgdGhlIGNvbnRhaW5lcidzIHNjYWxlKCkgc2hvdWxkIGJlIHVuZG9uZVxuICogQHBhcmFtICB7W0hUTUxFbGVtZW50XX0gY29udGFpbmVyICAgICAgICAgICAgICBUaGUgcGFyZW50IHRoZSBlbGVtZW50IHdpbGwgYmUgcGxhY2VkIGluXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBib3VuZGluZ0NsaWVudFJlY3Qgb2YgZWwsIHdpdGggc3BlY2lmaWVkIGFkanVzdG1lbnRzXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRSZWN0KGVsLCByZWxhdGl2ZVRvQ29udGFpbmluZ0Jsb2NrLCByZWxhdGl2ZVRvTm9uU3RhdGljUGFyZW50LCB1bmRvU2NhbGUsIGNvbnRhaW5lcikge1xuICBpZiAoIWVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiBlbCAhPT0gd2luZG93KSByZXR1cm47XG4gIHZhciBlbFJlY3QsIHRvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgaGVpZ2h0LCB3aWR0aDtcblxuICBpZiAoZWwgIT09IHdpbmRvdyAmJiBlbC5wYXJlbnROb2RlICYmIGVsICE9PSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCkpIHtcbiAgICBlbFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB0b3AgPSBlbFJlY3QudG9wO1xuICAgIGxlZnQgPSBlbFJlY3QubGVmdDtcbiAgICBib3R0b20gPSBlbFJlY3QuYm90dG9tO1xuICAgIHJpZ2h0ID0gZWxSZWN0LnJpZ2h0O1xuICAgIGhlaWdodCA9IGVsUmVjdC5oZWlnaHQ7XG4gICAgd2lkdGggPSBlbFJlY3Qud2lkdGg7XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gMDtcbiAgICBsZWZ0ID0gMDtcbiAgICBib3R0b20gPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgcmlnaHQgPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgfVxuXG4gIGlmICgocmVsYXRpdmVUb0NvbnRhaW5pbmdCbG9jayB8fCByZWxhdGl2ZVRvTm9uU3RhdGljUGFyZW50KSAmJiBlbCAhPT0gd2luZG93KSB7XG4gICAgLy8gQWRqdXN0IGZvciB0cmFuc2xhdGUoKVxuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBlbC5wYXJlbnROb2RlOyAvLyBzb2x2ZXMgIzExMjMgKHNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM3OTUzODA2LzYwODgzMTIpXG4gICAgLy8gTm90IG5lZWRlZCBvbiA8PSBJRTExXG5cbiAgICBpZiAoIUlFMTFPckxlc3MpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIChjc3MoY29udGFpbmVyLCAndHJhbnNmb3JtJykgIT09ICdub25lJyB8fCByZWxhdGl2ZVRvTm9uU3RhdGljUGFyZW50ICYmIGNzcyhjb250YWluZXIsICdwb3NpdGlvbicpICE9PSAnc3RhdGljJykpIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gU2V0IHJlbGF0aXZlIHRvIGVkZ2VzIG9mIHBhZGRpbmcgYm94IG9mIGNvbnRhaW5lclxuXG4gICAgICAgICAgdG9wIC09IGNvbnRhaW5lclJlY3QudG9wICsgcGFyc2VJbnQoY3NzKGNvbnRhaW5lciwgJ2JvcmRlci10b3Atd2lkdGgnKSk7XG4gICAgICAgICAgbGVmdCAtPSBjb250YWluZXJSZWN0LmxlZnQgKyBwYXJzZUludChjc3MoY29udGFpbmVyLCAnYm9yZGVyLWxlZnQtd2lkdGgnKSk7XG4gICAgICAgICAgYm90dG9tID0gdG9wICsgZWxSZWN0LmhlaWdodDtcbiAgICAgICAgICByaWdodCA9IGxlZnQgKyBlbFJlY3Qud2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuXG4gICAgICB9IHdoaWxlIChjb250YWluZXIgPSBjb250YWluZXIucGFyZW50Tm9kZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHVuZG9TY2FsZSAmJiBlbCAhPT0gd2luZG93KSB7XG4gICAgLy8gQWRqdXN0IGZvciBzY2FsZSgpXG4gICAgdmFyIGVsTWF0cml4ID0gbWF0cml4KGNvbnRhaW5lciB8fCBlbCksXG4gICAgICAgIHNjYWxlWCA9IGVsTWF0cml4ICYmIGVsTWF0cml4LmEsXG4gICAgICAgIHNjYWxlWSA9IGVsTWF0cml4ICYmIGVsTWF0cml4LmQ7XG5cbiAgICBpZiAoZWxNYXRyaXgpIHtcbiAgICAgIHRvcCAvPSBzY2FsZVk7XG4gICAgICBsZWZ0IC89IHNjYWxlWDtcbiAgICAgIHdpZHRoIC89IHNjYWxlWDtcbiAgICAgIGhlaWdodCAvPSBzY2FsZVk7XG4gICAgICBib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gICAgICByaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvcDogdG9wLFxuICAgIGxlZnQ6IGxlZnQsXG4gICAgYm90dG9tOiBib3R0b20sXG4gICAgcmlnaHQ6IHJpZ2h0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYSBzaWRlIG9mIGFuIGVsZW1lbnQgaXMgc2Nyb2xsZWQgcGFzdCBhIHNpZGUgb2YgaXRzIHBhcmVudHNcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSAgZWwgICAgICAgICAgIFRoZSBlbGVtZW50IHdobydzIHNpZGUgYmVpbmcgc2Nyb2xsZWQgb3V0IG9mIHZpZXcgaXMgaW4gcXVlc3Rpb25cbiAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgZWxTaWRlICAgICAgIFNpZGUgb2YgdGhlIGVsZW1lbnQgaW4gcXVlc3Rpb24gKCd0b3AnLCAnbGVmdCcsICdyaWdodCcsICdib3R0b20nKVxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICBwYXJlbnRTaWRlICAgU2lkZSBvZiB0aGUgcGFyZW50IGluIHF1ZXN0aW9uICgndG9wJywgJ2xlZnQnLCAncmlnaHQnLCAnYm90dG9tJylcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgICAgICAgICAgICAgIFRoZSBwYXJlbnQgc2Nyb2xsIGVsZW1lbnQgdGhhdCB0aGUgZWwncyBzaWRlIGlzIHNjcm9sbGVkIHBhc3QsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gc3VjaCBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiBpc1Njcm9sbGVkUGFzdChlbCwgZWxTaWRlLCBwYXJlbnRTaWRlKSB7XG4gIHZhciBwYXJlbnQgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbCwgdHJ1ZSksXG4gICAgICBlbFNpZGVWYWwgPSBnZXRSZWN0KGVsKVtlbFNpZGVdO1xuICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIHZhciBwYXJlbnRTaWRlVmFsID0gZ2V0UmVjdChwYXJlbnQpW3BhcmVudFNpZGVdLFxuICAgICAgICB2aXNpYmxlID0gdm9pZCAwO1xuXG4gICAgaWYgKHBhcmVudFNpZGUgPT09ICd0b3AnIHx8IHBhcmVudFNpZGUgPT09ICdsZWZ0Jykge1xuICAgICAgdmlzaWJsZSA9IGVsU2lkZVZhbCA+PSBwYXJlbnRTaWRlVmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aXNpYmxlID0gZWxTaWRlVmFsIDw9IHBhcmVudFNpZGVWYWw7XG4gICAgfVxuXG4gICAgaWYgKCF2aXNpYmxlKSByZXR1cm4gcGFyZW50O1xuICAgIGlmIChwYXJlbnQgPT09IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKSkgYnJlYWs7XG4gICAgcGFyZW50ID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQocGFyZW50LCBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEdldHMgbnRoIGNoaWxkIG9mIGVsLCBpZ25vcmluZyBoaWRkZW4gY2hpbGRyZW4sIHNvcnRhYmxlJ3MgZWxlbWVudHMgKGRvZXMgbm90IGlnbm9yZSBjbG9uZSBpZiBpdCdzIHZpc2libGUpXG4gKiBhbmQgbm9uLWRyYWdnYWJsZSBlbGVtZW50c1xuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgICAgIFRoZSBwYXJlbnQgZWxlbWVudFxuICogQHBhcmFtICB7TnVtYmVyfSBjaGlsZE51bSAgICAgIFRoZSBpbmRleCBvZiB0aGUgY2hpbGRcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyAgICAgICBQYXJlbnQgU29ydGFibGUncyBvcHRpb25zXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gICAgICAgICAgVGhlIGNoaWxkIGF0IGluZGV4IGNoaWxkTnVtLCBvciBudWxsIGlmIG5vdCBmb3VuZFxuICovXG5cblxuZnVuY3Rpb24gZ2V0Q2hpbGQoZWwsIGNoaWxkTnVtLCBvcHRpb25zLCBpbmNsdWRlRHJhZ0VsKSB7XG4gIHZhciBjdXJyZW50Q2hpbGQgPSAwLFxuICAgICAgaSA9IDAsXG4gICAgICBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuXG4gIHdoaWxlIChpIDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJyAmJiBjaGlsZHJlbltpXSAhPT0gU29ydGFibGUuZ2hvc3QgJiYgKGluY2x1ZGVEcmFnRWwgfHwgY2hpbGRyZW5baV0gIT09IFNvcnRhYmxlLmRyYWdnZWQpICYmIGNsb3Nlc3QoY2hpbGRyZW5baV0sIG9wdGlvbnMuZHJhZ2dhYmxlLCBlbCwgZmFsc2UpKSB7XG4gICAgICBpZiAoY3VycmVudENoaWxkID09PSBjaGlsZE51bSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5baV07XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRDaGlsZCsrO1xuICAgIH1cblxuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGNoaWxkIGluIHRoZSBlbCwgaWdub3JpbmcgZ2hvc3RFbCBvciBpbnZpc2libGUgZWxlbWVudHMgKGNsb25lcylcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICAgICBQYXJlbnQgZWxlbWVudFxuICogQHBhcmFtICB7c2VsZWN0b3J9IHNlbGVjdG9yICAgIEFueSBvdGhlciBlbGVtZW50cyB0aGF0IHNob3VsZCBiZSBpZ25vcmVkXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gICAgICAgICAgVGhlIGxhc3QgY2hpbGQsIGlnbm9yaW5nIGdob3N0RWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGxhc3RDaGlsZChlbCwgc2VsZWN0b3IpIHtcbiAgdmFyIGxhc3QgPSBlbC5sYXN0RWxlbWVudENoaWxkO1xuXG4gIHdoaWxlIChsYXN0ICYmIChsYXN0ID09PSBTb3J0YWJsZS5naG9zdCB8fCBjc3MobGFzdCwgJ2Rpc3BsYXknKSA9PT0gJ25vbmUnIHx8IHNlbGVjdG9yICYmICFtYXRjaGVzKGxhc3QsIHNlbGVjdG9yKSkpIHtcbiAgICBsYXN0ID0gbGFzdC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIGxhc3QgfHwgbnVsbDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgaW5kZXggb2YgYW4gZWxlbWVudCB3aXRoaW4gaXRzIHBhcmVudCBmb3IgYSBzZWxlY3RlZCBzZXQgb2ZcbiAqIGVsZW1lbnRzXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWxcbiAqIEBwYXJhbSAge3NlbGVjdG9yfSBzZWxlY3RvclxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gaW5kZXgoZWwsIHNlbGVjdG9yKSB7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgaWYgKCFlbCB8fCAhZWwucGFyZW50Tm9kZSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cblxuICB3aGlsZSAoZWwgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XG4gICAgaWYgKGVsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdURU1QTEFURScgJiYgZWwgIT09IFNvcnRhYmxlLmNsb25lICYmICghc2VsZWN0b3IgfHwgbWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSkge1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHNjcm9sbCBvZmZzZXQgb2YgdGhlIGdpdmVuIGVsZW1lbnQsIGFkZGVkIHdpdGggYWxsIHRoZSBzY3JvbGwgb2Zmc2V0cyBvZiBwYXJlbnQgZWxlbWVudHMuXG4gKiBUaGUgdmFsdWUgaXMgcmV0dXJuZWQgaW4gcmVhbCBwaXhlbHMuXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICBPZmZzZXRzIGluIHRoZSBmb3JtYXQgb2YgW2xlZnQsIHRvcF1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFJlbGF0aXZlU2Nyb2xsT2Zmc2V0KGVsKSB7XG4gIHZhciBvZmZzZXRMZWZ0ID0gMCxcbiAgICAgIG9mZnNldFRvcCA9IDAsXG4gICAgICB3aW5TY3JvbGxlciA9IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcblxuICBpZiAoZWwpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgZWxNYXRyaXggPSBtYXRyaXgoZWwpLFxuICAgICAgICAgIHNjYWxlWCA9IGVsTWF0cml4LmEsXG4gICAgICAgICAgc2NhbGVZID0gZWxNYXRyaXguZDtcbiAgICAgIG9mZnNldExlZnQgKz0gZWwuc2Nyb2xsTGVmdCAqIHNjYWxlWDtcbiAgICAgIG9mZnNldFRvcCArPSBlbC5zY3JvbGxUb3AgKiBzY2FsZVk7XG4gICAgfSB3aGlsZSAoZWwgIT09IHdpblNjcm9sbGVyICYmIChlbCA9IGVsLnBhcmVudE5vZGUpKTtcbiAgfVxuXG4gIHJldHVybiBbb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wXTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG9iamVjdCB3aXRoaW4gdGhlIGdpdmVuIGFycmF5XG4gKiBAcGFyYW0gIHtBcnJheX0gYXJyICAgQXJyYXkgdGhhdCBtYXkgb3IgbWF5IG5vdCBob2xkIHRoZSBvYmplY3RcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqICBBbiBvYmplY3QgdGhhdCBoYXMgYSBrZXktdmFsdWUgcGFpciB1bmlxdWUgdG8gYW5kIGlkZW50aWNhbCB0byBhIGtleS12YWx1ZSBwYWlyIGluIHRoZSBvYmplY3QgeW91IHdhbnQgdG8gZmluZFxuICogQHJldHVybiB7TnVtYmVyfSAgICAgIFRoZSBpbmRleCBvZiB0aGUgb2JqZWN0IGluIHRoZSBhcnJheSwgb3IgLTFcbiAqL1xuXG5cbmZ1bmN0aW9uIGluZGV4T2ZPYmplY3QoYXJyLCBvYmopIHtcbiAgZm9yICh2YXIgaSBpbiBhcnIpIHtcbiAgICBpZiAoIWFyci5oYXNPd25Qcm9wZXJ0eShpKSkgY29udGludWU7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkgJiYgb2JqW2tleV0gPT09IGFycltpXVtrZXldKSByZXR1cm4gTnVtYmVyKGkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWwsIGluY2x1ZGVTZWxmKSB7XG4gIC8vIHNraXAgdG8gd2luZG93XG4gIGlmICghZWwgfHwgIWVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkgcmV0dXJuIGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgdmFyIGVsZW0gPSBlbDtcbiAgdmFyIGdvdFNlbGYgPSBmYWxzZTtcblxuICBkbyB7XG4gICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBnZXQgZWxlbSBjc3MgaWYgaXQgaXNuJ3QgZXZlbiBvdmVyZmxvd2luZyBpbiB0aGUgZmlyc3QgcGxhY2UgKHBlcmZvcm1hbmNlKVxuICAgIGlmIChlbGVtLmNsaWVudFdpZHRoIDwgZWxlbS5zY3JvbGxXaWR0aCB8fCBlbGVtLmNsaWVudEhlaWdodCA8IGVsZW0uc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICB2YXIgZWxlbUNTUyA9IGNzcyhlbGVtKTtcblxuICAgICAgaWYgKGVsZW0uY2xpZW50V2lkdGggPCBlbGVtLnNjcm9sbFdpZHRoICYmIChlbGVtQ1NTLm92ZXJmbG93WCA9PSAnYXV0bycgfHwgZWxlbUNTUy5vdmVyZmxvd1ggPT0gJ3Njcm9sbCcpIHx8IGVsZW0uY2xpZW50SGVpZ2h0IDwgZWxlbS5zY3JvbGxIZWlnaHQgJiYgKGVsZW1DU1Mub3ZlcmZsb3dZID09ICdhdXRvJyB8fCBlbGVtQ1NTLm92ZXJmbG93WSA9PSAnc2Nyb2xsJykpIHtcbiAgICAgICAgaWYgKCFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCB8fCBlbGVtID09PSBkb2N1bWVudC5ib2R5KSByZXR1cm4gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgICAgICBpZiAoZ290U2VsZiB8fCBpbmNsdWRlU2VsZikgcmV0dXJuIGVsZW07XG4gICAgICAgIGdvdFNlbGYgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cbiAgfSB3aGlsZSAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSk7XG5cbiAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKGRzdCwgc3JjKSB7XG4gIGlmIChkc3QgJiYgc3JjKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgICAgaWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGRzdFtrZXldID0gc3JjW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuZnVuY3Rpb24gaXNSZWN0RXF1YWwocmVjdDEsIHJlY3QyKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHJlY3QxLnRvcCkgPT09IE1hdGgucm91bmQocmVjdDIudG9wKSAmJiBNYXRoLnJvdW5kKHJlY3QxLmxlZnQpID09PSBNYXRoLnJvdW5kKHJlY3QyLmxlZnQpICYmIE1hdGgucm91bmQocmVjdDEuaGVpZ2h0KSA9PT0gTWF0aC5yb3VuZChyZWN0Mi5oZWlnaHQpICYmIE1hdGgucm91bmQocmVjdDEud2lkdGgpID09PSBNYXRoLnJvdW5kKHJlY3QyLndpZHRoKTtcbn1cblxudmFyIF90aHJvdHRsZVRpbWVvdXQ7XG5cbmZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrLCBtcykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghX3Rocm90dGxlVGltZW91dCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChfdGhpcywgYXJnc1swXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjay5hcHBseShfdGhpcywgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIF90aHJvdHRsZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3Rocm90dGxlVGltZW91dCA9IHZvaWQgMDtcbiAgICAgIH0sIG1zKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhbmNlbFRocm90dGxlKCkge1xuICBjbGVhclRpbWVvdXQoX3Rocm90dGxlVGltZW91dCk7XG4gIF90aHJvdHRsZVRpbWVvdXQgPSB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIHNjcm9sbEJ5KGVsLCB4LCB5KSB7XG4gIGVsLnNjcm9sbExlZnQgKz0geDtcbiAgZWwuc2Nyb2xsVG9wICs9IHk7XG59XG5cbmZ1bmN0aW9uIGNsb25lKGVsKSB7XG4gIHZhciBQb2x5bWVyID0gd2luZG93LlBvbHltZXI7XG4gIHZhciAkID0gd2luZG93LmpRdWVyeSB8fCB3aW5kb3cuWmVwdG87XG5cbiAgaWYgKFBvbHltZXIgJiYgUG9seW1lci5kb20pIHtcbiAgICByZXR1cm4gUG9seW1lci5kb20oZWwpLmNsb25lTm9kZSh0cnVlKTtcbiAgfSBlbHNlIGlmICgkKSB7XG4gICAgcmV0dXJuICQoZWwpLmNsb25lKHRydWUpWzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbC5jbG9uZU5vZGUodHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0UmVjdChlbCwgcmVjdCkge1xuICBjc3MoZWwsICdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xuICBjc3MoZWwsICd0b3AnLCByZWN0LnRvcCk7XG4gIGNzcyhlbCwgJ2xlZnQnLCByZWN0LmxlZnQpO1xuICBjc3MoZWwsICd3aWR0aCcsIHJlY3Qud2lkdGgpO1xuICBjc3MoZWwsICdoZWlnaHQnLCByZWN0LmhlaWdodCk7XG59XG5cbmZ1bmN0aW9uIHVuc2V0UmVjdChlbCkge1xuICBjc3MoZWwsICdwb3NpdGlvbicsICcnKTtcbiAgY3NzKGVsLCAndG9wJywgJycpO1xuICBjc3MoZWwsICdsZWZ0JywgJycpO1xuICBjc3MoZWwsICd3aWR0aCcsICcnKTtcbiAgY3NzKGVsLCAnaGVpZ2h0JywgJycpO1xufVxuXG52YXIgZXhwYW5kbyA9ICdTb3J0YWJsZScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuZnVuY3Rpb24gQW5pbWF0aW9uU3RhdGVNYW5hZ2VyKCkge1xuICB2YXIgYW5pbWF0aW9uU3RhdGVzID0gW10sXG4gICAgICBhbmltYXRpb25DYWxsYmFja0lkO1xuICByZXR1cm4ge1xuICAgIGNhcHR1cmVBbmltYXRpb25TdGF0ZTogZnVuY3Rpb24gY2FwdHVyZUFuaW1hdGlvblN0YXRlKCkge1xuICAgICAgYW5pbWF0aW9uU3RhdGVzID0gW107XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbmltYXRpb24pIHJldHVybjtcbiAgICAgIHZhciBjaGlsZHJlbiA9IFtdLnNsaWNlLmNhbGwodGhpcy5lbC5jaGlsZHJlbik7XG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoY3NzKGNoaWxkLCAnZGlzcGxheScpID09PSAnbm9uZScgfHwgY2hpbGQgPT09IFNvcnRhYmxlLmdob3N0KSByZXR1cm47XG4gICAgICAgIGFuaW1hdGlvblN0YXRlcy5wdXNoKHtcbiAgICAgICAgICB0YXJnZXQ6IGNoaWxkLFxuICAgICAgICAgIHJlY3Q6IGdldFJlY3QoY2hpbGQpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBmcm9tUmVjdCA9IF9vYmplY3RTcHJlYWQyKHt9LCBhbmltYXRpb25TdGF0ZXNbYW5pbWF0aW9uU3RhdGVzLmxlbmd0aCAtIDFdLnJlY3QpOyAvLyBJZiBhbmltYXRpbmc6IGNvbXBlbnNhdGUgZm9yIGN1cnJlbnQgYW5pbWF0aW9uXG5cblxuICAgICAgICBpZiAoY2hpbGQudGhpc0FuaW1hdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgdmFyIGNoaWxkTWF0cml4ID0gbWF0cml4KGNoaWxkLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChjaGlsZE1hdHJpeCkge1xuICAgICAgICAgICAgZnJvbVJlY3QudG9wIC09IGNoaWxkTWF0cml4LmY7XG4gICAgICAgICAgICBmcm9tUmVjdC5sZWZ0IC09IGNoaWxkTWF0cml4LmU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQuZnJvbVJlY3QgPSBmcm9tUmVjdDtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYWRkQW5pbWF0aW9uU3RhdGU6IGZ1bmN0aW9uIGFkZEFuaW1hdGlvblN0YXRlKHN0YXRlKSB7XG4gICAgICBhbmltYXRpb25TdGF0ZXMucHVzaChzdGF0ZSk7XG4gICAgfSxcbiAgICByZW1vdmVBbmltYXRpb25TdGF0ZTogZnVuY3Rpb24gcmVtb3ZlQW5pbWF0aW9uU3RhdGUodGFyZ2V0KSB7XG4gICAgICBhbmltYXRpb25TdGF0ZXMuc3BsaWNlKGluZGV4T2ZPYmplY3QoYW5pbWF0aW9uU3RhdGVzLCB7XG4gICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICB9KSwgMSk7XG4gICAgfSxcbiAgICBhbmltYXRlQWxsOiBmdW5jdGlvbiBhbmltYXRlQWxsKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvbkNhbGxiYWNrSWQpO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBhbmltYXRpbmcgPSBmYWxzZSxcbiAgICAgICAgICBhbmltYXRpb25UaW1lID0gMDtcbiAgICAgIGFuaW1hdGlvblN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgdGltZSA9IDAsXG4gICAgICAgICAgICB0YXJnZXQgPSBzdGF0ZS50YXJnZXQsXG4gICAgICAgICAgICBmcm9tUmVjdCA9IHRhcmdldC5mcm9tUmVjdCxcbiAgICAgICAgICAgIHRvUmVjdCA9IGdldFJlY3QodGFyZ2V0KSxcbiAgICAgICAgICAgIHByZXZGcm9tUmVjdCA9IHRhcmdldC5wcmV2RnJvbVJlY3QsXG4gICAgICAgICAgICBwcmV2VG9SZWN0ID0gdGFyZ2V0LnByZXZUb1JlY3QsXG4gICAgICAgICAgICBhbmltYXRpbmdSZWN0ID0gc3RhdGUucmVjdCxcbiAgICAgICAgICAgIHRhcmdldE1hdHJpeCA9IG1hdHJpeCh0YXJnZXQsIHRydWUpO1xuXG4gICAgICAgIGlmICh0YXJnZXRNYXRyaXgpIHtcbiAgICAgICAgICAvLyBDb21wZW5zYXRlIGZvciBjdXJyZW50IGFuaW1hdGlvblxuICAgICAgICAgIHRvUmVjdC50b3AgLT0gdGFyZ2V0TWF0cml4LmY7XG4gICAgICAgICAgdG9SZWN0LmxlZnQgLT0gdGFyZ2V0TWF0cml4LmU7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQudG9SZWN0ID0gdG9SZWN0O1xuXG4gICAgICAgIGlmICh0YXJnZXQudGhpc0FuaW1hdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgLy8gQ291bGQgYWxzbyBjaGVjayBpZiBhbmltYXRpbmdSZWN0IGlzIGJldHdlZW4gZnJvbVJlY3QgYW5kIHRvUmVjdFxuICAgICAgICAgIGlmIChpc1JlY3RFcXVhbChwcmV2RnJvbVJlY3QsIHRvUmVjdCkgJiYgIWlzUmVjdEVxdWFsKGZyb21SZWN0LCB0b1JlY3QpICYmIC8vIE1ha2Ugc3VyZSBhbmltYXRpbmdSZWN0IGlzIG9uIGxpbmUgYmV0d2VlbiB0b1JlY3QgJiBmcm9tUmVjdFxuICAgICAgICAgIChhbmltYXRpbmdSZWN0LnRvcCAtIHRvUmVjdC50b3ApIC8gKGFuaW1hdGluZ1JlY3QubGVmdCAtIHRvUmVjdC5sZWZ0KSA9PT0gKGZyb21SZWN0LnRvcCAtIHRvUmVjdC50b3ApIC8gKGZyb21SZWN0LmxlZnQgLSB0b1JlY3QubGVmdCkpIHtcbiAgICAgICAgICAgIC8vIElmIHJldHVybmluZyB0byBzYW1lIHBsYWNlIGFzIHN0YXJ0ZWQgZnJvbSBhbmltYXRpb24gYW5kIG9uIHNhbWUgYXhpc1xuICAgICAgICAgICAgdGltZSA9IGNhbGN1bGF0ZVJlYWxUaW1lKGFuaW1hdGluZ1JlY3QsIHByZXZGcm9tUmVjdCwgcHJldlRvUmVjdCwgX3RoaXMub3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGlmIGZyb21SZWN0ICE9IHRvUmVjdDogYW5pbWF0ZVxuXG5cbiAgICAgICAgaWYgKCFpc1JlY3RFcXVhbCh0b1JlY3QsIGZyb21SZWN0KSkge1xuICAgICAgICAgIHRhcmdldC5wcmV2RnJvbVJlY3QgPSBmcm9tUmVjdDtcbiAgICAgICAgICB0YXJnZXQucHJldlRvUmVjdCA9IHRvUmVjdDtcblxuICAgICAgICAgIGlmICghdGltZSkge1xuICAgICAgICAgICAgdGltZSA9IF90aGlzLm9wdGlvbnMuYW5pbWF0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLmFuaW1hdGUodGFyZ2V0LCBhbmltYXRpbmdSZWN0LCB0b1JlY3QsIHRpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICBhbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIGFuaW1hdGlvblRpbWUgPSBNYXRoLm1heChhbmltYXRpb25UaW1lLCB0aW1lKTtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGFyZ2V0LmFuaW1hdGlvblJlc2V0VGltZXIpO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRpb25SZXNldFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0YXJnZXQuYW5pbWF0aW9uVGltZSA9IDA7XG4gICAgICAgICAgICB0YXJnZXQucHJldkZyb21SZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRhcmdldC5mcm9tUmVjdCA9IG51bGw7XG4gICAgICAgICAgICB0YXJnZXQucHJldlRvUmVjdCA9IG51bGw7XG4gICAgICAgICAgICB0YXJnZXQudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgICB9LCB0aW1lKTtcbiAgICAgICAgICB0YXJnZXQudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gdGltZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjbGVhclRpbWVvdXQoYW5pbWF0aW9uQ2FsbGJhY2tJZCk7XG5cbiAgICAgIGlmICghYW5pbWF0aW5nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmltYXRpb25DYWxsYmFja0lkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcbiAgICAgICAgfSwgYW5pbWF0aW9uVGltZSk7XG4gICAgICB9XG5cbiAgICAgIGFuaW1hdGlvblN0YXRlcyA9IFtdO1xuICAgIH0sXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24gYW5pbWF0ZSh0YXJnZXQsIGN1cnJlbnRSZWN0LCB0b1JlY3QsIGR1cmF0aW9uKSB7XG4gICAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgICAgIHZhciBlbE1hdHJpeCA9IG1hdHJpeCh0aGlzLmVsKSxcbiAgICAgICAgICAgIHNjYWxlWCA9IGVsTWF0cml4ICYmIGVsTWF0cml4LmEsXG4gICAgICAgICAgICBzY2FsZVkgPSBlbE1hdHJpeCAmJiBlbE1hdHJpeC5kLFxuICAgICAgICAgICAgdHJhbnNsYXRlWCA9IChjdXJyZW50UmVjdC5sZWZ0IC0gdG9SZWN0LmxlZnQpIC8gKHNjYWxlWCB8fCAxKSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVkgPSAoY3VycmVudFJlY3QudG9wIC0gdG9SZWN0LnRvcCkgLyAoc2NhbGVZIHx8IDEpO1xuICAgICAgICB0YXJnZXQuYW5pbWF0aW5nWCA9ICEhdHJhbnNsYXRlWDtcbiAgICAgICAgdGFyZ2V0LmFuaW1hdGluZ1kgPSAhIXRyYW5zbGF0ZVk7XG4gICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlM2QoJyArIHRyYW5zbGF0ZVggKyAncHgsJyArIHRyYW5zbGF0ZVkgKyAncHgsMCknKTtcbiAgICAgICAgdGhpcy5mb3JSZXBhaW50RHVtbXkgPSByZXBhaW50KHRhcmdldCk7IC8vIHJlcGFpbnRcblxuICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNpdGlvbicsICd0cmFuc2Zvcm0gJyArIGR1cmF0aW9uICsgJ21zJyArICh0aGlzLm9wdGlvbnMuZWFzaW5nID8gJyAnICsgdGhpcy5vcHRpb25zLmVhc2luZyA6ICcnKSk7XG4gICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlM2QoMCwwLDApJyk7XG4gICAgICAgIHR5cGVvZiB0YXJnZXQuYW5pbWF0ZWQgPT09ICdudW1iZXInICYmIGNsZWFyVGltZW91dCh0YXJnZXQuYW5pbWF0ZWQpO1xuICAgICAgICB0YXJnZXQuYW5pbWF0ZWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNpdGlvbicsICcnKTtcbiAgICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJycpO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRlZCA9IGZhbHNlO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRpbmdYID0gZmFsc2U7XG4gICAgICAgICAgdGFyZ2V0LmFuaW1hdGluZ1kgPSBmYWxzZTtcbiAgICAgICAgfSwgZHVyYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVwYWludCh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldC5vZmZzZXRXaWR0aDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUmVhbFRpbWUoYW5pbWF0aW5nUmVjdCwgZnJvbVJlY3QsIHRvUmVjdCwgb3B0aW9ucykge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGZyb21SZWN0LnRvcCAtIGFuaW1hdGluZ1JlY3QudG9wLCAyKSArIE1hdGgucG93KGZyb21SZWN0LmxlZnQgLSBhbmltYXRpbmdSZWN0LmxlZnQsIDIpKSAvIE1hdGguc3FydChNYXRoLnBvdyhmcm9tUmVjdC50b3AgLSB0b1JlY3QudG9wLCAyKSArIE1hdGgucG93KGZyb21SZWN0LmxlZnQgLSB0b1JlY3QubGVmdCwgMikpICogb3B0aW9ucy5hbmltYXRpb247XG59XG5cbnZhciBwbHVnaW5zID0gW107XG52YXIgZGVmYXVsdHMgPSB7XG4gIGluaXRpYWxpemVCeURlZmF1bHQ6IHRydWVcbn07XG52YXIgUGx1Z2luTWFuYWdlciA9IHtcbiAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KHBsdWdpbikge1xuICAgIC8vIFNldCBkZWZhdWx0IHN0YXRpYyBwcm9wZXJ0aWVzXG4gICAgZm9yICh2YXIgb3B0aW9uIGluIGRlZmF1bHRzKSB7XG4gICAgICBpZiAoZGVmYXVsdHMuaGFzT3duUHJvcGVydHkob3B0aW9uKSAmJiAhKG9wdGlvbiBpbiBwbHVnaW4pKSB7XG4gICAgICAgIHBsdWdpbltvcHRpb25dID0gZGVmYXVsdHNbb3B0aW9uXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgIGlmIChwLnBsdWdpbk5hbWUgPT09IHBsdWdpbi5wbHVnaW5OYW1lKSB7XG4gICAgICAgIHRocm93IFwiU29ydGFibGU6IENhbm5vdCBtb3VudCBwbHVnaW4gXCIuY29uY2F0KHBsdWdpbi5wbHVnaW5OYW1lLCBcIiBtb3JlIHRoYW4gb25jZVwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgfSxcbiAgcGx1Z2luRXZlbnQ6IGZ1bmN0aW9uIHBsdWdpbkV2ZW50KGV2ZW50TmFtZSwgc29ydGFibGUsIGV2dCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmV2ZW50Q2FuY2VsZWQgPSBmYWxzZTtcblxuICAgIGV2dC5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5ldmVudENhbmNlbGVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGV2ZW50TmFtZUdsb2JhbCA9IGV2ZW50TmFtZSArICdHbG9iYWwnO1xuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICBpZiAoIXNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXSkgcmV0dXJuOyAvLyBGaXJlIGdsb2JhbCBldmVudHMgaWYgaXQgZXhpc3RzIGluIHRoaXMgc29ydGFibGVcblxuICAgICAgaWYgKHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVHbG9iYWxdKSB7XG4gICAgICAgIHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVHbG9iYWxdKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGVcbiAgICAgICAgfSwgZXZ0KSk7XG4gICAgICB9IC8vIE9ubHkgZmlyZSBwbHVnaW4gZXZlbnQgaWYgcGx1Z2luIGlzIGVuYWJsZWQgaW4gdGhpcyBzb3J0YWJsZSxcbiAgICAgIC8vIGFuZCBwbHVnaW4gaGFzIGV2ZW50IGRlZmluZWRcblxuXG4gICAgICBpZiAoc29ydGFibGUub3B0aW9uc1twbHVnaW4ucGx1Z2luTmFtZV0gJiYgc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdW2V2ZW50TmFtZV0oX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZVxuICAgICAgICB9LCBldnQpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgaW5pdGlhbGl6ZVBsdWdpbnM6IGZ1bmN0aW9uIGluaXRpYWxpemVQbHVnaW5zKHNvcnRhYmxlLCBlbCwgZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgdmFyIHBsdWdpbk5hbWUgPSBwbHVnaW4ucGx1Z2luTmFtZTtcbiAgICAgIGlmICghc29ydGFibGUub3B0aW9uc1twbHVnaW5OYW1lXSAmJiAhcGx1Z2luLmluaXRpYWxpemVCeURlZmF1bHQpIHJldHVybjtcbiAgICAgIHZhciBpbml0aWFsaXplZCA9IG5ldyBwbHVnaW4oc29ydGFibGUsIGVsLCBzb3J0YWJsZS5vcHRpb25zKTtcbiAgICAgIGluaXRpYWxpemVkLnNvcnRhYmxlID0gc29ydGFibGU7XG4gICAgICBpbml0aWFsaXplZC5vcHRpb25zID0gc29ydGFibGUub3B0aW9ucztcbiAgICAgIHNvcnRhYmxlW3BsdWdpbk5hbWVdID0gaW5pdGlhbGl6ZWQ7IC8vIEFkZCBkZWZhdWx0IG9wdGlvbnMgZnJvbSBwbHVnaW5cblxuICAgICAgX2V4dGVuZHMoZGVmYXVsdHMsIGluaXRpYWxpemVkLmRlZmF1bHRzKTtcbiAgICB9KTtcblxuICAgIGZvciAodmFyIG9wdGlvbiBpbiBzb3J0YWJsZS5vcHRpb25zKSB7XG4gICAgICBpZiAoIXNvcnRhYmxlLm9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkgY29udGludWU7XG4gICAgICB2YXIgbW9kaWZpZWQgPSB0aGlzLm1vZGlmeU9wdGlvbihzb3J0YWJsZSwgb3B0aW9uLCBzb3J0YWJsZS5vcHRpb25zW29wdGlvbl0pO1xuXG4gICAgICBpZiAodHlwZW9mIG1vZGlmaWVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzb3J0YWJsZS5vcHRpb25zW29wdGlvbl0gPSBtb2RpZmllZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGdldEV2ZW50UHJvcGVydGllczogZnVuY3Rpb24gZ2V0RXZlbnRQcm9wZXJ0aWVzKG5hbWUsIHNvcnRhYmxlKSB7XG4gICAgdmFyIGV2ZW50UHJvcGVydGllcyA9IHt9O1xuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbi5ldmVudFByb3BlcnRpZXMgIT09ICdmdW5jdGlvbicpIHJldHVybjtcblxuICAgICAgX2V4dGVuZHMoZXZlbnRQcm9wZXJ0aWVzLCBwbHVnaW4uZXZlbnRQcm9wZXJ0aWVzLmNhbGwoc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdLCBuYW1lKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGV2ZW50UHJvcGVydGllcztcbiAgfSxcbiAgbW9kaWZ5T3B0aW9uOiBmdW5jdGlvbiBtb2RpZnlPcHRpb24oc29ydGFibGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIG1vZGlmaWVkVmFsdWU7XG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIC8vIFBsdWdpbiBtdXN0IGV4aXN0IG9uIHRoZSBTb3J0YWJsZVxuICAgICAgaWYgKCFzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV0pIHJldHVybjsgLy8gSWYgc3RhdGljIG9wdGlvbiBsaXN0ZW5lciBleGlzdHMgZm9yIHRoaXMgb3B0aW9uLCBjYWxsIGluIHRoZSBjb250ZXh0IG9mIHRoZSBTb3J0YWJsZSdzIGluc3RhbmNlIG9mIHRoaXMgcGx1Z2luXG5cbiAgICAgIGlmIChwbHVnaW4ub3B0aW9uTGlzdGVuZXJzICYmIHR5cGVvZiBwbHVnaW4ub3B0aW9uTGlzdGVuZXJzW25hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1vZGlmaWVkVmFsdWUgPSBwbHVnaW4ub3B0aW9uTGlzdGVuZXJzW25hbWVdLmNhbGwoc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1vZGlmaWVkVmFsdWU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoX3JlZikge1xuICB2YXIgc29ydGFibGUgPSBfcmVmLnNvcnRhYmxlLFxuICAgICAgcm9vdEVsID0gX3JlZi5yb290RWwsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgdGFyZ2V0RWwgPSBfcmVmLnRhcmdldEVsLFxuICAgICAgY2xvbmVFbCA9IF9yZWYuY2xvbmVFbCxcbiAgICAgIHRvRWwgPSBfcmVmLnRvRWwsXG4gICAgICBmcm9tRWwgPSBfcmVmLmZyb21FbCxcbiAgICAgIG9sZEluZGV4ID0gX3JlZi5vbGRJbmRleCxcbiAgICAgIG5ld0luZGV4ID0gX3JlZi5uZXdJbmRleCxcbiAgICAgIG9sZERyYWdnYWJsZUluZGV4ID0gX3JlZi5vbGREcmFnZ2FibGVJbmRleCxcbiAgICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gX3JlZi5uZXdEcmFnZ2FibGVJbmRleCxcbiAgICAgIG9yaWdpbmFsRXZlbnQgPSBfcmVmLm9yaWdpbmFsRXZlbnQsXG4gICAgICBwdXRTb3J0YWJsZSA9IF9yZWYucHV0U29ydGFibGUsXG4gICAgICBleHRyYUV2ZW50UHJvcGVydGllcyA9IF9yZWYuZXh0cmFFdmVudFByb3BlcnRpZXM7XG4gIHNvcnRhYmxlID0gc29ydGFibGUgfHwgcm9vdEVsICYmIHJvb3RFbFtleHBhbmRvXTtcbiAgaWYgKCFzb3J0YWJsZSkgcmV0dXJuO1xuICB2YXIgZXZ0LFxuICAgICAgb3B0aW9ucyA9IHNvcnRhYmxlLm9wdGlvbnMsXG4gICAgICBvbk5hbWUgPSAnb24nICsgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpOyAvLyBTdXBwb3J0IGZvciBuZXcgQ3VzdG9tRXZlbnQgZmVhdHVyZVxuXG4gIGlmICh3aW5kb3cuQ3VzdG9tRXZlbnQgJiYgIUlFMTFPckxlc3MgJiYgIUVkZ2UpIHtcbiAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQobmFtZSwge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldnQuaW5pdEV2ZW50KG5hbWUsIHRydWUsIHRydWUpO1xuICB9XG5cbiAgZXZ0LnRvID0gdG9FbCB8fCByb290RWw7XG4gIGV2dC5mcm9tID0gZnJvbUVsIHx8IHJvb3RFbDtcbiAgZXZ0Lml0ZW0gPSB0YXJnZXRFbCB8fCByb290RWw7XG4gIGV2dC5jbG9uZSA9IGNsb25lRWw7XG4gIGV2dC5vbGRJbmRleCA9IG9sZEluZGV4O1xuICBldnQubmV3SW5kZXggPSBuZXdJbmRleDtcbiAgZXZ0Lm9sZERyYWdnYWJsZUluZGV4ID0gb2xkRHJhZ2dhYmxlSW5kZXg7XG4gIGV2dC5uZXdEcmFnZ2FibGVJbmRleCA9IG5ld0RyYWdnYWJsZUluZGV4O1xuICBldnQub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gIGV2dC5wdWxsTW9kZSA9IHB1dFNvcnRhYmxlID8gcHV0U29ydGFibGUubGFzdFB1dE1vZGUgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGFsbEV2ZW50UHJvcGVydGllcyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBleHRyYUV2ZW50UHJvcGVydGllcyksIFBsdWdpbk1hbmFnZXIuZ2V0RXZlbnRQcm9wZXJ0aWVzKG5hbWUsIHNvcnRhYmxlKSk7XG5cbiAgZm9yICh2YXIgb3B0aW9uIGluIGFsbEV2ZW50UHJvcGVydGllcykge1xuICAgIGV2dFtvcHRpb25dID0gYWxsRXZlbnRQcm9wZXJ0aWVzW29wdGlvbl07XG4gIH1cblxuICBpZiAocm9vdEVsKSB7XG4gICAgcm9vdEVsLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfVxuXG4gIGlmIChvcHRpb25zW29uTmFtZV0pIHtcbiAgICBvcHRpb25zW29uTmFtZV0uY2FsbChzb3J0YWJsZSwgZXZ0KTtcbiAgfVxufVxuXG52YXIgX2V4Y2x1ZGVkID0gW1wiZXZ0XCJdO1xuXG52YXIgcGx1Z2luRXZlbnQgPSBmdW5jdGlvbiBwbHVnaW5FdmVudChldmVudE5hbWUsIHNvcnRhYmxlKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgIG9yaWdpbmFsRXZlbnQgPSBfcmVmLmV2dCxcbiAgICAgIGRhdGEgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkKTtcblxuICBQbHVnaW5NYW5hZ2VyLnBsdWdpbkV2ZW50LmJpbmQoU29ydGFibGUpKGV2ZW50TmFtZSwgc29ydGFibGUsIF9vYmplY3RTcHJlYWQyKHtcbiAgICBkcmFnRWw6IGRyYWdFbCxcbiAgICBwYXJlbnRFbDogcGFyZW50RWwsXG4gICAgZ2hvc3RFbDogZ2hvc3RFbCxcbiAgICByb290RWw6IHJvb3RFbCxcbiAgICBuZXh0RWw6IG5leHRFbCxcbiAgICBsYXN0RG93bkVsOiBsYXN0RG93bkVsLFxuICAgIGNsb25lRWw6IGNsb25lRWwsXG4gICAgY2xvbmVIaWRkZW46IGNsb25lSGlkZGVuLFxuICAgIGRyYWdTdGFydGVkOiBtb3ZlZCxcbiAgICBwdXRTb3J0YWJsZTogcHV0U29ydGFibGUsXG4gICAgYWN0aXZlU29ydGFibGU6IFNvcnRhYmxlLmFjdGl2ZSxcbiAgICBvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50LFxuICAgIG9sZEluZGV4OiBvbGRJbmRleCxcbiAgICBvbGREcmFnZ2FibGVJbmRleDogb2xkRHJhZ2dhYmxlSW5kZXgsXG4gICAgbmV3SW5kZXg6IG5ld0luZGV4LFxuICAgIG5ld0RyYWdnYWJsZUluZGV4OiBuZXdEcmFnZ2FibGVJbmRleCxcbiAgICBoaWRlR2hvc3RGb3JUYXJnZXQ6IF9oaWRlR2hvc3RGb3JUYXJnZXQsXG4gICAgdW5oaWRlR2hvc3RGb3JUYXJnZXQ6IF91bmhpZGVHaG9zdEZvclRhcmdldCxcbiAgICBjbG9uZU5vd0hpZGRlbjogZnVuY3Rpb24gY2xvbmVOb3dIaWRkZW4oKSB7XG4gICAgICBjbG9uZUhpZGRlbiA9IHRydWU7XG4gICAgfSxcbiAgICBjbG9uZU5vd1Nob3duOiBmdW5jdGlvbiBjbG9uZU5vd1Nob3duKCkge1xuICAgICAgY2xvbmVIaWRkZW4gPSBmYWxzZTtcbiAgICB9LFxuICAgIGRpc3BhdGNoU29ydGFibGVFdmVudDogZnVuY3Rpb24gZGlzcGF0Y2hTb3J0YWJsZUV2ZW50KG5hbWUpIHtcbiAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIGRhdGEpKTtcbn07XG5cbmZ1bmN0aW9uIF9kaXNwYXRjaEV2ZW50KGluZm8pIHtcbiAgZGlzcGF0Y2hFdmVudChfb2JqZWN0U3ByZWFkMih7XG4gICAgcHV0U29ydGFibGU6IHB1dFNvcnRhYmxlLFxuICAgIGNsb25lRWw6IGNsb25lRWwsXG4gICAgdGFyZ2V0RWw6IGRyYWdFbCxcbiAgICByb290RWw6IHJvb3RFbCxcbiAgICBvbGRJbmRleDogb2xkSW5kZXgsXG4gICAgb2xkRHJhZ2dhYmxlSW5kZXg6IG9sZERyYWdnYWJsZUluZGV4LFxuICAgIG5ld0luZGV4OiBuZXdJbmRleCxcbiAgICBuZXdEcmFnZ2FibGVJbmRleDogbmV3RHJhZ2dhYmxlSW5kZXhcbiAgfSwgaW5mbykpO1xufVxuXG52YXIgZHJhZ0VsLFxuICAgIHBhcmVudEVsLFxuICAgIGdob3N0RWwsXG4gICAgcm9vdEVsLFxuICAgIG5leHRFbCxcbiAgICBsYXN0RG93bkVsLFxuICAgIGNsb25lRWwsXG4gICAgY2xvbmVIaWRkZW4sXG4gICAgb2xkSW5kZXgsXG4gICAgbmV3SW5kZXgsXG4gICAgb2xkRHJhZ2dhYmxlSW5kZXgsXG4gICAgbmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgYWN0aXZlR3JvdXAsXG4gICAgcHV0U29ydGFibGUsXG4gICAgYXdhaXRpbmdEcmFnU3RhcnRlZCA9IGZhbHNlLFxuICAgIGlnbm9yZU5leHRDbGljayA9IGZhbHNlLFxuICAgIHNvcnRhYmxlcyA9IFtdLFxuICAgIHRhcEV2dCxcbiAgICB0b3VjaEV2dCxcbiAgICBsYXN0RHgsXG4gICAgbGFzdER5LFxuICAgIHRhcERpc3RhbmNlTGVmdCxcbiAgICB0YXBEaXN0YW5jZVRvcCxcbiAgICBtb3ZlZCxcbiAgICBsYXN0VGFyZ2V0LFxuICAgIGxhc3REaXJlY3Rpb24sXG4gICAgcGFzdEZpcnN0SW52ZXJ0VGhyZXNoID0gZmFsc2UsXG4gICAgaXNDaXJjdW1zdGFudGlhbEludmVydCA9IGZhbHNlLFxuICAgIHRhcmdldE1vdmVEaXN0YW5jZSxcbiAgICAvLyBGb3IgcG9zaXRpb25pbmcgZ2hvc3QgYWJzb2x1dGVseVxuZ2hvc3RSZWxhdGl2ZVBhcmVudCxcbiAgICBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbCA9IFtdLFxuICAgIC8vIChsZWZ0LCB0b3ApXG5fc2lsZW50ID0gZmFsc2UsXG4gICAgc2F2ZWRJbnB1dENoZWNrZWQgPSBbXTtcbi8qKiBAY29uc3QgKi9cblxudmFyIGRvY3VtZW50RXhpc3RzID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyxcbiAgICBQb3NpdGlvbkdob3N0QWJzb2x1dGVseSA9IElPUyxcbiAgICBDU1NGbG9hdFByb3BlcnR5ID0gRWRnZSB8fCBJRTExT3JMZXNzID8gJ2Nzc0Zsb2F0JyA6ICdmbG9hdCcsXG4gICAgLy8gVGhpcyB3aWxsIG5vdCBwYXNzIGZvciBJRTksIGJlY2F1c2UgSUU5IERuRCBvbmx5IHdvcmtzIG9uIGFuY2hvcnNcbnN1cHBvcnREcmFnZ2FibGUgPSBkb2N1bWVudEV4aXN0cyAmJiAhQ2hyb21lRm9yQW5kcm9pZCAmJiAhSU9TICYmICdkcmFnZ2FibGUnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgIHN1cHBvcnRDc3NQb2ludGVyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIWRvY3VtZW50RXhpc3RzKSByZXR1cm47IC8vIGZhbHNlIHdoZW4gPD0gSUUxMVxuXG4gIGlmIChJRTExT3JMZXNzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgneCcpO1xuICBlbC5zdHlsZS5jc3NUZXh0ID0gJ3BvaW50ZXItZXZlbnRzOmF1dG8nO1xuICByZXR1cm4gZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9PT0gJ2F1dG8nO1xufSgpLFxuICAgIF9kZXRlY3REaXJlY3Rpb24gPSBmdW5jdGlvbiBfZGV0ZWN0RGlyZWN0aW9uKGVsLCBvcHRpb25zKSB7XG4gIHZhciBlbENTUyA9IGNzcyhlbCksXG4gICAgICBlbFdpZHRoID0gcGFyc2VJbnQoZWxDU1Mud2lkdGgpIC0gcGFyc2VJbnQoZWxDU1MucGFkZGluZ0xlZnQpIC0gcGFyc2VJbnQoZWxDU1MucGFkZGluZ1JpZ2h0KSAtIHBhcnNlSW50KGVsQ1NTLmJvcmRlckxlZnRXaWR0aCkgLSBwYXJzZUludChlbENTUy5ib3JkZXJSaWdodFdpZHRoKSxcbiAgICAgIGNoaWxkMSA9IGdldENoaWxkKGVsLCAwLCBvcHRpb25zKSxcbiAgICAgIGNoaWxkMiA9IGdldENoaWxkKGVsLCAxLCBvcHRpb25zKSxcbiAgICAgIGZpcnN0Q2hpbGRDU1MgPSBjaGlsZDEgJiYgY3NzKGNoaWxkMSksXG4gICAgICBzZWNvbmRDaGlsZENTUyA9IGNoaWxkMiAmJiBjc3MoY2hpbGQyKSxcbiAgICAgIGZpcnN0Q2hpbGRXaWR0aCA9IGZpcnN0Q2hpbGRDU1MgJiYgcGFyc2VJbnQoZmlyc3RDaGlsZENTUy5tYXJnaW5MZWZ0KSArIHBhcnNlSW50KGZpcnN0Q2hpbGRDU1MubWFyZ2luUmlnaHQpICsgZ2V0UmVjdChjaGlsZDEpLndpZHRoLFxuICAgICAgc2Vjb25kQ2hpbGRXaWR0aCA9IHNlY29uZENoaWxkQ1NTICYmIHBhcnNlSW50KHNlY29uZENoaWxkQ1NTLm1hcmdpbkxlZnQpICsgcGFyc2VJbnQoc2Vjb25kQ2hpbGRDU1MubWFyZ2luUmlnaHQpICsgZ2V0UmVjdChjaGlsZDIpLndpZHRoO1xuXG4gIGlmIChlbENTUy5kaXNwbGF5ID09PSAnZmxleCcpIHtcbiAgICByZXR1cm4gZWxDU1MuZmxleERpcmVjdGlvbiA9PT0gJ2NvbHVtbicgfHwgZWxDU1MuZmxleERpcmVjdGlvbiA9PT0gJ2NvbHVtbi1yZXZlcnNlJyA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gIH1cblxuICBpZiAoZWxDU1MuZGlzcGxheSA9PT0gJ2dyaWQnKSB7XG4gICAgcmV0dXJuIGVsQ1NTLmdyaWRUZW1wbGF0ZUNvbHVtbnMuc3BsaXQoJyAnKS5sZW5ndGggPD0gMSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gIH1cblxuICBpZiAoY2hpbGQxICYmIGZpcnN0Q2hpbGRDU1NbXCJmbG9hdFwiXSAmJiBmaXJzdENoaWxkQ1NTW1wiZmxvYXRcIl0gIT09ICdub25lJykge1xuICAgIHZhciB0b3VjaGluZ1NpZGVDaGlsZDIgPSBmaXJzdENoaWxkQ1NTW1wiZmxvYXRcIl0gPT09ICdsZWZ0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgcmV0dXJuIGNoaWxkMiAmJiAoc2Vjb25kQ2hpbGRDU1MuY2xlYXIgPT09ICdib3RoJyB8fCBzZWNvbmRDaGlsZENTUy5jbGVhciA9PT0gdG91Y2hpbmdTaWRlQ2hpbGQyKSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gIH1cblxuICByZXR1cm4gY2hpbGQxICYmIChmaXJzdENoaWxkQ1NTLmRpc3BsYXkgPT09ICdibG9jaycgfHwgZmlyc3RDaGlsZENTUy5kaXNwbGF5ID09PSAnZmxleCcgfHwgZmlyc3RDaGlsZENTUy5kaXNwbGF5ID09PSAndGFibGUnIHx8IGZpcnN0Q2hpbGRDU1MuZGlzcGxheSA9PT0gJ2dyaWQnIHx8IGZpcnN0Q2hpbGRXaWR0aCA+PSBlbFdpZHRoICYmIGVsQ1NTW0NTU0Zsb2F0UHJvcGVydHldID09PSAnbm9uZScgfHwgY2hpbGQyICYmIGVsQ1NTW0NTU0Zsb2F0UHJvcGVydHldID09PSAnbm9uZScgJiYgZmlyc3RDaGlsZFdpZHRoICsgc2Vjb25kQ2hpbGRXaWR0aCA+IGVsV2lkdGgpID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbn0sXG4gICAgX2RyYWdFbEluUm93Q29sdW1uID0gZnVuY3Rpb24gX2RyYWdFbEluUm93Q29sdW1uKGRyYWdSZWN0LCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCkge1xuICB2YXIgZHJhZ0VsUzFPcHAgPSB2ZXJ0aWNhbCA/IGRyYWdSZWN0LmxlZnQgOiBkcmFnUmVjdC50b3AsXG4gICAgICBkcmFnRWxTMk9wcCA9IHZlcnRpY2FsID8gZHJhZ1JlY3QucmlnaHQgOiBkcmFnUmVjdC5ib3R0b20sXG4gICAgICBkcmFnRWxPcHBMZW5ndGggPSB2ZXJ0aWNhbCA/IGRyYWdSZWN0LndpZHRoIDogZHJhZ1JlY3QuaGVpZ2h0LFxuICAgICAgdGFyZ2V0UzFPcHAgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QubGVmdCA6IHRhcmdldFJlY3QudG9wLFxuICAgICAgdGFyZ2V0UzJPcHAgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QucmlnaHQgOiB0YXJnZXRSZWN0LmJvdHRvbSxcbiAgICAgIHRhcmdldE9wcExlbmd0aCA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC53aWR0aCA6IHRhcmdldFJlY3QuaGVpZ2h0O1xuICByZXR1cm4gZHJhZ0VsUzFPcHAgPT09IHRhcmdldFMxT3BwIHx8IGRyYWdFbFMyT3BwID09PSB0YXJnZXRTMk9wcCB8fCBkcmFnRWxTMU9wcCArIGRyYWdFbE9wcExlbmd0aCAvIDIgPT09IHRhcmdldFMxT3BwICsgdGFyZ2V0T3BwTGVuZ3RoIC8gMjtcbn0sXG5cbi8qKlxuICogRGV0ZWN0cyBmaXJzdCBuZWFyZXN0IGVtcHR5IHNvcnRhYmxlIHRvIFggYW5kIFkgcG9zaXRpb24gdXNpbmcgZW1wdHlJbnNlcnRUaHJlc2hvbGQuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHggICAgICBYIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHkgICAgICBZIHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gICBFbGVtZW50IG9mIHRoZSBmaXJzdCBmb3VuZCBuZWFyZXN0IFNvcnRhYmxlXG4gKi9cbl9kZXRlY3ROZWFyZXN0RW1wdHlTb3J0YWJsZSA9IGZ1bmN0aW9uIF9kZXRlY3ROZWFyZXN0RW1wdHlTb3J0YWJsZSh4LCB5KSB7XG4gIHZhciByZXQ7XG4gIHNvcnRhYmxlcy5zb21lKGZ1bmN0aW9uIChzb3J0YWJsZSkge1xuICAgIHZhciB0aHJlc2hvbGQgPSBzb3J0YWJsZVtleHBhbmRvXS5vcHRpb25zLmVtcHR5SW5zZXJ0VGhyZXNob2xkO1xuICAgIGlmICghdGhyZXNob2xkIHx8IGxhc3RDaGlsZChzb3J0YWJsZSkpIHJldHVybjtcbiAgICB2YXIgcmVjdCA9IGdldFJlY3Qoc29ydGFibGUpLFxuICAgICAgICBpbnNpZGVIb3Jpem9udGFsbHkgPSB4ID49IHJlY3QubGVmdCAtIHRocmVzaG9sZCAmJiB4IDw9IHJlY3QucmlnaHQgKyB0aHJlc2hvbGQsXG4gICAgICAgIGluc2lkZVZlcnRpY2FsbHkgPSB5ID49IHJlY3QudG9wIC0gdGhyZXNob2xkICYmIHkgPD0gcmVjdC5ib3R0b20gKyB0aHJlc2hvbGQ7XG5cbiAgICBpZiAoaW5zaWRlSG9yaXpvbnRhbGx5ICYmIGluc2lkZVZlcnRpY2FsbHkpIHtcbiAgICAgIHJldHVybiByZXQgPSBzb3J0YWJsZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufSxcbiAgICBfcHJlcGFyZUdyb3VwID0gZnVuY3Rpb24gX3ByZXBhcmVHcm91cChvcHRpb25zKSB7XG4gIGZ1bmN0aW9uIHRvRm4odmFsdWUsIHB1bGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRvLCBmcm9tLCBkcmFnRWwsIGV2dCkge1xuICAgICAgdmFyIHNhbWVHcm91cCA9IHRvLm9wdGlvbnMuZ3JvdXAubmFtZSAmJiBmcm9tLm9wdGlvbnMuZ3JvdXAubmFtZSAmJiB0by5vcHRpb25zLmdyb3VwLm5hbWUgPT09IGZyb20ub3B0aW9ucy5ncm91cC5uYW1lO1xuXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiAocHVsbCB8fCBzYW1lR3JvdXApKSB7XG4gICAgICAgIC8vIERlZmF1bHQgcHVsbCB2YWx1ZVxuICAgICAgICAvLyBEZWZhdWx0IHB1bGwgYW5kIHB1dCB2YWx1ZSBpZiBzYW1lIGdyb3VwXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHB1bGwgJiYgdmFsdWUgPT09ICdjbG9uZScpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRvRm4odmFsdWUodG8sIGZyb20sIGRyYWdFbCwgZXZ0KSwgcHVsbCkodG8sIGZyb20sIGRyYWdFbCwgZXZ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvdGhlckdyb3VwID0gKHB1bGwgPyB0byA6IGZyb20pLm9wdGlvbnMuZ3JvdXAubmFtZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUgPT09IG90aGVyR3JvdXAgfHwgdmFsdWUuam9pbiAmJiB2YWx1ZS5pbmRleE9mKG90aGVyR3JvdXApID4gLTE7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBncm91cCA9IHt9O1xuICB2YXIgb3JpZ2luYWxHcm91cCA9IG9wdGlvbnMuZ3JvdXA7XG5cbiAgaWYgKCFvcmlnaW5hbEdyb3VwIHx8IF90eXBlb2Yob3JpZ2luYWxHcm91cCkgIT0gJ29iamVjdCcpIHtcbiAgICBvcmlnaW5hbEdyb3VwID0ge1xuICAgICAgbmFtZTogb3JpZ2luYWxHcm91cFxuICAgIH07XG4gIH1cblxuICBncm91cC5uYW1lID0gb3JpZ2luYWxHcm91cC5uYW1lO1xuICBncm91cC5jaGVja1B1bGwgPSB0b0ZuKG9yaWdpbmFsR3JvdXAucHVsbCwgdHJ1ZSk7XG4gIGdyb3VwLmNoZWNrUHV0ID0gdG9GbihvcmlnaW5hbEdyb3VwLnB1dCk7XG4gIGdyb3VwLnJldmVydENsb25lID0gb3JpZ2luYWxHcm91cC5yZXZlcnRDbG9uZTtcbiAgb3B0aW9ucy5ncm91cCA9IGdyb3VwO1xufSxcbiAgICBfaGlkZUdob3N0Rm9yVGFyZ2V0ID0gZnVuY3Rpb24gX2hpZGVHaG9zdEZvclRhcmdldCgpIHtcbiAgaWYgKCFzdXBwb3J0Q3NzUG9pbnRlckV2ZW50cyAmJiBnaG9zdEVsKSB7XG4gICAgY3NzKGdob3N0RWwsICdkaXNwbGF5JywgJ25vbmUnKTtcbiAgfVxufSxcbiAgICBfdW5oaWRlR2hvc3RGb3JUYXJnZXQgPSBmdW5jdGlvbiBfdW5oaWRlR2hvc3RGb3JUYXJnZXQoKSB7XG4gIGlmICghc3VwcG9ydENzc1BvaW50ZXJFdmVudHMgJiYgZ2hvc3RFbCkge1xuICAgIGNzcyhnaG9zdEVsLCAnZGlzcGxheScsICcnKTtcbiAgfVxufTsgLy8gIzExODQgZml4IC0gUHJldmVudCBjbGljayBldmVudCBvbiBmYWxsYmFjayBpZiBkcmFnZ2VkIGJ1dCBpdGVtIG5vdCBjaGFuZ2VkIHBvc2l0aW9uXG5cblxuaWYgKGRvY3VtZW50RXhpc3RzKSB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xuICAgIGlmIChpZ25vcmVOZXh0Q2xpY2spIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbiAmJiBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBldnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uICYmIGV2dC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIGlnbm9yZU5leHRDbGljayA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG59XG5cbnZhciBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCA9IGZ1bmN0aW9uIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KGV2dCkge1xuICBpZiAoZHJhZ0VsKSB7XG4gICAgZXZ0ID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dDtcblxuICAgIHZhciBuZWFyZXN0ID0gX2RldGVjdE5lYXJlc3RFbXB0eVNvcnRhYmxlKGV2dC5jbGllbnRYLCBldnQuY2xpZW50WSk7XG5cbiAgICBpZiAobmVhcmVzdCkge1xuICAgICAgLy8gQ3JlYXRlIGltaXRhdGlvbiBldmVudFxuICAgICAgdmFyIGV2ZW50ID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgaW4gZXZ0KSB7XG4gICAgICAgIGlmIChldnQuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICBldmVudFtpXSA9IGV2dFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBldmVudC50YXJnZXQgPSBldmVudC5yb290RWwgPSBuZWFyZXN0O1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQgPSB2b2lkIDA7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24gPSB2b2lkIDA7XG5cbiAgICAgIG5lYXJlc3RbZXhwYW5kb10uX29uRHJhZ092ZXIoZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIF9jaGVja091dHNpZGVUYXJnZXRFbCA9IGZ1bmN0aW9uIF9jaGVja091dHNpZGVUYXJnZXRFbChldnQpIHtcbiAgaWYgKGRyYWdFbCkge1xuICAgIGRyYWdFbC5wYXJlbnROb2RlW2V4cGFuZG9dLl9pc091dHNpZGVUaGlzRWwoZXZ0LnRhcmdldCk7XG4gIH1cbn07XG4vKipcbiAqIEBjbGFzcyAgU29ydGFibGVcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSAgZWxcbiAqIEBwYXJhbSAge09iamVjdH0gICAgICAgW29wdGlvbnNdXG4gKi9cblxuXG5mdW5jdGlvbiBTb3J0YWJsZShlbCwgb3B0aW9ucykge1xuICBpZiAoIShlbCAmJiBlbC5ub2RlVHlwZSAmJiBlbC5ub2RlVHlwZSA9PT0gMSkpIHtcbiAgICB0aHJvdyBcIlNvcnRhYmxlOiBgZWxgIG11c3QgYmUgYW4gSFRNTEVsZW1lbnQsIG5vdCBcIi5jb25jYXQoe30udG9TdHJpbmcuY2FsbChlbCkpO1xuICB9XG5cbiAgdGhpcy5lbCA9IGVsOyAvLyByb290IGVsZW1lbnRcblxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gX2V4dGVuZHMoe30sIG9wdGlvbnMpOyAvLyBFeHBvcnQgaW5zdGFuY2VcblxuICBlbFtleHBhbmRvXSA9IHRoaXM7XG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBncm91cDogbnVsbCxcbiAgICBzb3J0OiB0cnVlLFxuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICBzdG9yZTogbnVsbCxcbiAgICBoYW5kbGU6IG51bGwsXG4gICAgZHJhZ2dhYmxlOiAvXlt1b11sJC9pLnRlc3QoZWwubm9kZU5hbWUpID8gJz5saScgOiAnPionLFxuICAgIHN3YXBUaHJlc2hvbGQ6IDEsXG4gICAgLy8gcGVyY2VudGFnZTsgMCA8PSB4IDw9IDFcbiAgICBpbnZlcnRTd2FwOiBmYWxzZSxcbiAgICAvLyBpbnZlcnQgYWx3YXlzXG4gICAgaW52ZXJ0ZWRTd2FwVGhyZXNob2xkOiBudWxsLFxuICAgIC8vIHdpbGwgYmUgc2V0IHRvIHNhbWUgYXMgc3dhcFRocmVzaG9sZCBpZiBkZWZhdWx0XG4gICAgcmVtb3ZlQ2xvbmVPbkhpZGU6IHRydWUsXG4gICAgZGlyZWN0aW9uOiBmdW5jdGlvbiBkaXJlY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX2RldGVjdERpcmVjdGlvbihlbCwgdGhpcy5vcHRpb25zKTtcbiAgICB9LFxuICAgIGdob3N0Q2xhc3M6ICdzb3J0YWJsZS1naG9zdCcsXG4gICAgY2hvc2VuQ2xhc3M6ICdzb3J0YWJsZS1jaG9zZW4nLFxuICAgIGRyYWdDbGFzczogJ3NvcnRhYmxlLWRyYWcnLFxuICAgIGlnbm9yZTogJ2EsIGltZycsXG4gICAgZmlsdGVyOiBudWxsLFxuICAgIHByZXZlbnRPbkZpbHRlcjogdHJ1ZSxcbiAgICBhbmltYXRpb246IDAsXG4gICAgZWFzaW5nOiBudWxsLFxuICAgIHNldERhdGE6IGZ1bmN0aW9uIHNldERhdGEoZGF0YVRyYW5zZmVyLCBkcmFnRWwpIHtcbiAgICAgIGRhdGFUcmFuc2Zlci5zZXREYXRhKCdUZXh0JywgZHJhZ0VsLnRleHRDb250ZW50KTtcbiAgICB9LFxuICAgIGRyb3BCdWJibGU6IGZhbHNlLFxuICAgIGRyYWdvdmVyQnViYmxlOiBmYWxzZSxcbiAgICBkYXRhSWRBdHRyOiAnZGF0YS1pZCcsXG4gICAgZGVsYXk6IDAsXG4gICAgZGVsYXlPblRvdWNoT25seTogZmFsc2UsXG4gICAgdG91Y2hTdGFydFRocmVzaG9sZDogKE51bWJlci5wYXJzZUludCA/IE51bWJlciA6IHdpbmRvdykucGFyc2VJbnQod2luZG93LmRldmljZVBpeGVsUmF0aW8sIDEwKSB8fCAxLFxuICAgIGZvcmNlRmFsbGJhY2s6IGZhbHNlLFxuICAgIGZhbGxiYWNrQ2xhc3M6ICdzb3J0YWJsZS1mYWxsYmFjaycsXG4gICAgZmFsbGJhY2tPbkJvZHk6IGZhbHNlLFxuICAgIGZhbGxiYWNrVG9sZXJhbmNlOiAwLFxuICAgIGZhbGxiYWNrT2Zmc2V0OiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH0sXG4gICAgc3VwcG9ydFBvaW50ZXI6IFNvcnRhYmxlLnN1cHBvcnRQb2ludGVyICE9PSBmYWxzZSAmJiAnUG9pbnRlckV2ZW50JyBpbiB3aW5kb3cgJiYgIVNhZmFyaSxcbiAgICBlbXB0eUluc2VydFRocmVzaG9sZDogNVxuICB9O1xuICBQbHVnaW5NYW5hZ2VyLmluaXRpYWxpemVQbHVnaW5zKHRoaXMsIGVsLCBkZWZhdWx0cyk7IC8vIFNldCBkZWZhdWx0IG9wdGlvbnNcblxuICBmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRzKSB7XG4gICAgIShuYW1lIGluIG9wdGlvbnMpICYmIChvcHRpb25zW25hbWVdID0gZGVmYXVsdHNbbmFtZV0pO1xuICB9XG5cbiAgX3ByZXBhcmVHcm91cChvcHRpb25zKTsgLy8gQmluZCBhbGwgcHJpdmF0ZSBtZXRob2RzXG5cblxuICBmb3IgKHZhciBmbiBpbiB0aGlzKSB7XG4gICAgaWYgKGZuLmNoYXJBdCgwKSA9PT0gJ18nICYmIHR5cGVvZiB0aGlzW2ZuXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tmbl0gPSB0aGlzW2ZuXS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgfSAvLyBTZXR1cCBkcmFnIG1vZGVcblxuXG4gIHRoaXMubmF0aXZlRHJhZ2dhYmxlID0gb3B0aW9ucy5mb3JjZUZhbGxiYWNrID8gZmFsc2UgOiBzdXBwb3J0RHJhZ2dhYmxlO1xuXG4gIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgIC8vIFRvdWNoIHN0YXJ0IHRocmVzaG9sZCBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIHRoZSBuYXRpdmUgZHJhZ3N0YXJ0IHRocmVzaG9sZFxuICAgIHRoaXMub3B0aW9ucy50b3VjaFN0YXJ0VGhyZXNob2xkID0gMTtcbiAgfSAvLyBCaW5kIGV2ZW50c1xuXG5cbiAgaWYgKG9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcbiAgICBvbihlbCwgJ3BvaW50ZXJkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XG4gIH0gZWxzZSB7XG4gICAgb24oZWwsICdtb3VzZWRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgICBvbihlbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgfVxuXG4gIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgIG9uKGVsLCAnZHJhZ292ZXInLCB0aGlzKTtcbiAgICBvbihlbCwgJ2RyYWdlbnRlcicsIHRoaXMpO1xuICB9XG5cbiAgc29ydGFibGVzLnB1c2godGhpcy5lbCk7IC8vIFJlc3RvcmUgc29ydGluZ1xuXG4gIG9wdGlvbnMuc3RvcmUgJiYgb3B0aW9ucy5zdG9yZS5nZXQgJiYgdGhpcy5zb3J0KG9wdGlvbnMuc3RvcmUuZ2V0KHRoaXMpIHx8IFtdKTsgLy8gQWRkIGFuaW1hdGlvbiBzdGF0ZSBtYW5hZ2VyXG5cbiAgX2V4dGVuZHModGhpcywgQW5pbWF0aW9uU3RhdGVNYW5hZ2VyKCkpO1xufVxuXG5Tb3J0YWJsZS5wcm90b3R5cGUgPVxuLyoqIEBsZW5kcyBTb3J0YWJsZS5wcm90b3R5cGUgKi9cbntcbiAgY29uc3RydWN0b3I6IFNvcnRhYmxlLFxuICBfaXNPdXRzaWRlVGhpc0VsOiBmdW5jdGlvbiBfaXNPdXRzaWRlVGhpc0VsKHRhcmdldCkge1xuICAgIGlmICghdGhpcy5lbC5jb250YWlucyh0YXJnZXQpICYmIHRhcmdldCAhPT0gdGhpcy5lbCkge1xuICAgICAgbGFzdFRhcmdldCA9IG51bGw7XG4gICAgfVxuICB9LFxuICBfZ2V0RGlyZWN0aW9uOiBmdW5jdGlvbiBfZ2V0RGlyZWN0aW9uKGV2dCwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uID09PSAnZnVuY3Rpb24nID8gdGhpcy5vcHRpb25zLmRpcmVjdGlvbi5jYWxsKHRoaXMsIGV2dCwgdGFyZ2V0LCBkcmFnRWwpIDogdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgfSxcbiAgX29uVGFwU3RhcnQ6IGZ1bmN0aW9uIF9vblRhcFN0YXJ0KFxuICAvKiogRXZlbnR8VG91Y2hFdmVudCAqL1xuICBldnQpIHtcbiAgICBpZiAoIWV2dC5jYW5jZWxhYmxlKSByZXR1cm47XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBlbCA9IHRoaXMuZWwsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHByZXZlbnRPbkZpbHRlciA9IG9wdGlvbnMucHJldmVudE9uRmlsdGVyLFxuICAgICAgICB0eXBlID0gZXZ0LnR5cGUsXG4gICAgICAgIHRvdWNoID0gZXZ0LnRvdWNoZXMgJiYgZXZ0LnRvdWNoZXNbMF0gfHwgZXZ0LnBvaW50ZXJUeXBlICYmIGV2dC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyAmJiBldnQsXG4gICAgICAgIHRhcmdldCA9ICh0b3VjaCB8fCBldnQpLnRhcmdldCxcbiAgICAgICAgb3JpZ2luYWxUYXJnZXQgPSBldnQudGFyZ2V0LnNoYWRvd1Jvb3QgJiYgKGV2dC5wYXRoICYmIGV2dC5wYXRoWzBdIHx8IGV2dC5jb21wb3NlZFBhdGggJiYgZXZ0LmNvbXBvc2VkUGF0aCgpWzBdKSB8fCB0YXJnZXQsXG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuXG4gICAgX3NhdmVJbnB1dENoZWNrZWRTdGF0ZShlbCk7IC8vIERvbid0IHRyaWdnZXIgc3RhcnQgZXZlbnQgd2hlbiBhbiBlbGVtZW50IGlzIGJlZW4gZHJhZ2dlZCwgb3RoZXJ3aXNlIHRoZSBldnQub2xkaW5kZXggYWx3YXlzIHdyb25nIHdoZW4gc2V0IG9wdGlvbi5ncm91cC5cblxuXG4gICAgaWYgKGRyYWdFbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICgvbW91c2Vkb3dufHBvaW50ZXJkb3duLy50ZXN0KHR5cGUpICYmIGV2dC5idXR0b24gIT09IDAgfHwgb3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuOyAvLyBvbmx5IGxlZnQgYnV0dG9uIGFuZCBlbmFibGVkXG4gICAgfSAvLyBjYW5jZWwgZG5kIGlmIG9yaWdpbmFsIHRhcmdldCBpcyBjb250ZW50IGVkaXRhYmxlXG5cblxuICAgIGlmIChvcmlnaW5hbFRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gU2FmYXJpIGlnbm9yZXMgZnVydGhlciBldmVudCBoYW5kbGluZyBhZnRlciBtb3VzZWRvd25cblxuXG4gICAgaWYgKCF0aGlzLm5hdGl2ZURyYWdnYWJsZSAmJiBTYWZhcmkgJiYgdGFyZ2V0ICYmIHRhcmdldC50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdTRUxFQ1QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gY2xvc2VzdCh0YXJnZXQsIG9wdGlvbnMuZHJhZ2dhYmxlLCBlbCwgZmFsc2UpO1xuXG4gICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuYW5pbWF0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGFzdERvd25FbCA9PT0gdGFyZ2V0KSB7XG4gICAgICAvLyBJZ25vcmluZyBkdXBsaWNhdGUgYGRvd25gXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkcmFnZ2VkIGVsZW1lbnQgd2l0aGluIGl0cyBwYXJlbnRcblxuXG4gICAgb2xkSW5kZXggPSBpbmRleCh0YXJnZXQpO1xuICAgIG9sZERyYWdnYWJsZUluZGV4ID0gaW5kZXgodGFyZ2V0LCBvcHRpb25zLmRyYWdnYWJsZSk7IC8vIENoZWNrIGZpbHRlclxuXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChmaWx0ZXIuY2FsbCh0aGlzLCBldnQsIHRhcmdldCwgdGhpcykpIHtcbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgICByb290RWw6IG9yaWdpbmFsVGFyZ2V0LFxuICAgICAgICAgIG5hbWU6ICdmaWx0ZXInLFxuICAgICAgICAgIHRhcmdldEVsOiB0YXJnZXQsXG4gICAgICAgICAgdG9FbDogZWwsXG4gICAgICAgICAgZnJvbUVsOiBlbFxuICAgICAgICB9KTtcblxuICAgICAgICBwbHVnaW5FdmVudCgnZmlsdGVyJywgX3RoaXMsIHtcbiAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICB9KTtcbiAgICAgICAgcHJldmVudE9uRmlsdGVyICYmIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47IC8vIGNhbmNlbCBkbmRcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZpbHRlcikge1xuICAgICAgZmlsdGVyID0gZmlsdGVyLnNwbGl0KCcsJykuc29tZShmdW5jdGlvbiAoY3JpdGVyaWEpIHtcbiAgICAgICAgY3JpdGVyaWEgPSBjbG9zZXN0KG9yaWdpbmFsVGFyZ2V0LCBjcml0ZXJpYS50cmltKCksIGVsLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKGNyaXRlcmlhKSB7XG4gICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgc29ydGFibGU6IF90aGlzLFxuICAgICAgICAgICAgcm9vdEVsOiBjcml0ZXJpYSxcbiAgICAgICAgICAgIG5hbWU6ICdmaWx0ZXInLFxuICAgICAgICAgICAgdGFyZ2V0RWw6IHRhcmdldCxcbiAgICAgICAgICAgIGZyb21FbDogZWwsXG4gICAgICAgICAgICB0b0VsOiBlbFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcGx1Z2luRXZlbnQoJ2ZpbHRlcicsIF90aGlzLCB7XG4gICAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICBwcmV2ZW50T25GaWx0ZXIgJiYgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjsgLy8gY2FuY2VsIGRuZFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmhhbmRsZSAmJiAhY2xvc2VzdChvcmlnaW5hbFRhcmdldCwgb3B0aW9ucy5oYW5kbGUsIGVsLCBmYWxzZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFByZXBhcmUgYGRyYWdzdGFydGBcblxuXG4gICAgdGhpcy5fcHJlcGFyZURyYWdTdGFydChldnQsIHRvdWNoLCB0YXJnZXQpO1xuICB9LFxuICBfcHJlcGFyZURyYWdTdGFydDogZnVuY3Rpb24gX3ByZXBhcmVEcmFnU3RhcnQoXG4gIC8qKiBFdmVudCAqL1xuICBldnQsXG4gIC8qKiBUb3VjaCAqL1xuICB0b3VjaCxcbiAgLyoqIEhUTUxFbGVtZW50ICovXG4gIHRhcmdldCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIGVsID0gX3RoaXMuZWwsXG4gICAgICAgIG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zLFxuICAgICAgICBvd25lckRvY3VtZW50ID0gZWwub3duZXJEb2N1bWVudCxcbiAgICAgICAgZHJhZ1N0YXJ0Rm47XG5cbiAgICBpZiAodGFyZ2V0ICYmICFkcmFnRWwgJiYgdGFyZ2V0LnBhcmVudE5vZGUgPT09IGVsKSB7XG4gICAgICB2YXIgZHJhZ1JlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG4gICAgICByb290RWwgPSBlbDtcbiAgICAgIGRyYWdFbCA9IHRhcmdldDtcbiAgICAgIHBhcmVudEVsID0gZHJhZ0VsLnBhcmVudE5vZGU7XG4gICAgICBuZXh0RWwgPSBkcmFnRWwubmV4dFNpYmxpbmc7XG4gICAgICBsYXN0RG93bkVsID0gdGFyZ2V0O1xuICAgICAgYWN0aXZlR3JvdXAgPSBvcHRpb25zLmdyb3VwO1xuICAgICAgU29ydGFibGUuZHJhZ2dlZCA9IGRyYWdFbDtcbiAgICAgIHRhcEV2dCA9IHtcbiAgICAgICAgdGFyZ2V0OiBkcmFnRWwsXG4gICAgICAgIGNsaWVudFg6ICh0b3VjaCB8fCBldnQpLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6ICh0b3VjaCB8fCBldnQpLmNsaWVudFlcbiAgICAgIH07XG4gICAgICB0YXBEaXN0YW5jZUxlZnQgPSB0YXBFdnQuY2xpZW50WCAtIGRyYWdSZWN0LmxlZnQ7XG4gICAgICB0YXBEaXN0YW5jZVRvcCA9IHRhcEV2dC5jbGllbnRZIC0gZHJhZ1JlY3QudG9wO1xuICAgICAgdGhpcy5fbGFzdFggPSAodG91Y2ggfHwgZXZ0KS5jbGllbnRYO1xuICAgICAgdGhpcy5fbGFzdFkgPSAodG91Y2ggfHwgZXZ0KS5jbGllbnRZO1xuICAgICAgZHJhZ0VsLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJ2FsbCc7XG5cbiAgICAgIGRyYWdTdGFydEZuID0gZnVuY3Rpb24gZHJhZ1N0YXJ0Rm4oKSB7XG4gICAgICAgIHBsdWdpbkV2ZW50KCdkZWxheUVuZGVkJywgX3RoaXMsIHtcbiAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgICAgIF90aGlzLl9vbkRyb3AoKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBEZWxheWVkIGRyYWcgaGFzIGJlZW4gdHJpZ2dlcmVkXG4gICAgICAgIC8vIHdlIGNhbiByZS1lbmFibGUgdGhlIGV2ZW50czogdG91Y2htb3ZlL21vdXNlbW92ZVxuXG5cbiAgICAgICAgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cygpO1xuXG4gICAgICAgIGlmICghRmlyZUZveCAmJiBfdGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgICBkcmFnRWwuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgfSAvLyBCaW5kIHRoZSBldmVudHM6IGRyYWdzdGFydC9kcmFnZW5kXG5cblxuICAgICAgICBfdGhpcy5fdHJpZ2dlckRyYWdTdGFydChldnQsIHRvdWNoKTsgLy8gRHJhZyBzdGFydCBldmVudFxuXG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgICBuYW1lOiAnY2hvb3NlJyxcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgfSk7IC8vIENob3NlbiBpdGVtXG5cblxuICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuY2hvc2VuQ2xhc3MsIHRydWUpO1xuICAgICAgfTsgLy8gRGlzYWJsZSBcImRyYWdnYWJsZVwiXG5cblxuICAgICAgb3B0aW9ucy5pZ25vcmUuc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uIChjcml0ZXJpYSkge1xuICAgICAgICBmaW5kKGRyYWdFbCwgY3JpdGVyaWEudHJpbSgpLCBfZGlzYWJsZURyYWdnYWJsZSk7XG4gICAgICB9KTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdkcmFnb3ZlcicsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2htb3ZlJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgICAgb24ob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCBfdGhpcy5fb25Ecm9wKTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgX3RoaXMuX29uRHJvcCk7IC8vIE1ha2UgZHJhZ0VsIGRyYWdnYWJsZSAobXVzdCBiZSBiZWZvcmUgZGVsYXkgZm9yIEZpcmVGb3gpXG5cbiAgICAgIGlmIChGaXJlRm94ICYmIHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy50b3VjaFN0YXJ0VGhyZXNob2xkID0gNDtcbiAgICAgICAgZHJhZ0VsLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHBsdWdpbkV2ZW50KCdkZWxheVN0YXJ0JywgdGhpcywge1xuICAgICAgICBldnQ6IGV2dFxuICAgICAgfSk7IC8vIERlbGF5IGlzIGltcG9zc2libGUgZm9yIG5hdGl2ZSBEbkQgaW4gRWRnZSBvciBJRVxuXG4gICAgICBpZiAob3B0aW9ucy5kZWxheSAmJiAoIW9wdGlvbnMuZGVsYXlPblRvdWNoT25seSB8fCB0b3VjaCkgJiYgKCF0aGlzLm5hdGl2ZURyYWdnYWJsZSB8fCAhKEVkZ2UgfHwgSUUxMU9yTGVzcykpKSB7XG4gICAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICAgICAgdGhpcy5fb25Ecm9wKCk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gSWYgdGhlIHVzZXIgbW92ZXMgdGhlIHBvaW50ZXIgb3IgbGV0IGdvIHRoZSBjbGljayBvciB0b3VjaFxuICAgICAgICAvLyBiZWZvcmUgdGhlIGRlbGF5IGhhcyBiZWVuIHJlYWNoZWQ6XG4gICAgICAgIC8vIGRpc2FibGUgdGhlIGRlbGF5ZWQgZHJhZ1xuXG5cbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgX3RoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaG1vdmUnLCBfdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICAgICAgb3B0aW9ucy5zdXBwb3J0UG9pbnRlciAmJiBvbihvd25lckRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCBfdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICAgICAgX3RoaXMuX2RyYWdTdGFydFRpbWVyID0gc2V0VGltZW91dChkcmFnU3RhcnRGbiwgb3B0aW9ucy5kZWxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkcmFnU3RhcnRGbigpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcjogZnVuY3Rpb24gX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcihcbiAgLyoqIFRvdWNoRXZlbnR8UG9pbnRlckV2ZW50ICoqL1xuICBlKSB7XG4gICAgdmFyIHRvdWNoID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcblxuICAgIGlmIChNYXRoLm1heChNYXRoLmFicyh0b3VjaC5jbGllbnRYIC0gdGhpcy5fbGFzdFgpLCBNYXRoLmFicyh0b3VjaC5jbGllbnRZIC0gdGhpcy5fbGFzdFkpKSA+PSBNYXRoLmZsb29yKHRoaXMub3B0aW9ucy50b3VjaFN0YXJ0VGhyZXNob2xkIC8gKHRoaXMubmF0aXZlRHJhZ2dhYmxlICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpKSkge1xuICAgICAgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKCk7XG4gICAgfVxuICB9LFxuICBfZGlzYWJsZURlbGF5ZWREcmFnOiBmdW5jdGlvbiBfZGlzYWJsZURlbGF5ZWREcmFnKCkge1xuICAgIGRyYWdFbCAmJiBfZGlzYWJsZURyYWdnYWJsZShkcmFnRWwpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9kcmFnU3RhcnRUaW1lcik7XG5cbiAgICB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMoKTtcbiAgfSxcbiAgX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50czogZnVuY3Rpb24gX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cygpIHtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IHRoaXMuZWwub3duZXJEb2N1bWVudDtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gIH0sXG4gIF90cmlnZ2VyRHJhZ1N0YXJ0OiBmdW5jdGlvbiBfdHJpZ2dlckRyYWdTdGFydChcbiAgLyoqIEV2ZW50ICovXG4gIGV2dCxcbiAgLyoqIFRvdWNoICovXG4gIHRvdWNoKSB7XG4gICAgdG91Y2ggPSB0b3VjaCB8fCBldnQucG9pbnRlclR5cGUgPT0gJ3RvdWNoJyAmJiBldnQ7XG5cbiAgICBpZiAoIXRoaXMubmF0aXZlRHJhZ2dhYmxlIHx8IHRvdWNoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN1cHBvcnRQb2ludGVyKSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgICB9IGVsc2UgaWYgKHRvdWNoKSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uKGRyYWdFbCwgJ2RyYWdlbmQnLCB0aGlzKTtcbiAgICAgIG9uKHJvb3RFbCwgJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuICAgICAgICAvLyBUaW1lb3V0IG5lY2Nlc3NhcnkgZm9yIElFOVxuICAgICAgICBfbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHt9XG4gIH0sXG4gIF9kcmFnU3RhcnRlZDogZnVuY3Rpb24gX2RyYWdTdGFydGVkKGZhbGxiYWNrLCBldnQpIHtcblxuICAgIGF3YWl0aW5nRHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIGlmIChyb290RWwgJiYgZHJhZ0VsKSB7XG4gICAgICBwbHVnaW5FdmVudCgnZHJhZ1N0YXJ0ZWQnLCB0aGlzLCB7XG4gICAgICAgIGV2dDogZXZ0XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAnZHJhZ292ZXInLCBfY2hlY2tPdXRzaWRlVGFyZ2V0RWwpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uczsgLy8gQXBwbHkgZWZmZWN0XG5cbiAgICAgICFmYWxsYmFjayAmJiB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuZHJhZ0NsYXNzLCBmYWxzZSk7XG4gICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuZ2hvc3RDbGFzcywgdHJ1ZSk7XG4gICAgICBTb3J0YWJsZS5hY3RpdmUgPSB0aGlzO1xuICAgICAgZmFsbGJhY2sgJiYgdGhpcy5fYXBwZW5kR2hvc3QoKTsgLy8gRHJhZyBzdGFydCBldmVudFxuXG4gICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICBuYW1lOiAnc3RhcnQnLFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9udWxsaW5nKCk7XG4gICAgfVxuICB9LFxuICBfZW11bGF0ZURyYWdPdmVyOiBmdW5jdGlvbiBfZW11bGF0ZURyYWdPdmVyKCkge1xuICAgIGlmICh0b3VjaEV2dCkge1xuICAgICAgdGhpcy5fbGFzdFggPSB0b3VjaEV2dC5jbGllbnRYO1xuICAgICAgdGhpcy5fbGFzdFkgPSB0b3VjaEV2dC5jbGllbnRZO1xuXG4gICAgICBfaGlkZUdob3N0Rm9yVGFyZ2V0KCk7XG5cbiAgICAgIHZhciB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvdWNoRXZ0LmNsaWVudFgsIHRvdWNoRXZ0LmNsaWVudFkpO1xuICAgICAgdmFyIHBhcmVudCA9IHRhcmdldDtcblxuICAgICAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQuc2hhZG93Um9vdCkge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQuc2hhZG93Um9vdC5lbGVtZW50RnJvbVBvaW50KHRvdWNoRXZ0LmNsaWVudFgsIHRvdWNoRXZ0LmNsaWVudFkpO1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBwYXJlbnQpIGJyZWFrO1xuICAgICAgICBwYXJlbnQgPSB0YXJnZXQ7XG4gICAgICB9XG5cbiAgICAgIGRyYWdFbC5wYXJlbnROb2RlW2V4cGFuZG9dLl9pc091dHNpZGVUaGlzRWwodGFyZ2V0KTtcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKHBhcmVudFtleHBhbmRvXSkge1xuICAgICAgICAgICAgdmFyIGluc2VydGVkID0gdm9pZCAwO1xuICAgICAgICAgICAgaW5zZXJ0ZWQgPSBwYXJlbnRbZXhwYW5kb10uX29uRHJhZ092ZXIoe1xuICAgICAgICAgICAgICBjbGllbnRYOiB0b3VjaEV2dC5jbGllbnRYLFxuICAgICAgICAgICAgICBjbGllbnRZOiB0b3VjaEV2dC5jbGllbnRZLFxuICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgcm9vdEVsOiBwYXJlbnRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaW5zZXJ0ZWQgJiYgIXRoaXMub3B0aW9ucy5kcmFnb3ZlckJ1YmJsZSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0YXJnZXQgPSBwYXJlbnQ7IC8vIHN0b3JlIGxhc3QgZWxlbWVudFxuICAgICAgICB9XG4gICAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cbiAgICAgICAgd2hpbGUgKHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlKTtcbiAgICAgIH1cblxuICAgICAgX3VuaGlkZUdob3N0Rm9yVGFyZ2V0KCk7XG4gICAgfVxuICB9LFxuICBfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIF9vblRvdWNoTW92ZShcbiAgLyoqVG91Y2hFdmVudCovXG4gIGV2dCkge1xuICAgIGlmICh0YXBFdnQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIGZhbGxiYWNrVG9sZXJhbmNlID0gb3B0aW9ucy5mYWxsYmFja1RvbGVyYW5jZSxcbiAgICAgICAgICBmYWxsYmFja09mZnNldCA9IG9wdGlvbnMuZmFsbGJhY2tPZmZzZXQsXG4gICAgICAgICAgdG91Y2ggPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0LFxuICAgICAgICAgIGdob3N0TWF0cml4ID0gZ2hvc3RFbCAmJiBtYXRyaXgoZ2hvc3RFbCwgdHJ1ZSksXG4gICAgICAgICAgc2NhbGVYID0gZ2hvc3RFbCAmJiBnaG9zdE1hdHJpeCAmJiBnaG9zdE1hdHJpeC5hLFxuICAgICAgICAgIHNjYWxlWSA9IGdob3N0RWwgJiYgZ2hvc3RNYXRyaXggJiYgZ2hvc3RNYXRyaXguZCxcbiAgICAgICAgICByZWxhdGl2ZVNjcm9sbE9mZnNldCA9IFBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5ICYmIGdob3N0UmVsYXRpdmVQYXJlbnQgJiYgZ2V0UmVsYXRpdmVTY3JvbGxPZmZzZXQoZ2hvc3RSZWxhdGl2ZVBhcmVudCksXG4gICAgICAgICAgZHggPSAodG91Y2guY2xpZW50WCAtIHRhcEV2dC5jbGllbnRYICsgZmFsbGJhY2tPZmZzZXQueCkgLyAoc2NhbGVYIHx8IDEpICsgKHJlbGF0aXZlU2Nyb2xsT2Zmc2V0ID8gcmVsYXRpdmVTY3JvbGxPZmZzZXRbMF0gLSBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbFswXSA6IDApIC8gKHNjYWxlWCB8fCAxKSxcbiAgICAgICAgICBkeSA9ICh0b3VjaC5jbGllbnRZIC0gdGFwRXZ0LmNsaWVudFkgKyBmYWxsYmFja09mZnNldC55KSAvIChzY2FsZVkgfHwgMSkgKyAocmVsYXRpdmVTY3JvbGxPZmZzZXQgPyByZWxhdGl2ZVNjcm9sbE9mZnNldFsxXSAtIGdob3N0UmVsYXRpdmVQYXJlbnRJbml0aWFsU2Nyb2xsWzFdIDogMCkgLyAoc2NhbGVZIHx8IDEpOyAvLyBvbmx5IHNldCB0aGUgc3RhdHVzIHRvIGRyYWdnaW5nLCB3aGVuIHdlIGFyZSBhY3R1YWxseSBkcmFnZ2luZ1xuXG4gICAgICBpZiAoIVNvcnRhYmxlLmFjdGl2ZSAmJiAhYXdhaXRpbmdEcmFnU3RhcnRlZCkge1xuICAgICAgICBpZiAoZmFsbGJhY2tUb2xlcmFuY2UgJiYgTWF0aC5tYXgoTWF0aC5hYnModG91Y2guY2xpZW50WCAtIHRoaXMuX2xhc3RYKSwgTWF0aC5hYnModG91Y2guY2xpZW50WSAtIHRoaXMuX2xhc3RZKSkgPCBmYWxsYmFja1RvbGVyYW5jZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX29uRHJhZ1N0YXJ0KGV2dCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChnaG9zdEVsKSB7XG4gICAgICAgIGlmIChnaG9zdE1hdHJpeCkge1xuICAgICAgICAgIGdob3N0TWF0cml4LmUgKz0gZHggLSAobGFzdER4IHx8IDApO1xuICAgICAgICAgIGdob3N0TWF0cml4LmYgKz0gZHkgLSAobGFzdER5IHx8IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdob3N0TWF0cml4ID0ge1xuICAgICAgICAgICAgYTogMSxcbiAgICAgICAgICAgIGI6IDAsXG4gICAgICAgICAgICBjOiAwLFxuICAgICAgICAgICAgZDogMSxcbiAgICAgICAgICAgIGU6IGR4LFxuICAgICAgICAgICAgZjogZHlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNzc01hdHJpeCA9IFwibWF0cml4KFwiLmNvbmNhdChnaG9zdE1hdHJpeC5hLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmIsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguYywgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5kLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmUsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguZiwgXCIpXCIpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ3dlYmtpdFRyYW5zZm9ybScsIGNzc01hdHJpeCk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAnbW96VHJhbnNmb3JtJywgY3NzTWF0cml4KTtcbiAgICAgICAgY3NzKGdob3N0RWwsICdtc1RyYW5zZm9ybScsIGNzc01hdHJpeCk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAndHJhbnNmb3JtJywgY3NzTWF0cml4KTtcbiAgICAgICAgbGFzdER4ID0gZHg7XG4gICAgICAgIGxhc3REeSA9IGR5O1xuICAgICAgICB0b3VjaEV2dCA9IHRvdWNoO1xuICAgICAgfVxuXG4gICAgICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sXG4gIF9hcHBlbmRHaG9zdDogZnVuY3Rpb24gX2FwcGVuZEdob3N0KCkge1xuICAgIC8vIEJ1ZyBpZiB1c2luZyBzY2FsZSgpOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNjM3MDU4XG4gICAgLy8gTm90IGJlaW5nIGFkanVzdGVkIGZvclxuICAgIGlmICghZ2hvc3RFbCkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5mYWxsYmFja09uQm9keSA/IGRvY3VtZW50LmJvZHkgOiByb290RWwsXG4gICAgICAgICAgcmVjdCA9IGdldFJlY3QoZHJhZ0VsLCB0cnVlLCBQb3NpdGlvbkdob3N0QWJzb2x1dGVseSwgdHJ1ZSwgY29udGFpbmVyKSxcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zOyAvLyBQb3NpdGlvbiBhYnNvbHV0ZWx5XG5cbiAgICAgIGlmIChQb3NpdGlvbkdob3N0QWJzb2x1dGVseSkge1xuICAgICAgICAvLyBHZXQgcmVsYXRpdmVseSBwb3NpdGlvbmVkIHBhcmVudFxuICAgICAgICBnaG9zdFJlbGF0aXZlUGFyZW50ID0gY29udGFpbmVyO1xuXG4gICAgICAgIHdoaWxlIChjc3MoZ2hvc3RSZWxhdGl2ZVBhcmVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnICYmIGNzcyhnaG9zdFJlbGF0aXZlUGFyZW50LCAndHJhbnNmb3JtJykgPT09ICdub25lJyAmJiBnaG9zdFJlbGF0aXZlUGFyZW50ICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgIGdob3N0UmVsYXRpdmVQYXJlbnQgPSBnaG9zdFJlbGF0aXZlUGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2hvc3RSZWxhdGl2ZVBhcmVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiBnaG9zdFJlbGF0aXZlUGFyZW50ICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoZ2hvc3RSZWxhdGl2ZVBhcmVudCA9PT0gZG9jdW1lbnQpIGdob3N0UmVsYXRpdmVQYXJlbnQgPSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gICAgICAgICAgcmVjdC50b3AgKz0gZ2hvc3RSZWxhdGl2ZVBhcmVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgcmVjdC5sZWZ0ICs9IGdob3N0UmVsYXRpdmVQYXJlbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnaG9zdFJlbGF0aXZlUGFyZW50ID0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2hvc3RSZWxhdGl2ZVBhcmVudEluaXRpYWxTY3JvbGwgPSBnZXRSZWxhdGl2ZVNjcm9sbE9mZnNldChnaG9zdFJlbGF0aXZlUGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgZ2hvc3RFbCA9IGRyYWdFbC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICB0b2dnbGVDbGFzcyhnaG9zdEVsLCBvcHRpb25zLmdob3N0Q2xhc3MsIGZhbHNlKTtcbiAgICAgIHRvZ2dsZUNsYXNzKGdob3N0RWwsIG9wdGlvbnMuZmFsbGJhY2tDbGFzcywgdHJ1ZSk7XG4gICAgICB0b2dnbGVDbGFzcyhnaG9zdEVsLCBvcHRpb25zLmRyYWdDbGFzcywgdHJ1ZSk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zZm9ybScsICcnKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAnYm94LXNpemluZycsICdib3JkZXItYm94Jyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ21hcmdpbicsIDApO1xuICAgICAgY3NzKGdob3N0RWwsICd0b3AnLCByZWN0LnRvcCk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ2xlZnQnLCByZWN0LmxlZnQpO1xuICAgICAgY3NzKGdob3N0RWwsICd3aWR0aCcsIHJlY3Qud2lkdGgpO1xuICAgICAgY3NzKGdob3N0RWwsICdoZWlnaHQnLCByZWN0LmhlaWdodCk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ29wYWNpdHknLCAnMC44Jyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3Bvc2l0aW9uJywgUG9zaXRpb25HaG9zdEFic29sdXRlbHkgPyAnYWJzb2x1dGUnIDogJ2ZpeGVkJyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3pJbmRleCcsICcxMDAwMDAnKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAncG9pbnRlckV2ZW50cycsICdub25lJyk7XG4gICAgICBTb3J0YWJsZS5naG9zdCA9IGdob3N0RWw7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZ2hvc3RFbCk7IC8vIFNldCB0cmFuc2Zvcm0tb3JpZ2luXG5cbiAgICAgIGNzcyhnaG9zdEVsLCAndHJhbnNmb3JtLW9yaWdpbicsIHRhcERpc3RhbmNlTGVmdCAvIHBhcnNlSW50KGdob3N0RWwuc3R5bGUud2lkdGgpICogMTAwICsgJyUgJyArIHRhcERpc3RhbmNlVG9wIC8gcGFyc2VJbnQoZ2hvc3RFbC5zdHlsZS5oZWlnaHQpICogMTAwICsgJyUnKTtcbiAgICB9XG4gIH0sXG4gIF9vbkRyYWdTdGFydDogZnVuY3Rpb24gX29uRHJhZ1N0YXJ0KFxuICAvKipFdmVudCovXG4gIGV2dCxcbiAgLyoqYm9vbGVhbiovXG4gIGZhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBkYXRhVHJhbnNmZXIgPSBldnQuZGF0YVRyYW5zZmVyO1xuICAgIHZhciBvcHRpb25zID0gX3RoaXMub3B0aW9ucztcbiAgICBwbHVnaW5FdmVudCgnZHJhZ1N0YXJ0JywgdGhpcywge1xuICAgICAgZXZ0OiBldnRcbiAgICB9KTtcblxuICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICB0aGlzLl9vbkRyb3AoKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBsdWdpbkV2ZW50KCdzZXR1cENsb25lJywgdGhpcyk7XG5cbiAgICBpZiAoIVNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgIGNsb25lRWwgPSBjbG9uZShkcmFnRWwpO1xuICAgICAgY2xvbmVFbC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgIGNsb25lRWwuc3R5bGVbJ3dpbGwtY2hhbmdlJ10gPSAnJztcblxuICAgICAgdGhpcy5faGlkZUNsb25lKCk7XG5cbiAgICAgIHRvZ2dsZUNsYXNzKGNsb25lRWwsIHRoaXMub3B0aW9ucy5jaG9zZW5DbGFzcywgZmFsc2UpO1xuICAgICAgU29ydGFibGUuY2xvbmUgPSBjbG9uZUVsO1xuICAgIH0gLy8gIzExNDM6IElGcmFtZSBzdXBwb3J0IHdvcmthcm91bmRcblxuXG4gICAgX3RoaXMuY2xvbmVJZCA9IF9uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBwbHVnaW5FdmVudCgnY2xvbmUnLCBfdGhpcyk7XG4gICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuO1xuXG4gICAgICBpZiAoIV90aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUpIHtcbiAgICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShjbG9uZUVsLCBkcmFnRWwpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5faGlkZUNsb25lKCk7XG5cbiAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgc29ydGFibGU6IF90aGlzLFxuICAgICAgICBuYW1lOiAnY2xvbmUnXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAhZmFsbGJhY2sgJiYgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmRyYWdDbGFzcywgdHJ1ZSk7IC8vIFNldCBwcm9wZXIgZHJvcCBldmVudHNcblxuICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgaWdub3JlTmV4dENsaWNrID0gdHJ1ZTtcbiAgICAgIF90aGlzLl9sb29wSWQgPSBzZXRJbnRlcnZhbChfdGhpcy5fZW11bGF0ZURyYWdPdmVyLCA1MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVuZG8gd2hhdCB3YXMgc2V0IGluIF9wcmVwYXJlRHJhZ1N0YXJ0IGJlZm9yZSBkcmFnIHN0YXJ0ZWRcbiAgICAgIG9mZihkb2N1bWVudCwgJ21vdXNldXAnLCBfdGhpcy5fb25Ecm9wKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICBvZmYoZG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIF90aGlzLl9vbkRyb3ApO1xuXG4gICAgICBpZiAoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIGRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gJ21vdmUnO1xuICAgICAgICBvcHRpb25zLnNldERhdGEgJiYgb3B0aW9ucy5zZXREYXRhLmNhbGwoX3RoaXMsIGRhdGFUcmFuc2ZlciwgZHJhZ0VsKTtcbiAgICAgIH1cblxuICAgICAgb24oZG9jdW1lbnQsICdkcm9wJywgX3RoaXMpOyAvLyAjMTI3NiBmaXg6XG5cbiAgICAgIGNzcyhkcmFnRWwsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlWigwKScpO1xuICAgIH1cblxuICAgIGF3YWl0aW5nRHJhZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgIF90aGlzLl9kcmFnU3RhcnRJZCA9IF9uZXh0VGljayhfdGhpcy5fZHJhZ1N0YXJ0ZWQuYmluZChfdGhpcywgZmFsbGJhY2ssIGV2dCkpO1xuICAgIG9uKGRvY3VtZW50LCAnc2VsZWN0c3RhcnQnLCBfdGhpcyk7XG4gICAgbW92ZWQgPSB0cnVlO1xuXG4gICAgaWYgKFNhZmFyaSkge1xuICAgICAgY3NzKGRvY3VtZW50LmJvZHksICd1c2VyLXNlbGVjdCcsICdub25lJyk7XG4gICAgfVxuICB9LFxuICAvLyBSZXR1cm5zIHRydWUgLSBpZiBubyBmdXJ0aGVyIGFjdGlvbiBpcyBuZWVkZWQgKGVpdGhlciBpbnNlcnRlZCBvciBhbm90aGVyIGNvbmRpdGlvbilcbiAgX29uRHJhZ092ZXI6IGZ1bmN0aW9uIF9vbkRyYWdPdmVyKFxuICAvKipFdmVudCovXG4gIGV2dCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWwsXG4gICAgICAgIHRhcmdldCA9IGV2dC50YXJnZXQsXG4gICAgICAgIGRyYWdSZWN0LFxuICAgICAgICB0YXJnZXRSZWN0LFxuICAgICAgICByZXZlcnQsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGdyb3VwID0gb3B0aW9ucy5ncm91cCxcbiAgICAgICAgYWN0aXZlU29ydGFibGUgPSBTb3J0YWJsZS5hY3RpdmUsXG4gICAgICAgIGlzT3duZXIgPSBhY3RpdmVHcm91cCA9PT0gZ3JvdXAsXG4gICAgICAgIGNhblNvcnQgPSBvcHRpb25zLnNvcnQsXG4gICAgICAgIGZyb21Tb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IGFjdGl2ZVNvcnRhYmxlLFxuICAgICAgICB2ZXJ0aWNhbCxcbiAgICAgICAgX3RoaXMgPSB0aGlzLFxuICAgICAgICBjb21wbGV0ZWRGaXJlZCA9IGZhbHNlO1xuXG4gICAgaWYgKF9zaWxlbnQpIHJldHVybjtcblxuICAgIGZ1bmN0aW9uIGRyYWdPdmVyRXZlbnQobmFtZSwgZXh0cmEpIHtcbiAgICAgIHBsdWdpbkV2ZW50KG5hbWUsIF90aGlzLCBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgIGV2dDogZXZ0LFxuICAgICAgICBpc093bmVyOiBpc093bmVyLFxuICAgICAgICBheGlzOiB2ZXJ0aWNhbCA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgIHJldmVydDogcmV2ZXJ0LFxuICAgICAgICBkcmFnUmVjdDogZHJhZ1JlY3QsXG4gICAgICAgIHRhcmdldFJlY3Q6IHRhcmdldFJlY3QsXG4gICAgICAgIGNhblNvcnQ6IGNhblNvcnQsXG4gICAgICAgIGZyb21Tb3J0YWJsZTogZnJvbVNvcnRhYmxlLFxuICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgY29tcGxldGVkOiBjb21wbGV0ZWQsXG4gICAgICAgIG9uTW92ZTogZnVuY3Rpb24gb25Nb3ZlKHRhcmdldCwgYWZ0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gX29uTW92ZShyb290RWwsIGVsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXQsIGdldFJlY3QodGFyZ2V0KSwgZXZ0LCBhZnRlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGNoYW5nZWQ6IGNoYW5nZWRcbiAgICAgIH0sIGV4dHJhKSk7XG4gICAgfSAvLyBDYXB0dXJlIGFuaW1hdGlvbiBzdGF0ZVxuXG5cbiAgICBmdW5jdGlvbiBjYXB0dXJlKCkge1xuICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXJBbmltYXRpb25DYXB0dXJlJyk7XG5cbiAgICAgIF90aGlzLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuXG4gICAgICBpZiAoX3RoaXMgIT09IGZyb21Tb3J0YWJsZSkge1xuICAgICAgICBmcm9tU29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG4gICAgICB9XG4gICAgfSAvLyBSZXR1cm4gaW52b2NhdGlvbiB3aGVuIGRyYWdFbCBpcyBpbnNlcnRlZCAob3IgY29tcGxldGVkKVxuXG5cbiAgICBmdW5jdGlvbiBjb21wbGV0ZWQoaW5zZXJ0aW9uKSB7XG4gICAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlckNvbXBsZXRlZCcsIHtcbiAgICAgICAgaW5zZXJ0aW9uOiBpbnNlcnRpb25cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgICAgIC8vIENsb25lcyBtdXN0IGJlIGhpZGRlbiBiZWZvcmUgZm9sZGluZyBhbmltYXRpb24gdG8gY2FwdHVyZSBkcmFnUmVjdEFic29sdXRlIHByb3Blcmx5XG4gICAgICAgIGlmIChpc093bmVyKSB7XG4gICAgICAgICAgYWN0aXZlU29ydGFibGUuX2hpZGVDbG9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlLl9zaG93Q2xvbmUoX3RoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzICE9PSBmcm9tU29ydGFibGUpIHtcbiAgICAgICAgICAvLyBTZXQgZ2hvc3QgY2xhc3MgdG8gbmV3IHNvcnRhYmxlJ3MgZ2hvc3QgY2xhc3NcbiAgICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIHB1dFNvcnRhYmxlID8gcHV0U29ydGFibGUub3B0aW9ucy5naG9zdENsYXNzIDogYWN0aXZlU29ydGFibGUub3B0aW9ucy5naG9zdENsYXNzLCBmYWxzZSk7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmdob3N0Q2xhc3MsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHB1dFNvcnRhYmxlICE9PSBfdGhpcyAmJiBfdGhpcyAhPT0gU29ydGFibGUuYWN0aXZlKSB7XG4gICAgICAgICAgcHV0U29ydGFibGUgPSBfdGhpcztcbiAgICAgICAgfSBlbHNlIGlmIChfdGhpcyA9PT0gU29ydGFibGUuYWN0aXZlICYmIHB1dFNvcnRhYmxlKSB7XG4gICAgICAgICAgcHV0U29ydGFibGUgPSBudWxsO1xuICAgICAgICB9IC8vIEFuaW1hdGlvblxuXG5cbiAgICAgICAgaWYgKGZyb21Tb3J0YWJsZSA9PT0gX3RoaXMpIHtcbiAgICAgICAgICBfdGhpcy5faWdub3JlV2hpbGVBbmltYXRpbmcgPSB0YXJnZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5hbmltYXRlQWxsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlckFuaW1hdGlvbkNvbXBsZXRlJyk7XG4gICAgICAgICAgX3RoaXMuX2lnbm9yZVdoaWxlQW5pbWF0aW5nID0gbnVsbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKF90aGlzICE9PSBmcm9tU29ydGFibGUpIHtcbiAgICAgICAgICBmcm9tU29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICAgICAgICAgIGZyb21Tb3J0YWJsZS5faWdub3JlV2hpbGVBbmltYXRpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IC8vIE51bGwgbGFzdFRhcmdldCBpZiBpdCBpcyBub3QgaW5zaWRlIGEgcHJldmlvdXNseSBzd2FwcGVkIGVsZW1lbnRcblxuXG4gICAgICBpZiAodGFyZ2V0ID09PSBkcmFnRWwgJiYgIWRyYWdFbC5hbmltYXRlZCB8fCB0YXJnZXQgPT09IGVsICYmICF0YXJnZXQuYW5pbWF0ZWQpIHtcbiAgICAgICAgbGFzdFRhcmdldCA9IG51bGw7XG4gICAgICB9IC8vIG5vIGJ1YmJsaW5nIGFuZCBub3QgZmFsbGJhY2tcblxuXG4gICAgICBpZiAoIW9wdGlvbnMuZHJhZ292ZXJCdWJibGUgJiYgIWV2dC5yb290RWwgJiYgdGFyZ2V0ICE9PSBkb2N1bWVudCkge1xuICAgICAgICBkcmFnRWwucGFyZW50Tm9kZVtleHBhbmRvXS5faXNPdXRzaWRlVGhpc0VsKGV2dC50YXJnZXQpOyAvLyBEbyBub3QgZGV0ZWN0IGZvciBlbXB0eSBpbnNlcnQgaWYgYWxyZWFkeSBpbnNlcnRlZFxuXG5cbiAgICAgICAgIWluc2VydGlvbiAmJiBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudChldnQpO1xuICAgICAgfVxuXG4gICAgICAhb3B0aW9ucy5kcmFnb3ZlckJ1YmJsZSAmJiBldnQuc3RvcFByb3BhZ2F0aW9uICYmIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHJldHVybiBjb21wbGV0ZWRGaXJlZCA9IHRydWU7XG4gICAgfSAvLyBDYWxsIHdoZW4gZHJhZ0VsIGhhcyBiZWVuIGluc2VydGVkXG5cblxuICAgIGZ1bmN0aW9uIGNoYW5nZWQoKSB7XG4gICAgICBuZXdJbmRleCA9IGluZGV4KGRyYWdFbCk7XG4gICAgICBuZXdEcmFnZ2FibGVJbmRleCA9IGluZGV4KGRyYWdFbCwgb3B0aW9ucy5kcmFnZ2FibGUpO1xuXG4gICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgbmFtZTogJ2NoYW5nZScsXG4gICAgICAgIHRvRWw6IGVsLFxuICAgICAgICBuZXdJbmRleDogbmV3SW5kZXgsXG4gICAgICAgIG5ld0RyYWdnYWJsZUluZGV4OiBuZXdEcmFnZ2FibGVJbmRleCxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZXZ0LnByZXZlbnREZWZhdWx0ICE9PSB2b2lkIDApIHtcbiAgICAgIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHRhcmdldCA9IGNsb3Nlc3QodGFyZ2V0LCBvcHRpb25zLmRyYWdnYWJsZSwgZWwsIHRydWUpO1xuICAgIGRyYWdPdmVyRXZlbnQoJ2RyYWdPdmVyJyk7XG4gICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybiBjb21wbGV0ZWRGaXJlZDtcblxuICAgIGlmIChkcmFnRWwuY29udGFpbnMoZXZ0LnRhcmdldCkgfHwgdGFyZ2V0LmFuaW1hdGVkICYmIHRhcmdldC5hbmltYXRpbmdYICYmIHRhcmdldC5hbmltYXRpbmdZIHx8IF90aGlzLl9pZ25vcmVXaGlsZUFuaW1hdGluZyA9PT0gdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gY29tcGxldGVkKGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZ25vcmVOZXh0Q2xpY2sgPSBmYWxzZTtcblxuICAgIGlmIChhY3RpdmVTb3J0YWJsZSAmJiAhb3B0aW9ucy5kaXNhYmxlZCAmJiAoaXNPd25lciA/IGNhblNvcnQgfHwgKHJldmVydCA9IHBhcmVudEVsICE9PSByb290RWwpIC8vIFJldmVydGluZyBpdGVtIGludG8gdGhlIG9yaWdpbmFsIGxpc3RcbiAgICA6IHB1dFNvcnRhYmxlID09PSB0aGlzIHx8ICh0aGlzLmxhc3RQdXRNb2RlID0gYWN0aXZlR3JvdXAuY2hlY2tQdWxsKHRoaXMsIGFjdGl2ZVNvcnRhYmxlLCBkcmFnRWwsIGV2dCkpICYmIGdyb3VwLmNoZWNrUHV0KHRoaXMsIGFjdGl2ZVNvcnRhYmxlLCBkcmFnRWwsIGV2dCkpKSB7XG4gICAgICB2ZXJ0aWNhbCA9IHRoaXMuX2dldERpcmVjdGlvbihldnQsIHRhcmdldCkgPT09ICd2ZXJ0aWNhbCc7XG4gICAgICBkcmFnUmVjdCA9IGdldFJlY3QoZHJhZ0VsKTtcbiAgICAgIGRyYWdPdmVyRXZlbnQoJ2RyYWdPdmVyVmFsaWQnKTtcbiAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm4gY29tcGxldGVkRmlyZWQ7XG5cbiAgICAgIGlmIChyZXZlcnQpIHtcbiAgICAgICAgcGFyZW50RWwgPSByb290RWw7IC8vIGFjdHVhbGl6YXRpb25cblxuICAgICAgICBjYXB0dXJlKCk7XG5cbiAgICAgICAgdGhpcy5faGlkZUNsb25lKCk7XG5cbiAgICAgICAgZHJhZ092ZXJFdmVudCgncmV2ZXJ0Jyk7XG5cbiAgICAgICAgaWYgKCFTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICAgICAgaWYgKG5leHRFbCkge1xuICAgICAgICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShkcmFnRWwsIG5leHRFbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChkcmFnRWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wbGV0ZWQodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbExhc3RDaGlsZCA9IGxhc3RDaGlsZChlbCwgb3B0aW9ucy5kcmFnZ2FibGUpO1xuXG4gICAgICBpZiAoIWVsTGFzdENoaWxkIHx8IF9naG9zdElzTGFzdChldnQsIHZlcnRpY2FsLCB0aGlzKSAmJiAhZWxMYXN0Q2hpbGQuYW5pbWF0ZWQpIHtcbiAgICAgICAgLy8gSW5zZXJ0IHRvIGVuZCBvZiBsaXN0XG4gICAgICAgIC8vIElmIGFscmVhZHkgYXQgZW5kIG9mIGxpc3Q6IERvIG5vdCBpbnNlcnRcbiAgICAgICAgaWYgKGVsTGFzdENoaWxkID09PSBkcmFnRWwpIHtcbiAgICAgICAgICByZXR1cm4gY29tcGxldGVkKGZhbHNlKTtcbiAgICAgICAgfSAvLyBpZiB0aGVyZSBpcyBhIGxhc3QgZWxlbWVudCwgaXQgaXMgdGhlIHRhcmdldFxuXG5cbiAgICAgICAgaWYgKGVsTGFzdENoaWxkICYmIGVsID09PSBldnQudGFyZ2V0KSB7XG4gICAgICAgICAgdGFyZ2V0ID0gZWxMYXN0Q2hpbGQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgdGFyZ2V0UmVjdCA9IGdldFJlY3QodGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfb25Nb3ZlKHJvb3RFbCwgZWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldCwgdGFyZ2V0UmVjdCwgZXZ0LCAhIXRhcmdldCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgY2FwdHVyZSgpO1xuICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG4gICAgICAgICAgcGFyZW50RWwgPSBlbDsgLy8gYWN0dWFsaXphdGlvblxuXG4gICAgICAgICAgY2hhbmdlZCgpO1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZWxMYXN0Q2hpbGQgJiYgX2dob3N0SXNGaXJzdChldnQsIHZlcnRpY2FsLCB0aGlzKSkge1xuICAgICAgICAvLyBJbnNlcnQgdG8gc3RhcnQgb2YgbGlzdFxuICAgICAgICB2YXIgZmlyc3RDaGlsZCA9IGdldENoaWxkKGVsLCAwLCBvcHRpb25zLCB0cnVlKTtcblxuICAgICAgICBpZiAoZmlyc3RDaGlsZCA9PT0gZHJhZ0VsKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQgPSBmaXJzdENoaWxkO1xuICAgICAgICB0YXJnZXRSZWN0ID0gZ2V0UmVjdCh0YXJnZXQpO1xuXG4gICAgICAgIGlmIChfb25Nb3ZlKHJvb3RFbCwgZWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldCwgdGFyZ2V0UmVjdCwgZXZ0LCBmYWxzZSkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgY2FwdHVyZSgpO1xuICAgICAgICAgIGVsLmluc2VydEJlZm9yZShkcmFnRWwsIGZpcnN0Q2hpbGQpO1xuICAgICAgICAgIHBhcmVudEVsID0gZWw7IC8vIGFjdHVhbGl6YXRpb25cblxuICAgICAgICAgIGNoYW5nZWQoKTtcbiAgICAgICAgICByZXR1cm4gY29tcGxldGVkKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldC5wYXJlbnROb2RlID09PSBlbCkge1xuICAgICAgICB0YXJnZXRSZWN0ID0gZ2V0UmVjdCh0YXJnZXQpO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gMCxcbiAgICAgICAgICAgIHRhcmdldEJlZm9yZUZpcnN0U3dhcCxcbiAgICAgICAgICAgIGRpZmZlcmVudExldmVsID0gZHJhZ0VsLnBhcmVudE5vZGUgIT09IGVsLFxuICAgICAgICAgICAgZGlmZmVyZW50Um93Q29sID0gIV9kcmFnRWxJblJvd0NvbHVtbihkcmFnRWwuYW5pbWF0ZWQgJiYgZHJhZ0VsLnRvUmVjdCB8fCBkcmFnUmVjdCwgdGFyZ2V0LmFuaW1hdGVkICYmIHRhcmdldC50b1JlY3QgfHwgdGFyZ2V0UmVjdCwgdmVydGljYWwpLFxuICAgICAgICAgICAgc2lkZTEgPSB2ZXJ0aWNhbCA/ICd0b3AnIDogJ2xlZnQnLFxuICAgICAgICAgICAgc2Nyb2xsZWRQYXN0VG9wID0gaXNTY3JvbGxlZFBhc3QodGFyZ2V0LCAndG9wJywgJ3RvcCcpIHx8IGlzU2Nyb2xsZWRQYXN0KGRyYWdFbCwgJ3RvcCcsICd0b3AnKSxcbiAgICAgICAgICAgIHNjcm9sbEJlZm9yZSA9IHNjcm9sbGVkUGFzdFRvcCA/IHNjcm9sbGVkUGFzdFRvcC5zY3JvbGxUb3AgOiB2b2lkIDA7XG5cbiAgICAgICAgaWYgKGxhc3RUYXJnZXQgIT09IHRhcmdldCkge1xuICAgICAgICAgIHRhcmdldEJlZm9yZUZpcnN0U3dhcCA9IHRhcmdldFJlY3Rbc2lkZTFdO1xuICAgICAgICAgIHBhc3RGaXJzdEludmVydFRocmVzaCA9IGZhbHNlO1xuICAgICAgICAgIGlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQgPSAhZGlmZmVyZW50Um93Q29sICYmIG9wdGlvbnMuaW52ZXJ0U3dhcCB8fCBkaWZmZXJlbnRMZXZlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpcmVjdGlvbiA9IF9nZXRTd2FwRGlyZWN0aW9uKGV2dCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCwgZGlmZmVyZW50Um93Q29sID8gMSA6IG9wdGlvbnMuc3dhcFRocmVzaG9sZCwgb3B0aW9ucy5pbnZlcnRlZFN3YXBUaHJlc2hvbGQgPT0gbnVsbCA/IG9wdGlvbnMuc3dhcFRocmVzaG9sZCA6IG9wdGlvbnMuaW52ZXJ0ZWRTd2FwVGhyZXNob2xkLCBpc0NpcmN1bXN0YW50aWFsSW52ZXJ0LCBsYXN0VGFyZ2V0ID09PSB0YXJnZXQpO1xuICAgICAgICB2YXIgc2libGluZztcblxuICAgICAgICBpZiAoZGlyZWN0aW9uICE9PSAwKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGJlc2lkZSBkcmFnRWwgaW4gcmVzcGVjdGl2ZSBkaXJlY3Rpb24gKGlnbm9yaW5nIGhpZGRlbiBlbGVtZW50cylcbiAgICAgICAgICB2YXIgZHJhZ0luZGV4ID0gaW5kZXgoZHJhZ0VsKTtcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGRyYWdJbmRleCAtPSBkaXJlY3Rpb247XG4gICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50RWwuY2hpbGRyZW5bZHJhZ0luZGV4XTtcbiAgICAgICAgICB9IHdoaWxlIChzaWJsaW5nICYmIChjc3Moc2libGluZywgJ2Rpc3BsYXknKSA9PT0gJ25vbmUnIHx8IHNpYmxpbmcgPT09IGdob3N0RWwpKTtcbiAgICAgICAgfSAvLyBJZiBkcmFnRWwgaXMgYWxyZWFkeSBiZXNpZGUgdGFyZ2V0OiBEbyBub3QgaW5zZXJ0XG5cblxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAwIHx8IHNpYmxpbmcgPT09IHRhcmdldCkge1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgbGFzdERpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gdGFyZ2V0Lm5leHRFbGVtZW50U2libGluZyxcbiAgICAgICAgICAgIGFmdGVyID0gZmFsc2U7XG4gICAgICAgIGFmdGVyID0gZGlyZWN0aW9uID09PSAxO1xuXG4gICAgICAgIHZhciBtb3ZlVmVjdG9yID0gX29uTW92ZShyb290RWwsIGVsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXQsIHRhcmdldFJlY3QsIGV2dCwgYWZ0ZXIpO1xuXG4gICAgICAgIGlmIChtb3ZlVmVjdG9yICE9PSBmYWxzZSkge1xuICAgICAgICAgIGlmIChtb3ZlVmVjdG9yID09PSAxIHx8IG1vdmVWZWN0b3IgPT09IC0xKSB7XG4gICAgICAgICAgICBhZnRlciA9IG1vdmVWZWN0b3IgPT09IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3NpbGVudCA9IHRydWU7XG4gICAgICAgICAgc2V0VGltZW91dChfdW5zaWxlbnQsIDMwKTtcbiAgICAgICAgICBjYXB0dXJlKCk7XG5cbiAgICAgICAgICBpZiAoYWZ0ZXIgJiYgIW5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChkcmFnRWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZHJhZ0VsLCBhZnRlciA/IG5leHRTaWJsaW5nIDogdGFyZ2V0KTtcbiAgICAgICAgICB9IC8vIFVuZG8gY2hyb21lJ3Mgc2Nyb2xsIGFkanVzdG1lbnQgKGhhcyBubyBlZmZlY3Qgb24gb3RoZXIgYnJvd3NlcnMpXG5cblxuICAgICAgICAgIGlmIChzY3JvbGxlZFBhc3RUb3ApIHtcbiAgICAgICAgICAgIHNjcm9sbEJ5KHNjcm9sbGVkUGFzdFRvcCwgMCwgc2Nyb2xsQmVmb3JlIC0gc2Nyb2xsZWRQYXN0VG9wLnNjcm9sbFRvcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFyZW50RWwgPSBkcmFnRWwucGFyZW50Tm9kZTsgLy8gYWN0dWFsaXphdGlvblxuICAgICAgICAgIC8vIG11c3QgYmUgZG9uZSBiZWZvcmUgYW5pbWF0aW9uXG5cbiAgICAgICAgICBpZiAodGFyZ2V0QmVmb3JlRmlyc3RTd2FwICE9PSB1bmRlZmluZWQgJiYgIWlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQpIHtcbiAgICAgICAgICAgIHRhcmdldE1vdmVEaXN0YW5jZSA9IE1hdGguYWJzKHRhcmdldEJlZm9yZUZpcnN0U3dhcCAtIGdldFJlY3QodGFyZ2V0KVtzaWRlMV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoYW5nZWQoKTtcbiAgICAgICAgICByZXR1cm4gY29tcGxldGVkKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbC5jb250YWlucyhkcmFnRWwpKSB7XG4gICAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgX2lnbm9yZVdoaWxlQW5pbWF0aW5nOiBudWxsLFxuICBfb2ZmTW92ZUV2ZW50czogZnVuY3Rpb24gX29mZk1vdmVFdmVudHMoKSB7XG4gICAgb2ZmKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgIG9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICBvZmYoZG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICBvZmYoZG9jdW1lbnQsICdkcmFnb3ZlcicsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICBvZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgb2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICB9LFxuICBfb2ZmVXBFdmVudHM6IGZ1bmN0aW9uIF9vZmZVcEV2ZW50cygpIHtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IHRoaXMuZWwub3duZXJEb2N1bWVudDtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9vbkRyb3ApO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vbkRyb3ApO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAncG9pbnRlcnVwJywgdGhpcy5fb25Ecm9wKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgdGhpcy5fb25Ecm9wKTtcbiAgICBvZmYoZG9jdW1lbnQsICdzZWxlY3RzdGFydCcsIHRoaXMpO1xuICB9LFxuICBfb25Ecm9wOiBmdW5jdGlvbiBfb25Ecm9wKFxuICAvKipFdmVudCovXG4gIGV2dCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWwsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7IC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGRyYWdnZWQgZWxlbWVudCB3aXRoaW4gaXRzIHBhcmVudFxuXG4gICAgbmV3SW5kZXggPSBpbmRleChkcmFnRWwpO1xuICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gaW5kZXgoZHJhZ0VsLCBvcHRpb25zLmRyYWdnYWJsZSk7XG4gICAgcGx1Z2luRXZlbnQoJ2Ryb3AnLCB0aGlzLCB7XG4gICAgICBldnQ6IGV2dFxuICAgIH0pO1xuICAgIHBhcmVudEVsID0gZHJhZ0VsICYmIGRyYWdFbC5wYXJlbnROb2RlOyAvLyBHZXQgYWdhaW4gYWZ0ZXIgcGx1Z2luIGV2ZW50XG5cbiAgICBuZXdJbmRleCA9IGluZGV4KGRyYWdFbCk7XG4gICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBpbmRleChkcmFnRWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcblxuICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICB0aGlzLl9udWxsaW5nKCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhd2FpdGluZ0RyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgaXNDaXJjdW1zdGFudGlhbEludmVydCA9IGZhbHNlO1xuICAgIHBhc3RGaXJzdEludmVydFRocmVzaCA9IGZhbHNlO1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fbG9vcElkKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fZHJhZ1N0YXJ0VGltZXIpO1xuXG4gICAgX2NhbmNlbE5leHRUaWNrKHRoaXMuY2xvbmVJZCk7XG5cbiAgICBfY2FuY2VsTmV4dFRpY2sodGhpcy5fZHJhZ1N0YXJ0SWQpOyAvLyBVbmJpbmQgZXZlbnRzXG5cblxuICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgb2ZmKGRvY3VtZW50LCAnZHJvcCcsIHRoaXMpO1xuICAgICAgb2ZmKGVsLCAnZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xuICAgIH1cblxuICAgIHRoaXMuX29mZk1vdmVFdmVudHMoKTtcblxuICAgIHRoaXMuX29mZlVwRXZlbnRzKCk7XG5cbiAgICBpZiAoU2FmYXJpKSB7XG4gICAgICBjc3MoZG9jdW1lbnQuYm9keSwgJ3VzZXItc2VsZWN0JywgJycpO1xuICAgIH1cblxuICAgIGNzcyhkcmFnRWwsICd0cmFuc2Zvcm0nLCAnJyk7XG5cbiAgICBpZiAoZXZ0KSB7XG4gICAgICBpZiAobW92ZWQpIHtcbiAgICAgICAgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICFvcHRpb25zLmRyb3BCdWJibGUgJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBnaG9zdEVsICYmIGdob3N0RWwucGFyZW50Tm9kZSAmJiBnaG9zdEVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZ2hvc3RFbCk7XG5cbiAgICAgIGlmIChyb290RWwgPT09IHBhcmVudEVsIHx8IHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLmxhc3RQdXRNb2RlICE9PSAnY2xvbmUnKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjbG9uZShzKVxuICAgICAgICBjbG9uZUVsICYmIGNsb25lRWwucGFyZW50Tm9kZSAmJiBjbG9uZUVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvbmVFbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkcmFnRWwpIHtcbiAgICAgICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgICAgb2ZmKGRyYWdFbCwgJ2RyYWdlbmQnLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9kaXNhYmxlRHJhZ2dhYmxlKGRyYWdFbCk7XG5cbiAgICAgICAgZHJhZ0VsLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJyc7IC8vIFJlbW92ZSBjbGFzc2VzXG4gICAgICAgIC8vIGdob3N0Q2xhc3MgaXMgYWRkZWQgaW4gZHJhZ1N0YXJ0ZWRcblxuICAgICAgICBpZiAobW92ZWQgJiYgIWF3YWl0aW5nRHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIHB1dFNvcnRhYmxlID8gcHV0U29ydGFibGUub3B0aW9ucy5naG9zdENsYXNzIDogdGhpcy5vcHRpb25zLmdob3N0Q2xhc3MsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgdGhpcy5vcHRpb25zLmNob3NlbkNsYXNzLCBmYWxzZSk7IC8vIERyYWcgc3RvcCBldmVudFxuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICBuYW1lOiAndW5jaG9vc2UnLFxuICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgIG5ld0luZGV4OiBudWxsLFxuICAgICAgICAgIG5ld0RyYWdnYWJsZUluZGV4OiBudWxsLFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocm9vdEVsICE9PSBwYXJlbnRFbCkge1xuICAgICAgICAgIGlmIChuZXdJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBBZGQgZXZlbnRcbiAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgcm9vdEVsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgbmFtZTogJ2FkZCcsXG4gICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBmcm9tRWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICB9KTsgLy8gUmVtb3ZlIGV2ZW50XG5cblxuICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgICAgbmFtZTogJ3JlbW92ZScsXG4gICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgIH0pOyAvLyBkcmFnIGZyb20gb25lIGxpc3QgYW5kIGRyb3AgaW50byBhbm90aGVyXG5cblxuICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICByb290RWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBuYW1lOiAnc29ydCcsXG4gICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBmcm9tRWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgICAgbmFtZTogJ3NvcnQnLFxuICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwdXRTb3J0YWJsZSAmJiBwdXRTb3J0YWJsZS5zYXZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG5ld0luZGV4ICE9PSBvbGRJbmRleCkge1xuICAgICAgICAgICAgaWYgKG5ld0luZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgLy8gZHJhZyAmIGRyb3Agd2l0aGluIHRoZSBzYW1lIGxpc3RcbiAgICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd1cGRhdGUnLFxuICAgICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3NvcnQnLFxuICAgICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoU29ydGFibGUuYWN0aXZlKSB7XG4gICAgICAgICAgLyoganNoaW50IGVxbnVsbDp0cnVlICovXG4gICAgICAgICAgaWYgKG5ld0luZGV4ID09IG51bGwgfHwgbmV3SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBuZXdJbmRleCA9IG9sZEluZGV4O1xuICAgICAgICAgICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBvbGREcmFnZ2FibGVJbmRleDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgIG5hbWU6ICdlbmQnLFxuICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICB9KTsgLy8gU2F2ZSBzb3J0aW5nXG5cblxuICAgICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbnVsbGluZygpO1xuICB9LFxuICBfbnVsbGluZzogZnVuY3Rpb24gX251bGxpbmcoKSB7XG4gICAgcGx1Z2luRXZlbnQoJ251bGxpbmcnLCB0aGlzKTtcbiAgICByb290RWwgPSBkcmFnRWwgPSBwYXJlbnRFbCA9IGdob3N0RWwgPSBuZXh0RWwgPSBjbG9uZUVsID0gbGFzdERvd25FbCA9IGNsb25lSGlkZGVuID0gdGFwRXZ0ID0gdG91Y2hFdnQgPSBtb3ZlZCA9IG5ld0luZGV4ID0gbmV3RHJhZ2dhYmxlSW5kZXggPSBvbGRJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4ID0gbGFzdFRhcmdldCA9IGxhc3REaXJlY3Rpb24gPSBwdXRTb3J0YWJsZSA9IGFjdGl2ZUdyb3VwID0gU29ydGFibGUuZHJhZ2dlZCA9IFNvcnRhYmxlLmdob3N0ID0gU29ydGFibGUuY2xvbmUgPSBTb3J0YWJsZS5hY3RpdmUgPSBudWxsO1xuICAgIHNhdmVkSW5wdXRDaGVja2VkLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICBlbC5jaGVja2VkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBzYXZlZElucHV0Q2hlY2tlZC5sZW5ndGggPSBsYXN0RHggPSBsYXN0RHkgPSAwO1xuICB9LFxuICBoYW5kbGVFdmVudDogZnVuY3Rpb24gaGFuZGxlRXZlbnQoXG4gIC8qKkV2ZW50Ki9cbiAgZXZ0KSB7XG4gICAgc3dpdGNoIChldnQudHlwZSkge1xuICAgICAgY2FzZSAnZHJvcCc6XG4gICAgICBjYXNlICdkcmFnZW5kJzpcbiAgICAgICAgdGhpcy5fb25Ecm9wKGV2dCk7XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2RyYWdlbnRlcic6XG4gICAgICBjYXNlICdkcmFnb3Zlcic6XG4gICAgICAgIGlmIChkcmFnRWwpIHtcbiAgICAgICAgICB0aGlzLl9vbkRyYWdPdmVyKGV2dCk7XG5cbiAgICAgICAgICBfZ2xvYmFsRHJhZ092ZXIoZXZ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzZWxlY3RzdGFydCc6XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIGl0ZW0gaW50byBhbiBhcnJheSBvZiBzdHJpbmcuXG4gICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICovXG4gIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgdmFyIG9yZGVyID0gW10sXG4gICAgICAgIGVsLFxuICAgICAgICBjaGlsZHJlbiA9IHRoaXMuZWwuY2hpbGRyZW4sXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBuID0gY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgIGVsID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChjbG9zZXN0KGVsLCBvcHRpb25zLmRyYWdnYWJsZSwgdGhpcy5lbCwgZmFsc2UpKSB7XG4gICAgICAgIG9yZGVyLnB1c2goZWwuZ2V0QXR0cmlidXRlKG9wdGlvbnMuZGF0YUlkQXR0cikgfHwgX2dlbmVyYXRlSWQoZWwpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3JkZXI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNvcnRzIHRoZSBlbGVtZW50cyBhY2NvcmRpbmcgdG8gdGhlIGFycmF5LlxuICAgKiBAcGFyYW0gIHtTdHJpbmdbXX0gIG9yZGVyICBvcmRlciBvZiB0aGUgaXRlbXNcbiAgICovXG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQob3JkZXIsIHVzZUFuaW1hdGlvbikge1xuICAgIHZhciBpdGVtcyA9IHt9LFxuICAgICAgICByb290RWwgPSB0aGlzLmVsO1xuICAgIHRoaXMudG9BcnJheSgpLmZvckVhY2goZnVuY3Rpb24gKGlkLCBpKSB7XG4gICAgICB2YXIgZWwgPSByb290RWwuY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChjbG9zZXN0KGVsLCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlLCByb290RWwsIGZhbHNlKSkge1xuICAgICAgICBpdGVtc1tpZF0gPSBlbDtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICB1c2VBbmltYXRpb24gJiYgdGhpcy5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICBvcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgaWYgKGl0ZW1zW2lkXSkge1xuICAgICAgICByb290RWwucmVtb3ZlQ2hpbGQoaXRlbXNbaWRdKTtcbiAgICAgICAgcm9vdEVsLmFwcGVuZENoaWxkKGl0ZW1zW2lkXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdXNlQW5pbWF0aW9uICYmIHRoaXMuYW5pbWF0ZUFsbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYXZlIHRoZSBjdXJyZW50IHNvcnRpbmdcbiAgICovXG4gIHNhdmU6IGZ1bmN0aW9uIHNhdmUoKSB7XG4gICAgdmFyIHN0b3JlID0gdGhpcy5vcHRpb25zLnN0b3JlO1xuICAgIHN0b3JlICYmIHN0b3JlLnNldCAmJiBzdG9yZS5zZXQodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldCwgZ2V0IHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IgYnkgdGVzdGluZyB0aGUgZWxlbWVudCBpdHNlbGYgYW5kIHRyYXZlcnNpbmcgdXAgdGhyb3VnaCBpdHMgYW5jZXN0b3JzIGluIHRoZSBET00gdHJlZS5cbiAgICogQHBhcmFtICAge0hUTUxFbGVtZW50fSAgZWxcbiAgICogQHBhcmFtICAge1N0cmluZ30gICAgICAgW3NlbGVjdG9yXSAgZGVmYXVsdDogYG9wdGlvbnMuZHJhZ2dhYmxlYFxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8bnVsbH1cbiAgICovXG4gIGNsb3Nlc3Q6IGZ1bmN0aW9uIGNsb3Nlc3QkMShlbCwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gY2xvc2VzdChlbCwgc2VsZWN0b3IgfHwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSwgdGhpcy5lbCwgZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQvZ2V0IG9wdGlvblxuICAgKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSAgIHsqfSAgICAgIFt2YWx1ZV1cbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBvcHRpb246IGZ1bmN0aW9uIG9wdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBvcHRpb25zW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbW9kaWZpZWRWYWx1ZSA9IFBsdWdpbk1hbmFnZXIubW9kaWZ5T3B0aW9uKHRoaXMsIG5hbWUsIHZhbHVlKTtcblxuICAgICAgaWYgKHR5cGVvZiBtb2RpZmllZFZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvcHRpb25zW25hbWVdID0gbW9kaWZpZWRWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgPT09ICdncm91cCcpIHtcbiAgICAgICAgX3ByZXBhcmVHcm91cChvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlc3Ryb3lcbiAgICovXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgcGx1Z2luRXZlbnQoJ2Rlc3Ryb3knLCB0aGlzKTtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIGVsW2V4cGFuZG9dID0gbnVsbDtcbiAgICBvZmYoZWwsICdtb3VzZWRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgICBvZmYoZWwsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25UYXBTdGFydCk7XG4gICAgb2ZmKGVsLCAncG9pbnRlcmRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcblxuICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgb2ZmKGVsLCAnZHJhZ292ZXInLCB0aGlzKTtcbiAgICAgIG9mZihlbCwgJ2RyYWdlbnRlcicsIHRoaXMpO1xuICAgIH0gLy8gUmVtb3ZlIGRyYWdnYWJsZSBhdHRyaWJ1dGVzXG5cblxuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZWwucXVlcnlTZWxlY3RvckFsbCgnW2RyYWdnYWJsZV0nKSwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RyYWdnYWJsZScpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fb25Ecm9wKCk7XG5cbiAgICB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMoKTtcblxuICAgIHNvcnRhYmxlcy5zcGxpY2Uoc29ydGFibGVzLmluZGV4T2YodGhpcy5lbCksIDEpO1xuICAgIHRoaXMuZWwgPSBlbCA9IG51bGw7XG4gIH0sXG4gIF9oaWRlQ2xvbmU6IGZ1bmN0aW9uIF9oaWRlQ2xvbmUoKSB7XG4gICAgaWYgKCFjbG9uZUhpZGRlbikge1xuICAgICAgcGx1Z2luRXZlbnQoJ2hpZGVDbG9uZScsIHRoaXMpO1xuICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybjtcbiAgICAgIGNzcyhjbG9uZUVsLCAnZGlzcGxheScsICdub25lJyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUgJiYgY2xvbmVFbC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNsb25lRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZUVsKTtcbiAgICAgIH1cblxuICAgICAgY2xvbmVIaWRkZW4gPSB0cnVlO1xuICAgIH1cbiAgfSxcbiAgX3Nob3dDbG9uZTogZnVuY3Rpb24gX3Nob3dDbG9uZShwdXRTb3J0YWJsZSkge1xuICAgIGlmIChwdXRTb3J0YWJsZS5sYXN0UHV0TW9kZSAhPT0gJ2Nsb25lJykge1xuICAgICAgdGhpcy5faGlkZUNsb25lKCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2xvbmVIaWRkZW4pIHtcbiAgICAgIHBsdWdpbkV2ZW50KCdzaG93Q2xvbmUnLCB0aGlzKTtcbiAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm47IC8vIHNob3cgY2xvbmUgYXQgZHJhZ0VsIG9yIG9yaWdpbmFsIHBvc2l0aW9uXG5cbiAgICAgIGlmIChkcmFnRWwucGFyZW50Tm9kZSA9PSByb290RWwgJiYgIXRoaXMub3B0aW9ucy5ncm91cC5yZXZlcnRDbG9uZSkge1xuICAgICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGNsb25lRWwsIGRyYWdFbCk7XG4gICAgICB9IGVsc2UgaWYgKG5leHRFbCkge1xuICAgICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGNsb25lRWwsIG5leHRFbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290RWwuYXBwZW5kQ2hpbGQoY2xvbmVFbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3JvdXAucmV2ZXJ0Q2xvbmUpIHtcbiAgICAgICAgdGhpcy5hbmltYXRlKGRyYWdFbCwgY2xvbmVFbCk7XG4gICAgICB9XG5cbiAgICAgIGNzcyhjbG9uZUVsLCAnZGlzcGxheScsICcnKTtcbiAgICAgIGNsb25lSGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfZ2xvYmFsRHJhZ092ZXIoXG4vKipFdmVudCovXG5ldnQpIHtcbiAgaWYgKGV2dC5kYXRhVHJhbnNmZXIpIHtcbiAgICBldnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnbW92ZSc7XG4gIH1cblxuICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuZnVuY3Rpb24gX29uTW92ZShmcm9tRWwsIHRvRWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldEVsLCB0YXJnZXRSZWN0LCBvcmlnaW5hbEV2ZW50LCB3aWxsSW5zZXJ0QWZ0ZXIpIHtcbiAgdmFyIGV2dCxcbiAgICAgIHNvcnRhYmxlID0gZnJvbUVsW2V4cGFuZG9dLFxuICAgICAgb25Nb3ZlRm4gPSBzb3J0YWJsZS5vcHRpb25zLm9uTW92ZSxcbiAgICAgIHJldFZhbDsgLy8gU3VwcG9ydCBmb3IgbmV3IEN1c3RvbUV2ZW50IGZlYXR1cmVcblxuICBpZiAod2luZG93LkN1c3RvbUV2ZW50ICYmICFJRTExT3JMZXNzICYmICFFZGdlKSB7XG4gICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KCdtb3ZlJywge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldnQuaW5pdEV2ZW50KCdtb3ZlJywgdHJ1ZSwgdHJ1ZSk7XG4gIH1cblxuICBldnQudG8gPSB0b0VsO1xuICBldnQuZnJvbSA9IGZyb21FbDtcbiAgZXZ0LmRyYWdnZWQgPSBkcmFnRWw7XG4gIGV2dC5kcmFnZ2VkUmVjdCA9IGRyYWdSZWN0O1xuICBldnQucmVsYXRlZCA9IHRhcmdldEVsIHx8IHRvRWw7XG4gIGV2dC5yZWxhdGVkUmVjdCA9IHRhcmdldFJlY3QgfHwgZ2V0UmVjdCh0b0VsKTtcbiAgZXZ0LndpbGxJbnNlcnRBZnRlciA9IHdpbGxJbnNlcnRBZnRlcjtcbiAgZXZ0Lm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuICBmcm9tRWwuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gIGlmIChvbk1vdmVGbikge1xuICAgIHJldFZhbCA9IG9uTW92ZUZuLmNhbGwoc29ydGFibGUsIGV2dCwgb3JpZ2luYWxFdmVudCk7XG4gIH1cblxuICByZXR1cm4gcmV0VmFsO1xufVxuXG5mdW5jdGlvbiBfZGlzYWJsZURyYWdnYWJsZShlbCkge1xuICBlbC5kcmFnZ2FibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3Vuc2lsZW50KCkge1xuICBfc2lsZW50ID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF9naG9zdElzRmlyc3QoZXZ0LCB2ZXJ0aWNhbCwgc29ydGFibGUpIHtcbiAgdmFyIHJlY3QgPSBnZXRSZWN0KGdldENoaWxkKHNvcnRhYmxlLmVsLCAwLCBzb3J0YWJsZS5vcHRpb25zLCB0cnVlKSk7XG4gIHZhciBzcGFjZXIgPSAxMDtcbiAgcmV0dXJuIHZlcnRpY2FsID8gZXZ0LmNsaWVudFggPCByZWN0LmxlZnQgLSBzcGFjZXIgfHwgZXZ0LmNsaWVudFkgPCByZWN0LnRvcCAmJiBldnQuY2xpZW50WCA8IHJlY3QucmlnaHQgOiBldnQuY2xpZW50WSA8IHJlY3QudG9wIC0gc3BhY2VyIHx8IGV2dC5jbGllbnRZIDwgcmVjdC5ib3R0b20gJiYgZXZ0LmNsaWVudFggPCByZWN0LmxlZnQ7XG59XG5cbmZ1bmN0aW9uIF9naG9zdElzTGFzdChldnQsIHZlcnRpY2FsLCBzb3J0YWJsZSkge1xuICB2YXIgcmVjdCA9IGdldFJlY3QobGFzdENoaWxkKHNvcnRhYmxlLmVsLCBzb3J0YWJsZS5vcHRpb25zLmRyYWdnYWJsZSkpO1xuICB2YXIgc3BhY2VyID0gMTA7XG4gIHJldHVybiB2ZXJ0aWNhbCA/IGV2dC5jbGllbnRYID4gcmVjdC5yaWdodCArIHNwYWNlciB8fCBldnQuY2xpZW50WCA8PSByZWN0LnJpZ2h0ICYmIGV2dC5jbGllbnRZID4gcmVjdC5ib3R0b20gJiYgZXZ0LmNsaWVudFggPj0gcmVjdC5sZWZ0IDogZXZ0LmNsaWVudFggPiByZWN0LnJpZ2h0ICYmIGV2dC5jbGllbnRZID4gcmVjdC50b3AgfHwgZXZ0LmNsaWVudFggPD0gcmVjdC5yaWdodCAmJiBldnQuY2xpZW50WSA+IHJlY3QuYm90dG9tICsgc3BhY2VyO1xufVxuXG5mdW5jdGlvbiBfZ2V0U3dhcERpcmVjdGlvbihldnQsIHRhcmdldCwgdGFyZ2V0UmVjdCwgdmVydGljYWwsIHN3YXBUaHJlc2hvbGQsIGludmVydGVkU3dhcFRocmVzaG9sZCwgaW52ZXJ0U3dhcCwgaXNMYXN0VGFyZ2V0KSB7XG4gIHZhciBtb3VzZU9uQXhpcyA9IHZlcnRpY2FsID8gZXZ0LmNsaWVudFkgOiBldnQuY2xpZW50WCxcbiAgICAgIHRhcmdldExlbmd0aCA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC5oZWlnaHQgOiB0YXJnZXRSZWN0LndpZHRoLFxuICAgICAgdGFyZ2V0UzEgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QudG9wIDogdGFyZ2V0UmVjdC5sZWZ0LFxuICAgICAgdGFyZ2V0UzIgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QuYm90dG9tIDogdGFyZ2V0UmVjdC5yaWdodCxcbiAgICAgIGludmVydCA9IGZhbHNlO1xuXG4gIGlmICghaW52ZXJ0U3dhcCkge1xuICAgIC8vIE5ldmVyIGludmVydCBvciBjcmVhdGUgZHJhZ0VsIHNoYWRvdyB3aGVuIHRhcmdldCBtb3ZlbWVuZXQgY2F1c2VzIG1vdXNlIHRvIG1vdmUgcGFzdCB0aGUgZW5kIG9mIHJlZ3VsYXIgc3dhcFRocmVzaG9sZFxuICAgIGlmIChpc0xhc3RUYXJnZXQgJiYgdGFyZ2V0TW92ZURpc3RhbmNlIDwgdGFyZ2V0TGVuZ3RoICogc3dhcFRocmVzaG9sZCkge1xuICAgICAgLy8gbXVsdGlwbGllZCBvbmx5IGJ5IHN3YXBUaHJlc2hvbGQgYmVjYXVzZSBtb3VzZSB3aWxsIGFscmVhZHkgYmUgaW5zaWRlIHRhcmdldCBieSAoMSAtIHRocmVzaG9sZCkgKiB0YXJnZXRMZW5ndGggLyAyXG4gICAgICAvLyBjaGVjayBpZiBwYXN0IGZpcnN0IGludmVydCB0aHJlc2hvbGQgb24gc2lkZSBvcHBvc2l0ZSBvZiBsYXN0RGlyZWN0aW9uXG4gICAgICBpZiAoIXBhc3RGaXJzdEludmVydFRocmVzaCAmJiAobGFzdERpcmVjdGlvbiA9PT0gMSA/IG1vdXNlT25BeGlzID4gdGFyZ2V0UzEgKyB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyIDogbW91c2VPbkF4aXMgPCB0YXJnZXRTMiAtIHRhcmdldExlbmd0aCAqIGludmVydGVkU3dhcFRocmVzaG9sZCAvIDIpKSB7XG4gICAgICAgIC8vIHBhc3QgZmlyc3QgaW52ZXJ0IHRocmVzaG9sZCwgZG8gbm90IHJlc3RyaWN0IGludmVydGVkIHRocmVzaG9sZCB0byBkcmFnRWwgc2hhZG93XG4gICAgICAgIHBhc3RGaXJzdEludmVydFRocmVzaCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFzdEZpcnN0SW52ZXJ0VGhyZXNoKSB7XG4gICAgICAgIC8vIGRyYWdFbCBzaGFkb3cgKHRhcmdldCBtb3ZlIGRpc3RhbmNlIHNoYWRvdylcbiAgICAgICAgaWYgKGxhc3REaXJlY3Rpb24gPT09IDEgPyBtb3VzZU9uQXhpcyA8IHRhcmdldFMxICsgdGFyZ2V0TW92ZURpc3RhbmNlIC8vIG92ZXIgZHJhZ0VsIHNoYWRvd1xuICAgICAgICA6IG1vdXNlT25BeGlzID4gdGFyZ2V0UzIgLSB0YXJnZXRNb3ZlRGlzdGFuY2UpIHtcbiAgICAgICAgICByZXR1cm4gLWxhc3REaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmVydCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlZ3VsYXJcbiAgICAgIGlmIChtb3VzZU9uQXhpcyA+IHRhcmdldFMxICsgdGFyZ2V0TGVuZ3RoICogKDEgLSBzd2FwVGhyZXNob2xkKSAvIDIgJiYgbW91c2VPbkF4aXMgPCB0YXJnZXRTMiAtIHRhcmdldExlbmd0aCAqICgxIC0gc3dhcFRocmVzaG9sZCkgLyAyKSB7XG4gICAgICAgIHJldHVybiBfZ2V0SW5zZXJ0RGlyZWN0aW9uKHRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW52ZXJ0ID0gaW52ZXJ0IHx8IGludmVydFN3YXA7XG5cbiAgaWYgKGludmVydCkge1xuICAgIC8vIEludmVydCBvZiByZWd1bGFyXG4gICAgaWYgKG1vdXNlT25BeGlzIDwgdGFyZ2V0UzEgKyB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyIHx8IG1vdXNlT25BeGlzID4gdGFyZ2V0UzIgLSB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyKSB7XG4gICAgICByZXR1cm4gbW91c2VPbkF4aXMgPiB0YXJnZXRTMSArIHRhcmdldExlbmd0aCAvIDIgPyAxIDogLTE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG4vKipcbiAqIEdldHMgdGhlIGRpcmVjdGlvbiBkcmFnRWwgbXVzdCBiZSBzd2FwcGVkIHJlbGF0aXZlIHRvIHRhcmdldCBpbiBvcmRlciB0byBtYWtlIGl0XG4gKiBzZWVtIHRoYXQgZHJhZ0VsIGhhcyBiZWVuIFwiaW5zZXJ0ZWRcIiBpbnRvIHRoYXQgZWxlbWVudCdzIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gdGFyZ2V0ICAgICAgIFRoZSB0YXJnZXQgd2hvc2UgcG9zaXRpb24gZHJhZ0VsIGlzIGJlaW5nIGluc2VydGVkIGF0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgIERpcmVjdGlvbiBkcmFnRWwgbXVzdCBiZSBzd2FwcGVkXG4gKi9cblxuXG5mdW5jdGlvbiBfZ2V0SW5zZXJ0RGlyZWN0aW9uKHRhcmdldCkge1xuICBpZiAoaW5kZXgoZHJhZ0VsKSA8IGluZGV4KHRhcmdldCkpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbn1cbi8qKlxuICogR2VuZXJhdGUgaWRcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gZWxcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gX2dlbmVyYXRlSWQoZWwpIHtcbiAgdmFyIHN0ciA9IGVsLnRhZ05hbWUgKyBlbC5jbGFzc05hbWUgKyBlbC5zcmMgKyBlbC5ocmVmICsgZWwudGV4dENvbnRlbnQsXG4gICAgICBpID0gc3RyLmxlbmd0aCxcbiAgICAgIHN1bSA9IDA7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHN1bSArPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuXG4gIHJldHVybiBzdW0udG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBfc2F2ZUlucHV0Q2hlY2tlZFN0YXRlKHJvb3QpIHtcbiAgc2F2ZWRJbnB1dENoZWNrZWQubGVuZ3RoID0gMDtcbiAgdmFyIGlucHV0cyA9IHJvb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lucHV0Jyk7XG4gIHZhciBpZHggPSBpbnB1dHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpZHgtLSkge1xuICAgIHZhciBlbCA9IGlucHV0c1tpZHhdO1xuICAgIGVsLmNoZWNrZWQgJiYgc2F2ZWRJbnB1dENoZWNrZWQucHVzaChlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX25leHRUaWNrKGZuKSB7XG4gIHJldHVybiBzZXRUaW1lb3V0KGZuLCAwKTtcbn1cblxuZnVuY3Rpb24gX2NhbmNlbE5leHRUaWNrKGlkKSB7XG4gIHJldHVybiBjbGVhclRpbWVvdXQoaWQpO1xufSAvLyBGaXhlZCAjOTczOlxuXG5cbmlmIChkb2N1bWVudEV4aXN0cykge1xuICBvbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIGZ1bmN0aW9uIChldnQpIHtcbiAgICBpZiAoKFNvcnRhYmxlLmFjdGl2ZSB8fCBhd2FpdGluZ0RyYWdTdGFydGVkKSAmJiBldnQuY2FuY2VsYWJsZSkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9KTtcbn0gLy8gRXhwb3J0IHV0aWxzXG5cblxuU29ydGFibGUudXRpbHMgPSB7XG4gIG9uOiBvbixcbiAgb2ZmOiBvZmYsXG4gIGNzczogY3NzLFxuICBmaW5kOiBmaW5kLFxuICBpczogZnVuY3Rpb24gaXMoZWwsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuICEhY2xvc2VzdChlbCwgc2VsZWN0b3IsIGVsLCBmYWxzZSk7XG4gIH0sXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0aHJvdHRsZTogdGhyb3R0bGUsXG4gIGNsb3Nlc3Q6IGNsb3Nlc3QsXG4gIHRvZ2dsZUNsYXNzOiB0b2dnbGVDbGFzcyxcbiAgY2xvbmU6IGNsb25lLFxuICBpbmRleDogaW5kZXgsXG4gIG5leHRUaWNrOiBfbmV4dFRpY2ssXG4gIGNhbmNlbE5leHRUaWNrOiBfY2FuY2VsTmV4dFRpY2ssXG4gIGRldGVjdERpcmVjdGlvbjogX2RldGVjdERpcmVjdGlvbixcbiAgZ2V0Q2hpbGQ6IGdldENoaWxkXG59O1xuLyoqXG4gKiBHZXQgdGhlIFNvcnRhYmxlIGluc3RhbmNlIG9mIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50XG4gKiBAcmV0dXJuIHtTb3J0YWJsZXx1bmRlZmluZWR9ICAgICAgICAgVGhlIGluc3RhbmNlIG9mIFNvcnRhYmxlXG4gKi9cblxuU29ydGFibGUuZ2V0ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnRbZXhwYW5kb107XG59O1xuLyoqXG4gKiBNb3VudCBhIHBsdWdpbiB0byBTb3J0YWJsZVxuICogQHBhcmFtICB7Li4uU29ydGFibGVQbHVnaW58U29ydGFibGVQbHVnaW5bXX0gcGx1Z2lucyAgICAgICBQbHVnaW5zIGJlaW5nIG1vdW50ZWRcbiAqL1xuXG5cblNvcnRhYmxlLm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGx1Z2lucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBwbHVnaW5zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKHBsdWdpbnNbMF0uY29uc3RydWN0b3IgPT09IEFycmF5KSBwbHVnaW5zID0gcGx1Z2luc1swXTtcbiAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICBpZiAoIXBsdWdpbi5wcm90b3R5cGUgfHwgIXBsdWdpbi5wcm90b3R5cGUuY29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IFwiU29ydGFibGU6IE1vdW50ZWQgcGx1Z2luIG11c3QgYmUgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgbm90IFwiLmNvbmNhdCh7fS50b1N0cmluZy5jYWxsKHBsdWdpbikpO1xuICAgIH1cblxuICAgIGlmIChwbHVnaW4udXRpbHMpIFNvcnRhYmxlLnV0aWxzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIFNvcnRhYmxlLnV0aWxzKSwgcGx1Z2luLnV0aWxzKTtcbiAgICBQbHVnaW5NYW5hZ2VyLm1vdW50KHBsdWdpbik7XG4gIH0pO1xufTtcbi8qKlxuICogQ3JlYXRlIHNvcnRhYmxlIGluc3RhbmNlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSAgZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgIFtvcHRpb25zXVxuICovXG5cblxuU29ydGFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgU29ydGFibGUoZWwsIG9wdGlvbnMpO1xufTsgLy8gRXhwb3J0XG5cblxuU29ydGFibGUudmVyc2lvbiA9IHZlcnNpb247XG5cbnZhciBhdXRvU2Nyb2xscyA9IFtdLFxuICAgIHNjcm9sbEVsLFxuICAgIHNjcm9sbFJvb3RFbCxcbiAgICBzY3JvbGxpbmcgPSBmYWxzZSxcbiAgICBsYXN0QXV0b1Njcm9sbFgsXG4gICAgbGFzdEF1dG9TY3JvbGxZLFxuICAgIHRvdWNoRXZ0JDEsXG4gICAgcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWw7XG5cbmZ1bmN0aW9uIEF1dG9TY3JvbGxQbHVnaW4oKSB7XG4gIGZ1bmN0aW9uIEF1dG9TY3JvbGwoKSB7XG4gICAgdGhpcy5kZWZhdWx0cyA9IHtcbiAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgIGZvcmNlQXV0b1Njcm9sbEZhbGxiYWNrOiBmYWxzZSxcbiAgICAgIHNjcm9sbFNlbnNpdGl2aXR5OiAzMCxcbiAgICAgIHNjcm9sbFNwZWVkOiAxMCxcbiAgICAgIGJ1YmJsZVNjcm9sbDogdHJ1ZVxuICAgIH07IC8vIEJpbmQgYWxsIHByaXZhdGUgbWV0aG9kc1xuXG4gICAgZm9yICh2YXIgZm4gaW4gdGhpcykge1xuICAgICAgaWYgKGZuLmNoYXJBdCgwKSA9PT0gJ18nICYmIHR5cGVvZiB0aGlzW2ZuXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzW2ZuXSA9IHRoaXNbZm5dLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgQXV0b1Njcm9sbC5wcm90b3R5cGUgPSB7XG4gICAgZHJhZ1N0YXJ0ZWQ6IGZ1bmN0aW9uIGRyYWdTdGFydGVkKF9yZWYpIHtcbiAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gX3JlZi5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICBpZiAodGhpcy5zb3J0YWJsZS5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdkcmFnb3ZlcicsIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgICAgICAgIG9uKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsRXZlbnQudG91Y2hlcykge1xuICAgICAgICAgIG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdPdmVyQ29tcGxldGVkOiBmdW5jdGlvbiBkcmFnT3ZlckNvbXBsZXRlZChfcmVmMikge1xuICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBfcmVmMi5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICAvLyBGb3Igd2hlbiBidWJibGluZyBpcyBjYW5jZWxlZCBhbmQgdXNpbmcgZmFsbGJhY2sgKGZhbGxiYWNrICd0b3VjaG1vdmUnIGFsd2F5cyByZWFjaGVkKVxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZHJhZ092ZXJCdWJibGUgJiYgIW9yaWdpbmFsRXZlbnQucm9vdEVsKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwob3JpZ2luYWxFdmVudCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcm9wOiBmdW5jdGlvbiBkcm9wKCkge1xuICAgICAgaWYgKHRoaXMuc29ydGFibGUubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ2RyYWdvdmVyJywgdGhpcy5faGFuZGxlQXV0b1Njcm9sbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmYoZG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICB9XG5cbiAgICAgIGNsZWFyUG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwoKTtcbiAgICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICAgIGNhbmNlbFRocm90dGxlKCk7XG4gICAgfSxcbiAgICBudWxsaW5nOiBmdW5jdGlvbiBudWxsaW5nKCkge1xuICAgICAgdG91Y2hFdnQkMSA9IHNjcm9sbFJvb3RFbCA9IHNjcm9sbEVsID0gc2Nyb2xsaW5nID0gcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgPSBsYXN0QXV0b1Njcm9sbFggPSBsYXN0QXV0b1Njcm9sbFkgPSBudWxsO1xuICAgICAgYXV0b1Njcm9sbHMubGVuZ3RoID0gMDtcbiAgICB9LFxuICAgIF9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGw6IGZ1bmN0aW9uIF9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwoZXZ0KSB7XG4gICAgICB0aGlzLl9oYW5kbGVBdXRvU2Nyb2xsKGV2dCwgdHJ1ZSk7XG4gICAgfSxcbiAgICBfaGFuZGxlQXV0b1Njcm9sbDogZnVuY3Rpb24gX2hhbmRsZUF1dG9TY3JvbGwoZXZ0LCBmYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHggPSAoZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCkuY2xpZW50WCxcbiAgICAgICAgICB5ID0gKGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpLmNsaWVudFksXG4gICAgICAgICAgZWxlbSA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICB0b3VjaEV2dCQxID0gZXZ0OyAvLyBJRSBkb2VzIG5vdCBzZWVtIHRvIGhhdmUgbmF0aXZlIGF1dG9zY3JvbGwsXG4gICAgICAvLyBFZGdlJ3MgYXV0b3Njcm9sbCBzZWVtcyB0b28gY29uZGl0aW9uYWwsXG4gICAgICAvLyBNQUNPUyBTYWZhcmkgZG9lcyBub3QgaGF2ZSBhdXRvc2Nyb2xsLFxuICAgICAgLy8gRmlyZWZveCBhbmQgQ2hyb21lIGFyZSBnb29kXG5cbiAgICAgIGlmIChmYWxsYmFjayB8fCB0aGlzLm9wdGlvbnMuZm9yY2VBdXRvU2Nyb2xsRmFsbGJhY2sgfHwgRWRnZSB8fCBJRTExT3JMZXNzIHx8IFNhZmFyaSkge1xuICAgICAgICBhdXRvU2Nyb2xsKGV2dCwgdGhpcy5vcHRpb25zLCBlbGVtLCBmYWxsYmFjayk7IC8vIExpc3RlbmVyIGZvciBwb2ludGVyIGVsZW1lbnQgY2hhbmdlXG5cbiAgICAgICAgdmFyIG9nRWxlbVNjcm9sbGVyID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWxlbSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHNjcm9sbGluZyAmJiAoIXBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsIHx8IHggIT09IGxhc3RBdXRvU2Nyb2xsWCB8fCB5ICE9PSBsYXN0QXV0b1Njcm9sbFkpKSB7XG4gICAgICAgICAgcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgJiYgY2xlYXJQb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCgpOyAvLyBEZXRlY3QgZm9yIHBvaW50ZXIgZWxlbSBjaGFuZ2UsIGVtdWxhdGluZyBuYXRpdmUgRG5EIGJlaGF2aW91clxuXG4gICAgICAgICAgcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV3RWxlbSA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSksIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAobmV3RWxlbSAhPT0gb2dFbGVtU2Nyb2xsZXIpIHtcbiAgICAgICAgICAgICAgb2dFbGVtU2Nyb2xsZXIgPSBuZXdFbGVtO1xuICAgICAgICAgICAgICBjbGVhckF1dG9TY3JvbGxzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF1dG9TY3JvbGwoZXZ0LCBfdGhpcy5vcHRpb25zLCBuZXdFbGVtLCBmYWxsYmFjayk7XG4gICAgICAgICAgfSwgMTApO1xuICAgICAgICAgIGxhc3RBdXRvU2Nyb2xsWCA9IHg7XG4gICAgICAgICAgbGFzdEF1dG9TY3JvbGxZID0geTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgRG5EIGlzIGVuYWJsZWQgKGFuZCBicm93c2VyIGhhcyBnb29kIGF1dG9zY3JvbGxpbmcpLCBmaXJzdCBhdXRvc2Nyb2xsIHdpbGwgYWxyZWFkeSBzY3JvbGwsIHNvIGdldCBwYXJlbnQgYXV0b3Njcm9sbCBvZiBmaXJzdCBhdXRvc2Nyb2xsXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmJ1YmJsZVNjcm9sbCB8fCBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbGVtLCB0cnVlKSA9PT0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpKSB7XG4gICAgICAgICAgY2xlYXJBdXRvU2Nyb2xscygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF1dG9TY3JvbGwoZXZ0LCB0aGlzLm9wdGlvbnMsIGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsZW0sIGZhbHNlKSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzKEF1dG9TY3JvbGwsIHtcbiAgICBwbHVnaW5OYW1lOiAnc2Nyb2xsJyxcbiAgICBpbml0aWFsaXplQnlEZWZhdWx0OiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjbGVhckF1dG9TY3JvbGxzKCkge1xuICBhdXRvU2Nyb2xscy5mb3JFYWNoKGZ1bmN0aW9uIChhdXRvU2Nyb2xsKSB7XG4gICAgY2xlYXJJbnRlcnZhbChhdXRvU2Nyb2xsLnBpZCk7XG4gIH0pO1xuICBhdXRvU2Nyb2xscyA9IFtdO1xufVxuXG5mdW5jdGlvbiBjbGVhclBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKCkge1xuICBjbGVhckludGVydmFsKHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKTtcbn1cblxudmFyIGF1dG9TY3JvbGwgPSB0aHJvdHRsZShmdW5jdGlvbiAoZXZ0LCBvcHRpb25zLCByb290RWwsIGlzRmFsbGJhY2spIHtcbiAgLy8gQnVnOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01MDU1MjFcbiAgaWYgKCFvcHRpb25zLnNjcm9sbCkgcmV0dXJuO1xuICB2YXIgeCA9IChldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0KS5jbGllbnRYLFxuICAgICAgeSA9IChldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0KS5jbGllbnRZLFxuICAgICAgc2VucyA9IG9wdGlvbnMuc2Nyb2xsU2Vuc2l0aXZpdHksXG4gICAgICBzcGVlZCA9IG9wdGlvbnMuc2Nyb2xsU3BlZWQsXG4gICAgICB3aW5TY3JvbGxlciA9IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgdmFyIHNjcm9sbFRoaXNJbnN0YW5jZSA9IGZhbHNlLFxuICAgICAgc2Nyb2xsQ3VzdG9tRm47IC8vIE5ldyBzY3JvbGwgcm9vdCwgc2V0IHNjcm9sbEVsXG5cbiAgaWYgKHNjcm9sbFJvb3RFbCAhPT0gcm9vdEVsKSB7XG4gICAgc2Nyb2xsUm9vdEVsID0gcm9vdEVsO1xuICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICBzY3JvbGxFbCA9IG9wdGlvbnMuc2Nyb2xsO1xuICAgIHNjcm9sbEN1c3RvbUZuID0gb3B0aW9ucy5zY3JvbGxGbjtcblxuICAgIGlmIChzY3JvbGxFbCA9PT0gdHJ1ZSkge1xuICAgICAgc2Nyb2xsRWwgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChyb290RWwsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsYXllcnNPdXQgPSAwO1xuICB2YXIgY3VycmVudFBhcmVudCA9IHNjcm9sbEVsO1xuXG4gIGRvIHtcbiAgICB2YXIgZWwgPSBjdXJyZW50UGFyZW50LFxuICAgICAgICByZWN0ID0gZ2V0UmVjdChlbCksXG4gICAgICAgIHRvcCA9IHJlY3QudG9wLFxuICAgICAgICBib3R0b20gPSByZWN0LmJvdHRvbSxcbiAgICAgICAgbGVmdCA9IHJlY3QubGVmdCxcbiAgICAgICAgcmlnaHQgPSByZWN0LnJpZ2h0LFxuICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0LFxuICAgICAgICBjYW5TY3JvbGxYID0gdm9pZCAwLFxuICAgICAgICBjYW5TY3JvbGxZID0gdm9pZCAwLFxuICAgICAgICBzY3JvbGxXaWR0aCA9IGVsLnNjcm9sbFdpZHRoLFxuICAgICAgICBzY3JvbGxIZWlnaHQgPSBlbC5zY3JvbGxIZWlnaHQsXG4gICAgICAgIGVsQ1NTID0gY3NzKGVsKSxcbiAgICAgICAgc2Nyb2xsUG9zWCA9IGVsLnNjcm9sbExlZnQsXG4gICAgICAgIHNjcm9sbFBvc1kgPSBlbC5zY3JvbGxUb3A7XG5cbiAgICBpZiAoZWwgPT09IHdpblNjcm9sbGVyKSB7XG4gICAgICBjYW5TY3JvbGxYID0gd2lkdGggPCBzY3JvbGxXaWR0aCAmJiAoZWxDU1Mub3ZlcmZsb3dYID09PSAnYXV0bycgfHwgZWxDU1Mub3ZlcmZsb3dYID09PSAnc2Nyb2xsJyB8fCBlbENTUy5vdmVyZmxvd1ggPT09ICd2aXNpYmxlJyk7XG4gICAgICBjYW5TY3JvbGxZID0gaGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0ICYmIChlbENTUy5vdmVyZmxvd1kgPT09ICdhdXRvJyB8fCBlbENTUy5vdmVyZmxvd1kgPT09ICdzY3JvbGwnIHx8IGVsQ1NTLm92ZXJmbG93WSA9PT0gJ3Zpc2libGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FuU2Nyb2xsWCA9IHdpZHRoIDwgc2Nyb2xsV2lkdGggJiYgKGVsQ1NTLm92ZXJmbG93WCA9PT0gJ2F1dG8nIHx8IGVsQ1NTLm92ZXJmbG93WCA9PT0gJ3Njcm9sbCcpO1xuICAgICAgY2FuU2Nyb2xsWSA9IGhlaWdodCA8IHNjcm9sbEhlaWdodCAmJiAoZWxDU1Mub3ZlcmZsb3dZID09PSAnYXV0bycgfHwgZWxDU1Mub3ZlcmZsb3dZID09PSAnc2Nyb2xsJyk7XG4gICAgfVxuXG4gICAgdmFyIHZ4ID0gY2FuU2Nyb2xsWCAmJiAoTWF0aC5hYnMocmlnaHQgLSB4KSA8PSBzZW5zICYmIHNjcm9sbFBvc1ggKyB3aWR0aCA8IHNjcm9sbFdpZHRoKSAtIChNYXRoLmFicyhsZWZ0IC0geCkgPD0gc2VucyAmJiAhIXNjcm9sbFBvc1gpO1xuICAgIHZhciB2eSA9IGNhblNjcm9sbFkgJiYgKE1hdGguYWJzKGJvdHRvbSAtIHkpIDw9IHNlbnMgJiYgc2Nyb2xsUG9zWSArIGhlaWdodCA8IHNjcm9sbEhlaWdodCkgLSAoTWF0aC5hYnModG9wIC0geSkgPD0gc2VucyAmJiAhIXNjcm9sbFBvc1kpO1xuXG4gICAgaWYgKCFhdXRvU2Nyb2xsc1tsYXllcnNPdXRdKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBsYXllcnNPdXQ7IGkrKykge1xuICAgICAgICBpZiAoIWF1dG9TY3JvbGxzW2ldKSB7XG4gICAgICAgICAgYXV0b1Njcm9sbHNbaV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnZ4ICE9IHZ4IHx8IGF1dG9TY3JvbGxzW2xheWVyc091dF0udnkgIT0gdnkgfHwgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5lbCAhPT0gZWwpIHtcbiAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0uZWwgPSBlbDtcbiAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0udnggPSB2eDtcbiAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0udnkgPSB2eTtcbiAgICAgIGNsZWFySW50ZXJ2YWwoYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5waWQpO1xuXG4gICAgICBpZiAodnggIT0gMCB8fCB2eSAhPSAwKSB7XG4gICAgICAgIHNjcm9sbFRoaXNJbnN0YW5jZSA9IHRydWU7XG4gICAgICAgIC8qIGpzaGludCBsb29wZnVuYzp0cnVlICovXG5cbiAgICAgICAgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5waWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gZW11bGF0ZSBkcmFnIG92ZXIgZHVyaW5nIGF1dG9zY3JvbGwgKGZhbGxiYWNrKSwgZW11bGF0aW5nIG5hdGl2ZSBEbkQgYmVoYXZpb3VyXG4gICAgICAgICAgaWYgKGlzRmFsbGJhY2sgJiYgdGhpcy5sYXllciA9PT0gMCkge1xuICAgICAgICAgICAgU29ydGFibGUuYWN0aXZlLl9vblRvdWNoTW92ZSh0b3VjaEV2dCQxKTsgLy8gVG8gbW92ZSBnaG9zdCBpZiBpdCBpcyBwb3NpdGlvbmVkIGFic29sdXRlbHlcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzY3JvbGxPZmZzZXRZID0gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnkgPyBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS52eSAqIHNwZWVkIDogMDtcbiAgICAgICAgICB2YXIgc2Nyb2xsT2Zmc2V0WCA9IGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLnZ4ID8gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnggKiBzcGVlZCA6IDA7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHNjcm9sbEN1c3RvbUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsQ3VzdG9tRm4uY2FsbChTb3J0YWJsZS5kcmFnZ2VkLnBhcmVudE5vZGVbZXhwYW5kb10sIHNjcm9sbE9mZnNldFgsIHNjcm9sbE9mZnNldFksIGV2dCwgdG91Y2hFdnQkMSwgYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0uZWwpICE9PSAnY29udGludWUnKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY3JvbGxCeShhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS5lbCwgc2Nyb2xsT2Zmc2V0WCwgc2Nyb2xsT2Zmc2V0WSk7XG4gICAgICAgIH0uYmluZCh7XG4gICAgICAgICAgbGF5ZXI6IGxheWVyc091dFxuICAgICAgICB9KSwgMjQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxheWVyc091dCsrO1xuICB9IHdoaWxlIChvcHRpb25zLmJ1YmJsZVNjcm9sbCAmJiBjdXJyZW50UGFyZW50ICE9PSB3aW5TY3JvbGxlciAmJiAoY3VycmVudFBhcmVudCA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGN1cnJlbnRQYXJlbnQsIGZhbHNlKSkpO1xuXG4gIHNjcm9sbGluZyA9IHNjcm9sbFRoaXNJbnN0YW5jZTsgLy8gaW4gY2FzZSBhbm90aGVyIGZ1bmN0aW9uIGNhdGNoZXMgc2Nyb2xsaW5nIGFzIGZhbHNlIGluIGJldHdlZW4gd2hlbiBpdCBpcyBub3Rcbn0sIDMwKTtcblxudmFyIGRyb3AgPSBmdW5jdGlvbiBkcm9wKF9yZWYpIHtcbiAgdmFyIG9yaWdpbmFsRXZlbnQgPSBfcmVmLm9yaWdpbmFsRXZlbnQsXG4gICAgICBwdXRTb3J0YWJsZSA9IF9yZWYucHV0U29ydGFibGUsXG4gICAgICBkcmFnRWwgPSBfcmVmLmRyYWdFbCxcbiAgICAgIGFjdGl2ZVNvcnRhYmxlID0gX3JlZi5hY3RpdmVTb3J0YWJsZSxcbiAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCA9IF9yZWYuZGlzcGF0Y2hTb3J0YWJsZUV2ZW50LFxuICAgICAgaGlkZUdob3N0Rm9yVGFyZ2V0ID0gX3JlZi5oaWRlR2hvc3RGb3JUYXJnZXQsXG4gICAgICB1bmhpZGVHaG9zdEZvclRhcmdldCA9IF9yZWYudW5oaWRlR2hvc3RGb3JUYXJnZXQ7XG4gIGlmICghb3JpZ2luYWxFdmVudCkgcmV0dXJuO1xuICB2YXIgdG9Tb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IGFjdGl2ZVNvcnRhYmxlO1xuICBoaWRlR2hvc3RGb3JUYXJnZXQoKTtcbiAgdmFyIHRvdWNoID0gb3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBvcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA/IG9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBvcmlnaW5hbEV2ZW50O1xuICB2YXIgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKTtcbiAgdW5oaWRlR2hvc3RGb3JUYXJnZXQoKTtcblxuICBpZiAodG9Tb3J0YWJsZSAmJiAhdG9Tb3J0YWJsZS5lbC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50KCdzcGlsbCcpO1xuICAgIHRoaXMub25TcGlsbCh7XG4gICAgICBkcmFnRWw6IGRyYWdFbCxcbiAgICAgIHB1dFNvcnRhYmxlOiBwdXRTb3J0YWJsZVxuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBSZXZlcnQoKSB7fVxuXG5SZXZlcnQucHJvdG90eXBlID0ge1xuICBzdGFydEluZGV4OiBudWxsLFxuICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIGRyYWdTdGFydChfcmVmMikge1xuICAgIHZhciBvbGREcmFnZ2FibGVJbmRleCA9IF9yZWYyLm9sZERyYWdnYWJsZUluZGV4O1xuICAgIHRoaXMuc3RhcnRJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4O1xuICB9LFxuICBvblNwaWxsOiBmdW5jdGlvbiBvblNwaWxsKF9yZWYzKSB7XG4gICAgdmFyIGRyYWdFbCA9IF9yZWYzLmRyYWdFbCxcbiAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmMy5wdXRTb3J0YWJsZTtcbiAgICB0aGlzLnNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuXG4gICAgaWYgKHB1dFNvcnRhYmxlKSB7XG4gICAgICBwdXRTb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFNpYmxpbmcgPSBnZXRDaGlsZCh0aGlzLnNvcnRhYmxlLmVsLCB0aGlzLnN0YXJ0SW5kZXgsIHRoaXMub3B0aW9ucyk7XG5cbiAgICBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgIHRoaXMuc29ydGFibGUuZWwuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgbmV4dFNpYmxpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNvcnRhYmxlLmVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG4gICAgfVxuXG4gICAgdGhpcy5zb3J0YWJsZS5hbmltYXRlQWxsKCk7XG5cbiAgICBpZiAocHV0U29ydGFibGUpIHtcbiAgICAgIHB1dFNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICB9XG4gIH0sXG4gIGRyb3A6IGRyb3Bcbn07XG5cbl9leHRlbmRzKFJldmVydCwge1xuICBwbHVnaW5OYW1lOiAncmV2ZXJ0T25TcGlsbCdcbn0pO1xuXG5mdW5jdGlvbiBSZW1vdmUoKSB7fVxuXG5SZW1vdmUucHJvdG90eXBlID0ge1xuICBvblNwaWxsOiBmdW5jdGlvbiBvblNwaWxsKF9yZWY0KSB7XG4gICAgdmFyIGRyYWdFbCA9IF9yZWY0LmRyYWdFbCxcbiAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmNC5wdXRTb3J0YWJsZTtcbiAgICB2YXIgcGFyZW50U29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCB0aGlzLnNvcnRhYmxlO1xuICAgIHBhcmVudFNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgIGRyYWdFbC5wYXJlbnROb2RlICYmIGRyYWdFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRyYWdFbCk7XG4gICAgcGFyZW50U29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICB9LFxuICBkcm9wOiBkcm9wXG59O1xuXG5fZXh0ZW5kcyhSZW1vdmUsIHtcbiAgcGx1Z2luTmFtZTogJ3JlbW92ZU9uU3BpbGwnXG59KTtcblxudmFyIGxhc3RTd2FwRWw7XG5cbmZ1bmN0aW9uIFN3YXBQbHVnaW4oKSB7XG4gIGZ1bmN0aW9uIFN3YXAoKSB7XG4gICAgdGhpcy5kZWZhdWx0cyA9IHtcbiAgICAgIHN3YXBDbGFzczogJ3NvcnRhYmxlLXN3YXAtaGlnaGxpZ2h0J1xuICAgIH07XG4gIH1cblxuICBTd2FwLnByb3RvdHlwZSA9IHtcbiAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIGRyYWdTdGFydChfcmVmKSB7XG4gICAgICB2YXIgZHJhZ0VsID0gX3JlZi5kcmFnRWw7XG4gICAgICBsYXN0U3dhcEVsID0gZHJhZ0VsO1xuICAgIH0sXG4gICAgZHJhZ092ZXJWYWxpZDogZnVuY3Rpb24gZHJhZ092ZXJWYWxpZChfcmVmMikge1xuICAgICAgdmFyIGNvbXBsZXRlZCA9IF9yZWYyLmNvbXBsZXRlZCxcbiAgICAgICAgICB0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICAgICAgb25Nb3ZlID0gX3JlZjIub25Nb3ZlLFxuICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlID0gX3JlZjIuYWN0aXZlU29ydGFibGUsXG4gICAgICAgICAgY2hhbmdlZCA9IF9yZWYyLmNoYW5nZWQsXG4gICAgICAgICAgY2FuY2VsID0gX3JlZjIuY2FuY2VsO1xuICAgICAgaWYgKCFhY3RpdmVTb3J0YWJsZS5vcHRpb25zLnN3YXApIHJldHVybjtcbiAgICAgIHZhciBlbCA9IHRoaXMuc29ydGFibGUuZWwsXG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQgIT09IGVsKSB7XG4gICAgICAgIHZhciBwcmV2U3dhcEVsID0gbGFzdFN3YXBFbDtcblxuICAgICAgICBpZiAob25Nb3ZlKHRhcmdldCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3ModGFyZ2V0LCBvcHRpb25zLnN3YXBDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgbGFzdFN3YXBFbCA9IHRhcmdldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0U3dhcEVsID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2U3dhcEVsICYmIHByZXZTd2FwRWwgIT09IGxhc3RTd2FwRWwpIHtcbiAgICAgICAgICB0b2dnbGVDbGFzcyhwcmV2U3dhcEVsLCBvcHRpb25zLnN3YXBDbGFzcywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoYW5nZWQoKTtcbiAgICAgIGNvbXBsZXRlZCh0cnVlKTtcbiAgICAgIGNhbmNlbCgpO1xuICAgIH0sXG4gICAgZHJvcDogZnVuY3Rpb24gZHJvcChfcmVmMykge1xuICAgICAgdmFyIGFjdGl2ZVNvcnRhYmxlID0gX3JlZjMuYWN0aXZlU29ydGFibGUsXG4gICAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmMy5wdXRTb3J0YWJsZSxcbiAgICAgICAgICBkcmFnRWwgPSBfcmVmMy5kcmFnRWw7XG4gICAgICB2YXIgdG9Tb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IHRoaXMuc29ydGFibGU7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGxhc3RTd2FwRWwgJiYgdG9nZ2xlQ2xhc3MobGFzdFN3YXBFbCwgb3B0aW9ucy5zd2FwQ2xhc3MsIGZhbHNlKTtcblxuICAgICAgaWYgKGxhc3RTd2FwRWwgJiYgKG9wdGlvbnMuc3dhcCB8fCBwdXRTb3J0YWJsZSAmJiBwdXRTb3J0YWJsZS5vcHRpb25zLnN3YXApKSB7XG4gICAgICAgIGlmIChkcmFnRWwgIT09IGxhc3RTd2FwRWwpIHtcbiAgICAgICAgICB0b1NvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIGlmICh0b1NvcnRhYmxlICE9PSBhY3RpdmVTb3J0YWJsZSkgYWN0aXZlU29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG4gICAgICAgICAgc3dhcE5vZGVzKGRyYWdFbCwgbGFzdFN3YXBFbCk7XG4gICAgICAgICAgdG9Tb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gICAgICAgICAgaWYgKHRvU29ydGFibGUgIT09IGFjdGl2ZVNvcnRhYmxlKSBhY3RpdmVTb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG51bGxpbmc6IGZ1bmN0aW9uIG51bGxpbmcoKSB7XG4gICAgICBsYXN0U3dhcEVsID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcyhTd2FwLCB7XG4gICAgcGx1Z2luTmFtZTogJ3N3YXAnLFxuICAgIGV2ZW50UHJvcGVydGllczogZnVuY3Rpb24gZXZlbnRQcm9wZXJ0aWVzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3dhcEl0ZW06IGxhc3RTd2FwRWxcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc3dhcE5vZGVzKG4xLCBuMikge1xuICB2YXIgcDEgPSBuMS5wYXJlbnROb2RlLFxuICAgICAgcDIgPSBuMi5wYXJlbnROb2RlLFxuICAgICAgaTEsXG4gICAgICBpMjtcbiAgaWYgKCFwMSB8fCAhcDIgfHwgcDEuaXNFcXVhbE5vZGUobjIpIHx8IHAyLmlzRXF1YWxOb2RlKG4xKSkgcmV0dXJuO1xuICBpMSA9IGluZGV4KG4xKTtcbiAgaTIgPSBpbmRleChuMik7XG5cbiAgaWYgKHAxLmlzRXF1YWxOb2RlKHAyKSAmJiBpMSA8IGkyKSB7XG4gICAgaTIrKztcbiAgfVxuXG4gIHAxLmluc2VydEJlZm9yZShuMiwgcDEuY2hpbGRyZW5baTFdKTtcbiAgcDIuaW5zZXJ0QmVmb3JlKG4xLCBwMi5jaGlsZHJlbltpMl0pO1xufVxuXG52YXIgbXVsdGlEcmFnRWxlbWVudHMgPSBbXSxcbiAgICBtdWx0aURyYWdDbG9uZXMgPSBbXSxcbiAgICBsYXN0TXVsdGlEcmFnU2VsZWN0LFxuICAgIC8vIGZvciBzZWxlY3Rpb24gd2l0aCBtb2RpZmllciBrZXkgZG93biAoU0hJRlQpXG5tdWx0aURyYWdTb3J0YWJsZSxcbiAgICBpbml0aWFsRm9sZGluZyA9IGZhbHNlLFxuICAgIC8vIEluaXRpYWwgbXVsdGktZHJhZyBmb2xkIHdoZW4gZHJhZyBzdGFydGVkXG5mb2xkaW5nID0gZmFsc2UsXG4gICAgLy8gRm9sZGluZyBhbnkgb3RoZXIgdGltZVxuZHJhZ1N0YXJ0ZWQgPSBmYWxzZSxcbiAgICBkcmFnRWwkMSxcbiAgICBjbG9uZXNGcm9tUmVjdCxcbiAgICBjbG9uZXNIaWRkZW47XG5cbmZ1bmN0aW9uIE11bHRpRHJhZ1BsdWdpbigpIHtcbiAgZnVuY3Rpb24gTXVsdGlEcmFnKHNvcnRhYmxlKSB7XG4gICAgLy8gQmluZCBhbGwgcHJpdmF0ZSBtZXRob2RzXG4gICAgZm9yICh2YXIgZm4gaW4gdGhpcykge1xuICAgICAgaWYgKGZuLmNoYXJBdCgwKSA9PT0gJ18nICYmIHR5cGVvZiB0aGlzW2ZuXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzW2ZuXSA9IHRoaXNbZm5dLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNvcnRhYmxlLm9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcbiAgICAgIG9uKGRvY3VtZW50LCAncG9pbnRlcnVwJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbihkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICBvbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgIH1cblxuICAgIG9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX2NoZWNrS2V5RG93bik7XG4gICAgb24oZG9jdW1lbnQsICdrZXl1cCcsIHRoaXMuX2NoZWNrS2V5VXApO1xuICAgIHRoaXMuZGVmYXVsdHMgPSB7XG4gICAgICBzZWxlY3RlZENsYXNzOiAnc29ydGFibGUtc2VsZWN0ZWQnLFxuICAgICAgbXVsdGlEcmFnS2V5OiBudWxsLFxuICAgICAgc2V0RGF0YTogZnVuY3Rpb24gc2V0RGF0YShkYXRhVHJhbnNmZXIsIGRyYWdFbCkge1xuICAgICAgICB2YXIgZGF0YSA9ICcnO1xuXG4gICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggJiYgbXVsdGlEcmFnU29ydGFibGUgPT09IHNvcnRhYmxlKSB7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCwgaSkge1xuICAgICAgICAgICAgZGF0YSArPSAoIWkgPyAnJyA6ICcsICcpICsgbXVsdGlEcmFnRWxlbWVudC50ZXh0Q29udGVudDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhID0gZHJhZ0VsLnRleHRDb250ZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVRyYW5zZmVyLnNldERhdGEoJ1RleHQnLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgTXVsdGlEcmFnLnByb3RvdHlwZSA9IHtcbiAgICBtdWx0aURyYWdLZXlEb3duOiBmYWxzZSxcbiAgICBpc011bHRpRHJhZzogZmFsc2UsXG4gICAgZGVsYXlTdGFydEdsb2JhbDogZnVuY3Rpb24gZGVsYXlTdGFydEdsb2JhbChfcmVmKSB7XG4gICAgICB2YXIgZHJhZ2dlZCA9IF9yZWYuZHJhZ0VsO1xuICAgICAgZHJhZ0VsJDEgPSBkcmFnZ2VkO1xuICAgIH0sXG4gICAgZGVsYXlFbmRlZDogZnVuY3Rpb24gZGVsYXlFbmRlZCgpIHtcbiAgICAgIHRoaXMuaXNNdWx0aURyYWcgPSB+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihkcmFnRWwkMSk7XG4gICAgfSxcbiAgICBzZXR1cENsb25lOiBmdW5jdGlvbiBzZXR1cENsb25lKF9yZWYyKSB7XG4gICAgICB2YXIgc29ydGFibGUgPSBfcmVmMi5zb3J0YWJsZSxcbiAgICAgICAgICBjYW5jZWwgPSBfcmVmMi5jYW5jZWw7XG4gICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdWx0aURyYWdFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtdWx0aURyYWdDbG9uZXMucHVzaChjbG9uZShtdWx0aURyYWdFbGVtZW50c1tpXSkpO1xuICAgICAgICBtdWx0aURyYWdDbG9uZXNbaV0uc29ydGFibGVJbmRleCA9IG11bHRpRHJhZ0VsZW1lbnRzW2ldLnNvcnRhYmxlSW5kZXg7XG4gICAgICAgIG11bHRpRHJhZ0Nsb25lc1tpXS5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgbXVsdGlEcmFnQ2xvbmVzW2ldLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJyc7XG4gICAgICAgIHRvZ2dsZUNsYXNzKG11bHRpRHJhZ0Nsb25lc1tpXSwgdGhpcy5vcHRpb25zLnNlbGVjdGVkQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudHNbaV0gPT09IGRyYWdFbCQxICYmIHRvZ2dsZUNsYXNzKG11bHRpRHJhZ0Nsb25lc1tpXSwgdGhpcy5vcHRpb25zLmNob3NlbkNsYXNzLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHNvcnRhYmxlLl9oaWRlQ2xvbmUoKTtcblxuICAgICAgY2FuY2VsKCk7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoX3JlZjMpIHtcbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWYzLnNvcnRhYmxlLFxuICAgICAgICAgIHJvb3RFbCA9IF9yZWYzLnJvb3RFbCxcbiAgICAgICAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQgPSBfcmVmMy5kaXNwYXRjaFNvcnRhYmxlRXZlbnQsXG4gICAgICAgICAgY2FuY2VsID0gX3JlZjMuY2FuY2VsO1xuICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnKSByZXR1cm47XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlKSB7XG4gICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggJiYgbXVsdGlEcmFnU29ydGFibGUgPT09IHNvcnRhYmxlKSB7XG4gICAgICAgICAgaW5zZXJ0TXVsdGlEcmFnQ2xvbmVzKHRydWUsIHJvb3RFbCk7XG4gICAgICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50KCdjbG9uZScpO1xuICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzaG93Q2xvbmU6IGZ1bmN0aW9uIHNob3dDbG9uZShfcmVmNCkge1xuICAgICAgdmFyIGNsb25lTm93U2hvd24gPSBfcmVmNC5jbG9uZU5vd1Nob3duLFxuICAgICAgICAgIHJvb3RFbCA9IF9yZWY0LnJvb3RFbCxcbiAgICAgICAgICBjYW5jZWwgPSBfcmVmNC5jYW5jZWw7XG4gICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcbiAgICAgIGluc2VydE11bHRpRHJhZ0Nsb25lcyhmYWxzZSwgcm9vdEVsKTtcbiAgICAgIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICBjc3MoY2xvbmUsICdkaXNwbGF5JywgJycpO1xuICAgICAgfSk7XG4gICAgICBjbG9uZU5vd1Nob3duKCk7XG4gICAgICBjbG9uZXNIaWRkZW4gPSBmYWxzZTtcbiAgICAgIGNhbmNlbCgpO1xuICAgIH0sXG4gICAgaGlkZUNsb25lOiBmdW5jdGlvbiBoaWRlQ2xvbmUoX3JlZjUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWY1LnNvcnRhYmxlLFxuICAgICAgICAgIGNsb25lTm93SGlkZGVuID0gX3JlZjUuY2xvbmVOb3dIaWRkZW4sXG4gICAgICAgICAgY2FuY2VsID0gX3JlZjUuY2FuY2VsO1xuICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnKSByZXR1cm47XG4gICAgICBtdWx0aURyYWdDbG9uZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgY3NzKGNsb25lLCAnZGlzcGxheScsICdub25lJyk7XG5cbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUgJiYgY2xvbmUucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNsb25lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNsb25lTm93SGlkZGVuKCk7XG4gICAgICBjbG9uZXNIaWRkZW4gPSB0cnVlO1xuICAgICAgY2FuY2VsKCk7XG4gICAgfSxcbiAgICBkcmFnU3RhcnRHbG9iYWw6IGZ1bmN0aW9uIGRyYWdTdGFydEdsb2JhbChfcmVmNikge1xuICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjYuc29ydGFibGU7XG5cbiAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZyAmJiBtdWx0aURyYWdTb3J0YWJsZSkge1xuICAgICAgICBtdWx0aURyYWdTb3J0YWJsZS5tdWx0aURyYWcuX2Rlc2VsZWN0TXVsdGlEcmFnKCk7XG4gICAgICB9XG5cbiAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudC5zb3J0YWJsZUluZGV4ID0gaW5kZXgobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICB9KTsgLy8gU29ydCBtdWx0aS1kcmFnIGVsZW1lbnRzXG5cbiAgICAgIG11bHRpRHJhZ0VsZW1lbnRzID0gbXVsdGlEcmFnRWxlbWVudHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5zb3J0YWJsZUluZGV4IC0gYi5zb3J0YWJsZUluZGV4O1xuICAgICAgfSk7XG4gICAgICBkcmFnU3RhcnRlZCA9IHRydWU7XG4gICAgfSxcbiAgICBkcmFnU3RhcnRlZDogZnVuY3Rpb24gZHJhZ1N0YXJ0ZWQoX3JlZjcpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgc29ydGFibGUgPSBfcmVmNy5zb3J0YWJsZTtcbiAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZykgcmV0dXJuO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNvcnQpIHtcbiAgICAgICAgLy8gQ2FwdHVyZSByZWN0cyxcbiAgICAgICAgLy8gaGlkZSBtdWx0aSBkcmFnIGVsZW1lbnRzIChieSBwb3NpdGlvbmluZyB0aGVtIGFic29sdXRlKSxcbiAgICAgICAgLy8gc2V0IG11bHRpIGRyYWcgZWxlbWVudHMgcmVjdHMgdG8gZHJhZ1JlY3QsXG4gICAgICAgIC8vIHNob3cgbXVsdGkgZHJhZyBlbGVtZW50cyxcbiAgICAgICAgLy8gYW5pbWF0ZSB0byByZWN0cyxcbiAgICAgICAgLy8gdW5zZXQgcmVjdHMgJiByZW1vdmUgZnJvbSBET01cbiAgICAgICAgc29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudCA9PT0gZHJhZ0VsJDEpIHJldHVybjtcbiAgICAgICAgICAgIGNzcyhtdWx0aURyYWdFbGVtZW50LCAncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgZHJhZ1JlY3QgPSBnZXRSZWN0KGRyYWdFbCQxLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQgPT09IGRyYWdFbCQxKSByZXR1cm47XG4gICAgICAgICAgICBzZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQsIGRyYWdSZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb2xkaW5nID0gdHJ1ZTtcbiAgICAgICAgICBpbml0aWFsRm9sZGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc29ydGFibGUuYW5pbWF0ZUFsbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvbGRpbmcgPSBmYWxzZTtcbiAgICAgICAgaW5pdGlhbEZvbGRpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAoX3RoaXMyLm9wdGlvbnMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgdW5zZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIFJlbW92ZSBhbGwgYXV4aWxpYXJ5IG11bHRpZHJhZyBpdGVtcyBmcm9tIGVsLCBpZiBzb3J0aW5nIGVuYWJsZWRcblxuXG4gICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5zb3J0KSB7XG4gICAgICAgICAgcmVtb3ZlTXVsdGlEcmFnRWxlbWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBkcmFnT3ZlcjogZnVuY3Rpb24gZHJhZ092ZXIoX3JlZjgpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBfcmVmOC50YXJnZXQsXG4gICAgICAgICAgY29tcGxldGVkID0gX3JlZjguY29tcGxldGVkLFxuICAgICAgICAgIGNhbmNlbCA9IF9yZWY4LmNhbmNlbDtcblxuICAgICAgaWYgKGZvbGRpbmcgJiYgfm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YodGFyZ2V0KSkge1xuICAgICAgICBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJldmVydDogZnVuY3Rpb24gcmV2ZXJ0KF9yZWY5KSB7XG4gICAgICB2YXIgZnJvbVNvcnRhYmxlID0gX3JlZjkuZnJvbVNvcnRhYmxlLFxuICAgICAgICAgIHJvb3RFbCA9IF9yZWY5LnJvb3RFbCxcbiAgICAgICAgICBzb3J0YWJsZSA9IF9yZWY5LnNvcnRhYmxlLFxuICAgICAgICAgIGRyYWdSZWN0ID0gX3JlZjkuZHJhZ1JlY3Q7XG5cbiAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIFNldHVwIHVuZm9sZCBhbmltYXRpb25cbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgIHNvcnRhYmxlLmFkZEFuaW1hdGlvblN0YXRlKHtcbiAgICAgICAgICAgIHRhcmdldDogbXVsdGlEcmFnRWxlbWVudCxcbiAgICAgICAgICAgIHJlY3Q6IGZvbGRpbmcgPyBnZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQpIDogZHJhZ1JlY3RcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB1bnNldFJlY3QobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudC5mcm9tUmVjdCA9IGRyYWdSZWN0O1xuICAgICAgICAgIGZyb21Tb3J0YWJsZS5yZW1vdmVBbmltYXRpb25TdGF0ZShtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvbGRpbmcgPSBmYWxzZTtcbiAgICAgICAgaW5zZXJ0TXVsdGlEcmFnRWxlbWVudHMoIXRoaXMub3B0aW9ucy5yZW1vdmVDbG9uZU9uSGlkZSwgcm9vdEVsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdPdmVyQ29tcGxldGVkOiBmdW5jdGlvbiBkcmFnT3ZlckNvbXBsZXRlZChfcmVmMTApIHtcbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWYxMC5zb3J0YWJsZSxcbiAgICAgICAgICBpc093bmVyID0gX3JlZjEwLmlzT3duZXIsXG4gICAgICAgICAgaW5zZXJ0aW9uID0gX3JlZjEwLmluc2VydGlvbixcbiAgICAgICAgICBhY3RpdmVTb3J0YWJsZSA9IF9yZWYxMC5hY3RpdmVTb3J0YWJsZSxcbiAgICAgICAgICBwYXJlbnRFbCA9IF9yZWYxMC5wYXJlbnRFbCxcbiAgICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWYxMC5wdXRTb3J0YWJsZTtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgICAgIC8vIENsb25lcyBtdXN0IGJlIGhpZGRlbiBiZWZvcmUgZm9sZGluZyBhbmltYXRpb24gdG8gY2FwdHVyZSBkcmFnUmVjdEFic29sdXRlIHByb3Blcmx5XG4gICAgICAgIGlmIChpc093bmVyKSB7XG4gICAgICAgICAgYWN0aXZlU29ydGFibGUuX2hpZGVDbG9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5pdGlhbEZvbGRpbmcgPSBmYWxzZTsgLy8gSWYgbGVhdmluZyBzb3J0OmZhbHNlIHJvb3QsIG9yIGFscmVhZHkgZm9sZGluZyAtIEZvbGQgdG8gbmV3IGxvY2F0aW9uXG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uICYmIG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCA+IDEgJiYgKGZvbGRpbmcgfHwgIWlzT3duZXIgJiYgIWFjdGl2ZVNvcnRhYmxlLm9wdGlvbnMuc29ydCAmJiAhcHV0U29ydGFibGUpKSB7XG4gICAgICAgICAgLy8gRm9sZDogU2V0IGFsbCBtdWx0aSBkcmFnIGVsZW1lbnRzJ3MgcmVjdHMgdG8gZHJhZ0VsJ3MgcmVjdCB3aGVuIG11bHRpLWRyYWcgZWxlbWVudHMgYXJlIGludmlzaWJsZVxuICAgICAgICAgIHZhciBkcmFnUmVjdEFic29sdXRlID0gZ2V0UmVjdChkcmFnRWwkMSwgZmFsc2UsIHRydWUsIHRydWUpO1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50ID09PSBkcmFnRWwkMSkgcmV0dXJuO1xuICAgICAgICAgICAgc2V0UmVjdChtdWx0aURyYWdFbGVtZW50LCBkcmFnUmVjdEFic29sdXRlKTsgLy8gTW92ZSBlbGVtZW50KHMpIHRvIGVuZCBvZiBwYXJlbnRFbCBzbyB0aGF0IGl0IGRvZXMgbm90IGludGVyZmVyZSB3aXRoIG11bHRpLWRyYWcgY2xvbmVzIGluc2VydGlvbiBpZiB0aGV5IGFyZSBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gd2hpbGUgZm9sZGluZywgYW5kIHNvIHRoYXQgd2UgY2FuIGNhcHR1cmUgdGhlbSBhZ2FpbiBiZWNhdXNlIG9sZCBzb3J0YWJsZSB3aWxsIG5vIGxvbmdlciBiZSBmcm9tU29ydGFibGVcblxuICAgICAgICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9sZGluZyA9IHRydWU7XG4gICAgICAgIH0gLy8gQ2xvbmVzIG11c3QgYmUgc2hvd24gKGFuZCBjaGVjayB0byByZW1vdmUgbXVsdGkgZHJhZ3MpIGFmdGVyIGZvbGRpbmcgd2hlbiBpbnRlcmZlcmluZyBtdWx0aURyYWdFbGVtZW50cyBhcmUgbW92ZWQgb3V0XG5cblxuICAgICAgICBpZiAoIWlzT3duZXIpIHtcbiAgICAgICAgICAvLyBPbmx5IHJlbW92ZSBpZiBub3QgZm9sZGluZyAoZm9sZGluZyB3aWxsIHJlbW92ZSB0aGVtIGFueXdheXMpXG4gICAgICAgICAgaWYgKCFmb2xkaW5nKSB7XG4gICAgICAgICAgICByZW1vdmVNdWx0aURyYWdFbGVtZW50cygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgY2xvbmVzSGlkZGVuQmVmb3JlID0gY2xvbmVzSGlkZGVuO1xuXG4gICAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5fc2hvd0Nsb25lKHNvcnRhYmxlKTsgLy8gVW5mb2xkIGFuaW1hdGlvbiBmb3IgY2xvbmVzIGlmIHNob3dpbmcgZnJvbSBoaWRkZW5cblxuXG4gICAgICAgICAgICBpZiAoYWN0aXZlU29ydGFibGUub3B0aW9ucy5hbmltYXRpb24gJiYgIWNsb25lc0hpZGRlbiAmJiBjbG9uZXNIaWRkZW5CZWZvcmUpIHtcbiAgICAgICAgICAgICAgbXVsdGlEcmFnQ2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlU29ydGFibGUuYWRkQW5pbWF0aW9uU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBjbG9uZSxcbiAgICAgICAgICAgICAgICAgIHJlY3Q6IGNsb25lc0Zyb21SZWN0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2xvbmUuZnJvbVJlY3QgPSBjbG9uZXNGcm9tUmVjdDtcbiAgICAgICAgICAgICAgICBjbG9uZS50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlU29ydGFibGUuX3Nob3dDbG9uZShzb3J0YWJsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkcmFnT3ZlckFuaW1hdGlvbkNhcHR1cmU6IGZ1bmN0aW9uIGRyYWdPdmVyQW5pbWF0aW9uQ2FwdHVyZShfcmVmMTEpIHtcbiAgICAgIHZhciBkcmFnUmVjdCA9IF9yZWYxMS5kcmFnUmVjdCxcbiAgICAgICAgICBpc093bmVyID0gX3JlZjExLmlzT3duZXIsXG4gICAgICAgICAgYWN0aXZlU29ydGFibGUgPSBfcmVmMTEuYWN0aXZlU29ydGFibGU7XG4gICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgIG11bHRpRHJhZ0VsZW1lbnQudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gbnVsbDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoYWN0aXZlU29ydGFibGUub3B0aW9ucy5hbmltYXRpb24gJiYgIWlzT3duZXIgJiYgYWN0aXZlU29ydGFibGUubXVsdGlEcmFnLmlzTXVsdGlEcmFnKSB7XG4gICAgICAgIGNsb25lc0Zyb21SZWN0ID0gX2V4dGVuZHMoe30sIGRyYWdSZWN0KTtcbiAgICAgICAgdmFyIGRyYWdNYXRyaXggPSBtYXRyaXgoZHJhZ0VsJDEsIHRydWUpO1xuICAgICAgICBjbG9uZXNGcm9tUmVjdC50b3AgLT0gZHJhZ01hdHJpeC5mO1xuICAgICAgICBjbG9uZXNGcm9tUmVjdC5sZWZ0IC09IGRyYWdNYXRyaXguZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdPdmVyQW5pbWF0aW9uQ29tcGxldGU6IGZ1bmN0aW9uIGRyYWdPdmVyQW5pbWF0aW9uQ29tcGxldGUoKSB7XG4gICAgICBpZiAoZm9sZGluZykge1xuICAgICAgICBmb2xkaW5nID0gZmFsc2U7XG4gICAgICAgIHJlbW92ZU11bHRpRHJhZ0VsZW1lbnRzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcm9wOiBmdW5jdGlvbiBkcm9wKF9yZWYxMikge1xuICAgICAgdmFyIGV2dCA9IF9yZWYxMi5vcmlnaW5hbEV2ZW50LFxuICAgICAgICAgIHJvb3RFbCA9IF9yZWYxMi5yb290RWwsXG4gICAgICAgICAgcGFyZW50RWwgPSBfcmVmMTIucGFyZW50RWwsXG4gICAgICAgICAgc29ydGFibGUgPSBfcmVmMTIuc29ydGFibGUsXG4gICAgICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50ID0gX3JlZjEyLmRpc3BhdGNoU29ydGFibGVFdmVudCxcbiAgICAgICAgICBvbGRJbmRleCA9IF9yZWYxMi5vbGRJbmRleCxcbiAgICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWYxMi5wdXRTb3J0YWJsZTtcbiAgICAgIHZhciB0b1NvcnRhYmxlID0gcHV0U29ydGFibGUgfHwgdGhpcy5zb3J0YWJsZTtcbiAgICAgIGlmICghZXZ0KSByZXR1cm47XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBjaGlsZHJlbiA9IHBhcmVudEVsLmNoaWxkcmVuOyAvLyBNdWx0aS1kcmFnIHNlbGVjdGlvblxuXG4gICAgICBpZiAoIWRyYWdTdGFydGVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm11bHRpRHJhZ0tleSAmJiAhdGhpcy5tdWx0aURyYWdLZXlEb3duKSB7XG4gICAgICAgICAgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCQxLCBvcHRpb25zLnNlbGVjdGVkQ2xhc3MsICF+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihkcmFnRWwkMSkpO1xuXG4gICAgICAgIGlmICghfm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZHJhZ0VsJDEpKSB7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMucHVzaChkcmFnRWwkMSk7XG4gICAgICAgICAgZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGUsXG4gICAgICAgICAgICByb290RWw6IHJvb3RFbCxcbiAgICAgICAgICAgIG5hbWU6ICdzZWxlY3QnLFxuICAgICAgICAgICAgdGFyZ2V0RWw6IGRyYWdFbCQxLFxuICAgICAgICAgICAgb3JpZ2luYWxFdnQ6IGV2dFxuICAgICAgICAgIH0pOyAvLyBNb2RpZmllciBhY3RpdmF0ZWQsIHNlbGVjdCBmcm9tIGxhc3QgdG8gZHJhZ0VsXG5cbiAgICAgICAgICBpZiAoZXZ0LnNoaWZ0S2V5ICYmIGxhc3RNdWx0aURyYWdTZWxlY3QgJiYgc29ydGFibGUuZWwuY29udGFpbnMobGFzdE11bHRpRHJhZ1NlbGVjdCkpIHtcbiAgICAgICAgICAgIHZhciBsYXN0SW5kZXggPSBpbmRleChsYXN0TXVsdGlEcmFnU2VsZWN0KSxcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5kZXggPSBpbmRleChkcmFnRWwkMSk7XG5cbiAgICAgICAgICAgIGlmICh+bGFzdEluZGV4ICYmIH5jdXJyZW50SW5kZXggJiYgbGFzdEluZGV4ICE9PSBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgLy8gTXVzdCBpbmNsdWRlIGxhc3RNdWx0aURyYWdTZWxlY3QgKHNlbGVjdCBpdCksIGluIGNhc2UgbW9kaWZpZWQgc2VsZWN0aW9uIGZyb20gbm8gc2VsZWN0aW9uXG4gICAgICAgICAgICAgIC8vIChidXQgcHJldmlvdXMgc2VsZWN0aW9uIGV4aXN0ZWQpXG4gICAgICAgICAgICAgIHZhciBuLCBpO1xuXG4gICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgIG4gPSBjdXJyZW50SW5kZXg7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaSA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICBuID0gbGFzdEluZGV4ICsgMTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKH5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGNoaWxkcmVuW2ldKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoY2hpbGRyZW5baV0sIG9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMucHVzaChjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGUsXG4gICAgICAgICAgICAgICAgICByb290RWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgICAgIG5hbWU6ICdzZWxlY3QnLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0RWw6IGNoaWxkcmVuW2ldLFxuICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdnQ6IGV2dFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RNdWx0aURyYWdTZWxlY3QgPSBkcmFnRWwkMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtdWx0aURyYWdTb3J0YWJsZSA9IHRvU29ydGFibGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuc3BsaWNlKG11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZHJhZ0VsJDEpLCAxKTtcbiAgICAgICAgICBsYXN0TXVsdGlEcmFnU2VsZWN0ID0gbnVsbDtcbiAgICAgICAgICBkaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgICAgIHJvb3RFbDogcm9vdEVsLFxuICAgICAgICAgICAgbmFtZTogJ2Rlc2VsZWN0JyxcbiAgICAgICAgICAgIHRhcmdldEVsOiBkcmFnRWwkMSxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZ0OiBldnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBNdWx0aS1kcmFnIGRyb3BcblxuXG4gICAgICBpZiAoZHJhZ1N0YXJ0ZWQgJiYgdGhpcy5pc011bHRpRHJhZykge1xuICAgICAgICBmb2xkaW5nID0gZmFsc2U7IC8vIERvIG5vdCBcInVuZm9sZFwiIGFmdGVyIGFyb3VuZCBkcmFnRWwgaWYgcmV2ZXJ0ZWRcblxuICAgICAgICBpZiAoKHBhcmVudEVsW2V4cGFuZG9dLm9wdGlvbnMuc29ydCB8fCBwYXJlbnRFbCAhPT0gcm9vdEVsKSAmJiBtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdmFyIGRyYWdSZWN0ID0gZ2V0UmVjdChkcmFnRWwkMSksXG4gICAgICAgICAgICAgIG11bHRpRHJhZ0luZGV4ID0gaW5kZXgoZHJhZ0VsJDEsICc6bm90KC4nICsgdGhpcy5vcHRpb25zLnNlbGVjdGVkQ2xhc3MgKyAnKScpO1xuICAgICAgICAgIGlmICghaW5pdGlhbEZvbGRpbmcgJiYgb3B0aW9ucy5hbmltYXRpb24pIGRyYWdFbCQxLnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgdG9Tb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcblxuICAgICAgICAgIGlmICghaW5pdGlhbEZvbGRpbmcpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgICBkcmFnRWwkMS5mcm9tUmVjdCA9IGRyYWdSZWN0O1xuICAgICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudC50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQgIT09IGRyYWdFbCQxKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGZvbGRpbmcgPyBnZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQpIDogZHJhZ1JlY3Q7XG4gICAgICAgICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50LmZyb21SZWN0ID0gcmVjdDsgLy8gUHJlcGFyZSB1bmZvbGQgYW5pbWF0aW9uXG5cbiAgICAgICAgICAgICAgICAgIHRvU29ydGFibGUuYWRkQW5pbWF0aW9uU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IG11bHRpRHJhZ0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHJlY3Q6IHJlY3RcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IC8vIE11bHRpIGRyYWcgZWxlbWVudHMgYXJlIG5vdCBuZWNlc3NhcmlseSByZW1vdmVkIGZyb20gdGhlIERPTSBvbiBkcm9wLCBzbyB0byByZWluc2VydFxuICAgICAgICAgICAgLy8gcHJvcGVybHkgdGhleSBtdXN0IGFsbCBiZSByZW1vdmVkXG5cblxuICAgICAgICAgICAgcmVtb3ZlTXVsdGlEcmFnRWxlbWVudHMoKTtcbiAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuW211bHRpRHJhZ0luZGV4XSkge1xuICAgICAgICAgICAgICAgIHBhcmVudEVsLmluc2VydEJlZm9yZShtdWx0aURyYWdFbGVtZW50LCBjaGlsZHJlblttdWx0aURyYWdJbmRleF0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbXVsdGlEcmFnSW5kZXgrKztcbiAgICAgICAgICAgIH0pOyAvLyBJZiBpbml0aWFsIGZvbGRpbmcgaXMgZG9uZSwgdGhlIGVsZW1lbnRzIG1heSBoYXZlIGNoYW5nZWQgcG9zaXRpb24gYmVjYXVzZSB0aGV5IGFyZSBub3dcbiAgICAgICAgICAgIC8vIHVuZm9sZGluZyBhcm91bmQgZHJhZ0VsLCBldmVuIHRob3VnaCBkcmFnRWwgbWF5IG5vdCBoYXZlIGhpcyBpbmRleCBjaGFuZ2VkLCBzbyB1cGRhdGUgZXZlbnRcbiAgICAgICAgICAgIC8vIG11c3QgYmUgZmlyZWQgaGVyZSBhcyBTb3J0YWJsZSB3aWxsIG5vdC5cblxuICAgICAgICAgICAgaWYgKG9sZEluZGV4ID09PSBpbmRleChkcmFnRWwkMSkpIHtcbiAgICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQuc29ydGFibGVJbmRleCAhPT0gaW5kZXgobXVsdGlEcmFnRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50KCd1cGRhdGUnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gTXVzdCBiZSBkb25lIGFmdGVyIGNhcHR1cmluZyBpbmRpdmlkdWFsIHJlY3RzIChzY3JvbGwgYmFyKVxuXG5cbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICB1bnNldFJlY3QobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdG9Tb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBtdWx0aURyYWdTb3J0YWJsZSA9IHRvU29ydGFibGU7XG4gICAgICB9IC8vIFJlbW92ZSBjbG9uZXMgaWYgbmVjZXNzYXJ5XG5cblxuICAgICAgaWYgKHJvb3RFbCA9PT0gcGFyZW50RWwgfHwgcHV0U29ydGFibGUgJiYgcHV0U29ydGFibGUubGFzdFB1dE1vZGUgIT09ICdjbG9uZScpIHtcbiAgICAgICAgbXVsdGlEcmFnQ2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgICAgY2xvbmUucGFyZW50Tm9kZSAmJiBjbG9uZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBudWxsaW5nR2xvYmFsOiBmdW5jdGlvbiBudWxsaW5nR2xvYmFsKCkge1xuICAgICAgdGhpcy5pc011bHRpRHJhZyA9IGRyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgICBtdWx0aURyYWdDbG9uZXMubGVuZ3RoID0gMDtcbiAgICB9LFxuICAgIGRlc3Ryb3lHbG9iYWw6IGZ1bmN0aW9uIGRlc3Ryb3lHbG9iYWwoKSB7XG4gICAgICB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZygpO1xuXG4gICAgICBvZmYoZG9jdW1lbnQsICdwb2ludGVydXAnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICBvZmYoZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgICAgb2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICBvZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fY2hlY2tLZXlEb3duKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ2tleXVwJywgdGhpcy5fY2hlY2tLZXlVcCk7XG4gICAgfSxcbiAgICBfZGVzZWxlY3RNdWx0aURyYWc6IGZ1bmN0aW9uIF9kZXNlbGVjdE11bHRpRHJhZyhldnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZHJhZ1N0YXJ0ZWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZHJhZ1N0YXJ0ZWQpIHJldHVybjsgLy8gT25seSBkZXNlbGVjdCBpZiBzZWxlY3Rpb24gaXMgaW4gdGhpcyBzb3J0YWJsZVxuXG4gICAgICBpZiAobXVsdGlEcmFnU29ydGFibGUgIT09IHRoaXMuc29ydGFibGUpIHJldHVybjsgLy8gT25seSBkZXNlbGVjdCBpZiB0YXJnZXQgaXMgbm90IGl0ZW0gaW4gdGhpcyBzb3J0YWJsZVxuXG4gICAgICBpZiAoZXZ0ICYmIGNsb3Nlc3QoZXZ0LnRhcmdldCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSwgdGhpcy5zb3J0YWJsZS5lbCwgZmFsc2UpKSByZXR1cm47IC8vIE9ubHkgZGVzZWxlY3QgaWYgbGVmdCBjbGlja1xuXG4gICAgICBpZiAoZXZ0ICYmIGV2dC5idXR0b24gIT09IDApIHJldHVybjtcblxuICAgICAgd2hpbGUgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgZWwgPSBtdWx0aURyYWdFbGVtZW50c1swXTtcbiAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHRoaXMub3B0aW9ucy5zZWxlY3RlZENsYXNzLCBmYWxzZSk7XG4gICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLnNoaWZ0KCk7XG4gICAgICAgIGRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLnNvcnRhYmxlLFxuICAgICAgICAgIHJvb3RFbDogdGhpcy5zb3J0YWJsZS5lbCxcbiAgICAgICAgICBuYW1lOiAnZGVzZWxlY3QnLFxuICAgICAgICAgIHRhcmdldEVsOiBlbCxcbiAgICAgICAgICBvcmlnaW5hbEV2dDogZXZ0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2NoZWNrS2V5RG93bjogZnVuY3Rpb24gX2NoZWNrS2V5RG93bihldnQpIHtcbiAgICAgIGlmIChldnQua2V5ID09PSB0aGlzLm9wdGlvbnMubXVsdGlEcmFnS2V5KSB7XG4gICAgICAgIHRoaXMubXVsdGlEcmFnS2V5RG93biA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBfY2hlY2tLZXlVcDogZnVuY3Rpb24gX2NoZWNrS2V5VXAoZXZ0KSB7XG4gICAgICBpZiAoZXZ0LmtleSA9PT0gdGhpcy5vcHRpb25zLm11bHRpRHJhZ0tleSkge1xuICAgICAgICB0aGlzLm11bHRpRHJhZ0tleURvd24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcyhNdWx0aURyYWcsIHtcbiAgICAvLyBTdGF0aWMgbWV0aG9kcyAmIHByb3BlcnRpZXNcbiAgICBwbHVnaW5OYW1lOiAnbXVsdGlEcmFnJyxcbiAgICB1dGlsczoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZWxlY3RzIHRoZSBwcm92aWRlZCBtdWx0aS1kcmFnIGl0ZW1cbiAgICAgICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICBUaGUgZWxlbWVudCB0byBiZSBzZWxlY3RlZFxuICAgICAgICovXG4gICAgICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdChlbCkge1xuICAgICAgICB2YXIgc29ydGFibGUgPSBlbC5wYXJlbnROb2RlW2V4cGFuZG9dO1xuICAgICAgICBpZiAoIXNvcnRhYmxlIHx8ICFzb3J0YWJsZS5vcHRpb25zLm11bHRpRHJhZyB8fCB+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihlbCkpIHJldHVybjtcblxuICAgICAgICBpZiAobXVsdGlEcmFnU29ydGFibGUgJiYgbXVsdGlEcmFnU29ydGFibGUgIT09IHNvcnRhYmxlKSB7XG4gICAgICAgICAgbXVsdGlEcmFnU29ydGFibGUubXVsdGlEcmFnLl9kZXNlbGVjdE11bHRpRHJhZygpO1xuXG4gICAgICAgICAgbXVsdGlEcmFnU29ydGFibGUgPSBzb3J0YWJsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvZ2dsZUNsYXNzKGVsLCBzb3J0YWJsZS5vcHRpb25zLnNlbGVjdGVkQ2xhc3MsIHRydWUpO1xuICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5wdXNoKGVsKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogRGVzZWxlY3RzIHRoZSBwcm92aWRlZCBtdWx0aS1kcmFnIGl0ZW1cbiAgICAgICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICBUaGUgZWxlbWVudCB0byBiZSBkZXNlbGVjdGVkXG4gICAgICAgKi9cbiAgICAgIGRlc2VsZWN0OiBmdW5jdGlvbiBkZXNlbGVjdChlbCkge1xuICAgICAgICB2YXIgc29ydGFibGUgPSBlbC5wYXJlbnROb2RlW2V4cGFuZG9dLFxuICAgICAgICAgICAgaW5kZXggPSBtdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGVsKTtcbiAgICAgICAgaWYgKCFzb3J0YWJsZSB8fCAhc29ydGFibGUub3B0aW9ucy5tdWx0aURyYWcgfHwgIX5pbmRleCkgcmV0dXJuO1xuICAgICAgICB0b2dnbGVDbGFzcyhlbCwgc29ydGFibGUub3B0aW9ucy5zZWxlY3RlZENsYXNzLCBmYWxzZSk7XG4gICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBldmVudFByb3BlcnRpZXM6IGZ1bmN0aW9uIGV2ZW50UHJvcGVydGllcygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgb2xkSW5kaWNpZXMgPSBbXSxcbiAgICAgICAgICBuZXdJbmRpY2llcyA9IFtdO1xuICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICBvbGRJbmRpY2llcy5wdXNoKHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50OiBtdWx0aURyYWdFbGVtZW50LFxuICAgICAgICAgIGluZGV4OiBtdWx0aURyYWdFbGVtZW50LnNvcnRhYmxlSW5kZXhcbiAgICAgICAgfSk7IC8vIG11bHRpRHJhZ0VsZW1lbnRzIHdpbGwgYWxyZWFkeSBiZSBzb3J0ZWQgaWYgZm9sZGluZ1xuXG4gICAgICAgIHZhciBuZXdJbmRleDtcblxuICAgICAgICBpZiAoZm9sZGluZyAmJiBtdWx0aURyYWdFbGVtZW50ICE9PSBkcmFnRWwkMSkge1xuICAgICAgICAgIG5ld0luZGV4ID0gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9sZGluZykge1xuICAgICAgICAgIG5ld0luZGV4ID0gaW5kZXgobXVsdGlEcmFnRWxlbWVudCwgJzpub3QoLicgKyBfdGhpczMub3B0aW9ucy5zZWxlY3RlZENsYXNzICsgJyknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdJbmRleCA9IGluZGV4KG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3SW5kaWNpZXMucHVzaCh7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudDogbXVsdGlEcmFnRWxlbWVudCxcbiAgICAgICAgICBpbmRleDogbmV3SW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGl0ZW1zOiBfdG9Db25zdW1hYmxlQXJyYXkobXVsdGlEcmFnRWxlbWVudHMpLFxuICAgICAgICBjbG9uZXM6IFtdLmNvbmNhdChtdWx0aURyYWdDbG9uZXMpLFxuICAgICAgICBvbGRJbmRpY2llczogb2xkSW5kaWNpZXMsXG4gICAgICAgIG5ld0luZGljaWVzOiBuZXdJbmRpY2llc1xuICAgICAgfTtcbiAgICB9LFxuICAgIG9wdGlvbkxpc3RlbmVyczoge1xuICAgICAgbXVsdGlEcmFnS2V5OiBmdW5jdGlvbiBtdWx0aURyYWdLZXkoa2V5KSB7XG4gICAgICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdjdHJsJykge1xuICAgICAgICAgIGtleSA9ICdDb250cm9sJztcbiAgICAgICAgfSBlbHNlIGlmIChrZXkubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGtleSA9IGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHIoMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluc2VydE11bHRpRHJhZ0VsZW1lbnRzKGNsb25lc0luc2VydGVkLCByb290RWwpIHtcbiAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCwgaSkge1xuICAgIHZhciB0YXJnZXQgPSByb290RWwuY2hpbGRyZW5bbXVsdGlEcmFnRWxlbWVudC5zb3J0YWJsZUluZGV4ICsgKGNsb25lc0luc2VydGVkID8gTnVtYmVyKGkpIDogMCldO1xuXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShtdWx0aURyYWdFbGVtZW50LCB0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290RWwuYXBwZW5kQ2hpbGQobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogSW5zZXJ0IG11bHRpLWRyYWcgY2xvbmVzXG4gKiBAcGFyYW0gIHtbQm9vbGVhbl19IGVsZW1lbnRzSW5zZXJ0ZWQgIFdoZXRoZXIgdGhlIG11bHRpLWRyYWcgZWxlbWVudHMgYXJlIGluc2VydGVkXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gcm9vdEVsXG4gKi9cblxuXG5mdW5jdGlvbiBpbnNlcnRNdWx0aURyYWdDbG9uZXMoZWxlbWVudHNJbnNlcnRlZCwgcm9vdEVsKSB7XG4gIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSwgaSkge1xuICAgIHZhciB0YXJnZXQgPSByb290RWwuY2hpbGRyZW5bY2xvbmUuc29ydGFibGVJbmRleCArIChlbGVtZW50c0luc2VydGVkID8gTnVtYmVyKGkpIDogMCldO1xuXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShjbG9uZSwgdGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdEVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVNdWx0aURyYWdFbGVtZW50cygpIHtcbiAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgIGlmIChtdWx0aURyYWdFbGVtZW50ID09PSBkcmFnRWwkMSkgcmV0dXJuO1xuICAgIG11bHRpRHJhZ0VsZW1lbnQucGFyZW50Tm9kZSAmJiBtdWx0aURyYWdFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobXVsdGlEcmFnRWxlbWVudCk7XG4gIH0pO1xufVxuXG5Tb3J0YWJsZS5tb3VudChuZXcgQXV0b1Njcm9sbFBsdWdpbigpKTtcblNvcnRhYmxlLm1vdW50KFJlbW92ZSwgUmV2ZXJ0KTtcblxuZXhwb3J0IGRlZmF1bHQgU29ydGFibGU7XG5leHBvcnQgeyBNdWx0aURyYWdQbHVnaW4gYXMgTXVsdGlEcmFnLCBTb3J0YWJsZSwgU3dhcFBsdWdpbiBhcyBTd2FwIH07XG4iLCJpbXBvcnQgU29ydGFibGUgZnJvbSAnc29ydGFibGVqcydcclxuaW1wb3J0IHskfSBmcm9tICcuLi9jb21tb24nXHJcbmltcG9ydCB7X3F1ZXN0aW9ufSBmcm9tIFwiLi4vVGVzdC9tb2RlbC9xdWVzdGlvblwiO1xyXG5cclxuZXhwb3J0IGxldCBzb3J0YWJsZSA9IHtcclxuXHJcbiAgICBjb25uZWN0OiAoc2VsZWN0b3IpID0+IHtcclxuICAgICAgICBsZXQgZWwgPSAkKHNlbGVjdG9yKS5lbFswXTtcclxuICAgICAgICBpZiAoZWwpIHtcclxuICAgICAgICAgICAgbGV0IHNvcnRhYmxlID0gU29ydGFibGUuY3JlYXRlKGVsLCB7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb246IDE1MCxcclxuICAgICAgICAgICAgICAgIG9uRW5kOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9sZEkgPSBldnQub2xkSW5kZXhcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3SSA9IGV2dC5uZXdJbmRleFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRJPm5ld0kpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcXVlc3Rpb25zID0gX3F1ZXN0aW9uLnF1ZXN0aW9ucygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9xdWVzdGlvbi5zb3J0KG9sZEkpXHJcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBxdWVzdGlvbnMgPSBfcXVlc3Rpb24ucXVlc3Rpb25zKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3F1ZXN0aW9uLnNvcnQobmV3SSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImltcG9ydCAnLi90ZXN0LWVkaXQuc2NzcydcclxuaW1wb3J0ICcuLi9jb21wb25lbnRzL2Zvb3Rlci9mb290ZXIuc2NzcydcclxuXHJcbmltcG9ydCAnLi90ZXN0LWVkaXQtbWVudS5zY3NzJ1xyXG5pbXBvcnQgJy4uL2NvbXBvbmVudHMvcG9wdXAuc2NzcydcclxuXHJcbi8vIGltcG9ydCAnLi90ZXN0J1xyXG5pbXBvcnQgJy4vdGVzdC11cGRhdGUnXHJcbmltcG9ydCAnLi4vQWRtaW4vYWRtaW4nXHJcblxyXG5pbXBvcnQgeyQsIGFkZFRvb2x0aXB9IGZyb20gJy4uL2NvbW1vbidcclxuXHJcbmltcG9ydCB7X3Rlc3R9IGZyb20gXCIuL21vZGVsL3Rlc3RcIlxyXG5pbXBvcnQge19xdWVzdGlvbn0gZnJvbSBcIi4vbW9kZWwvcXVlc3Rpb25cIlxyXG5pbXBvcnQge19hbnN3ZXJ9IGZyb20gXCIuL21vZGVsL2Fuc3dlclwiXHJcbmltcG9ydCB7c29ydGFibGV9IGZyb20gXCIuLi9jb21wb25lbnRzL3NvcnRhYmxlXCJcclxuaW1wb3J0IFdEU1NlbGVjdCBmcm9tIFwiLi4vY29tcG9uZW50cy9zZWxlY3QvV0RTU2VsZWN0XCJcclxuaW1wb3J0IGFjY29yZGlvblNob3cgZnJvbSBcIi4vYWNjb3JkaW9uLXNob3dcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRlc3RFZGl0KCkge1xyXG5cclxuICBhY2NvcmRpb25TaG93KClcclxuXHJcbiAgbGV0IHBhcmVudFNlbGVjdCA9IG5ldyBXRFNTZWxlY3Qoe1xyXG4gICAgZWxlbWVudDogJChcIltkYXRhLWN1c3RvbS1wYXJlbnRdXCIpWzBdLFxyXG4gICAgdGl0bGU6ICfQn9Cw0L/QutCwJyxcclxuICAgIGNsYXNzOiAncGFyZW50J1xyXG4gIH0pXHJcblxyXG5cclxuICBsZXQgZW5hYmxlU2VsZWN0ID0gbmV3IFdEU1NlbGVjdCh7XHJcbiAgICBlbGVtZW50OiAkKFwiW2RhdGEtY3VzdG9tLWVuYWJsZV1cIilbMF0sXHJcbiAgICB0aXRsZTogJ9Cf0L7QutCw0LfRi9Cy0LDRgtGMINC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRj9C8JyxcclxuICAgIGNsYXNzOiAnZW5hYmxlJ1xyXG4gIH0pXHJcblxyXG5cclxuICBpZiAoJChcIltkYXRhLXF1ZXN0aW9uLXBhcmVudC1pZF1cIikpIHtcclxuICAgICQoXCIuc2VsZWN0X193cmFwIHNlbGVjdFwiKS5vbignY2hhbmdlJywgX3F1ZXN0aW9uLmNoYW5nZVBhcmVudClcclxuICB9XHJcblxyXG5cclxuLy8g0L/QvtC00YHQstC10YLQutCwINGC0LXQutGD0YnQtdCz0L4g0YLQtdGB0YLQsFxyXG4gIF90ZXN0Lm1hcmtDdXJyZW50SW5NZW51KClcclxuXHJcblxyXG4gIHNvcnRhYmxlLmNvbm5lY3QoJy5xdWVzdGlvbnMnKVxyXG5cclxuXHJcbi8vINC/0YDQuCDRgdC+0LfQtNCw0L3QuNC4INC90L7QstC+0LPQviDRgtC10YHRgtCwINC/0L7QutCw0LfQsNGC0Ywg0L/Rg9GB0YLQvtC5INCy0L7Qv9GA0L7RgVxyXG4gIGlmICghX3F1ZXN0aW9uLnF1ZXN0aW9ucygpLmxlbmd0aFxyXG4gICAgJiYgL1xcL2FkbWluc2NcXC90ZXN0XFwvZWRpdC8udGVzdCh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpKSB7XHJcbiAgICBfcXVlc3Rpb24uc2hvd0ZpcnN0KClcclxuICB9XHJcblxyXG4gIC8vICQoJy50ZXN0X191cGRhdGUnKS5vbignY2xpY2snLCBfdGVzdC51cGRhdGUuYmluZChudWxsLCBwYXJlbnRTZWxlY3Quc2VsZWN0ZWRPcHRpb24sIGVuYWJsZVNlbGVjdC5zZWxlY3RlZE9wdGlvbikpXHJcbiAgJCgnLnRlc3QtcGF0aF9fdXBkYXRlJykub24oJ2NsaWNrJywgX3Rlc3QudXBkYXRlKVxyXG5cclxuLy8gJCgnLnF1ZXN0aW9uX19zb3J0Jykub24oJ2NoYW5nZScsIHZhbGlkYXRlLnNvcnQpXHJcbiAgJCgnLnF1ZXN0aW9uX19zYXZlJykub24oJ2NsaWNrJywgX3F1ZXN0aW9uLnNhdmUpXHJcbiAgJCgnLnF1ZXN0aW9uX19zaG93LWFuc3dlcnMnKS5vbignY2xpY2snLCBfcXVlc3Rpb24uc2hvd0Fuc3dlcnMpXHJcbiAgJCgnLnF1ZXN0aW9uX19kZWxldGUnKS5vbignY2xpY2snLCBfcXVlc3Rpb24uZGVsZXRlKVxyXG4gICQoJy5xdWVzdGlvbl9fY3JlYXRlLWJ1dHRvbicpLm9uKCdjbGljaycsIF9xdWVzdGlvbi5jcmVhdGUpXHJcblxyXG5cclxuICAkKCcuYW5zd2VyX19kZWxldGUnKS5vbignY2xpY2snLCBfYW5zd2VyLmRlbClcclxuICAkKCcuYW5zd2VyX19jcmVhdGUtYnV0dG9uJykub24oJ2NsaWNrJywgX2Fuc3dlci5jcmVhdGUpXHJcblxyXG5cclxuXHJcbiAgYWRkVG9vbHRpcCh7XHJcbiAgICBlbHM6ICQoJy5xdWVzdGlvbl9fc2F2ZScpLmVsLFxyXG4gICAgbWVzc2FnZTogJ9Ch0L7RhdGA0LDQvdC40YLRjCDQstC+0L/RgNC+0YHRiyDQuCDQvtGC0LLQtdGC0YsnXHJcbiAgfSlcclxuXHJcbiAgYWRkVG9vbHRpcCh7XHJcbiAgICBlbHM6ICQoJy5xdWVzdGlvbl9fbWVudScpLmVsLFxyXG4gICAgbWVzc2FnZTogJ9Cf0LXRgNC10LvQvtC20LjRgtGMINCyINC00YDRg9Cz0L7QuSDRgtC10YHRgidcclxuICB9KVxyXG4gIGFkZFRvb2x0aXAoe1xyXG4gICAgZWxzOiAkKCcucXVlc3Rpb25fX2RlbGV0ZScpLmVsLFxyXG4gICAgbWVzc2FnZTogJ9Cj0LTQsNC70LjRgtGMINCy0L7Qv9GA0L7RgdGLINC4INC+0YLQstC10YLRiydcclxuICB9KVxyXG5cclxuICBhZGRUb29sdGlwKHtcclxuICAgIGVsczogJCgnLnF1ZXN0aW9uX19zaG93LWFuc3dlcnMnKS5lbCxcclxuICAgIG1lc3NhZ2U6ICfQn9C+0LrQsNC30LDRgtGMINC+0YLQstC10YLRiydcclxuICB9KVxyXG5cclxuICBhZGRUb29sdGlwKHtcclxuICAgIGVsczogJCgnLnRlc3QtZWRpdC1tZW51X19wYXJhbXMnKS5lbCxcclxuICAgIG1lc3NhZ2U6ICfQoNC10LTQsNC60YLQuNGA0L7QstCw0YLRjCdcclxuICB9KVxyXG5cclxuICBhZGRUb29sdGlwKHtcclxuICAgIGVsczogJCgnLnF1ZXN0aW9uX19tZW51JykuZWwsXHJcbiAgICBtZXNzYWdlOiAn0J/QtdGA0LXQvdC10YHRgtC4INCyINC00YDRg9Cz0L7QuSDRgtC10YHRgidcclxuICB9KVxyXG5cclxufVxyXG5cclxuXHJcbiIsImltcG9ydCAnLi90ZXN0LXBhZ2luYXRpb24uc2NzcydcclxuaW1wb3J0IHskLCBwb3B1cCwgcG9zdH0gZnJvbSBcIi4uLy4uL2NvbW1vblwiO1xyXG5pbXBvcnQge19xdWVzdGlvbn0gZnJvbSBcIi4uLy4uL1Rlc3QvbW9kZWwvcXVlc3Rpb25cIjtcclxuaW1wb3J0IHtfYW5zd2VyfSBmcm9tIFwiLi4vLi4vVGVzdC9tb2RlbC9hbnN3ZXJcIjtcclxuXHJcbi8vINCf0L7QutCw0LfQsNGC0Ywg0L/QtdGA0LLRg9GOINC60L3QvtC/0LrRg1xyXG4kKCdbZGF0YS1wYWdpbmF0aW9uXTpmaXJzdC1jaGlsZCcpLmFkZENsYXNzKCduYXYtYWN0aXZlJylcclxuLy8gJCgnLnRlc3QtZWRpdF9fY29udGVudCcpLmFkZENsYXNzKCdmbGV4MScpXHJcblxyXG4vLy8vIGFkZCBxdWVzdGlvblxyXG4kKCcucGFnaW5hdGlvbicpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICBpZiAoZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhZGQtcXVlc3Rpb24nKSkge1xyXG4gICAgICAgIGRlYnVnZ2VyXHJcbiAgICAgICAgc2hvdygpXHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbi8vLy8gcGFnaW5hdGVcclxuICAgIGlmIChlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGFnaW5hdGlvbicpKSB7XHJcbiAgICAgICAgcGFnaW5hdGUoZS50YXJnZXQpXHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbn0pXHJcblxyXG5mdW5jdGlvbiBwYWdpbmF0ZShzZWxmKSB7XHJcbi8vLyBnZXQgY2xpY2tlZCBidXR0b24gUmV0dXJuIGlmIGNsaWNrZWQgaXMgYWN0aXZlXHJcbiAgICBpZiAoc2VsZi5jbGFzc0xpc3QuY29udGFpbnMoJ25hdi1hY3RpdmUnKSkgcmV0dXJuXHJcbiAgICBsZXQgYWN0aXZlX2J0biA9ICQoJy5wYWdpbmF0aW9uIC5uYXYtYWN0aXZlJykuZWxbMF1cclxuLy8vLyBjaGFuZ2UgYWN0aXZlIGJ1dHRvblxyXG4gICAgYWN0aXZlX2J0bi5jbGFzc0xpc3QucmVtb3ZlKCduYXYtYWN0aXZlJylcclxuICAgIHNlbGYuY2xhc3NMaXN0LmFkZCgnbmF2LWFjdGl2ZScpXHJcbi8vLy8gaGlkZSB0aGUgY2FyZFxyXG4gICAgbGV0IGlkX3RvX2hpZGUgPSBhY3RpdmVfYnRuLmRhdGFzZXRbJ3BhZ2luYXRpb24nXVxyXG4gICAgJChgI3F1ZXN0aW9uLSR7aWRfdG9faGlkZX1gKS5yZW1vdmVDbGFzcygnZmxleDEnKVxyXG4vLy8vIHNob3cgdGhlIGNhcmRcclxuICAgIGxldCBpZF90b19zaG93ID0gc2VsZi5kYXRhc2V0WydwYWdpbmF0aW9uJ11cclxuICAgICQoYCNxdWVzdGlvbi0ke2lkX3RvX3Nob3d9YCkuYWRkQ2xhc3MoJ2ZsZXgxJylcclxufVxyXG5cclxuLy8vLyDQtNC+0LHQsNCy0LvQtdC90LjQtSDQstC+0L/RgNC+0YHQsFxyXG5hc3luYyBmdW5jdGlvbiBzaG93KGUpIHtcclxuICAgIGxldCB0ZXN0aWQgPSArJCgnLnRlc3QtbmFtZScpLnZhbHVlKClcclxuICAgIGxldCBxdWVzdENvdW50ID0gJChcIltkYXRhLXBhZ2luYXRpb25dXCIpLmNvdW50KClcclxuXHJcbiAgICBsZXQgcmVzID0gYXdhaXQgcG9zdChcclxuICAgICAgICAnL3F1ZXN0aW9uL3Nob3cnLFxyXG4gICAgICAgIHt0ZXN0aWQsIHF1ZXN0Q291bnR9KVxyXG4gICAgcmVzID0gSlNPTi5wYXJzZShyZXMpXHJcbiAgICBsZXQgQmxvY2sgPSByZXMuYmxvY2tcclxuICAgIGxldCBibG9ja3MgPSAkKCcuYmxvY2tzJykuZWxbMF1cclxuICAgIGJsb2Nrcy5pbnNlcnRBZGphY2VudEhUTUwoJ2FmdGVyQmVnaW4nLCBCbG9jaylcclxuICAgIGxldCBuZXdCbG9jayA9ICQoJy5ibG9ja3MgLmJsb2NrOmZpcnN0LWNoaWxkJykuZWxbMF1cclxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mbGV4MScpLmNsYXNzTGlzdC5yZW1vdmUoJ2ZsZXgxJylcclxuICAgICQobmV3QmxvY2spLmFkZENsYXNzKCdmbGV4MScpXHJcbiAgICBsZXQgc2F2ZV9idXR0b24gPSAkKG5ld0Jsb2NrKS5maW5kKCcucXVlc3Rpb25fX3NhdmUnKVxyXG4gICAgICAgICQoc2F2ZV9idXR0b24pLm9uKCdjbGljaycsIF9xdWVzdGlvbigpLnNhdmUpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNob3dIaWRlUGFnaW5CdG4ocGFnSXRlbSkge1xyXG4gICAgbGV0IGFjdGl2ZVBhZ2luQnRuID0gJCgnLnBhZ2luYXRpb24gLm5hdi1hY3RpdmUnKS5lbFswXVxyXG4gICAgaWYgKGFjdGl2ZVBhZ2luQnRuKSB7XHJcbiAgICAgICAgYWN0aXZlUGFnaW5CdG4uY2xhc3NMaXN0LnJlbW92ZSgnbmF2LWFjdGl2ZScpXHJcbiAgICB9XHJcbiAgICAkKCcuYWRkLXF1ZXN0aW9uJykuZWxbMF0uaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVCZWdpbicsIHBhZ0l0ZW0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGVuZEJsb2NrKCkge1xyXG4gICAgbGV0IGJsb2NrID0gJCgnLm92ZXJsYXknKS5maW5kKCcuYmxvY2snKVxyXG4gICAgJCgnLmJsb2NrcycpLmFwcGVuZChibG9jaylcclxuICAgICQoYmxvY2spLmFkZENsYXNzKCdmbGV4MScpXHJcbiAgICAkKCcuYS1hZGQnKS5vbignY2xpY2snLCBfYW5zd2VyLmNyZWF0ZSlcclxuICAgICQoJy5xLWRlbGV0ZScpLm9uKCdjbGljaycsIF9xdWVzdGlvbigpLmRlbGV0ZSgpKVxyXG4gICAgJCgnLmEtZGVsJykub24oJ2NsaWNrJywgX2Fuc3dlci5kZWxldGUoKSlcclxufVxyXG5cclxuZnVuY3Rpb24gbmF2SW5pdCgpIHtcclxuICAgIGxldCBuYXZfYnV0dG9ucyA9ICQoJ1tkYXRhLXBhZ2luYXRpb25dJylcclxuICAgIGlmICghbmF2X2J1dHRvbnNbMF0pIHJldHVybiBmYWxzZVxyXG4gICAgQXJyYXkuZnJvbShuYXZfYnV0dG9ucykubWFwKChlbCk9PntcclxuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCduYXYtYWN0aXZlJylcclxuICAgIH0pXHJcbiAgICBuYXZfYnV0dG9uc1swXS5jbGFzc0xpc3QuYWRkKCduYXYtYWN0aXZlJylcclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7c2hvd0hpZGVQYWdpbkJ0biwgYXBwZW5kQmxvY2ssIG5hdkluaXR9XHJcblxyXG5cclxuIiwiaW1wb3J0ICcuL2RvLnNjc3MnXHJcblxyXG5cclxuXHJcbmltcG9ydCB7X3Rlc3R9IGZyb20gXCIuL21vZGVsL3Rlc3RcIlxyXG5pbXBvcnQge3Bvc3QsICR9IGZyb20gJy4uL2NvbW1vbidcclxuaW1wb3J0IHtuYXZJbml0fSBmcm9tICcuLi9jb21wb25lbnRzL3Rlc3QtcGFnaW5hdGlvbi90ZXN0LXBhZ2luYXRpb24nXHJcbmltcG9ydCBhY2NvcmRpb25TaG93IGZyb20gXCIuL2FjY29yZGlvbi1zaG93XCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0ZXN0RG8oKSB7XHJcblxyXG4gIGFjY29yZGlvblNob3coKVxyXG5cclxuLy/QodC60YDRi9GC0Ywg0LLRgdC1INCy0L7Qv9GA0L7RgdGLXHJcbiAgJCgnLnF1ZXN0aW9uJykucmVtb3ZlQ2xhc3MoXCJmbGV4MVwiKVxyXG5cclxuLy/Qn9C+0LrQsNC30YLRjCDQv9C10YDQstGL0Lkg0LLQvtC/0YDQvtGBXHJcbiAgJCgnLnF1ZXN0aW9uOmZpcnN0LWNoaWxkJykuYWRkQ2xhc3MoXCJmbGV4MVwiKVxyXG4vLyDQndCw0LbQsNGC0Ywg0L/QtdGA0LLRg9GO0LrQvdC+0L/QutGDIG5hdmlnYXRpb25cclxuICBuYXZJbml0KClcclxuICAkKCcudGVzdC1kb19fY29udGVudCBbdHlwZT1cImNoZWNrYm94XCJdJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcclxuICAgIGxldCBhID0gZS50YXJnZXQubGFiZWxzWzBdXHJcbiAgICBhLmNsYXNzTGlzdC50b2dnbGUoJ3B1c2hlZCcpXHJcbiAgfSlcclxuXHJcblxyXG4gICQoJyNwcmV2Jykub24oJ2NsaWNrJywgX3Rlc3QucHJldlEpXHJcbiAgJCgnI25leHQnKS5vbignY2xpY2snLCBfdGVzdC5uZXh0USlcclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLy8vLy8vLy8vLyAgUkVTVUxUUyAgVEVTVCAg0JfQsNC60L7QvdGH0LjRgtGMINGC0LXRgdGCLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8vINC10YHQu9C4INGN0YLQviDRgNC10LfRg9C70YzRgtCw0YIg0YLQtdGB0YLQsCwg0LTQtdCw0LrRgtC40LLQuNGA0YPQutC8INC60L3QvtC/0LrRgyDQl9Cw0LrQvtC90YfQuNGC0Ywg0YLQtdGB0YJcclxuICBsZXQgYnV0dG9uID0gJCgnLnRlc3QtZG9fX2ZpbmlzaC1idG4nKS5lbFswXVxyXG4gIGlmIChidXR0b24pIHtcclxuICAgIGlmICh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUubWF0Y2goJ14vdGVzdC9yZXN1bHQvLj8nKSkge1xyXG4gICAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgnaW5hY3RpdmUnKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgJCgnLnRlc3QtZG9fX2ZpbmlzaC1idG4nKS5vbignY2xpY2snLCBhc3luYyBmdW5jdGlvbiAoZSkge1xyXG5cclxuICAgIGxldCBidXR0b24gPSBlLnRhcmdldDtcclxuICAgIGlmIChidXR0b24uY2xhc3NMaXN0LmNvbnRhaW5zKCdpbmFjdGl2ZScpKSByZXR1cm4gZmFsc2VcclxuICAgIGlmIChidXR0b24uaWQgIT09ICdidG5uJykgcmV0dXJuIGZhbHNlXHJcblxyXG4gICAgaWYgKGJ1dHRvbi50ZXh0ID09IFwi0J/QoNCe0JnQotCYINCi0JXQodCiINCX0JDQndCe0JLQnlwiKSB7XHJcbiAgICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgY29yckFuc3dlcnMgPSBhd2FpdCBwb3N0KCcvdGVzdC9nZXRDb3JyZWN0QW5zd2VycycsIHt9KVxyXG4gICAgY29yckFuc3dlcnMgPSBKU09OLnBhcnNlKGNvcnJBbnN3ZXJzKVxyXG4gICAgbGV0IGVycm9yQ250ID0gY29sb3JWaWV3KGNvcnJBbnN3ZXJzKVxyXG4gICAgbGV0IGRhdGEgPSBvYmpUb1NlcnZlcihlcnJvckNudClcclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KCcvdGVzdC9jYWNoZVBhZ2VTZW5kRW1haWwnLCBkYXRhKVxyXG4gICAgaWYgKHJlcykge1xyXG4gICAgICAkKFwiI2J0bm5cIikuZWxbMF0uaHJlZiA9IGxvY2F0aW9uLmhyZWZcclxuICAgICAgJChcIiNidG5uXCIpLmVsWzBdLnRleHQgPSBcItCf0KDQntCZ0KLQmCDQotCV0KHQoiDQl9CQ0J3QntCS0J5cIlxyXG4gICAgfVxyXG4gIH0pXHJcblxyXG4gIGZ1bmN0aW9uIG9ialRvU2VydmVyKGVycm9yQ250KSB7XHJcblxyXG4gICAgbGV0IG9iaiA9IHtcclxuICAgICAgdG9rZW46IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT1cInRva2VuXCJdJykuZ2V0QXR0cmlidXRlKCdjb250ZW50JyksXHJcbiAgICAgIHF1ZXN0aW9uQ250OiAkKCcucXVlc3Rpb24nKS5lbC5sZW5ndGgsXHJcbiAgICAgIGVycm9yQ250OiBlcnJvckNudCxcclxuICAgICAgcGFnZUNhY2hlOiBgPCFET0NUWVBFICR7ZG9jdW1lbnQuZG9jdHlwZS5uYW1lfT5gICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm91dGVySFRNTCxcclxuICAgICAgdGVzdElkOiAkKCdbZGF0YS10ZXN0LWlkXScpLmVsWzBdLmRhdGFzZXQudGVzdElkLFxyXG4gICAgICB0ZXN0X25hbWU6ICQoJy50ZXN0LW5hbWUnKS5lbFswXS5pbm5lclRleHQsXHJcbiAgICAgIHVzZXJOYW1lOiAkKCcudXNlci1tZW51X19maW8nKS5lbFswXS5pbm5lclRleHQsXHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XHJcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ3Rva2VuJywgb2JqLnRva2VuKTtcclxuICAgIGZvcm1EYXRhLmFwcGVuZCgncXVlc3Rpb25DbnQnLCBvYmoucXVlc3Rpb25DbnQpO1xyXG4gICAgZm9ybURhdGEuYXBwZW5kKCdlcnJvckNudCcsIG9iai5lcnJvckNudCk7XHJcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ3BhZ2VDYWNoZScsIG9iai5wYWdlQ2FjaGUpO1xyXG4gICAgZm9ybURhdGEuYXBwZW5kKCd0ZXN0SWQnLCBvYmoudGVzdElkKTtcclxuICAgIGZvcm1EYXRhLmFwcGVuZCgndGVzdF9uYW1lJywgb2JqLnRlc3RfbmFtZSk7XHJcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ3VzZXJOYW1lJywgb2JqLnVzZXJOYW1lKTtcclxuICAgIHJldHVybiBmb3JtRGF0YVxyXG5cclxuICAgIHJldHVybiBvYmpcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiBjb2xvclZpZXcoY29ycmVjdEFuc3dlcnMpIHtcclxuICAgIGxldCBxID0gJCgnLnF1ZXN0aW9uJykuZWxcclxuICAgIEFycmF5LmZyb20ocSkubWFwKChxdWVzdGlvbiwgaSkgPT4ge1xyXG4gICAgICBsZXQgYW5zd2VycyA9IHF1ZXN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hJyksXHJcbiAgICAgICAgZXJyb3JzID0gW11cclxuICAgICAgQXJyYXkuZnJvbShhbnN3ZXJzKS5tYXAoKGFuc3dlcikgPT4ge1xyXG4gICAgICAgIGxldCBpbnB1dCA9IGFuc3dlci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5wdXQnKVswXSxcclxuICAgICAgICAgIGFuc3dlcklkID0gaW5wdXQuaWQucmVwbGFjZShcImFuc3dlci1cIiwgXCJcIiksIC8vIGlkIHF1ZXN0aW9uXHJcbiAgICAgICAgICBsYWJlbCA9IGFuc3dlci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGFiZWwnKVswXSwgLy8g0KfRgtC+0LHRiyDQv9GA0LjQutGA0LXQv9C40YLRjCDQt9C10LvQtdC90YvQuSDQt9C90LDRh9C10Log0Log0Y3RgtC+0LzRgyDRjdC70LXQvNC10L3RgtGDXHJcbiAgICAgICAgICBjb3JyZWN0QW5zZXIgPSBjb3JyZWN0QW5zd2Vycy5pbmRleE9mKGFuc3dlcklkKSAhPT0gLTFcclxuICAgICAgICBpZiAoIWNoZWNrQ29ycmVjdEFuc3dlcnMoY29ycmVjdEFuc2VyLCBpbnB1dCwgbGFiZWwpKSB7XHJcbiAgICAgICAgICBlcnJvcnMucHVzaCh0cnVlKVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuXHJcbiAgICAgIGxldCBxdWVzdElkID0gK3F1ZXN0aW9uLmRhdGFzZXRbJ2lkJ10sIC8vIGlkIHF1ZXN0aW9uXHJcbiAgICAgICAgcGFnaW5JdGVtID0gJCgnLnBhZ2luYXRpb24gW2RhdGEtcGFnaW5hdGlvbj1cIicgKyBxdWVzdElkICsgJ1wiXScpLmVsWzBdXHJcbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgJChwYWdpbkl0ZW0pLmFkZENsYXNzKCdyZWRTaGFkb3cnKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICQocGFnaW5JdGVtKS5hZGRDbGFzcygnZ3JlZW5TaGFkb3cnKVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gICAgcmV0dXJuICQoJy5yZWRTaGFkb3cnKS5lbC5sZW5ndGhcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNoZWNrQ29ycmVjdEFuc3dlcnMoY29ycmVjdEFuc2VyLCBpbnB1dCwgbGFiZWwpIHtcclxuICAgIGlmIChpbnB1dC5jaGVja2VkICYmIGNvcnJlY3RBbnNlcikgey8vIGNoZWNrYm94INC90LDQttCw0YIuINCwINCyIGNvcnJlY3QgYW5zd2VyINC90LXRgtGDLiDQsiBjb3JyZWN0X2Fuc3dlcnMg0LXRgdGC0YwsINC10LPQviDQstGB0LXQs9C00LAg0L/QvtC00YHQstC10YfQuNCy0LDQtdC8INC30LXQu9C10L3Ri9C8XHJcbiAgICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2RvbmUnKTsgLy9ncmVlbiBjaGVjayDQt9C10LvQtdC90YvQuSDQt9C90LDRh9C10LpcclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH0gZWxzZSBpZiAoaW5wdXQuY2hlY2tlZCAmJiAhY29ycmVjdEFuc2VyKSB7Ly8gY2hlY2tib3gg0L3QsNC20LDRgizQuCDQtdGB0YLRjCDQsiBjb3JyZWN0IGFuc3dlci4g0LIgY29ycmVjdF9hbnN3ZXJzINC90LXRgiwg0LrQvdC+0L/QutCwINC90LUg0L3QsNC20LDRgtCwXHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfSBlbHNlIGlmICghaW5wdXQuY2hlY2tlZCAmJiBjb3JyZWN0QW5zZXIpIHsvLyDQutC90L7Qv9C60LAg0L3QtSDQvdCw0LbQsNGC0LAsINCyIGNvcnJlY3RfYW5zd2VycyDQtdGB0YLRjFxyXG4gICAgICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdkb25lJyk7IC8vZ3JlZW4gY2hlY2sg0LfQtdC70LXQvdGL0Lkg0LfQvdCw0YfQtdC6XHJcbiAgICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2RvbmUnKTsvLyBncmVlbiBjaGVjayDQt9C10LvQtdC90YvQuSDQt9C90LDRh9C10LpcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9IGVsc2UgaWYgKCFpbnB1dC5jaGVja2VkICYmICFjb3JyZWN0QW5zZXIpIHsvLyDQutC90L7Qv9C60LAg0L3QtSDQvdCw0LbQsNGC0LAsINCyIGNvcnJlY3RfYW5zd2VycyDQvdC10YJcclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH1cclxuICB9XHJcblxyXG59XHJcblxyXG4iLCJpbXBvcnQgJy4vdXNlcnMuc2Nzcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0KCl7XHJcblxyXG59IiwiLy8gaW1wb3J0IHJpZ2h0cyBmcm9tICcuLi9SaWdodHMvcmlnaHRzJ1xyXG5pbXBvcnQgdXNlcnMgZnJvbSAnLi91c2VycydcclxuLy8gaW1wb3J0IHJpZ2h0cyBmcm9tIFwiLi9yaWdodHNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHRpbmdzKCl7XHJcblxyXG4gIC8vIHJpZ2h0cygpXHJcbiAgdXNlcnMoKVxyXG5cclxufSIsImltcG9ydCAnLi9saXN0LnNjc3MnO1xyXG5pbXBvcnQgeyR9IGZyb20gJy4uLy4uL2NvbW1vbic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0KHNlbGVjdG9yKSB7XHJcbiAgLy8gZGVidWdnZXI7XHJcblxyXG4gICQoJ2h0bWwnKS5yZWFkeShmdW5jdGlvbiAoKSB7XHJcbiAgICBjb25zdCB0YWJsZSA9ICQoJy5jdXN0b20tbGlzdCcpWzBdXHJcbiAgICBjb25zdCBoZWFkZXJzID0gdGFibGUucXVlcnlTZWxlY3RvckFsbCgnLmhlYWQnKVxyXG4gICAgY29uc3QgaW5wdXRzID0gdGFibGUucXVlcnlTZWxlY3RvckFsbCgnLmhlYWQgaW5wdXQnKVxyXG4gICAgY29uc3QgdGFibGVCb2R5ID0gdGFibGUucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtaWRdJylcclxuICAgIGNvbnN0IGlkcyA9ICQodGFibGUpWzBdLnF1ZXJ5U2VsZWN0b3JBbGwoJy5pZDpub3QoLmhlYWQnKVxyXG4gICAgY29uc3Qgcm93cyA9IFtdXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBsZXQgaWQgPSBpZHNbaV0uZGF0YXNldC5pZFxyXG4gICAgICBsZXQgcm93ID0gJCh0YWJsZSlbMF0ucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtaWQ9JyR7aWR9J11gKVxyXG4gICAgICByb3dzLnB1c2gocm93KVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbnN0IHJvd3MgPSB0YWJsZS5xdWVyeVNlbGVjdG9yQWxsKCd0ZCcpXHJcblxyXG4gICAgLy8g0J3QsNC/0YDQsNCy0LvQtdC90LjQtSDRgdC+0YDRgtC40YDQvtCy0LrQuFxyXG4gICAgY29uc3QgZGlyZWN0aW9ucyA9IEFycmF5LmZyb20oaGVhZGVycykubWFwKGZ1bmN0aW9uIChoZWFkZXIpIHtcclxuICAgICAgcmV0dXJuICcnXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyDQn9GA0LXQvtCx0YDQsNC30L7QstCw0YLRjCDRgdC+0LTQtdGA0LbQuNC80L7QtSDQtNCw0L3QvdC+0Lkg0Y/Rh9C10LnQutC4INCyINC30LDQtNCw0L3QvdC+0Lwg0YHRgtC+0LvQsdGG0LVcclxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShpbmRleCwgY29udGVudCkge1xyXG4gICAgICAvLyDQn9C+0LvRg9GH0LjRgtGMINGC0LjQvyDQtNCw0L3QvdGL0YUg0YHRgtC+0LvQsdGG0LBcclxuICAgICAgY29uc3QgdHlwZSA9IGhlYWRlcnNbaW5kZXhdLmdldEF0dHJpYnV0ZSgnZGF0YS10eXBlJylcclxuICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGNvbnRlbnQpXHJcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcmV0dXJuIGNvbnRlbnRcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBzaG93QWxsUm93cygpIHtcclxuICAgICAgW10uZm9yRWFjaC5jYWxsKHJvd3MsIChyb3cpID0+IHtcclxuICAgICAgICBbXS5mb3JFYWNoLmNhbGwocm93LCBlbCA9PiB7XHJcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0nZmxleCdcclxuICAgICAgICB9KVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNlYXJjaChpbmRleCwgaW5wdXQpIHtcclxuICAgICAgc2hvd0FsbFJvd3MoKVxyXG4gICAgICBjb25zdCB2YWx1ZSA9IGlucHV0LnZhbHVlO1xyXG5cclxuICAgICAgW10uZm9yRWFjaC5jYWxsKGlucHV0cywgKGlucCkgPT4ge1xyXG4gICAgICAgIGlmIChpbnAgIT09IGlucHV0KSBpbnAudmFsdWUgPSAnJ1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIFtdLmZvckVhY2guY2FsbChyb3dzLCBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgY29uc3Qgc3RyID0gcm93W2luZGV4XS5pbm5lclRleHRcclxuICAgICAgICBjb25zdCByZWdleHAgPSBuZXcgUmVnRXhwKGAke3ZhbHVlfWAsICdnaScpXHJcbiAgICAgICAgaWYgKCFzdHIubWF0Y2gocmVnZXhwKSkge1xyXG4gICAgICAgICAgW10uZm9yRWFjaC5jYWxsKHJvdywgZWwgPT4ge1xyXG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0nbm9uZSdcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHNvcnRDb2x1bW4oaW5kZXgpIHtcclxuICAgICAgLy8g0J/QvtC70YPRh9C40YLRjCDRgtC10LrRg9GJ0LXQtSDQvdCw0L/RgNCw0LLQu9C10L3QuNC1XHJcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGRpcmVjdGlvbnNbaW5kZXhdIHx8ICdhc2MnXHJcblxyXG4gICAgICAvLyDQpNCw0LrRgtC+0YAg0L/QviDQvdCw0L/RgNCw0LLQu9C10L3QuNGOXHJcbiAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSAoZGlyZWN0aW9uID09PSAnYXNjJykgPyAxIDogLTFcclxuXHJcbiAgICAgIGNvbnN0IG5ld1Jvd3MgPSBBcnJheS5mcm9tKHJvd3MpXHJcblxyXG4gICAgICBuZXdSb3dzLnNvcnQoZnVuY3Rpb24gKHJvd0EsIHJvd0IpIHtcclxuICAgICAgICBjb25zdCBjZWxsQSA9IHJvd0FbaW5kZXhdLmlubmVySFRNTFxyXG4gICAgICAgIGNvbnN0IGNlbGxCID0gcm93QltpbmRleF0uaW5uZXJIVE1MXHJcblxyXG4gICAgICAgIGNvbnN0IGEgPSB0cmFuc2Zvcm0oaW5kZXgsIGNlbGxBKVxyXG4gICAgICAgIGNvbnN0IGIgPSB0cmFuc2Zvcm0oaW5kZXgsIGNlbGxCKVxyXG5cclxuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcclxuICAgICAgICAgIGNhc2UgYSA+IGI6XHJcbiAgICAgICAgICAgIHJldHVybiAxICogbXVsdGlwbGllclxyXG4gICAgICAgICAgY2FzZSBhIDwgYjpcclxuICAgICAgICAgICAgcmV0dXJuIC0xICogbXVsdGlwbGllclxyXG4gICAgICAgICAgY2FzZSBhID09PSBiOlxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8g0KPQtNCw0LvQuNGC0Ywg0YHRgtCw0YDRi9C1INGB0YLRgNC+0LrQuFxyXG4gICAgICBbXS5mb3JFYWNoLmNhbGwocm93cywgZnVuY3Rpb24gKG5vZGVMaXN0KSB7XHJcbiAgICAgICAgW10uZm9yRWFjaC5jYWxsKG5vZGVMaXN0LCBlbCA9PiB7XHJcbiAgICAgICAgICBlbC5yZW1vdmUoKVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8g0J/QvtC80LXQvdGP0YLRjCDQvdCw0L/RgNCw0LLQu9C10L3QuNC1XHJcbiAgICAgIGRpcmVjdGlvbnNbaW5kZXhdID0gZGlyZWN0aW9uID09PSAnYXNjJyA/ICdkZXNjJyA6ICdhc2MnXHJcblxyXG4gICAgICAvLyDQlNC+0LHQsNCy0LjRgtGMINC90L7QstGD0Y4g0YHRgtGA0L7QutGDXHJcbiAgICAgIG5ld1Jvd3MuZm9yRWFjaChmdW5jdGlvbiAobmV3Um93KSB7XHJcbiAgICAgICAgbmV3Um93ID0gQXJyYXkuZnJvbShuZXdSb3cpO1xyXG4gICAgICAgIG5ld1Jvdy5yZXZlcnNlKCk7XHJcbiAgICAgICAgW10uZm9yRWFjaC5jYWxsKG5ld1JvdywgZWwgPT4ge1xyXG4gICAgICAgICAgaGVhZGVyc1toZWFkZXJzLmxlbmd0aCAtIDFdLmFmdGVyKGVsKVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgW10uZm9yRWFjaC5jYWxsKGhlYWRlcnMsIGZ1bmN0aW9uIChoZWFkZXIsIGluZGV4KSB7XHJcbiAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGhlYWRlci5jbGFzc05hbWVcclxuICAgICAgaGVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBpZiAoZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdoZWFkJykpIHtcclxuICAgICAgICAgIHNvcnRDb2x1bW4oaW5kZXgpXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgICBjb25zdCBpbnB1dCA9IGhlYWRlci5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpXHJcbiAgICAgIGlmIChpbnB1dCkge1xyXG4gICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcclxuICAgICAgICAgIHNlYXJjaChpbmRleCwgaW5wdXQpXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG5cclxuXHJcbiAgICB9KVxyXG5cclxuICB9KVxyXG59XHJcbiIsImltcG9ydCB7JH0gZnJvbSAnLi4vY29tbW9uJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGVudGVkaXRhYmxlKCkge1xyXG4gIGxldCBjb250ZW50ZWRpdGFibGUgPSAkKCdbY29udGVudGVkaXRhYmxlXScpXHJcbiAgbGV0IG1vZGVsID0gJCgnLmN1c3RvbS1saXN0JylbMF1cclxuICBsZXQgZGVib3VuY2VUaW1lclxyXG5cclxuICBpZiAobW9kZWwgJiYgY29udGVudGVkaXRhYmxlKSB7XHJcbiAgICAkKG1vZGVsKS5vbigna2V5dXAnLCBoYW5kbGUuYmluZChtb2RlbCwgY29udGVudGVkaXRhYmxlKSlcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGhhbmRsZShlKSB7XHJcbiAgICBpZiAoWydOdW1wYWRFbnRlcicsICdFbnRlciddLmluY2x1ZGVzKGUuY29kZSkpIHtcclxuICAgICAgc2F2ZSgpXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgbGV0IHRleHQgPSBlLnRhcmdldFxyXG5cclxuICAgICAgLy8gaW5wdXRlZChlLnRhcmdldCwgY29udGVudGVkaXRhYmxlKVxyXG4gICAgICAvLyBkZWJ1Z2dlclxyXG4gICAgICBpZiAoZGVib3VuY2VUaW1lcikge1xyXG4gICAgICAgIGNsZWFyVGltZW91dChkZWJvdW5jZVRpbWVyKVxyXG4gICAgICB9XHJcbiAgICAgIGRlYm91bmNlVGltZXIgPSBzZXRUaW1lb3V0KGlucHV0ZWQuYmluZChtb2RlbCwgY29udGVudGVkaXRhYmxlKSwgMzAwMClcclxuXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbnB1dGVkKHRhcmdldCwgY29udGVudGVkaXRhYmxlKSB7XHJcblxyXG5cclxuICAgIGxldCBlbCA9ICQoY29udGVudGVkaXRhYmxlKS5maW5kKHRhcmdldClcclxuICAgIGlmIChlbCkge1xyXG4gICAgICBzYXZlKClcclxuICAgICAgLy8gYWxlcnQoZWwuaW5uZXJUZXh0KVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2F2ZSgpIHtcclxuICAgIGFsZXJ0KCdkZCcpXHJcblxyXG4gIH1cclxufVxyXG5cclxuIiwiaW1wb3J0ICcuL3JpZ2h0cy5zY3NzJztcclxuaW1wb3J0IHskLCBwb3B1cCwgcG9zdH0gZnJvbSAnLi4vLi4vY29tbW9uJztcclxuaW1wb3J0IGxpc3QgZnJvbSAnQGNvbXBvbmVudHMvbGlzdC9saXN0J1xyXG5pbXBvcnQgY29udGVudGVkaXRhYmxlIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvY29udGVudGVkaXRhYmxlJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmlnaHRzKCkge1xyXG4gIC8vIGRlYnVnZ2VyXHJcbiAgY29udGVudGVkaXRhYmxlKClcclxuXHJcbiAgbGlzdCgpXHJcblxyXG4gICQoJy5yaWdodHMtdGFibGUnKS5vbignY2xpY2snLCBoYW5kbGUpXHJcblxyXG4gIGZ1bmN0aW9uIGhhbmRsZSh7dGFyZ2V0fSkge1xyXG4gICAgaWYgKHRhcmdldC5jbG9zZXN0KCcuZGVsJykpIGRlbCh0YXJnZXQuY2xvc2VzdCgnLmRlbCcpKVxyXG4gICAgaWYgKHRhcmdldC5jbG9zZXN0KCcuc2F2ZScpKSBzYXZlKHRhcmdldC5jbG9zZXN0KCcuc2F2ZScpKVxyXG5cclxuICAgIGZ1bmN0aW9uIG1vZGVsKGVsKSB7XHJcbiAgICAgIGxldCBkYXRhSWQgPSBlbC5kYXRhc2V0LmlkID8/ICduZXcnXHJcbiAgICAgIGxldCBmaWVsZHMgPSAkKGBbZGF0YS1pZD0nJHtkYXRhSWR9J11gKVxyXG4gICAgICBsZXQgbW9kZWwgPSB7fVxyXG4gICAgICBtb2RlbC50b1NlcnYgPSB7fVxyXG4gICAgICBtb2RlbC5lbXB0eSA9IHt9XHJcblxyXG4gICAgICBmaWVsZHMubWFwKChmKSA9PiB7XHJcbiAgICAgICAgaWYgKGYuY2xhc3NMaXN0LmNvbnRhaW5zKCdpZCcpKSB7XHJcbiAgICAgICAgICBtb2RlbC5pZCA9IGZcclxuICAgICAgICAgIG1vZGVsLnRvU2Vydi5pZCA9IGYuZGF0YXNldC5pZFxyXG4gICAgICAgIH0gZWxzZSBpZiAoZi5jbGFzc0xpc3QuY29udGFpbnMoJ25hbWUnKSkge1xyXG4gICAgICAgICAgbW9kZWwubmFtZSA9IGZcclxuICAgICAgICAgIG1vZGVsLnRvU2Vydi5uYW1lID0gZi5pbm5lclRleHQudHJpbSgpXHJcbiAgICAgICAgfSBlbHNlIGlmIChmLmNsYXNzTGlzdC5jb250YWlucygnZGVzY3JpcHRpb24nKSkge1xyXG4gICAgICAgICAgbW9kZWwuZGVzY3JpcHRpb24gPSBmXHJcbiAgICAgICAgICBtb2RlbC50b1NlcnYuZGVzY3JpcHRpb24gPSBmLmlubmVyVGV4dC50cmltKClcclxuICAgICAgICB9IGVsc2UgaWYgKGYuY2xhc3NMaXN0LmNvbnRhaW5zKCdzYXZlLnN2ZycpKSB7XHJcbiAgICAgICAgICBtb2RlbC5zYXZlID0gZlxyXG4gICAgICAgIH0gZWxzZSBpZiAoZi5jbGFzc0xpc3QuY29udGFpbnMoJ2RlbCcpKSB7XHJcbiAgICAgICAgICBtb2RlbC5kZWwgPSBmXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgbW9kZWwuZW1wdHkuZGVsID0gbW9kZWwuaWQucHJldmlvdXNFbGVtZW50U2libGluZy5jbG9uZU5vZGUodHJ1ZSlcclxuICAgICAgbW9kZWwuZW1wdHkuc2F2ZSA9IG1vZGVsLmlkLnByZXZpb3VzRWxlbWVudFNpYmxpbmcucHJldmlvdXNFbGVtZW50U2libGluZy5jbG9uZU5vZGUodHJ1ZSlcclxuICAgICAgbW9kZWwuZW1wdHkuZGVzY3JpcHRpb24gPSBtb2RlbC5pZC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnByZXZpb3VzRWxlbWVudFNpYmxpbmcucHJldmlvdXNFbGVtZW50U2libGluZy5jbG9uZU5vZGUodHJ1ZSlcclxuICAgICAgbW9kZWwuZW1wdHkubmFtZSA9IG1vZGVsLmlkLnByZXZpb3VzRWxlbWVudFNpYmxpbmcucHJldmlvdXNFbGVtZW50U2libGluZy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuY2xvbmVOb2RlKHRydWUpXHJcbiAgICAgIG1vZGVsLmVtcHR5LmlkID0gbW9kZWwuaWQucHJldmlvdXNFbGVtZW50U2libGluZy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnByZXZpb3VzRWxlbWVudFNpYmxpbmcucHJldmlvdXNFbGVtZW50U2libGluZy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmNsb25lTm9kZSh0cnVlKVxyXG5cclxuICAgICAgcmV0dXJuIG1vZGVsXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGRlbChlbCkge1xyXG4gICAgICBsZXQgbW9kID0gbW9kZWwoZWwpXHJcbiAgICAgIGlmIChtb2QudG9TZXJ2LmlkID09PSAnbmV3JykgcmV0dXJuXHJcbiAgICAgIGlmIChjb25maXJtKFwi0KPQtNCw0LvQuNGC0Ywg0L/RgNCw0LLQvj9cIikpIHtcclxuICAgICAgICBkZWxEb20obW9kKVxyXG4gICAgICAgIGRlbFNlcnZlcihtb2QpXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBmdW5jdGlvbiBkZWxTZXJ2ZXIobW9kZWwpIHtcclxuICAgICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9yaWdodC9kZWxldGUnLCB7aWQ6IG1vZGVsLnRvU2Vydi5pZH0pXHJcbiAgICAgIHJlcyA9IGF3YWl0IEpTT04ucGFyc2UocmVzKVxyXG4gICAgICBpZiAocmVzLm1zZyA9PT0gJ29rJykge1xyXG4gICAgICAgIHBvcHVwLnNob3coJ9Cj0LTQsNC70LXQvdC+JylcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRlbERvbShtb2RlbCkge1xyXG4gICAgICBtb2RlbC5pZC5yZW1vdmUoKVxyXG4gICAgICBtb2RlbC5uYW1lLnJlbW92ZSgpXHJcbiAgICAgIG1vZGVsLmRlc2NyaXB0aW9uLnJlbW92ZSgpXHJcbiAgICAgIG1vZGVsLnNhdmUucmVtb3ZlKClcclxuICAgICAgbW9kZWwuZGVsLnJlbW92ZSgpXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHNhdmUoZWwpIHtcclxuICAgICAgbGV0IG1vZCA9IG1vZGVsKGVsKVxyXG4gICAgICBpZiAobW9kLnRvU2Vydi5pZCAhPT0gJ25ldycpIHtcclxuICAgICAgICB1cGRhdGUobW9kLnRvU2VydilcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoIW1vZC50b1NlcnYubmFtZSB8fCAhbW9kLnRvU2Vydi5kZXNjcmlwdGlvbikgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgY3JlYXRlKG1vZClcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZSh0b1NlcnYpIHtcclxuICAgICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9yaWdodC91cGRhdGUnLCB0b1NlcnYpXHJcbiAgICAgIGlmIChhd2FpdCBKU09OLnBhcnNlKHJlcykudXBkYXRlZCkge1xyXG4gICAgICAgIHBvcHVwLnNob3coJ9Ce0LHQvdC+0LLQu9C10L3QvicpXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjbGVhck1vZGVsKG1vZGVsKXtcclxuICAgICAgbW9kZWwubmFtZS5pbm5lclRleHQgPSBcIlwiXHJcbiAgICAgIG1vZGVsLmRlc2NyaXB0aW9uLmlubmVyVGV4dCA9IFwiXCJcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVPbkRvbShtb2RlbCl7XHJcbiAgICAgIGxldCBsYXN0RWxlbWVudCA9ICQoXCIuaWRbZGF0YS1pZD0nbmV3J11cIilbMF1cclxuICAgICAgbGFzdEVsZW1lbnQuYmVmb3JlKG1vZGVsLmVtcHR5LmlkKVxyXG4gICAgICBsYXN0RWxlbWVudC5iZWZvcmUobW9kZWwuZW1wdHkubmFtZSlcclxuICAgICAgbGFzdEVsZW1lbnQuYmVmb3JlKG1vZGVsLmVtcHR5LmRlc2NyaXB0aW9uKVxyXG4gICAgICBsYXN0RWxlbWVudC5iZWZvcmUobW9kZWwuZW1wdHkuc2F2ZSlcclxuICAgICAgbGFzdEVsZW1lbnQuYmVmb3JlKG1vZGVsLmVtcHR5LmRlbClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhc3NpZ25OZXdWYWx1ZXNPbkNsb25lKG1vZGVsLCBpZCl7XHJcbiAgICAgIG1vZGVsLmVtcHR5LmlkLmRhdGFzZXQuaWQgPSBpZFxyXG4gICAgICBtb2RlbC5lbXB0eS5pZC5pbm5lclRleHQgPSBpZFxyXG4gICAgICBtb2RlbC5lbXB0eS5uYW1lLmRhdGFzZXQuaWQgPSBpZFxyXG4gICAgICBtb2RlbC5lbXB0eS5uYW1lLmlubmVyVGV4dCA9IG1vZGVsLm5hbWUuaW5uZXJUZXh0LnRyaW0oKVxyXG4gICAgICBtb2RlbC5lbXB0eS5kZXNjcmlwdGlvbi5kYXRhc2V0LmlkID0gaWRcclxuICAgICAgbW9kZWwuZW1wdHkuZGVzY3JpcHRpb24uaW5uZXJUZXh0ID0gbW9kZWwuZGVzY3JpcHRpb24uaW5uZXJUZXh0LnRyaW0oKVxyXG4gICAgICBtb2RlbC5lbXB0eS5zYXZlLmRhdGFzZXQuaWQgPSBpZFxyXG4gICAgICBtb2RlbC5lbXB0eS5kZWwuZGF0YXNldC5pZCA9IGlkXHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlKG1vZGVsKSB7XHJcbiAgICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KCcvcmlnaHQvY3JlYXRlJywgbW9kZWwudG9TZXJ2KVxyXG4gICAgICByZXMgPSBhd2FpdCBKU09OLnBhcnNlKHJlcylcclxuXHJcbiAgICAgIGlmIChyZXMuaWQpIHtcclxuXHJcbiAgICAgICAgYXNzaWduTmV3VmFsdWVzT25DbG9uZShtb2RlbCwgcmVzLmlkLTEpXHJcbiAgICAgICAgY3JlYXRlT25Eb20obW9kZWwpXHJcbiAgICAgICAgY2xlYXJNb2RlbChtb2RlbClcclxuXHJcbiAgICAgICAgcG9wdXAuc2hvdygn0KHQvtGF0YDQsNC90LXQvdC+JylcclxuICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcblxyXG4gIH1cclxufSIsImltcG9ydCAnLi9jcmVhdGUvY3JlYXRlJ1xyXG5cclxuaW1wb3J0ICcuL3BsYW5uaW5nLnNjc3MnXHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGxhbm5pbmcoKXtcclxuZGVidWdnZXJcclxuXHJcbn0iLCJpbXBvcnQgeyQsIHBvcHVwLCBwb3N0fSBmcm9tICcuLi8uLi9jb21tb24nXHJcbmltcG9ydCBsaXN0IGZyb20gJ0AvY29tcG9uZW50cy9saXN0L2xpc3QnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VyKCkge1xyXG5cclxuICBsaXN0KClcclxuXHJcbiAgJCgnI3VzZXItdXBkYXRlLWJ0bicpLm9uKCdjbGljaycsIHNhdmUpXHJcblxyXG4gIGFzeW5jIGZ1bmN0aW9uIHNhdmUoZSkge1xyXG4gICAgbGV0IHJpZ2h0cyA9ICQoJ2lucHV0LnJpZ2h0OmNoZWNrZWQnKVxyXG4gICAgcmlnaHRzID0gcmlnaHRzLm1hcCgocikgPT4gci5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmlubmVySFRNTClcclxuICAgIHJpZ2h0cyA9IHJpZ2h0cy5qb2luKCcsJyk7XHJcbiAgICBsZXQgc2VsID0gJCgnLnRhYnMnKS5maW5kKCcjY29uZicpXHJcbiAgICBsZXQgY29uZiA9IHNlbC5vcHRpb25zW3NlbC5vcHRpb25zLnNlbGVjdGVkSW5kZXhdLnZhbHVlXHJcblxyXG4gICAgZnVuY3Rpb24gc2V4KCkge1xyXG4gICAgICBjb25zdCBmID0gJCgnW25hbWU9XCJzZXhcIl06Y2hlY2tlZCcpWzBdXHJcbiAgICAgIGNvbnN0IHMgPSAkKCdbbmFtZT1cInNleFwiXScpLmVsXHJcbiAgICAgIGZvciAobGV0IGYgb2Ygcykge1xyXG4gICAgICAgIGlmIChmLmNoZWNrZWQpIHtcclxuICAgICAgICAgIHJldHVybiBmLnZhbHVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAnbSdcclxuICAgIH1cclxuICAgIGNvbnN0IG1vZGVsID0ge1xyXG4gICAgICBpZDogJCgnLnRhYnMnKS5maW5kKCcjaWQnKS5pbm5lclRleHQudHJpbSgpLFxyXG4gICAgICBjb25maXJtOiBjb25mLFxyXG4gICAgICBuYW1lOiAkKCcudGFicycpLmZpbmQoJyNuYW1lJykuaW5uZXJUZXh0LFxyXG4gICAgICBzdXJOYW1lOiAkKCcudGFicycpLmZpbmQoJyNzLW5hbWUnKS5pbm5lclRleHQsXHJcbiAgICAgIGVtYWlsOiAkKCcudGFicycpLmZpbmQoJyNlbWFpbCcpLmlubmVyVGV4dC50cmltKCksXHJcbiAgICAgIG1pZGRsZU5hbWU6ICQoJy50YWJzJykuZmluZCgnI20tbmFtZScpLmlubmVyVGV4dCxcclxuICAgICAgcGhvbmU6ICQoJy50YWJzJykuZmluZCgnI3Bob25lJykuaW5uZXJUZXh0LFxyXG4gICAgICBiaXJ0aERhdGU6ICQoJy50YWJzJykuZmluZCgnI2JkYXknKS52YWx1ZSxcclxuICAgICAgaGlyZWQ6ICQoJy50YWJzJykuZmluZCgnI2hpcmVkJykudmFsdWUsXHJcbiAgICAgIGZpcmVkOiAkKCcudGFicycpLmZpbmQoJyNmaXJlZCcpLnZhbHVlLFxyXG4gICAgICByaWdodHM6IHJpZ2h0cyxcclxuICAgICAgc2V4OiBzZXgoKSxcclxuICAgIH1cclxuXHJcbiAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCgnL3VzZXIvdXBkYXRlJywgbW9kZWwpXHJcblxyXG4gICAgaWYocmVzID09PSAnb2snKXtcclxuICAgICAgcG9wdXAuc2hvdygn0KHQvtGF0YDQsNC90LXQvdC+JylcclxuICAgIH1cclxuXHJcblxyXG5cclxuICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4iLCJpbXBvcnQgeyR9IGZyb20gJy4uLy4uL2NvbW1vbidcclxuaW1wb3J0IGxpc3QgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9saXN0L2xpc3QnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VycygpIHtcclxuXHJcbiAgbGlzdCgpXHJcblxyXG4gICQoJyN1c2VycyBkaXZbZGF0YS1pZF0nKS5vbignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgY3J1ZFVzZXIoJ1VQREFURScsICQodGhpcykpO1xyXG4gIH0pO1xyXG5cclxuICBmdW5jdGlvbiBjcnVkVXNlcihjcnVkLCB0YXJnZXQpIHtcclxuXHJcbiAgICB2YXIgZGF0YSA9IHtcclxuXHJcbiAgICAgIG5hbWU6ICQodGFyZ2V0KS5maW5kKCcubmFtZScpLnZhbCgpLFxyXG4gICAgICBzTmFtZTogJCh0YXJnZXQpLmZpbmQoJy5zLW5hbWUnKS52YWwoKSxcclxuICAgICAgbU5hbWU6ICQodGFyZ2V0KS5maW5kKCcubS1uYW1lJykudmFsKCksXHJcbiAgICAgIGJkYXk6ICQodGFyZ2V0KS5maW5kKCcuYmRheScpLnZhbCgpLFxyXG4gICAgICBwaG9uZTogJCh0YXJnZXQpLmZpbmQoJy5waG9uZScpLnZhbCgpLFxyXG4gICAgICBjb25mOiAkKHRhcmdldCkuZmluZCgnLmNvbmZpcm0nKS52YWwoKSxcclxuICAgICAgZW1haWw6ICQodGFyZ2V0KS5maW5kKCcuZW1haWwnKS52YWwoKSxcclxuICAgICAgaGlyZWQ6ICQodGFyZ2V0KS5maW5kKCcuaGlyZWQnKS52YWwoKSxcclxuICAgICAgZmlyZWQ6ICQodGFyZ2V0KS5maW5kKCcuZmlyZWQnKS52YWwoKSxcclxuICAgICAgdXNlcklkOiAkKHRhcmdldCkuZGF0YSgnaWQnKSxcclxuICAgICAgdGFibGU6ICd1c2VycycsXHJcbiAgICAgIGNydWQ6IGNydWRcclxuICAgIH07XHJcbiAgICB2YXIgcGFyYW0gPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxuXHJcblxyXG4gIH1cclxuICA7XHJcblxyXG5cclxuICAkKCcud3JhcCcpLm9uKCdjbGljaycsICcuc2F2ZS5zdmcnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc2VsZiA9ICQodGhpcylbMF07XHJcbiAgICBpZiAoc2VsZi5jbGFzc0xpc3QuY29udGFpbnMoJ25ldycpKSB7XHJcbiAgICAgIGNydWRVc2VyKCdJTlNFUlQnLCAkKHRoaXMpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNydWRVc2VyKCdVUERBVEUnLCAkKHRoaXMpKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcblxyXG4gICQoJy53cmFwJykub24oJ2NsaWNrJywgJy5idG5hZGQtdXNlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBkYXRhID0ge1xyXG4gICAgICBhY3Rpb246ICdhZGRVc2VyJ1xyXG4gICAgfTtcclxuICAgIHBvc3QoJy9hZG1pbnNjL3VzZXJzJywgZGF0YSkudGhlbihmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICQoJ3Rib2R5JykuYXBwZW5kKHN0cik7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgYXN5bmMgZnVuY3Rpb24gcG9zdCh1cmwsIGRhdGEpIHtcclxuLy8gICAgICBkZWJ1Z2dlcjtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgcmVxLm9wZW4oJ1BPU1QnLCB1cmwpO1xyXG4gICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xyXG4gICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcclxuICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoXCJYLVJlcXVlc3RlZC1XaXRoXCIsIFwiWE1MSHR0cFJlcXVlc3RcIik7XHJcbiAgICAgIHJlcS5zZW5kKCdwYXJhbT0nICsgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xyXG4gICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZWplY3QoRXJyb3IoXCJOZXR3b3JrIEVycm9yXCIpKTtcclxuICAgICAgfTtcclxuICAgICAgcmVxLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXNvbHZlKHJlcS5yZXNwb25zZSk7XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG59XHJcblxyXG5cclxuIiwiaW1wb3J0ICcuL2FkbWluLnNjc3MnXHJcblxyXG5pbXBvcnQgJy4uL2NvbXBvbmVudHMvaGVhZGVyL2hlYWRlci1hZG0nXHJcbmltcG9ydCAnLi4vY29tcG9uZW50cy9hY2NvcmRpb24vYWNjb3JkaW9uJ1xyXG5pbXBvcnQgXCIuL21vZGVsL2NhY2hlXCI7XHJcbmltcG9ydCB7JH0gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5cclxuaW1wb3J0IHRlc3RSZXN1bHRzIGZyb20gJy4uL1Rlc3QvdGVzdF9yZXN1bHRzL3Rlc3RfcmVzdWx0cydcclxuaW1wb3J0IHRlc3RFZGl0IGZyb20gJy4uL1Rlc3QvdGVzdC1lZGl0J1xyXG5pbXBvcnQgdGVzdERvIGZyb20gJy4uL1Rlc3QvZG8nXHJcbmltcG9ydCB0ZXN0VXBkYXRlIGZyb20gJy4uL1Rlc3QvdGVzdC11cGRhdGUnXHJcbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuL1NldHRpbmdzL3NldHRpbmdzJ1xyXG5pbXBvcnQgcmlnaHRzIGZyb20gJy4vUmlnaHRzL3JpZ2h0cydcclxuaW1wb3J0IHBsYW5uaW5nIGZyb20gJy4vUGxhbm5pbmcvcGxhbm5pbmcnXHJcbmltcG9ydCB1c2VyIGZyb20gJy4vQ1JNL3VzZXInXHJcbmltcG9ydCB1c2VycyBmcm9tICcuL0NSTS91c2VycydcclxuXHJcbi8vIGxldCBwID0gJCgnLnBhZ2UtbmFtZScpWzBdXHJcbm5hdmlnYXRlKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSlcclxuXHJcblxyXG5mdW5jdGlvbiBuYXZpZ2F0ZShzdHIpIHtcclxuICAvLyBkZWJ1Z2dlclxyXG4gIHN3aXRjaCAodHJ1ZSkge1xyXG4gICAgY2FzZSAvXFwvYWRtaW5zY1xcL3NldHRpbmdzLy50ZXN0KHN0cik6XHJcbiAgICBjYXNlIC9cXC9hZG1pbnNjXFwvcmlnaHRcXC9saXN0Ly50ZXN0KHN0cik6XHJcbiAgICAgIC8vIGRlYnVnZ2VyXHJcbiAgICAgIHJpZ2h0cygpXHJcbiAgICAgICQoXCJbaHJlZj0nL2FkbWluc2Mvc2V0dGluZ3MnXVwiKS5hZGRDbGFzcygnY3VycmVudCcpXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAvXFwvYWRtaW5zY1xcL1NpdGVtYXAvLnRlc3Qoc3RyKTpcclxuICAgICAgc2V0dGluZ3MoKVxyXG4gICAgICAkKFwiW2hyZWY9Jy9hZG1pbnNjL3NldHRpbmdzJ11cIikuYWRkQ2xhc3MoJ2N1cnJlbnQnKVxyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlIC9cXC9hZG1pbnNjXFwvY3JtXFwvdGVzdHJlc3VsdHMvLnRlc3Qoc3RyKTpcclxuICAgICAgdGVzdFJlc3VsdHMoKVxyXG4gICAgICAkKFwiW2hyZWY9Jy9hZG1pbnNjL2NybS90ZXN0cmVzdWx0cyddXCIpLmFkZENsYXNzKCdjdXJyZW50JylcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAvXFwvYWRtaW5zY1xcL3VzZXIvLnRlc3Qoc3RyKTpcclxuICAgICAgdXNlcigpXHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgL1xcL2FkbWluc2NcXC91c2VyXFwvbGlzdC8udGVzdChzdHIpOlxyXG4gICAgICB1c2VycygpXHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgL1xcL2FkbWluc2NcXC9jcm0vLnRlc3Qoc3RyKTpcclxuICAgICAgJChcIltocmVmPScvYWRtaW5zYy9jcm0nXVwiKS5hZGRDbGFzcygnY3VycmVudCcpXHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgL1xcL2FkbWluc2NcXC9jYXRhbG9nLy50ZXN0KHN0cik6XHJcbiAgICAgICQoXCJbaHJlZj0nL2FkbWluc2MvY2F0YWxvZyddXCIpLmFkZENsYXNzKCdjdXJyZW50JylcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAvXFwvYWRtaW5zY1xcL3BsYW5uaW5nLy50ZXN0KHN0cik6XHJcbiAgICAgIHBsYW5uaW5nKClcclxuICAgICAgJChcIltocmVmPScvYWRtaW5zYy9wbGFubmluZyddXCIpLmFkZENsYXNzKCdjdXJyZW50JylcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAvXFwvYWRtaW5zY1xcL3Rlc3RcXC91cGRhdGUvLnRlc3Qoc3RyKTpcclxuICAgIGNhc2UgL1xcL2FkbWluc2NcXC90ZXN0XFwvc2hvdy8udGVzdChzdHIpOlxyXG4gICAgICB0ZXN0VXBkYXRlKClcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAvXFwvYWRtaW5zY1xcL3Rlc3RcXC9wYXRoc2hvdy8udGVzdChzdHIpOlxyXG4gICAgY2FzZSAvXFwvYWRtaW5zY1xcL3Rlc3RcXC9lZGl0Ly50ZXN0KHN0cik6XHJcbiAgICAgIC8vIGRlYnVnZ2VyXHJcbiAgICAgIHRlc3RFZGl0KClcclxuICAgICAgJChcIltocmVmPScvYWRtaW5zYy90ZXN0L2VkaXQnXVwiKS5hZGRDbGFzcygnY3VycmVudCcpXHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgL1xcL3Rlc3QvLnRlc3Qoc3RyKSB8fCAvXFwvdGVzdFxcL3Jlc3VsdC8udGVzdChzdHIpOlxyXG4gICAgICB0ZXN0RG8oKVxyXG4gICAgICAkKFwiW2hyZWY9Jy90ZXN0L2RvJ11cIikuYWRkQ2xhc3MoJ2N1cnJlbnQnKVxyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICAkKFwiW2hyZWY9Jy9ob3VzZSddXCIpLmFkZENsYXNzKCdjdXJyZW50JylcclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG59XHJcblxyXG5cclxuXHJcbiJdLCJuYW1lcyI6WyJkcm9wRG93biIsImVsZW1lbnRJZCIsImRyb3Bkb3duIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInNob3dEcm9wZG93biIsImUiLCJlbGVtZW50IiwiZXZlbnQiLCJjcmVhdGVFdmVudCIsImluaXRNb3VzZUV2ZW50Iiwid2luZG93IiwiZGlzcGF0Y2hFdmVudCIsInZhbGlkYXRlIiwic29ydCIsImVycm9yIiwibmV4dEVsZW1lbnRTaWJsaW5nIiwiYXIiLCJ2YWx1ZSIsIm1hdGNoIiwiaW5uZXJUZXh0Iiwic3R5bGUiLCJvcGFjaXR5IiwiZW1haWwiLCJyZSIsInRlc3QiLCJTdHJpbmciLCJ0b0xvd2VyQ2FzZSIsInBhc3N3b3JkIiwicG9wdXAiLCJzaG93IiwidHh0IiwiY2FsbGJhY2siLCJjbG9zZSIsImVsIiwicG9wdXBfX2l0ZW0iLCJhcHBlbmQiLCIkIiwiYWRkRXZlbnRMaXN0ZW5lciIsImJvZHkiLCJoaWRlRGVsYXkiLCJzZXRUaW1lb3V0IiwiY2xhc3NMaXN0IiwicmVtb3ZlIiwiYWRkIiwicmVtb3ZlRGVsYXkiLCJ0YXJnZXQiLCJjb250YWlucyIsImNsb3Nlc3QiLCJ0YWdOYW1lIiwiY2xhc3NOYW1lIiwiY3JlYXRlRWxlbWVudCIsInVuaXEiLCJhcnJheSIsIkFycmF5IiwiZnJvbSIsIlNldCIsImdldCIsImtleSIsInAiLCJsb2NhdGlvbiIsInNlYXJjaCIsIlJlZ0V4cCIsInBvc3QiLCJ1cmwiLCJkYXRhIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ0b2tlbiIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRBdHRyaWJ1dGUiLCJyZXEiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJzZXRSZXF1ZXN0SGVhZGVyIiwiRm9ybURhdGEiLCJzZW5kIiwiSlNPTiIsInN0cmluZ2lmeSIsIm9uZXJyb3IiLCJFcnJvciIsIm9ubG9hZCIsInJlc3BvbnNlIiwiRWxlbWVudENvbGxlY3Rpb24iLCJ0b1N0cmluZyIsImNhbGwiLCJhdHRyTmFtZSIsImF0dHJWYWwiLCJzZXRBdHRyaWJ1dGUiLCJsZW5ndGgiLCJzZWxlY3RlZE9wdGlvbnMiLCJvcHRpb25zIiwiY2hlY2tlZCIsImF0dHIiLCJ2YWwiLCJhcnIiLCJmb3JFYWNoIiwicyIsInB1c2giLCJhcHBlbmRDaGlsZCIsIml0ZW0iLCJmaWx0ZXJlZCIsImZpbHRlciIsIm9uIiwiY2JPclNlbGVjdG9yIiwiY2IiLCJlbGVtIiwibWF0Y2hlcyIsInJlYWR5IiwiaXNSZWFkeSIsInNvbWUiLCJyZWFkeVN0YXRlIiwic2VsZWN0b3IiLCJxdWVyeVNlbGVjdG9yQWxsIiwiYWRkVG9vbHRpcCIsImFyZ3MiLCJlbHMiLCJtYXAiLCJvbm1vdXNlZW50ZXIiLCJ0aXAiLCJhZGRDbGFzcyIsIm1lc3NhZ2UiLCJiaW5kIiwib25tb3VzZWxlYXZlIiwidGVzdF9kZWxldGVfYnV0dG9uIiwiY29uc3RydWN0b3IiLCJfZWxlbSIsIm9uY2xpY2siLCJkZWxldGUiLCJzaG93VG9vbGlwIiwiaGlkZVRvb2x0aXAiLCJvbm1vdXNlbW92ZSIsImNoYW5nZVRvb2x0aXBQb3MiLCJjb25maXJtIiwicmVzIiwiZGVsIiwibXNnIiwieCIsImNsaWVudFgiLCJ5IiwiY2xpZW50WSIsInRvcCIsImxlZnQiLCJwYWdlWSIsInBhZ2VYIiwiaGFuZGxlVG9nZ2xlIiwiY2hlY2tib3hlcyIsImNoIiwiY2hlY2tib3giLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwicGFyZW50IiwidWwiLCJwYXJlbnROb2RlIiwiZmluZCIsInNsaWRlVXAiLCJoZWlnaHQiLCJzbGlkZURvd24iLCJ1bEhlaWdodCIsInNjcm9sbEhlaWdodCIsImluY3JlYXNlUGFyZW50IiwiY2xvc2VTaWJsaW5ncyIsInBhcmVudEhlaWdodCIsInBhcnNlSW50IiwibWF4SGVpZ2h0IiwiY2hpbGRyZW4iLCJlbEFyciIsInR5cGUiLCJpbnRlcnZhbCIsIl9jYWNoZSIsImNsZWFyQ2FjaGUiLCJjYWNoZSIsIl90ZXN0UmVzdWx0IiwiZGVsU2VydmVyIiwiaWQiLCJkZWxEb20iLCJkYXRhc2V0Iiwicm93IiwiaSIsInRlc3RSZXN1bHRzIiwiX3Rlc3QiLCJtYXJrQ3VycmVudEluTWVudSIsImN1cnJlbnRUZXN0SWQiLCJtZW51SXRlbUNvbGxlY3Rpb24iLCJhIiwibmV4dFEiLCJjdXJyZW50IiwiY3VycmVudFEiLCJuYXZMZW5ndGgiLCJhaW1OYXZJZCIsImFpbU5hdklkRnVuY3Rpb24iLCJhaW1RRWwiLCJhaW1RRWxGdW5jdGlvbiIsInB1c2hOYXYiLCJwdXNoUSIsIlFFbCIsInByZXZRIiwiY3VycmVudElkIiwiY3Vyck5hdkVsIiwidG9nZ2xlIiwiTmF2RWwiLCJjdXJyZW50RWwiLCJkaXJlY3Rpb24iLCJkaXIiLCJRTmV4dEVsIiwiUVByZXZjIiwidmlld01vZGVsIiwiaHJlZiIsInNwbGl0IiwicG9wIiwidGVzdF9uYW1lIiwidGV4dCIsImVuYWJsZSIsInNlbGVjdGVkSW5kZXhWYWx1ZSIsImNoaWxkcmVuTGVuZ2h0IiwicGF0aF9jcmVhdGUiLCJ0ZXN0X3BhdGgiLCJzZXJ2ZXJNb2RlbCIsImlzVGVzdCIsInBhcnNlIiwibmFtZSIsImNyZWF0ZSIsInNlbGVjdGVkVmFsdWVDdXN0b21TZWxlY3QiLCJzZWxlY3QiLCJzZWxlY3RlZCIsIm9wdCIsInVwZGF0ZSIsIm1vZGVsIiwibm90QWRtaW4iLCJXRFNTZWxlY3QiLCJwcm9wcyIsInRpdGxlIiwiZ2V0Rm9ybWF0dGVkT3B0aW9ucyIsInNlbCIsImNsYXNzIiwibGFiZWwiLCJ0aXRsZUVsZW1lbnQiLCJzZXR1cCIsImRpc3BsYXkiLCJhZnRlciIsInNlbGVjdGVkT3B0aW9uIiwib3B0aW9uIiwic2VsZWN0ZWRPcHRpb25JbmRleCIsImluZGV4T2YiLCJzZWxlY3RWYWx1ZSIsIm5ld1NlbGVjdGVkT3B0aW9uIiwicHJldlNlbGVjdGVkT3B0aW9uIiwibmV3Q3VzdG9tRWxlbWVudCIsInNjcm9sbEludG9WaWV3IiwiYmxvY2siLCJ0YWJJbmRleCIsInNldE9wdGlvbiIsImxpIiwiZGVib3VuY2VUaW1lb3V0Iiwic2VhcmNoVGVybSIsImNvZGUiLCJwcmV2T3B0aW9uIiwibmV4dE9wdGlvbiIsImNsZWFyVGltZW91dCIsInNlYXJjaGVkT3B0aW9uIiwic3RhcnRzV2l0aCIsImFjY29yZGlvblNob3ciLCJidXR0b24iLCJtZW51IiwidGVzdFVwZGF0ZSIsInBhcmVudFNlbGVjdCIsImVuYWJsZVNlbGVjdCIsIl9hbnN3ZXIiLCJhZGRfYnV0dG9uIiwiYW5zd2VycyIsInByZXZfc29ydCIsImNsb25lTm9kZSIsInFfaWQiLCJwcmV2aW91c19zb3J0IiwiYW5zd2VyQ250IiwiZ2V0TW9kZWxGb3JTZXJ2ZXIiLCJhbnN3ZXIiLCJwYXJlbnRfcXVlc3Rpb24iLCJjb3JyZWN0X2Fuc3dlciIsInBpY2EiLCJhX2lkIiwiY3JlYXRlT25TZXJ2ZXIiLCJuZXdFbCIsImJlZm9yZSIsImRlbF9idXR0b24iLCJkZWxldGVGcm9tU2VydmVyIiwiZGVsZXRlRnJvbVZpZXciLCJfcXVlc3Rpb24iLCJ1cFRvUWVzdGlvbk51bWJlciIsInF1ZXN0aW9ucyIsInF1ZXN0aW9uc0VscyIsInRvQ2hhbmdlIiwiY2hhbmdlUGFyZW50Iiwic2VsZWN0ZWRJbmRleCIsInRlc3RfaWQiLCJxdWVzdGlvbiIsInNob3dUaXAiLCJhY3Rpb24iLCJzaG93Rmlyc3QiLCJjbG9uZUVtcHR5TW9kZWwiLCJzYXZlIiwicmVtb3ZlQ2xhc3MiLCJwcmVwZW5kIiwic2hvd0Fuc3dlcnMiLCJjcmVhdGVBbnN3ZXJCdXR0b24iLCJhZGRCdXR0b24iLCJxdXN0aW9uIiwibGFzdFNvcnQiLCJxcyIsInF1ZXN0aW9uc0NvdW50IiwibGFzdCIsImNyZWF0ZU9uVmlldyIsImNsb25lIiwiZ2V0QW5zd2VycyIsImRlbGV0ZWQiLCJwaWNxIiwiYW5zd2VyQmxvY2tzIiwiU29ydGFibGUiLCJzb3J0YWJsZSIsImNvbm5lY3QiLCJhbmltYXRpb24iLCJvbkVuZCIsImV2dCIsIm9sZEkiLCJvbGRJbmRleCIsIm5ld0kiLCJuZXdJbmRleCIsInRlc3RFZGl0IiwicGF0aG5hbWUiLCJwYWdpbmF0ZSIsInNlbGYiLCJhY3RpdmVfYnRuIiwiaWRfdG9faGlkZSIsImlkX3RvX3Nob3ciLCJ0ZXN0aWQiLCJxdWVzdENvdW50IiwiY291bnQiLCJCbG9jayIsImJsb2NrcyIsImluc2VydEFkamFjZW50SFRNTCIsIm5ld0Jsb2NrIiwic2F2ZV9idXR0b24iLCJzaG93SGlkZVBhZ2luQnRuIiwicGFnSXRlbSIsImFjdGl2ZVBhZ2luQnRuIiwiYXBwZW5kQmxvY2siLCJuYXZJbml0IiwibmF2X2J1dHRvbnMiLCJ0ZXN0RG8iLCJsYWJlbHMiLCJyZWxvYWQiLCJjb3JyQW5zd2VycyIsImVycm9yQ250IiwiY29sb3JWaWV3Iiwib2JqVG9TZXJ2ZXIiLCJvYmoiLCJxdWVzdGlvbkNudCIsInBhZ2VDYWNoZSIsImRvY3R5cGUiLCJkb2N1bWVudEVsZW1lbnQiLCJvdXRlckhUTUwiLCJ0ZXN0SWQiLCJ1c2VyTmFtZSIsImZvcm1EYXRhIiwiY29ycmVjdEFuc3dlcnMiLCJxIiwiZXJyb3JzIiwiaW5wdXQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImFuc3dlcklkIiwicmVwbGFjZSIsImNvcnJlY3RBbnNlciIsImNoZWNrQ29ycmVjdEFuc3dlcnMiLCJxdWVzdElkIiwicGFnaW5JdGVtIiwiaW5pdCIsInVzZXJzIiwic2V0dGluZ3MiLCJsaXN0IiwidGFibGUiLCJoZWFkZXJzIiwiaW5wdXRzIiwidGFibGVCb2R5IiwiaWRzIiwicm93cyIsImRpcmVjdGlvbnMiLCJoZWFkZXIiLCJ0cmFuc2Zvcm0iLCJpbmRleCIsImNvbnRlbnQiLCJwYXJzZUZsb2F0Iiwic2hvd0FsbFJvd3MiLCJpbnAiLCJzdHIiLCJyZWdleHAiLCJzb3J0Q29sdW1uIiwibXVsdGlwbGllciIsIm5ld1Jvd3MiLCJyb3dBIiwicm93QiIsImNlbGxBIiwiaW5uZXJIVE1MIiwiY2VsbEIiLCJiIiwibm9kZUxpc3QiLCJuZXdSb3ciLCJyZXZlcnNlIiwic3RvcFByb3BhZ2F0aW9uIiwiY29udGVudGVkaXRhYmxlIiwiZGVib3VuY2VUaW1lciIsImhhbmRsZSIsImluY2x1ZGVzIiwiaW5wdXRlZCIsImFsZXJ0IiwicmlnaHRzIiwiZGF0YUlkIiwiZmllbGRzIiwidG9TZXJ2IiwiZW1wdHkiLCJmIiwidHJpbSIsImRlc2NyaXB0aW9uIiwibW9kIiwidXBkYXRlZCIsImNsZWFyTW9kZWwiLCJjcmVhdGVPbkRvbSIsImxhc3RFbGVtZW50IiwiYXNzaWduTmV3VmFsdWVzT25DbG9uZSIsInBsYW5uaW5nIiwidXNlciIsInIiLCJqb2luIiwiY29uZiIsInNleCIsInN1ck5hbWUiLCJtaWRkbGVOYW1lIiwicGhvbmUiLCJiaXJ0aERhdGUiLCJoaXJlZCIsImZpcmVkIiwiY3J1ZFVzZXIiLCJjcnVkIiwic05hbWUiLCJtTmFtZSIsImJkYXkiLCJ1c2VySWQiLCJwYXJhbSIsInRoZW4iLCJuYXZpZ2F0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///637\n")}},__webpack_exports__={};__webpack_modules__[637]()})();