(function(){"use strict";var __webpack_modules__={62:function(){eval("\n;// CONCATENATED MODULE: ./public/src/common.js\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nfunction dropDown(elementId) {\n  var dropdown = document.getElementById(elementId);\n\n  try {\n    showDropdown(dropdown);\n  } catch (e) {}\n\n  return false;\n}\n\n;\n\nfunction showDropdown(element) {\n  var event;\n  event = document.createEvent('MouseEvents');\n  event.initMouseEvent('mousedown', true, true, window);\n  element.dispatchEvent(event);\n}\n\n;\nlet validate = {\n  sort: () => {\n    let error = undefined.nextElementSibling;\n    let ar = undefined.value.match(/\\D+/);\n\n    if (ar) {\n      error.innerText = 'Только цифры';\n      error.style.opacity = '1';\n    } else {\n      if (error.style.opacity === \"1\") {\n        error.style.opacity = '0';\n      }\n    }\n  },\n  email: email => {\n    if (!email) return false;\n    let re = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n    return re.test(String(email).toLowerCase());\n  },\n  password: password => {\n    if (!password) return false;\n    let re = /^[a-zA-Z\\-0-9]{6,20}$/;\n    return re.test(password);\n  }\n}; // function up() {\n//    var top = Math.max(document.body.scrollTop, document.documentElement.scrollTop);\n//    if (top > 0) {\n//       window.scrollBy(0, -100);\n//       var t = setTimeout('up()', 20);\n//    }\n//    else\n//       clearTimeout(t);\n//    return false;\n// }\n\nlet popup = {\n  show: function (txt, callback) {\n    let close = this.el('div', 'popup__close');\n    close.innerText = 'X';\n    let popup__item = this.el('div', 'popup__item');\n    popup__item.innerText = txt;\n    popup__item.append(close);\n    let popup = common_$('.popup')[0];\n\n    if (!popup) {\n      popup = this.el('div', 'popup');\n    }\n\n    popup.append(popup__item);\n    popup.addEventListener('click', this.close, true);\n    document.body.append(popup);\n    let hideDelay = 5000;\n    setTimeout(() => {\n      popup__item.classList.remove('popup__item');\n      popup__item.classList.add('popup-hide');\n    }, hideDelay);\n    let removeDelay = hideDelay + 950;\n    setTimeout(() => {\n      popup__item.remove();\n\n      if (callback) {\n        callback();\n      }\n    }, removeDelay);\n  },\n  close: function (e) {\n    if (e.target.classList.contains('popup__close')) {\n      let popup = this.closest('.popup').remove();\n    }\n  },\n  el: function (tagName, className) {\n    let el = document.createElement(tagName);\n    el.classList.add(className);\n    return el;\n  }\n};\n\nconst uniq = array => Array.from(new Set(array));\n\nasync function get(key) {\n  let p = window.location.search;\n  p = p.match(new RegExp(key + '=([^&=]+)'));\n  return p ? p[1] : false;\n}\n\nasync function post(url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new Promise(function (resolve, reject) {\n    data.token = document.querySelector('meta[name=\"token\"]').getAttribute('content');\n    let req = new XMLHttpRequest();\n    req.open('POST', url, true);\n    req.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n\n    if (data instanceof FormData) {\n      req.send(data);\n    } else {\n      req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n      req.send('param=' + JSON.stringify(data));\n    }\n\n    req.onerror = function (e) {\n      reject(Error(\"Network Error\" + e));\n    };\n\n    req.onload = async function () {\n      resolve(req.response);\n    };\n  });\n}\n\nclass ElementCollection extends Array {\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"value\", function () {\n      return this[0].getAttribute('value');\n    });\n\n    _defineProperty(this, \"attr\", function (attrName, attrVal) {\n      if (attrVal) {\n        this[0].setAttribute(attrName, attrVal);\n      }\n\n      return this[0].getAttribute(attrName);\n    });\n\n    _defineProperty(this, \"selectedIndexValue\", function () {\n      if (this.length) return this[0].selectedOptions[0].value;\n    });\n\n    _defineProperty(this, \"options\", function () {\n      if (this.length) return this[0].options;\n    });\n\n    _defineProperty(this, \"count\", function () {\n      return this.length;\n    });\n\n    _defineProperty(this, \"text\", function () {\n      if (this.length) return this[0].innerText;\n    });\n\n    _defineProperty(this, \"checked\", function () {\n      if (this.length) return this[0].checked;\n    });\n\n    _defineProperty(this, \"getWithStyle\", function (attr, val) {\n      let arr = [];\n      this.forEach(s => {\n        if (s.style[attr] === val) {\n          arr.push(s);\n        }\n      });\n      return arr;\n    });\n\n    _defineProperty(this, \"addClass\", function (className) {\n      this.forEach(s => {\n        s.classList.add(className);\n      });\n    });\n\n    _defineProperty(this, \"removeClass\", function (className) {\n      this.forEach(s => {\n        s.classList.remove(className);\n      });\n    });\n\n    _defineProperty(this, \"hasClass\", function (className) {\n      if (this.classList.contains(className)) return true;\n    });\n\n    _defineProperty(this, \"append\", function (el) {\n      this[0].appendChild(el);\n    });\n\n    _defineProperty(this, \"find\", function (item) {\n      if (typeof item === 'string') {\n        return this[0].querySelector(item);\n      } else {\n        let filtered = this[0].filter(el => {\n          return el === item;\n        });\n        return filtered[0];\n      }\n    });\n\n    _defineProperty(this, \"findAll\", function (item) {\n      if (typeof item === 'string') {\n        return this[0].querySelectorAll(item);\n      }\n    });\n\n    _defineProperty(this, \"css\", function (attr, val) {\n      if (!val) {\n        return this[0].style[attr];\n      }\n\n      this.forEach(s => {\n        s.style[attr] = val;\n      });\n    });\n  }\n\n  // el = this\n  // elType = function(){return {}.toString.call(this)}\n  on(event, cbOrSelector, cb) {\n    if (typeof cbOrSelector === 'function') {\n      this.forEach(e => e.addEventListener(event, cbOrSelector));\n    } else {\n      this.forEach(elem => {\n        elem.addEventListener(event, e => {\n          if (e.target === cbOrSelector) cb(e);\n        });\n      });\n    }\n  }\n\n  ready(cb) {\n    const isReady = this.some(e => {\n      return e.readyState != null && e.readyState != 'loading';\n    });\n\n    if (isReady) {\n      cb();\n    } else {\n      document.addEventListener('DOMContentLoaded', cb);\n    }\n  }\n\n}\n\nfunction common_$(selector) {\n  if (typeof selector === 'string' || selector instanceof String) {\n    return new ElementCollection(...document.querySelectorAll(selector));\n  } else {\n    return new ElementCollection(selector);\n  }\n}\n\nfunction addTooltip(args) {\n  [].forEach.call(args, el => {\n    el.onmouseenter = function () {\n      let tip = document.createElement('div');\n      tip.classList.add('tip');\n      tip.innerText = args.message;\n      el.append(tip);\n\n      let remove = () => tip.remove();\n\n      tip.addEventListener('mousemove', remove.bind(tip), true);\n    }.bind(args);\n\n    el.onmouseleave = () => {\n      let tip = el.querySelector('.tip');\n      tip.remove();\n    };\n  });\n}\n\n\n;// CONCATENATED MODULE: ./public/src/components/accordion/accordion.js\n\n\ncommon_$('.accordion label').on('click', handleToggle);\n\nwindow.onload = function () {\n  // debugger\n  let checkboxes = common_$('.admin-layout__sidebar.accordion input[type=checkbox]').el;\n\n  if (checkboxes) {\n    [...checkboxes].filter(ch => {\n      ch.checked = false;\n    });\n  }\n};\n\nfunction handleToggle(e) {\n  let checkbox = e.target.previousElementSibling;\n  let parent = checkbox.closest('ul');\n  let ul = common_$(checkbox.parentNode).find('ul');\n\n  if (checkbox.checked) {\n    slideUp(ul, 0);\n  } else {\n    parent.style.height = \"auto\";\n    slideDown(ul);\n    let ulHeight = ul.scrollHeight;\n    increaseParent(parent, ulHeight); // debugger\n\n    closeSiblings(parent);\n  }\n}\n\nfunction increaseParent(parent, ulHeight) {\n  if (!parent.classList.contains('accordion')) {\n    let parentHeight = parseInt(parent.style.maxHeight) + ulHeight;\n    parent.style.maxHeight = parentHeight + \"px\";\n  }\n}\n\nfunction slideDown(ul, callback) {\n  ul.style.maxHeight = ul.scrollHeight + \"px\";\n\n  if (callback) {\n    callback();\n  }\n}\n\nfunction closeSiblings(parent) {\n  Array.from(parent.children).map(el => {\n    let elArr = Array.from(el.children);\n    elArr.map(ch => {\n      if (ch.type && ch.type === 'checkbox' && ch.checked) {\n        let ul = common_$(ch.parentNode).find('ul');\n        slideUp(ul, 0, function () {\n          ch.checked = false;\n        });\n      }\n    });\n  });\n}\n\nfunction slideUp(ul, interval, callback) {\n  ul.style.maxHeight = 0 + \"px\";\n\n  if (callback) {\n    callback();\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Admin/model/cache.js\n\n\nlet _cache = {\n  clearCache: async function () {\n    let res = await post('/adminsc/clearCache', {});\n\n    if (res === 'Успешно') {\n      popup.show(res);\n    }\n  }\n};\nfunction cache() {\n  $('.clearCache').on('click', _cache.clearCache);\n}\n;// CONCATENATED MODULE: ./public/src/components/catalog-item/catalog-item.js\n\n\nfunction catalogItem() {// debugger;\n}\n;// CONCATENATED MODULE: ./public/src/Test/model/_testResult.js\n\nconst _testResult = {\n  delServer: async id => {\n    let res = await post('/adminsc/testresult/delete', {\n      id\n    });\n\n    if (res) {\n      popup.show('Удалено');\n    }\n  },\n  delDom: _ref => {\n    let {\n      target\n    } = _ref;\n    let id = target.closest('.del').dataset['row'];\n    [].map.call(common_$(`[data-row = \"${id}\"]`), function (i) {\n      i.remove();\n    });\n    return id;\n  },\n  delete: e => {\n    if (confirm(\"Удалить результат теста?\")) {\n      let id = _testResult.delDom(e);\n\n      _testResult.delServer(id);\n    }\n  }\n};\n;// CONCATENATED MODULE: ./public/src/Test/test_results/test_results.js\n\n\n\nfunction testResults() {\n  common_$('.test-results__table .del').on('click', _testResult[\"delete\"]);\n}\n;// CONCATENATED MODULE: ./public/src/components/tooltip/tooltip.js\n\nfunction tooltips() {\n  document.addEventListener('mouseenter', showTip, true);\n  document.addEventListener('mouseleave', hideTip, true);\n\n  function showTip(_ref) {\n    let {\n      target\n    } = _ref;\n    // debugger\n    // если у нас есть подсказка...\n    if (!target.dataset || !target.dataset.tooltip) return; // if (!) return;\n\n    let tooltipHtml = target.dataset.tooltip; // ...создадим элемент для подсказки\n\n    let tooltipElem = document.createElement('div');\n    tooltipElem.className = 'tooltip';\n    tooltipElem.innerHTML = tooltipHtml;\n    document.body.append(tooltipElem); // спозиционируем его сверху от аннотируемого элемента (top-center)\n\n    let coords = target.getBoundingClientRect();\n    let left = coords.left + (target.offsetWidth - tooltipElem.offsetWidth) / 2;\n    if (left < 0) left = 0; // не заезжать за левый край окна\n\n    let top = coords.top - tooltipElem.offsetHeight - 5;\n\n    if (top < 0) {\n      // если подсказка не помещается сверху, то отображать её снизу\n      top = coords.top + target.offsetHeight + 5;\n    }\n\n    tooltipElem.style.left = left + 'px';\n    tooltipElem.style.top = top + 'px';\n  }\n\n  ;\n\n  function hideTip() {\n    let tooltips = document.querySelectorAll('.tooltip');\n\n    if (tooltips) {\n      [].forEach.call(tooltips, tip => {\n        tip.remove();\n      });\n    }\n  }\n\n  ;\n}\n;// CONCATENATED MODULE: ./public/src/Test/model/test.js\n\nconst _test = {\n  nextQ: () => {\n    let current = _test.currentQ();\n\n    if (current.id > current.navLength - 2) return false;\n\n    let aimNavId = _test.aimNavIdFunction(current.id, 'next');\n\n    let aimQEl = _test.aimQElFunction(current, 'next');\n\n    _test.pushNav(current.id, aimNavId);\n\n    _test.pushQ(current.QEl, aimQEl);\n  },\n  prevQ: () => {\n    let current = _test.currentQ();\n\n    if (current.id < 1) return false;\n\n    let aimNavId = _test.aimNavIdFunction(current.id, 'back');\n\n    let aimQEl = _test.aimQElFunction(current, 'back');\n\n    _test.pushNav(current.id, aimNavId);\n\n    _test.pushQ(current.QEl, aimQEl);\n  },\n  pushNav: (currentId, aimNavId) => {\n    let currNavEl = common_$('[data-pagination]')[currentId];\n    currNavEl.classList.toggle('nav-active');\n    let NavEl = common_$('[data-pagination]')[aimNavId];\n    NavEl.classList.toggle('nav-active');\n  },\n  pushQ: (currentEl, aimQEl) => {\n    currentEl.classList.toggle('flex1');\n    aimQEl.classList.toggle('flex1');\n  },\n  aimNavIdFunction: (currentId, direction) => {\n    let dir = currentId;\n\n    switch (true) {\n      case direction === 'next':\n        return dir += 1;\n        break;\n\n      case direction === 'back':\n        return dir -= 1;\n        break;\n    }\n  },\n  aimQElFunction: (current, direction) => {\n    switch (true) {\n      case direction === 'next':\n        return current.QNextEl;\n        break;\n\n      case direction === 'back':\n        return current.QPrevc;\n        break;\n    }\n  },\n  currentQ: () => {\n    return {\n      id: common_$('.nav-active')[0].innerText - 1,\n      QEl: common_$('.question.flex1')[0],\n      navLength: common_$('[data-pagination]').length,\n      QPrevc: common_$('.question.flex1')[0].previousElementSibling,\n      QNextEl: common_$('.question.flex1')[0].nextElementSibling\n    };\n  },\n  viewModel: () => {\n    return {\n      id: +window.location.href.split('/').pop(),\n      test_name: common_$('#test_name').text(),\n      enable: common_$('#enable')[0],\n      parent: common_$('select').selectedIndexValue()\n    };\n  },\n  id: id => {\n    return id ?? common_$('.test-name')[0].dataset.testid;\n  },\n  children: () => {\n    let childrenLenght = common_$('.children').length;\n    if (childrenLenght) return childrenLenght;\n    return false;\n  },\n  path_create: async () => {\n    let test_path = _test.serverModel();\n\n    test_path.id = 0;\n    test_path.isTest = 0;\n    let url = `/test/create`;\n    let res = await post(url, test_path);\n    res = await JSON.parse(res);\n\n    if (res) {\n      window.location.href = `/adminsc/test/edit/${res.id - 1}`;\n    }\n  },\n  name: () => {\n    return common_$('.test-name')[0].innerText;\n  },\n  create: async () => {\n    let test = _test.serverModel();\n\n    test.id = 0;\n    test.isTest = 1;\n    let url = `/test/updateOrCreate`;\n    let res = await post(url, test);\n    res = await JSON.parse(res);\n    debugger;\n\n    if (res) {\n      window.location.href = `/adminsc/test/edit/${res.id}`;\n    }\n  },\n\n  selectedValueCustomSelect(className) {\n    let select = common_$(`[data-field=${className}]`)[0];\n    let selected = [...select.options].filter(opt => opt.selected);\n\n    if (selected) {\n      return +selected[0].value;\n    }\n  },\n\n  serverModel: () => {\n    let model = {\n      id: +window.location.href.split('/').pop(),\n      test_name: common_$('#test_name')[0].value,\n      isTest: +common_$('[isTest]')[0].getAttribute('isTest') // enable: _test.selectedValueCustomSelect('enable'),\n      // parent: _test.selectedValueCustomSelect('parent'),\n\n    }; // debugger\n\n    let fields = common_$('.custom-select');\n    [].forEach.call(fields, function (field) {\n      model[field.dataset['field']] = field.dataset['id'];\n    });\n    return model;\n  },\n  update: async () => {\n    let model = _test.serverModel();\n\n    let url = `/adminsc/test/update/${model.id}`;\n    let res = await post(url, model);\n    res = await JSON.parse(res);\n\n    if (res) {\n      window.location.href = `/adminsc/test/edit/${model.id}`;\n    }\n  },\n  delete: async function () {\n    if (_test.children()) {\n      popup.show('Сначала удалите все тесты из папки');\n      return false;\n    }\n\n    let id = _test.id();\n\n    let res = await post('/adminsc/test/delete', {\n      id\n    });\n    res = await JSON.parse(res);\n\n    if (res.notAdmin) {\n      popup.show('Видимость теста скрыта. Чтобы удалить полностью - обратитесь к ГД');\n      setTimeout(() => {\n        window.location = '/adminsc/test/edit/400';\n      }, 4000);\n    } else {\n      window.location = '/adminsc/test/edit/400';\n    }\n  }\n};\n;// CONCATENATED MODULE: ./public/src/Test/test-update.js\n\n\n\n // import accordionShow from \"./accordion-show\";\n\nfunction testUpdate() {// accordionShow()\n  // let parentSelect = new WDSSelect({\n  //   element: $(\"[data-custom-parent]\")[0],\n  //   title: 'Лежит в папке',\n  //   class: 'parent'\n  // })\n  // debugger\n  // let enableSelect = new WDSSelect({\n  //   title: 'Показывать пользователям',\n  //   class: 'enable',\n  //   field: 'enable',\n  // })\n  //\n  // let parentsSelect = new WDSSelect({\n  //   title: 'Лежит в папке',\n  //   class: 'parent',\n  //   field: 'parent',\n  // })\n}\n;// CONCATENATED MODULE: ./public/src/Test/model/answer.js\n\nlet answer_answer = {\n  el: add_button => {\n    let answers = add_button.parentNode.querySelectorAll('.answer');\n    let prev_sort = 0;\n\n    if (answers.length) {\n      prev_sort = +common_$(answers[answers.length - 1]).find('.answer__sort').innerText;\n    }\n\n    let el = common_$('.answer__create').find('.answer').cloneNode(true);\n    el.classList.add('answer');\n    el.classList.remove('answer__create');\n    return {\n      el: el,\n      id: 'new',\n      q_id: +add_button.closest('.question-edit').id,\n      previous_sort: prev_sort,\n      answerCnt: answers.length,\n      sort: common_$(el).find('.answer__sort'),\n      checked: common_$(el).find('input'),\n      text: common_$(el).find('.answer__text'),\n      delete: common_$(common_$(el).find('.answer__delete')).on('click', function () {\n        answer_answer.del(this);\n      })\n    };\n  },\n\n  getModelForServer(el) {\n    return {\n      answer: '',\n      parent_question: el.q_id,\n      correct_answer: 0,\n      pica: ''\n    };\n  },\n\n  async create(button) {\n    // debugger\n    let a_id = await createOnServer(button);\n    show(a_id);\n\n    async function createOnServer(button) {\n      let newEl = answer_answer.getModelForServer(answer_answer.el(button));\n\n      let res = await post('/answer/create', newEl);\n      res = JSON.parse(res);\n      return res.id;\n    }\n\n    function show(a_id) {\n      let el = answer_answer.el(button);\n\n      el.checked.checked = false;\n      el.el.dataset['answerId'] = a_id;\n      el.text.innerText = '';\n      el.sort.innerText = el.answerCnt + 1;\n      el.el.style.display = 'flex';\n      button.before(el.el);\n      el.el.style.opacity = 1;\n    }\n  },\n\n  async del(target) {\n    let del_button = target.closest('.answer__delete');\n    if (!del_button) return false;\n\n    if (confirm(\"Удалить этот ответ?\")) {\n      let res = await deleteFromServer(del_button);\n    }\n\n    async function deleteFromServer(del_button) {\n      let a_id = +del_button.closest('.answer').dataset['answerId'];\n      let res = await post('/answer/delete', {\n        a_id\n      });\n      res = JSON.parse(res);\n\n      if (res.msg === 'ok') {\n        del_button.closest('.answer').remove();\n        popup.show('Ответ удален');\n      }\n    }\n  }\n\n};\n;// CONCATENATED MODULE: ./public/src/Test/model/question.js\n\n\nlet question_question = {\n  sort: async function (upToQestionNumber) {\n    let questions = [...question_question.questions()];\n    let questionsEls = questions.filter(function (el, i) {\n      if (i + 1 < upToQestionNumber) return el;\n    });\n    let toChange = questionsEls.map(el => {\n      return el.id;\n    });\n    let res = await post('/question/sort', {\n      toChange\n    });\n    res = JSON.parse(res);\n\n    if (res.msg) {\n      popup.show(res.msg);\n    }\n\n    questionsEls.map((el, i) => {\n      common_$(el).find('.question__sort').innerText = i + 1;\n    });\n  },\n  changeParent: async function (target) {\n    debugger;\n    let opt = target.options[target.selectedIndex];\n    let id = target.closest('.question-edit').id;\n    let test_id = opt.dataset['questionParentId'];\n    let test_name = opt.value;\n    let res = await post('/adminsc/question/changeParent', {\n      id,\n      test_id\n    });\n    res = JSON.parse(res);\n    if (res.msg !== 'ok') throw e;\n    let question = target.closest('.question-edit');\n    question.remove();\n    popup.show('Перемещен в ' + test_name); // debugger\n  },\n  showTip: (action, event) => {\n    let el = event.target;\n    let tip = document.createElement(\"div\");\n\n    if (action === 'save.svg') {\n      addTooltip(el, 'сохранить');\n    }\n  },\n  showFirst: () => {\n    let question = question_question.cloneEmptyModel();\n\n    if (!question) return;\n\n    let model = question_question.viewModel(question);\n\n    model.sort.innerText = '1';\n    common_$(model.save).on('click', question_question.save);\n    common_$(model.del).on('click', question_question.delete);\n    common_$(question).addClass('question-edit');\n    common_$(question).removeClass('question__create');\n    let questions = common_$('.questions')[0];\n    questions.prepend(question);\n  },\n  cloneEmptyModel: () => {\n    let question = common_$('.questions .question__create .question-edit')[0];\n    if (question) return question.cloneNode(true);\n  },\n  showAnswers: target => {\n    let row = target.closest('.question-edit');\n    let answers = common_$(row).find('.question__answers');\n    answers.classList.toggle('height');\n    answers.classList.toggle('scale');\n    target.classList.toggle('rotate');\n  },\n  viewModel: el => {\n    return {\n      id: +el.id,\n      el: el,\n      sort: el.querySelector('.question__sort'),\n      save: el.querySelector('.question__save'),\n      text: el.querySelector('.question__text'),\n      del: el.querySelector('.question__delete'),\n      createAnswerButton: el.querySelector('.answer__create-button'),\n      addButton: common_$(common_$('.questions')[0]).find('.question__create-button')\n    };\n  },\n  serverModel: () => {\n    return {\n      question: {\n        id: null,\n        qustion: '',\n        parent: +window.location.href.split('/').pop(),\n        sort: question_question.lastSort()\n      }\n    };\n  },\n  questions: () => {\n    let qs = common_$('.questions>.question-edit'); // debugger\n\n    return common_$('.questions>.question-edit'); // return $('.questions>.question-edit').el\n  },\n  questionsCount: () => {\n    return common_$('.questions>.question-edit').el.length;\n  },\n  lastSort: () => {\n    let qs = question_question.questions();\n\n    let length = qs.length - 1;\n    let last = +question_question.viewModel(qs[length]).sort.innerText;\n    return last + 1;\n  },\n  create: async e => {\n    let q_id = await question_question.createOnServer(e);\n\n    if (q_id) {\n      question_question.createOnView(q_id);\n    }\n  },\n  createOnServer: async () => {\n    let question = question_question.serverModel();\n\n    let res = await post('/question/updateOrCreate', {\n      question: question.question,\n      answers: {}\n    });\n    res = await JSON.parse(res);\n    return res.id;\n  },\n  createOnView: q_id => {\n    let clone = question_question.cloneEmptyModel();\n\n    let model = question_question.viewModel(clone); // $(model.save).on('click', _question.save)\n    // $(model.del).on('click', _question.delete)\n    // $(model.text).on('click', _question.showAnswers)\n    // $(model.createAnswerButton).on('click', _answer.create)\n\n\n    model.sort.innerText = question_question.lastSort();\n    model.text.innerText = '';\n    model.el.id = q_id;\n    model.addButton.before(clone);\n  },\n  save: async target => {\n    let question = target.closest('.question-edit');\n    let res = await post('/question/UpdateOrCreate', {\n      question: question_question.getModelForServer(question),\n      answers: question_question.getAnswers(question)\n    });\n    res = await JSON.parse(res);\n    popup.show(res.msg);\n  },\n  delete: async target => {\n    if (confirm(\"Удалить вопрос со всеми его ответами?\")) {\n      let viewModel = question_question.viewModel(target.closest('.question-edit'));\n\n      let id = viewModel.id;\n      let deleted = await question_question.deleteFromServer(id);\n\n      if (deleted) {\n        question_question.deleteFromView(viewModel);\n\n        popup.show(deleted.msg);\n      }\n    }\n  },\n  deleteFromView: async viewModel => {\n    viewModel.el.remove();\n  },\n  deleteFromServer: async q_id => {\n    let res = await post('/question/delete', {\n      q_id\n    });\n    return JSON.parse(res);\n  },\n  getModelForServer: question => {\n    return {\n      id: +question.id,\n      parent: +common_$('.test-name')[0].getAttribute('value'),\n      picq: '',\n      qustion: common_$(question).find('.question__text').innerText,\n      sort: +common_$(question).find('.question__sort').innerText\n    };\n  },\n  getAnswers: question => {\n    let answerBlocks = question.querySelectorAll('.answer');\n    return [...answerBlocks].map(a => {\n      return {\n        id: +a.dataset['answerId'],\n        answer: a.querySelector('.answer__text').innerText,\n        correct_answer: +a.querySelector('[type=\"checkbox\"]').checked,\n        parent_question: +question.id,\n        pica: ''\n      };\n    }, question);\n  }\n};\n;// CONCATENATED MODULE: ./node_modules/sortablejs/modular/sortable.esm.js\n/**!\n * Sortable 1.14.0\n * @author\tRubaXa   <trash@rubaxa.org>\n * @author\towenm    <owen23355@gmail.com>\n * @license MIT\n */\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        sortable_esm_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction sortable_esm_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar version = \"1.14.0\";\n\nfunction userAgent(pattern) {\n  if (typeof window !== 'undefined' && window.navigator) {\n    return !! /*@__PURE__*/navigator.userAgent.match(pattern);\n  }\n}\n\nvar IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\\.|msie|iemobile|Windows Phone)/i);\nvar Edge = userAgent(/Edge/i);\nvar FireFox = userAgent(/firefox/i);\nvar Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);\nvar IOS = userAgent(/iP(ad|od|hone)/i);\nvar ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);\n\nvar captureMode = {\n  capture: false,\n  passive: false\n};\n\nfunction on(el, event, fn) {\n  el.addEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction off(el, event, fn) {\n  el.removeEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction matches(\n/**HTMLElement*/\nel,\n/**String*/\nselector) {\n  if (!selector) return;\n  selector[0] === '>' && (selector = selector.substring(1));\n\n  if (el) {\n    try {\n      if (el.matches) {\n        return el.matches(selector);\n      } else if (el.msMatchesSelector) {\n        return el.msMatchesSelector(selector);\n      } else if (el.webkitMatchesSelector) {\n        return el.webkitMatchesSelector(selector);\n      }\n    } catch (_) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction getParentOrHost(el) {\n  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;\n}\n\nfunction closest(\n/**HTMLElement*/\nel,\n/**String*/\nselector,\n/**HTMLElement*/\nctx, includeCTX) {\n  if (el) {\n    ctx = ctx || document;\n\n    do {\n      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {\n        return el;\n      }\n\n      if (el === ctx) break;\n      /* jshint boss:true */\n    } while (el = getParentOrHost(el));\n  }\n\n  return null;\n}\n\nvar R_SPACE = /\\s+/g;\n\nfunction toggleClass(el, name, state) {\n  if (el && name) {\n    if (el.classList) {\n      el.classList[state ? 'add' : 'remove'](name);\n    } else {\n      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');\n      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');\n    }\n  }\n}\n\nfunction css(el, prop, val) {\n  var style = el && el.style;\n\n  if (style) {\n    if (val === void 0) {\n      if (document.defaultView && document.defaultView.getComputedStyle) {\n        val = document.defaultView.getComputedStyle(el, '');\n      } else if (el.currentStyle) {\n        val = el.currentStyle;\n      }\n\n      return prop === void 0 ? val : val[prop];\n    } else {\n      if (!(prop in style) && prop.indexOf('webkit') === -1) {\n        prop = '-webkit-' + prop;\n      }\n\n      style[prop] = val + (typeof val === 'string' ? '' : 'px');\n    }\n  }\n}\n\nfunction matrix(el, selfOnly) {\n  var appliedTransforms = '';\n\n  if (typeof el === 'string') {\n    appliedTransforms = el;\n  } else {\n    do {\n      var transform = css(el, 'transform');\n\n      if (transform && transform !== 'none') {\n        appliedTransforms = transform + ' ' + appliedTransforms;\n      }\n      /* jshint boss:true */\n\n    } while (!selfOnly && (el = el.parentNode));\n  }\n\n  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;\n  /*jshint -W056 */\n\n  return matrixFn && new matrixFn(appliedTransforms);\n}\n\nfunction find(ctx, tagName, iterator) {\n  if (ctx) {\n    var list = ctx.getElementsByTagName(tagName),\n        i = 0,\n        n = list.length;\n\n    if (iterator) {\n      for (; i < n; i++) {\n        iterator(list[i], i);\n      }\n    }\n\n    return list;\n  }\n\n  return [];\n}\n\nfunction getWindowScrollingElement() {\n  var scrollingElement = document.scrollingElement;\n\n  if (scrollingElement) {\n    return scrollingElement;\n  } else {\n    return document.documentElement;\n  }\n}\n/**\n * Returns the \"bounding client rect\" of given element\n * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted\n * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container\n * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr\n * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone\n * @param  {[HTMLElement]} container              The parent the element will be placed in\n * @return {Object}                               The boundingClientRect of el, with specified adjustments\n */\n\n\nfunction getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {\n  if (!el.getBoundingClientRect && el !== window) return;\n  var elRect, top, left, bottom, right, height, width;\n\n  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {\n    elRect = el.getBoundingClientRect();\n    top = elRect.top;\n    left = elRect.left;\n    bottom = elRect.bottom;\n    right = elRect.right;\n    height = elRect.height;\n    width = elRect.width;\n  } else {\n    top = 0;\n    left = 0;\n    bottom = window.innerHeight;\n    right = window.innerWidth;\n    height = window.innerHeight;\n    width = window.innerWidth;\n  }\n\n  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {\n    // Adjust for translate()\n    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)\n    // Not needed on <= IE11\n\n    if (!IE11OrLess) {\n      do {\n        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {\n          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container\n\n          top -= containerRect.top + parseInt(css(container, 'border-top-width'));\n          left -= containerRect.left + parseInt(css(container, 'border-left-width'));\n          bottom = top + elRect.height;\n          right = left + elRect.width;\n          break;\n        }\n        /* jshint boss:true */\n\n      } while (container = container.parentNode);\n    }\n  }\n\n  if (undoScale && el !== window) {\n    // Adjust for scale()\n    var elMatrix = matrix(container || el),\n        scaleX = elMatrix && elMatrix.a,\n        scaleY = elMatrix && elMatrix.d;\n\n    if (elMatrix) {\n      top /= scaleY;\n      left /= scaleX;\n      width /= scaleX;\n      height /= scaleY;\n      bottom = top + height;\n      right = left + width;\n    }\n  }\n\n  return {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    width: width,\n    height: height\n  };\n}\n/**\n * Checks if a side of an element is scrolled past a side of its parents\n * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question\n * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')\n * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')\n * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element\n */\n\n\nfunction isScrolledPast(el, elSide, parentSide) {\n  var parent = getParentAutoScrollElement(el, true),\n      elSideVal = getRect(el)[elSide];\n  /* jshint boss:true */\n\n  while (parent) {\n    var parentSideVal = getRect(parent)[parentSide],\n        visible = void 0;\n\n    if (parentSide === 'top' || parentSide === 'left') {\n      visible = elSideVal >= parentSideVal;\n    } else {\n      visible = elSideVal <= parentSideVal;\n    }\n\n    if (!visible) return parent;\n    if (parent === getWindowScrollingElement()) break;\n    parent = getParentAutoScrollElement(parent, false);\n  }\n\n  return false;\n}\n/**\n * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\n * and non-draggable elements\n * @param  {HTMLElement} el       The parent element\n * @param  {Number} childNum      The index of the child\n * @param  {Object} options       Parent Sortable's options\n * @return {HTMLElement}          The child at index childNum, or null if not found\n */\n\n\nfunction getChild(el, childNum, options, includeDragEl) {\n  var currentChild = 0,\n      i = 0,\n      children = el.children;\n\n  while (i < children.length) {\n    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {\n      if (currentChild === childNum) {\n        return children[i];\n      }\n\n      currentChild++;\n    }\n\n    i++;\n  }\n\n  return null;\n}\n/**\n * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\n * @param  {HTMLElement} el       Parent element\n * @param  {selector} selector    Any other elements that should be ignored\n * @return {HTMLElement}          The last child, ignoring ghostEl\n */\n\n\nfunction lastChild(el, selector) {\n  var last = el.lastElementChild;\n\n  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {\n    last = last.previousElementSibling;\n  }\n\n  return last || null;\n}\n/**\n * Returns the index of an element within its parent for a selected set of\n * elements\n * @param  {HTMLElement} el\n * @param  {selector} selector\n * @return {number}\n */\n\n\nfunction index(el, selector) {\n  var index = 0;\n\n  if (!el || !el.parentNode) {\n    return -1;\n  }\n  /* jshint boss:true */\n\n\n  while (el = el.previousElementSibling) {\n    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {\n      index++;\n    }\n  }\n\n  return index;\n}\n/**\n * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\n * The value is returned in real pixels.\n * @param  {HTMLElement} el\n * @return {Array}             Offsets in the format of [left, top]\n */\n\n\nfunction getRelativeScrollOffset(el) {\n  var offsetLeft = 0,\n      offsetTop = 0,\n      winScroller = getWindowScrollingElement();\n\n  if (el) {\n    do {\n      var elMatrix = matrix(el),\n          scaleX = elMatrix.a,\n          scaleY = elMatrix.d;\n      offsetLeft += el.scrollLeft * scaleX;\n      offsetTop += el.scrollTop * scaleY;\n    } while (el !== winScroller && (el = el.parentNode));\n  }\n\n  return [offsetLeft, offsetTop];\n}\n/**\n * Returns the index of the object within the given array\n * @param  {Array} arr   Array that may or may not hold the object\n * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find\n * @return {Number}      The index of the object in the array, or -1\n */\n\n\nfunction indexOfObject(arr, obj) {\n  for (var i in arr) {\n    if (!arr.hasOwnProperty(i)) continue;\n\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);\n    }\n  }\n\n  return -1;\n}\n\nfunction getParentAutoScrollElement(el, includeSelf) {\n  // skip to window\n  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();\n  var elem = el;\n  var gotSelf = false;\n\n  do {\n    // we don't need to get elem css if it isn't even overflowing in the first place (performance)\n    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {\n      var elemCSS = css(elem);\n\n      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {\n        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();\n        if (gotSelf || includeSelf) return elem;\n        gotSelf = true;\n      }\n    }\n    /* jshint boss:true */\n\n  } while (elem = elem.parentNode);\n\n  return getWindowScrollingElement();\n}\n\nfunction extend(dst, src) {\n  if (dst && src) {\n    for (var key in src) {\n      if (src.hasOwnProperty(key)) {\n        dst[key] = src[key];\n      }\n    }\n  }\n\n  return dst;\n}\n\nfunction isRectEqual(rect1, rect2) {\n  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);\n}\n\nvar _throttleTimeout;\n\nfunction throttle(callback, ms) {\n  return function () {\n    if (!_throttleTimeout) {\n      var args = arguments,\n          _this = this;\n\n      if (args.length === 1) {\n        callback.call(_this, args[0]);\n      } else {\n        callback.apply(_this, args);\n      }\n\n      _throttleTimeout = setTimeout(function () {\n        _throttleTimeout = void 0;\n      }, ms);\n    }\n  };\n}\n\nfunction cancelThrottle() {\n  clearTimeout(_throttleTimeout);\n  _throttleTimeout = void 0;\n}\n\nfunction scrollBy(el, x, y) {\n  el.scrollLeft += x;\n  el.scrollTop += y;\n}\n\nfunction clone(el) {\n  var Polymer = window.Polymer;\n  var $ = window.jQuery || window.Zepto;\n\n  if (Polymer && Polymer.dom) {\n    return Polymer.dom(el).cloneNode(true);\n  } else if ($) {\n    return $(el).clone(true)[0];\n  } else {\n    return el.cloneNode(true);\n  }\n}\n\nfunction setRect(el, rect) {\n  css(el, 'position', 'absolute');\n  css(el, 'top', rect.top);\n  css(el, 'left', rect.left);\n  css(el, 'width', rect.width);\n  css(el, 'height', rect.height);\n}\n\nfunction unsetRect(el) {\n  css(el, 'position', '');\n  css(el, 'top', '');\n  css(el, 'left', '');\n  css(el, 'width', '');\n  css(el, 'height', '');\n}\n\nvar expando = 'Sortable' + new Date().getTime();\n\nfunction AnimationStateManager() {\n  var animationStates = [],\n      animationCallbackId;\n  return {\n    captureAnimationState: function captureAnimationState() {\n      animationStates = [];\n      if (!this.options.animation) return;\n      var children = [].slice.call(this.el.children);\n      children.forEach(function (child) {\n        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;\n        animationStates.push({\n          target: child,\n          rect: getRect(child)\n        });\n\n        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation\n\n\n        if (child.thisAnimationDuration) {\n          var childMatrix = matrix(child, true);\n\n          if (childMatrix) {\n            fromRect.top -= childMatrix.f;\n            fromRect.left -= childMatrix.e;\n          }\n        }\n\n        child.fromRect = fromRect;\n      });\n    },\n    addAnimationState: function addAnimationState(state) {\n      animationStates.push(state);\n    },\n    removeAnimationState: function removeAnimationState(target) {\n      animationStates.splice(indexOfObject(animationStates, {\n        target: target\n      }), 1);\n    },\n    animateAll: function animateAll(callback) {\n      var _this = this;\n\n      if (!this.options.animation) {\n        clearTimeout(animationCallbackId);\n        if (typeof callback === 'function') callback();\n        return;\n      }\n\n      var animating = false,\n          animationTime = 0;\n      animationStates.forEach(function (state) {\n        var time = 0,\n            target = state.target,\n            fromRect = target.fromRect,\n            toRect = getRect(target),\n            prevFromRect = target.prevFromRect,\n            prevToRect = target.prevToRect,\n            animatingRect = state.rect,\n            targetMatrix = matrix(target, true);\n\n        if (targetMatrix) {\n          // Compensate for current animation\n          toRect.top -= targetMatrix.f;\n          toRect.left -= targetMatrix.e;\n        }\n\n        target.toRect = toRect;\n\n        if (target.thisAnimationDuration) {\n          // Could also check if animatingRect is between fromRect and toRect\n          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect\n          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {\n            // If returning to same place as started from animation and on same axis\n            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);\n          }\n        } // if fromRect != toRect: animate\n\n\n        if (!isRectEqual(toRect, fromRect)) {\n          target.prevFromRect = fromRect;\n          target.prevToRect = toRect;\n\n          if (!time) {\n            time = _this.options.animation;\n          }\n\n          _this.animate(target, animatingRect, toRect, time);\n        }\n\n        if (time) {\n          animating = true;\n          animationTime = Math.max(animationTime, time);\n          clearTimeout(target.animationResetTimer);\n          target.animationResetTimer = setTimeout(function () {\n            target.animationTime = 0;\n            target.prevFromRect = null;\n            target.fromRect = null;\n            target.prevToRect = null;\n            target.thisAnimationDuration = null;\n          }, time);\n          target.thisAnimationDuration = time;\n        }\n      });\n      clearTimeout(animationCallbackId);\n\n      if (!animating) {\n        if (typeof callback === 'function') callback();\n      } else {\n        animationCallbackId = setTimeout(function () {\n          if (typeof callback === 'function') callback();\n        }, animationTime);\n      }\n\n      animationStates = [];\n    },\n    animate: function animate(target, currentRect, toRect, duration) {\n      if (duration) {\n        css(target, 'transition', '');\n        css(target, 'transform', '');\n        var elMatrix = matrix(this.el),\n            scaleX = elMatrix && elMatrix.a,\n            scaleY = elMatrix && elMatrix.d,\n            translateX = (currentRect.left - toRect.left) / (scaleX || 1),\n            translateY = (currentRect.top - toRect.top) / (scaleY || 1);\n        target.animatingX = !!translateX;\n        target.animatingY = !!translateY;\n        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');\n        this.forRepaintDummy = repaint(target); // repaint\n\n        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));\n        css(target, 'transform', 'translate3d(0,0,0)');\n        typeof target.animated === 'number' && clearTimeout(target.animated);\n        target.animated = setTimeout(function () {\n          css(target, 'transition', '');\n          css(target, 'transform', '');\n          target.animated = false;\n          target.animatingX = false;\n          target.animatingY = false;\n        }, duration);\n      }\n    }\n  };\n}\n\nfunction repaint(target) {\n  return target.offsetWidth;\n}\n\nfunction calculateRealTime(animatingRect, fromRect, toRect, options) {\n  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;\n}\n\nvar plugins = [];\nvar defaults = {\n  initializeByDefault: true\n};\nvar PluginManager = {\n  mount: function mount(plugin) {\n    // Set default static properties\n    for (var option in defaults) {\n      if (defaults.hasOwnProperty(option) && !(option in plugin)) {\n        plugin[option] = defaults[option];\n      }\n    }\n\n    plugins.forEach(function (p) {\n      if (p.pluginName === plugin.pluginName) {\n        throw \"Sortable: Cannot mount plugin \".concat(plugin.pluginName, \" more than once\");\n      }\n    });\n    plugins.push(plugin);\n  },\n  pluginEvent: function pluginEvent(eventName, sortable, evt) {\n    var _this = this;\n\n    this.eventCanceled = false;\n\n    evt.cancel = function () {\n      _this.eventCanceled = true;\n    };\n\n    var eventNameGlobal = eventName + 'Global';\n    plugins.forEach(function (plugin) {\n      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable\n\n      if (sortable[plugin.pluginName][eventNameGlobal]) {\n        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({\n          sortable: sortable\n        }, evt));\n      } // Only fire plugin event if plugin is enabled in this sortable,\n      // and plugin has event defined\n\n\n      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {\n        sortable[plugin.pluginName][eventName](_objectSpread2({\n          sortable: sortable\n        }, evt));\n      }\n    });\n  },\n  initializePlugins: function initializePlugins(sortable, el, defaults, options) {\n    plugins.forEach(function (plugin) {\n      var pluginName = plugin.pluginName;\n      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;\n      var initialized = new plugin(sortable, el, sortable.options);\n      initialized.sortable = sortable;\n      initialized.options = sortable.options;\n      sortable[pluginName] = initialized; // Add default options from plugin\n\n      _extends(defaults, initialized.defaults);\n    });\n\n    for (var option in sortable.options) {\n      if (!sortable.options.hasOwnProperty(option)) continue;\n      var modified = this.modifyOption(sortable, option, sortable.options[option]);\n\n      if (typeof modified !== 'undefined') {\n        sortable.options[option] = modified;\n      }\n    }\n  },\n  getEventProperties: function getEventProperties(name, sortable) {\n    var eventProperties = {};\n    plugins.forEach(function (plugin) {\n      if (typeof plugin.eventProperties !== 'function') return;\n\n      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));\n    });\n    return eventProperties;\n  },\n  modifyOption: function modifyOption(sortable, name, value) {\n    var modifiedValue;\n    plugins.forEach(function (plugin) {\n      // Plugin must exist on the Sortable\n      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin\n\n      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {\n        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);\n      }\n    });\n    return modifiedValue;\n  }\n};\n\nfunction dispatchEvent(_ref) {\n  var sortable = _ref.sortable,\n      rootEl = _ref.rootEl,\n      name = _ref.name,\n      targetEl = _ref.targetEl,\n      cloneEl = _ref.cloneEl,\n      toEl = _ref.toEl,\n      fromEl = _ref.fromEl,\n      oldIndex = _ref.oldIndex,\n      newIndex = _ref.newIndex,\n      oldDraggableIndex = _ref.oldDraggableIndex,\n      newDraggableIndex = _ref.newDraggableIndex,\n      originalEvent = _ref.originalEvent,\n      putSortable = _ref.putSortable,\n      extraEventProperties = _ref.extraEventProperties;\n  sortable = sortable || rootEl && rootEl[expando];\n  if (!sortable) return;\n  var evt,\n      options = sortable.options,\n      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature\n\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent(name, {\n      bubbles: true,\n      cancelable: true\n    });\n  } else {\n    evt = document.createEvent('Event');\n    evt.initEvent(name, true, true);\n  }\n\n  evt.to = toEl || rootEl;\n  evt.from = fromEl || rootEl;\n  evt.item = targetEl || rootEl;\n  evt.clone = cloneEl;\n  evt.oldIndex = oldIndex;\n  evt.newIndex = newIndex;\n  evt.oldDraggableIndex = oldDraggableIndex;\n  evt.newDraggableIndex = newDraggableIndex;\n  evt.originalEvent = originalEvent;\n  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;\n\n  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));\n\n  for (var option in allEventProperties) {\n    evt[option] = allEventProperties[option];\n  }\n\n  if (rootEl) {\n    rootEl.dispatchEvent(evt);\n  }\n\n  if (options[onName]) {\n    options[onName].call(sortable, evt);\n  }\n}\n\nvar _excluded = [\"evt\"];\n\nvar pluginEvent = function pluginEvent(eventName, sortable) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      originalEvent = _ref.evt,\n      data = _objectWithoutProperties(_ref, _excluded);\n\n  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({\n    dragEl: dragEl,\n    parentEl: parentEl,\n    ghostEl: ghostEl,\n    rootEl: rootEl,\n    nextEl: nextEl,\n    lastDownEl: lastDownEl,\n    cloneEl: cloneEl,\n    cloneHidden: cloneHidden,\n    dragStarted: moved,\n    putSortable: putSortable,\n    activeSortable: Sortable.active,\n    originalEvent: originalEvent,\n    oldIndex: oldIndex,\n    oldDraggableIndex: oldDraggableIndex,\n    newIndex: newIndex,\n    newDraggableIndex: newDraggableIndex,\n    hideGhostForTarget: _hideGhostForTarget,\n    unhideGhostForTarget: _unhideGhostForTarget,\n    cloneNowHidden: function cloneNowHidden() {\n      cloneHidden = true;\n    },\n    cloneNowShown: function cloneNowShown() {\n      cloneHidden = false;\n    },\n    dispatchSortableEvent: function dispatchSortableEvent(name) {\n      _dispatchEvent({\n        sortable: sortable,\n        name: name,\n        originalEvent: originalEvent\n      });\n    }\n  }, data));\n};\n\nfunction _dispatchEvent(info) {\n  dispatchEvent(_objectSpread2({\n    putSortable: putSortable,\n    cloneEl: cloneEl,\n    targetEl: dragEl,\n    rootEl: rootEl,\n    oldIndex: oldIndex,\n    oldDraggableIndex: oldDraggableIndex,\n    newIndex: newIndex,\n    newDraggableIndex: newDraggableIndex\n  }, info));\n}\n\nvar dragEl,\n    parentEl,\n    ghostEl,\n    rootEl,\n    nextEl,\n    lastDownEl,\n    cloneEl,\n    cloneHidden,\n    oldIndex,\n    newIndex,\n    oldDraggableIndex,\n    newDraggableIndex,\n    activeGroup,\n    putSortable,\n    awaitingDragStarted = false,\n    ignoreNextClick = false,\n    sortables = [],\n    tapEvt,\n    touchEvt,\n    lastDx,\n    lastDy,\n    tapDistanceLeft,\n    tapDistanceTop,\n    moved,\n    lastTarget,\n    lastDirection,\n    pastFirstInvertThresh = false,\n    isCircumstantialInvert = false,\n    targetMoveDistance,\n    // For positioning ghost absolutely\nghostRelativeParent,\n    ghostRelativeParentInitialScroll = [],\n    // (left, top)\n_silent = false,\n    savedInputChecked = [];\n/** @const */\n\nvar documentExists = typeof document !== 'undefined',\n    PositionGhostAbsolutely = IOS,\n    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',\n    // This will not pass for IE9, because IE9 DnD only works on anchors\nsupportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),\n    supportCssPointerEvents = function () {\n  if (!documentExists) return; // false when <= IE11\n\n  if (IE11OrLess) {\n    return false;\n  }\n\n  var el = document.createElement('x');\n  el.style.cssText = 'pointer-events:auto';\n  return el.style.pointerEvents === 'auto';\n}(),\n    _detectDirection = function _detectDirection(el, options) {\n  var elCSS = css(el),\n      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),\n      child1 = getChild(el, 0, options),\n      child2 = getChild(el, 1, options),\n      firstChildCSS = child1 && css(child1),\n      secondChildCSS = child2 && css(child2),\n      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,\n      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;\n\n  if (elCSS.display === 'flex') {\n    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';\n  }\n\n  if (elCSS.display === 'grid') {\n    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';\n  }\n\n  if (child1 && firstChildCSS[\"float\"] && firstChildCSS[\"float\"] !== 'none') {\n    var touchingSideChild2 = firstChildCSS[\"float\"] === 'left' ? 'left' : 'right';\n    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';\n  }\n\n  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';\n},\n    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {\n  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,\n      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,\n      dragElOppLength = vertical ? dragRect.width : dragRect.height,\n      targetS1Opp = vertical ? targetRect.left : targetRect.top,\n      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,\n      targetOppLength = vertical ? targetRect.width : targetRect.height;\n  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;\n},\n\n/**\n * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\n * @param  {Number} x      X position\n * @param  {Number} y      Y position\n * @return {HTMLElement}   Element of the first found nearest Sortable\n */\n_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {\n  var ret;\n  sortables.some(function (sortable) {\n    var threshold = sortable[expando].options.emptyInsertThreshold;\n    if (!threshold || lastChild(sortable)) return;\n    var rect = getRect(sortable),\n        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,\n        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;\n\n    if (insideHorizontally && insideVertically) {\n      return ret = sortable;\n    }\n  });\n  return ret;\n},\n    _prepareGroup = function _prepareGroup(options) {\n  function toFn(value, pull) {\n    return function (to, from, dragEl, evt) {\n      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;\n\n      if (value == null && (pull || sameGroup)) {\n        // Default pull value\n        // Default pull and put value if same group\n        return true;\n      } else if (value == null || value === false) {\n        return false;\n      } else if (pull && value === 'clone') {\n        return value;\n      } else if (typeof value === 'function') {\n        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);\n      } else {\n        var otherGroup = (pull ? to : from).options.group.name;\n        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;\n      }\n    };\n  }\n\n  var group = {};\n  var originalGroup = options.group;\n\n  if (!originalGroup || _typeof(originalGroup) != 'object') {\n    originalGroup = {\n      name: originalGroup\n    };\n  }\n\n  group.name = originalGroup.name;\n  group.checkPull = toFn(originalGroup.pull, true);\n  group.checkPut = toFn(originalGroup.put);\n  group.revertClone = originalGroup.revertClone;\n  options.group = group;\n},\n    _hideGhostForTarget = function _hideGhostForTarget() {\n  if (!supportCssPointerEvents && ghostEl) {\n    css(ghostEl, 'display', 'none');\n  }\n},\n    _unhideGhostForTarget = function _unhideGhostForTarget() {\n  if (!supportCssPointerEvents && ghostEl) {\n    css(ghostEl, 'display', '');\n  }\n}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position\n\n\nif (documentExists) {\n  document.addEventListener('click', function (evt) {\n    if (ignoreNextClick) {\n      evt.preventDefault();\n      evt.stopPropagation && evt.stopPropagation();\n      evt.stopImmediatePropagation && evt.stopImmediatePropagation();\n      ignoreNextClick = false;\n      return false;\n    }\n  }, true);\n}\n\nvar nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {\n  if (dragEl) {\n    evt = evt.touches ? evt.touches[0] : evt;\n\n    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);\n\n    if (nearest) {\n      // Create imitation event\n      var event = {};\n\n      for (var i in evt) {\n        if (evt.hasOwnProperty(i)) {\n          event[i] = evt[i];\n        }\n      }\n\n      event.target = event.rootEl = nearest;\n      event.preventDefault = void 0;\n      event.stopPropagation = void 0;\n\n      nearest[expando]._onDragOver(event);\n    }\n  }\n};\n\nvar _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {\n  if (dragEl) {\n    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n  }\n};\n/**\n * @class  Sortable\n * @param  {HTMLElement}  el\n * @param  {Object}       [options]\n */\n\n\nfunction Sortable(el, options) {\n  if (!(el && el.nodeType && el.nodeType === 1)) {\n    throw \"Sortable: `el` must be an HTMLElement, not \".concat({}.toString.call(el));\n  }\n\n  this.el = el; // root element\n\n  this.options = options = _extends({}, options); // Export instance\n\n  el[expando] = this;\n  var defaults = {\n    group: null,\n    sort: true,\n    disabled: false,\n    store: null,\n    handle: null,\n    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',\n    swapThreshold: 1,\n    // percentage; 0 <= x <= 1\n    invertSwap: false,\n    // invert always\n    invertedSwapThreshold: null,\n    // will be set to same as swapThreshold if default\n    removeCloneOnHide: true,\n    direction: function direction() {\n      return _detectDirection(el, this.options);\n    },\n    ghostClass: 'sortable-ghost',\n    chosenClass: 'sortable-chosen',\n    dragClass: 'sortable-drag',\n    ignore: 'a, img',\n    filter: null,\n    preventOnFilter: true,\n    animation: 0,\n    easing: null,\n    setData: function setData(dataTransfer, dragEl) {\n      dataTransfer.setData('Text', dragEl.textContent);\n    },\n    dropBubble: false,\n    dragoverBubble: false,\n    dataIdAttr: 'data-id',\n    delay: 0,\n    delayOnTouchOnly: false,\n    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,\n    forceFallback: false,\n    fallbackClass: 'sortable-fallback',\n    fallbackOnBody: false,\n    fallbackTolerance: 0,\n    fallbackOffset: {\n      x: 0,\n      y: 0\n    },\n    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,\n    emptyInsertThreshold: 5\n  };\n  PluginManager.initializePlugins(this, el, defaults); // Set default options\n\n  for (var name in defaults) {\n    !(name in options) && (options[name] = defaults[name]);\n  }\n\n  _prepareGroup(options); // Bind all private methods\n\n\n  for (var fn in this) {\n    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n      this[fn] = this[fn].bind(this);\n    }\n  } // Setup drag mode\n\n\n  this.nativeDraggable = options.forceFallback ? false : supportDraggable;\n\n  if (this.nativeDraggable) {\n    // Touch start threshold cannot be greater than the native dragstart threshold\n    this.options.touchStartThreshold = 1;\n  } // Bind events\n\n\n  if (options.supportPointer) {\n    on(el, 'pointerdown', this._onTapStart);\n  } else {\n    on(el, 'mousedown', this._onTapStart);\n    on(el, 'touchstart', this._onTapStart);\n  }\n\n  if (this.nativeDraggable) {\n    on(el, 'dragover', this);\n    on(el, 'dragenter', this);\n  }\n\n  sortables.push(this.el); // Restore sorting\n\n  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager\n\n  _extends(this, AnimationStateManager());\n}\n\nSortable.prototype =\n/** @lends Sortable.prototype */\n{\n  constructor: Sortable,\n  _isOutsideThisEl: function _isOutsideThisEl(target) {\n    if (!this.el.contains(target) && target !== this.el) {\n      lastTarget = null;\n    }\n  },\n  _getDirection: function _getDirection(evt, target) {\n    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;\n  },\n  _onTapStart: function _onTapStart(\n  /** Event|TouchEvent */\n  evt) {\n    if (!evt.cancelable) return;\n\n    var _this = this,\n        el = this.el,\n        options = this.options,\n        preventOnFilter = options.preventOnFilter,\n        type = evt.type,\n        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,\n        target = (touch || evt).target,\n        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,\n        filter = options.filter;\n\n    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.\n\n\n    if (dragEl) {\n      return;\n    }\n\n    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {\n      return; // only left button and enabled\n    } // cancel dnd if original target is content editable\n\n\n    if (originalTarget.isContentEditable) {\n      return;\n    } // Safari ignores further event handling after mousedown\n\n\n    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {\n      return;\n    }\n\n    target = closest(target, options.draggable, el, false);\n\n    if (target && target.animated) {\n      return;\n    }\n\n    if (lastDownEl === target) {\n      // Ignoring duplicate `down`\n      return;\n    } // Get the index of the dragged element within its parent\n\n\n    oldIndex = index(target);\n    oldDraggableIndex = index(target, options.draggable); // Check filter\n\n    if (typeof filter === 'function') {\n      if (filter.call(this, evt, target, this)) {\n        _dispatchEvent({\n          sortable: _this,\n          rootEl: originalTarget,\n          name: 'filter',\n          targetEl: target,\n          toEl: el,\n          fromEl: el\n        });\n\n        pluginEvent('filter', _this, {\n          evt: evt\n        });\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    } else if (filter) {\n      filter = filter.split(',').some(function (criteria) {\n        criteria = closest(originalTarget, criteria.trim(), el, false);\n\n        if (criteria) {\n          _dispatchEvent({\n            sortable: _this,\n            rootEl: criteria,\n            name: 'filter',\n            targetEl: target,\n            fromEl: el,\n            toEl: el\n          });\n\n          pluginEvent('filter', _this, {\n            evt: evt\n          });\n          return true;\n        }\n      });\n\n      if (filter) {\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    }\n\n    if (options.handle && !closest(originalTarget, options.handle, el, false)) {\n      return;\n    } // Prepare `dragstart`\n\n\n    this._prepareDragStart(evt, touch, target);\n  },\n  _prepareDragStart: function _prepareDragStart(\n  /** Event */\n  evt,\n  /** Touch */\n  touch,\n  /** HTMLElement */\n  target) {\n    var _this = this,\n        el = _this.el,\n        options = _this.options,\n        ownerDocument = el.ownerDocument,\n        dragStartFn;\n\n    if (target && !dragEl && target.parentNode === el) {\n      var dragRect = getRect(target);\n      rootEl = el;\n      dragEl = target;\n      parentEl = dragEl.parentNode;\n      nextEl = dragEl.nextSibling;\n      lastDownEl = target;\n      activeGroup = options.group;\n      Sortable.dragged = dragEl;\n      tapEvt = {\n        target: dragEl,\n        clientX: (touch || evt).clientX,\n        clientY: (touch || evt).clientY\n      };\n      tapDistanceLeft = tapEvt.clientX - dragRect.left;\n      tapDistanceTop = tapEvt.clientY - dragRect.top;\n      this._lastX = (touch || evt).clientX;\n      this._lastY = (touch || evt).clientY;\n      dragEl.style['will-change'] = 'all';\n\n      dragStartFn = function dragStartFn() {\n        pluginEvent('delayEnded', _this, {\n          evt: evt\n        });\n\n        if (Sortable.eventCanceled) {\n          _this._onDrop();\n\n          return;\n        } // Delayed drag has been triggered\n        // we can re-enable the events: touchmove/mousemove\n\n\n        _this._disableDelayedDragEvents();\n\n        if (!FireFox && _this.nativeDraggable) {\n          dragEl.draggable = true;\n        } // Bind the events: dragstart/dragend\n\n\n        _this._triggerDragStart(evt, touch); // Drag start event\n\n\n        _dispatchEvent({\n          sortable: _this,\n          name: 'choose',\n          originalEvent: evt\n        }); // Chosen item\n\n\n        toggleClass(dragEl, options.chosenClass, true);\n      }; // Disable \"draggable\"\n\n\n      options.ignore.split(',').forEach(function (criteria) {\n        find(dragEl, criteria.trim(), _disableDraggable);\n      });\n      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'mouseup', _this._onDrop);\n      on(ownerDocument, 'touchend', _this._onDrop);\n      on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)\n\n      if (FireFox && this.nativeDraggable) {\n        this.options.touchStartThreshold = 4;\n        dragEl.draggable = true;\n      }\n\n      pluginEvent('delayStart', this, {\n        evt: evt\n      }); // Delay is impossible for native DnD in Edge or IE\n\n      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {\n        if (Sortable.eventCanceled) {\n          this._onDrop();\n\n          return;\n        } // If the user moves the pointer or let go the click or touch\n        // before the delay has been reached:\n        // disable the delayed drag\n\n\n        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);\n        on(ownerDocument, 'touchend', _this._disableDelayedDrag);\n        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);\n        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);\n        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);\n        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);\n        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);\n      } else {\n        dragStartFn();\n      }\n    }\n  },\n  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(\n  /** TouchEvent|PointerEvent **/\n  e) {\n    var touch = e.touches ? e.touches[0] : e;\n\n    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {\n      this._disableDelayedDrag();\n    }\n  },\n  _disableDelayedDrag: function _disableDelayedDrag() {\n    dragEl && _disableDraggable(dragEl);\n    clearTimeout(this._dragStartTimer);\n\n    this._disableDelayedDragEvents();\n  },\n  _disableDelayedDragEvents: function _disableDelayedDragEvents() {\n    var ownerDocument = this.el.ownerDocument;\n    off(ownerDocument, 'mouseup', this._disableDelayedDrag);\n    off(ownerDocument, 'touchend', this._disableDelayedDrag);\n    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);\n    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);\n    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);\n    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);\n  },\n  _triggerDragStart: function _triggerDragStart(\n  /** Event */\n  evt,\n  /** Touch */\n  touch) {\n    touch = touch || evt.pointerType == 'touch' && evt;\n\n    if (!this.nativeDraggable || touch) {\n      if (this.options.supportPointer) {\n        on(document, 'pointermove', this._onTouchMove);\n      } else if (touch) {\n        on(document, 'touchmove', this._onTouchMove);\n      } else {\n        on(document, 'mousemove', this._onTouchMove);\n      }\n    } else {\n      on(dragEl, 'dragend', this);\n      on(rootEl, 'dragstart', this._onDragStart);\n    }\n\n    try {\n      if (document.selection) {\n        // Timeout neccessary for IE9\n        _nextTick(function () {\n          document.selection.empty();\n        });\n      } else {\n        window.getSelection().removeAllRanges();\n      }\n    } catch (err) {}\n  },\n  _dragStarted: function _dragStarted(fallback, evt) {\n\n    awaitingDragStarted = false;\n\n    if (rootEl && dragEl) {\n      pluginEvent('dragStarted', this, {\n        evt: evt\n      });\n\n      if (this.nativeDraggable) {\n        on(document, 'dragover', _checkOutsideTargetEl);\n      }\n\n      var options = this.options; // Apply effect\n\n      !fallback && toggleClass(dragEl, options.dragClass, false);\n      toggleClass(dragEl, options.ghostClass, true);\n      Sortable.active = this;\n      fallback && this._appendGhost(); // Drag start event\n\n      _dispatchEvent({\n        sortable: this,\n        name: 'start',\n        originalEvent: evt\n      });\n    } else {\n      this._nulling();\n    }\n  },\n  _emulateDragOver: function _emulateDragOver() {\n    if (touchEvt) {\n      this._lastX = touchEvt.clientX;\n      this._lastY = touchEvt.clientY;\n\n      _hideGhostForTarget();\n\n      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n      var parent = target;\n\n      while (target && target.shadowRoot) {\n        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n        if (target === parent) break;\n        parent = target;\n      }\n\n      dragEl.parentNode[expando]._isOutsideThisEl(target);\n\n      if (parent) {\n        do {\n          if (parent[expando]) {\n            var inserted = void 0;\n            inserted = parent[expando]._onDragOver({\n              clientX: touchEvt.clientX,\n              clientY: touchEvt.clientY,\n              target: target,\n              rootEl: parent\n            });\n\n            if (inserted && !this.options.dragoverBubble) {\n              break;\n            }\n          }\n\n          target = parent; // store last element\n        }\n        /* jshint boss:true */\n        while (parent = parent.parentNode);\n      }\n\n      _unhideGhostForTarget();\n    }\n  },\n  _onTouchMove: function _onTouchMove(\n  /**TouchEvent*/\n  evt) {\n    if (tapEvt) {\n      var options = this.options,\n          fallbackTolerance = options.fallbackTolerance,\n          fallbackOffset = options.fallbackOffset,\n          touch = evt.touches ? evt.touches[0] : evt,\n          ghostMatrix = ghostEl && matrix(ghostEl, true),\n          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,\n          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,\n          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),\n          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),\n          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging\n\n      if (!Sortable.active && !awaitingDragStarted) {\n        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {\n          return;\n        }\n\n        this._onDragStart(evt, true);\n      }\n\n      if (ghostEl) {\n        if (ghostMatrix) {\n          ghostMatrix.e += dx - (lastDx || 0);\n          ghostMatrix.f += dy - (lastDy || 0);\n        } else {\n          ghostMatrix = {\n            a: 1,\n            b: 0,\n            c: 0,\n            d: 1,\n            e: dx,\n            f: dy\n          };\n        }\n\n        var cssMatrix = \"matrix(\".concat(ghostMatrix.a, \",\").concat(ghostMatrix.b, \",\").concat(ghostMatrix.c, \",\").concat(ghostMatrix.d, \",\").concat(ghostMatrix.e, \",\").concat(ghostMatrix.f, \")\");\n        css(ghostEl, 'webkitTransform', cssMatrix);\n        css(ghostEl, 'mozTransform', cssMatrix);\n        css(ghostEl, 'msTransform', cssMatrix);\n        css(ghostEl, 'transform', cssMatrix);\n        lastDx = dx;\n        lastDy = dy;\n        touchEvt = touch;\n      }\n\n      evt.cancelable && evt.preventDefault();\n    }\n  },\n  _appendGhost: function _appendGhost() {\n    // Bug if using scale(): https://stackoverflow.com/questions/2637058\n    // Not being adjusted for\n    if (!ghostEl) {\n      var container = this.options.fallbackOnBody ? document.body : rootEl,\n          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),\n          options = this.options; // Position absolutely\n\n      if (PositionGhostAbsolutely) {\n        // Get relatively positioned parent\n        ghostRelativeParent = container;\n\n        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {\n          ghostRelativeParent = ghostRelativeParent.parentNode;\n        }\n\n        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {\n          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();\n          rect.top += ghostRelativeParent.scrollTop;\n          rect.left += ghostRelativeParent.scrollLeft;\n        } else {\n          ghostRelativeParent = getWindowScrollingElement();\n        }\n\n        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);\n      }\n\n      ghostEl = dragEl.cloneNode(true);\n      toggleClass(ghostEl, options.ghostClass, false);\n      toggleClass(ghostEl, options.fallbackClass, true);\n      toggleClass(ghostEl, options.dragClass, true);\n      css(ghostEl, 'transition', '');\n      css(ghostEl, 'transform', '');\n      css(ghostEl, 'box-sizing', 'border-box');\n      css(ghostEl, 'margin', 0);\n      css(ghostEl, 'top', rect.top);\n      css(ghostEl, 'left', rect.left);\n      css(ghostEl, 'width', rect.width);\n      css(ghostEl, 'height', rect.height);\n      css(ghostEl, 'opacity', '0.8');\n      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');\n      css(ghostEl, 'zIndex', '100000');\n      css(ghostEl, 'pointerEvents', 'none');\n      Sortable.ghost = ghostEl;\n      container.appendChild(ghostEl); // Set transform-origin\n\n      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');\n    }\n  },\n  _onDragStart: function _onDragStart(\n  /**Event*/\n  evt,\n  /**boolean*/\n  fallback) {\n    var _this = this;\n\n    var dataTransfer = evt.dataTransfer;\n    var options = _this.options;\n    pluginEvent('dragStart', this, {\n      evt: evt\n    });\n\n    if (Sortable.eventCanceled) {\n      this._onDrop();\n\n      return;\n    }\n\n    pluginEvent('setupClone', this);\n\n    if (!Sortable.eventCanceled) {\n      cloneEl = clone(dragEl);\n      cloneEl.draggable = false;\n      cloneEl.style['will-change'] = '';\n\n      this._hideClone();\n\n      toggleClass(cloneEl, this.options.chosenClass, false);\n      Sortable.clone = cloneEl;\n    } // #1143: IFrame support workaround\n\n\n    _this.cloneId = _nextTick(function () {\n      pluginEvent('clone', _this);\n      if (Sortable.eventCanceled) return;\n\n      if (!_this.options.removeCloneOnHide) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      }\n\n      _this._hideClone();\n\n      _dispatchEvent({\n        sortable: _this,\n        name: 'clone'\n      });\n    });\n    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events\n\n    if (fallback) {\n      ignoreNextClick = true;\n      _this._loopId = setInterval(_this._emulateDragOver, 50);\n    } else {\n      // Undo what was set in _prepareDragStart before drag started\n      off(document, 'mouseup', _this._onDrop);\n      off(document, 'touchend', _this._onDrop);\n      off(document, 'touchcancel', _this._onDrop);\n\n      if (dataTransfer) {\n        dataTransfer.effectAllowed = 'move';\n        options.setData && options.setData.call(_this, dataTransfer, dragEl);\n      }\n\n      on(document, 'drop', _this); // #1276 fix:\n\n      css(dragEl, 'transform', 'translateZ(0)');\n    }\n\n    awaitingDragStarted = true;\n    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));\n    on(document, 'selectstart', _this);\n    moved = true;\n\n    if (Safari) {\n      css(document.body, 'user-select', 'none');\n    }\n  },\n  // Returns true - if no further action is needed (either inserted or another condition)\n  _onDragOver: function _onDragOver(\n  /**Event*/\n  evt) {\n    var el = this.el,\n        target = evt.target,\n        dragRect,\n        targetRect,\n        revert,\n        options = this.options,\n        group = options.group,\n        activeSortable = Sortable.active,\n        isOwner = activeGroup === group,\n        canSort = options.sort,\n        fromSortable = putSortable || activeSortable,\n        vertical,\n        _this = this,\n        completedFired = false;\n\n    if (_silent) return;\n\n    function dragOverEvent(name, extra) {\n      pluginEvent(name, _this, _objectSpread2({\n        evt: evt,\n        isOwner: isOwner,\n        axis: vertical ? 'vertical' : 'horizontal',\n        revert: revert,\n        dragRect: dragRect,\n        targetRect: targetRect,\n        canSort: canSort,\n        fromSortable: fromSortable,\n        target: target,\n        completed: completed,\n        onMove: function onMove(target, after) {\n          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);\n        },\n        changed: changed\n      }, extra));\n    } // Capture animation state\n\n\n    function capture() {\n      dragOverEvent('dragOverAnimationCapture');\n\n      _this.captureAnimationState();\n\n      if (_this !== fromSortable) {\n        fromSortable.captureAnimationState();\n      }\n    } // Return invocation when dragEl is inserted (or completed)\n\n\n    function completed(insertion) {\n      dragOverEvent('dragOverCompleted', {\n        insertion: insertion\n      });\n\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        } else {\n          activeSortable._showClone(_this);\n        }\n\n        if (_this !== fromSortable) {\n          // Set ghost class to new sortable's ghost class\n          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);\n          toggleClass(dragEl, options.ghostClass, true);\n        }\n\n        if (putSortable !== _this && _this !== Sortable.active) {\n          putSortable = _this;\n        } else if (_this === Sortable.active && putSortable) {\n          putSortable = null;\n        } // Animation\n\n\n        if (fromSortable === _this) {\n          _this._ignoreWhileAnimating = target;\n        }\n\n        _this.animateAll(function () {\n          dragOverEvent('dragOverAnimationComplete');\n          _this._ignoreWhileAnimating = null;\n        });\n\n        if (_this !== fromSortable) {\n          fromSortable.animateAll();\n          fromSortable._ignoreWhileAnimating = null;\n        }\n      } // Null lastTarget if it is not inside a previously swapped element\n\n\n      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {\n        lastTarget = null;\n      } // no bubbling and not fallback\n\n\n      if (!options.dragoverBubble && !evt.rootEl && target !== document) {\n        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted\n\n\n        !insertion && nearestEmptyInsertDetectEvent(evt);\n      }\n\n      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\n      return completedFired = true;\n    } // Call when dragEl has been inserted\n\n\n    function changed() {\n      newIndex = index(dragEl);\n      newDraggableIndex = index(dragEl, options.draggable);\n\n      _dispatchEvent({\n        sortable: _this,\n        name: 'change',\n        toEl: el,\n        newIndex: newIndex,\n        newDraggableIndex: newDraggableIndex,\n        originalEvent: evt\n      });\n    }\n\n    if (evt.preventDefault !== void 0) {\n      evt.cancelable && evt.preventDefault();\n    }\n\n    target = closest(target, options.draggable, el, true);\n    dragOverEvent('dragOver');\n    if (Sortable.eventCanceled) return completedFired;\n\n    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {\n      return completed(false);\n    }\n\n    ignoreNextClick = false;\n\n    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list\n    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {\n      vertical = this._getDirection(evt, target) === 'vertical';\n      dragRect = getRect(dragEl);\n      dragOverEvent('dragOverValid');\n      if (Sortable.eventCanceled) return completedFired;\n\n      if (revert) {\n        parentEl = rootEl; // actualization\n\n        capture();\n\n        this._hideClone();\n\n        dragOverEvent('revert');\n\n        if (!Sortable.eventCanceled) {\n          if (nextEl) {\n            rootEl.insertBefore(dragEl, nextEl);\n          } else {\n            rootEl.appendChild(dragEl);\n          }\n        }\n\n        return completed(true);\n      }\n\n      var elLastChild = lastChild(el, options.draggable);\n\n      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {\n        // Insert to end of list\n        // If already at end of list: Do not insert\n        if (elLastChild === dragEl) {\n          return completed(false);\n        } // if there is a last element, it is the target\n\n\n        if (elLastChild && el === evt.target) {\n          target = elLastChild;\n        }\n\n        if (target) {\n          targetRect = getRect(target);\n        }\n\n        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {\n          capture();\n          el.appendChild(dragEl);\n          parentEl = el; // actualization\n\n          changed();\n          return completed(true);\n        }\n      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {\n        // Insert to start of list\n        var firstChild = getChild(el, 0, options, true);\n\n        if (firstChild === dragEl) {\n          return completed(false);\n        }\n\n        target = firstChild;\n        targetRect = getRect(target);\n\n        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {\n          capture();\n          el.insertBefore(dragEl, firstChild);\n          parentEl = el; // actualization\n\n          changed();\n          return completed(true);\n        }\n      } else if (target.parentNode === el) {\n        targetRect = getRect(target);\n        var direction = 0,\n            targetBeforeFirstSwap,\n            differentLevel = dragEl.parentNode !== el,\n            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),\n            side1 = vertical ? 'top' : 'left',\n            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),\n            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\n\n        if (lastTarget !== target) {\n          targetBeforeFirstSwap = targetRect[side1];\n          pastFirstInvertThresh = false;\n          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;\n        }\n\n        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);\n        var sibling;\n\n        if (direction !== 0) {\n          // Check if target is beside dragEl in respective direction (ignoring hidden elements)\n          var dragIndex = index(dragEl);\n\n          do {\n            dragIndex -= direction;\n            sibling = parentEl.children[dragIndex];\n          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));\n        } // If dragEl is already beside target: Do not insert\n\n\n        if (direction === 0 || sibling === target) {\n          return completed(false);\n        }\n\n        lastTarget = target;\n        lastDirection = direction;\n        var nextSibling = target.nextElementSibling,\n            after = false;\n        after = direction === 1;\n\n        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);\n\n        if (moveVector !== false) {\n          if (moveVector === 1 || moveVector === -1) {\n            after = moveVector === 1;\n          }\n\n          _silent = true;\n          setTimeout(_unsilent, 30);\n          capture();\n\n          if (after && !nextSibling) {\n            el.appendChild(dragEl);\n          } else {\n            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);\n          } // Undo chrome's scroll adjustment (has no effect on other browsers)\n\n\n          if (scrolledPastTop) {\n            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);\n          }\n\n          parentEl = dragEl.parentNode; // actualization\n          // must be done before animation\n\n          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\n            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);\n          }\n\n          changed();\n          return completed(true);\n        }\n      }\n\n      if (el.contains(dragEl)) {\n        return completed(false);\n      }\n    }\n\n    return false;\n  },\n  _ignoreWhileAnimating: null,\n  _offMoveEvents: function _offMoveEvents() {\n    off(document, 'mousemove', this._onTouchMove);\n    off(document, 'touchmove', this._onTouchMove);\n    off(document, 'pointermove', this._onTouchMove);\n    off(document, 'dragover', nearestEmptyInsertDetectEvent);\n    off(document, 'mousemove', nearestEmptyInsertDetectEvent);\n    off(document, 'touchmove', nearestEmptyInsertDetectEvent);\n  },\n  _offUpEvents: function _offUpEvents() {\n    var ownerDocument = this.el.ownerDocument;\n    off(ownerDocument, 'mouseup', this._onDrop);\n    off(ownerDocument, 'touchend', this._onDrop);\n    off(ownerDocument, 'pointerup', this._onDrop);\n    off(ownerDocument, 'touchcancel', this._onDrop);\n    off(document, 'selectstart', this);\n  },\n  _onDrop: function _onDrop(\n  /**Event*/\n  evt) {\n    var el = this.el,\n        options = this.options; // Get the index of the dragged element within its parent\n\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n    pluginEvent('drop', this, {\n      evt: evt\n    });\n    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event\n\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n\n    if (Sortable.eventCanceled) {\n      this._nulling();\n\n      return;\n    }\n\n    awaitingDragStarted = false;\n    isCircumstantialInvert = false;\n    pastFirstInvertThresh = false;\n    clearInterval(this._loopId);\n    clearTimeout(this._dragStartTimer);\n\n    _cancelNextTick(this.cloneId);\n\n    _cancelNextTick(this._dragStartId); // Unbind events\n\n\n    if (this.nativeDraggable) {\n      off(document, 'drop', this);\n      off(el, 'dragstart', this._onDragStart);\n    }\n\n    this._offMoveEvents();\n\n    this._offUpEvents();\n\n    if (Safari) {\n      css(document.body, 'user-select', '');\n    }\n\n    css(dragEl, 'transform', '');\n\n    if (evt) {\n      if (moved) {\n        evt.cancelable && evt.preventDefault();\n        !options.dropBubble && evt.stopPropagation();\n      }\n\n      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);\n\n      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n        // Remove clone(s)\n        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);\n      }\n\n      if (dragEl) {\n        if (this.nativeDraggable) {\n          off(dragEl, 'dragend', this);\n        }\n\n        _disableDraggable(dragEl);\n\n        dragEl.style['will-change'] = ''; // Remove classes\n        // ghostClass is added in dragStarted\n\n        if (moved && !awaitingDragStarted) {\n          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);\n        }\n\n        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event\n\n        _dispatchEvent({\n          sortable: this,\n          name: 'unchoose',\n          toEl: parentEl,\n          newIndex: null,\n          newDraggableIndex: null,\n          originalEvent: evt\n        });\n\n        if (rootEl !== parentEl) {\n          if (newIndex >= 0) {\n            // Add event\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: 'add',\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt\n            }); // Remove event\n\n\n            _dispatchEvent({\n              sortable: this,\n              name: 'remove',\n              toEl: parentEl,\n              originalEvent: evt\n            }); // drag from one list and drop into another\n\n\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: 'sort',\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt\n            });\n\n            _dispatchEvent({\n              sortable: this,\n              name: 'sort',\n              toEl: parentEl,\n              originalEvent: evt\n            });\n          }\n\n          putSortable && putSortable.save();\n        } else {\n          if (newIndex !== oldIndex) {\n            if (newIndex >= 0) {\n              // drag & drop within the same list\n              _dispatchEvent({\n                sortable: this,\n                name: 'update',\n                toEl: parentEl,\n                originalEvent: evt\n              });\n\n              _dispatchEvent({\n                sortable: this,\n                name: 'sort',\n                toEl: parentEl,\n                originalEvent: evt\n              });\n            }\n          }\n        }\n\n        if (Sortable.active) {\n          /* jshint eqnull:true */\n          if (newIndex == null || newIndex === -1) {\n            newIndex = oldIndex;\n            newDraggableIndex = oldDraggableIndex;\n          }\n\n          _dispatchEvent({\n            sortable: this,\n            name: 'end',\n            toEl: parentEl,\n            originalEvent: evt\n          }); // Save sorting\n\n\n          this.save();\n        }\n      }\n    }\n\n    this._nulling();\n  },\n  _nulling: function _nulling() {\n    pluginEvent('nulling', this);\n    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;\n    savedInputChecked.forEach(function (el) {\n      el.checked = true;\n    });\n    savedInputChecked.length = lastDx = lastDy = 0;\n  },\n  handleEvent: function handleEvent(\n  /**Event*/\n  evt) {\n    switch (evt.type) {\n      case 'drop':\n      case 'dragend':\n        this._onDrop(evt);\n\n        break;\n\n      case 'dragenter':\n      case 'dragover':\n        if (dragEl) {\n          this._onDragOver(evt);\n\n          _globalDragOver(evt);\n        }\n\n        break;\n\n      case 'selectstart':\n        evt.preventDefault();\n        break;\n    }\n  },\n\n  /**\n   * Serializes the item into an array of string.\n   * @returns {String[]}\n   */\n  toArray: function toArray() {\n    var order = [],\n        el,\n        children = this.el.children,\n        i = 0,\n        n = children.length,\n        options = this.options;\n\n    for (; i < n; i++) {\n      el = children[i];\n\n      if (closest(el, options.draggable, this.el, false)) {\n        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\n      }\n    }\n\n    return order;\n  },\n\n  /**\n   * Sorts the elements according to the array.\n   * @param  {String[]}  order  order of the items\n   */\n  sort: function sort(order, useAnimation) {\n    var items = {},\n        rootEl = this.el;\n    this.toArray().forEach(function (id, i) {\n      var el = rootEl.children[i];\n\n      if (closest(el, this.options.draggable, rootEl, false)) {\n        items[id] = el;\n      }\n    }, this);\n    useAnimation && this.captureAnimationState();\n    order.forEach(function (id) {\n      if (items[id]) {\n        rootEl.removeChild(items[id]);\n        rootEl.appendChild(items[id]);\n      }\n    });\n    useAnimation && this.animateAll();\n  },\n\n  /**\n   * Save the current sorting\n   */\n  save: function save() {\n    var store = this.options.store;\n    store && store.set && store.set(this);\n  },\n\n  /**\n   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.\n   * @param   {HTMLElement}  el\n   * @param   {String}       [selector]  default: `options.draggable`\n   * @returns {HTMLElement|null}\n   */\n  closest: function closest$1(el, selector) {\n    return closest(el, selector || this.options.draggable, this.el, false);\n  },\n\n  /**\n   * Set/get option\n   * @param   {string} name\n   * @param   {*}      [value]\n   * @returns {*}\n   */\n  option: function option(name, value) {\n    var options = this.options;\n\n    if (value === void 0) {\n      return options[name];\n    } else {\n      var modifiedValue = PluginManager.modifyOption(this, name, value);\n\n      if (typeof modifiedValue !== 'undefined') {\n        options[name] = modifiedValue;\n      } else {\n        options[name] = value;\n      }\n\n      if (name === 'group') {\n        _prepareGroup(options);\n      }\n    }\n  },\n\n  /**\n   * Destroy\n   */\n  destroy: function destroy() {\n    pluginEvent('destroy', this);\n    var el = this.el;\n    el[expando] = null;\n    off(el, 'mousedown', this._onTapStart);\n    off(el, 'touchstart', this._onTapStart);\n    off(el, 'pointerdown', this._onTapStart);\n\n    if (this.nativeDraggable) {\n      off(el, 'dragover', this);\n      off(el, 'dragenter', this);\n    } // Remove draggable attributes\n\n\n    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {\n      el.removeAttribute('draggable');\n    });\n\n    this._onDrop();\n\n    this._disableDelayedDragEvents();\n\n    sortables.splice(sortables.indexOf(this.el), 1);\n    this.el = el = null;\n  },\n  _hideClone: function _hideClone() {\n    if (!cloneHidden) {\n      pluginEvent('hideClone', this);\n      if (Sortable.eventCanceled) return;\n      css(cloneEl, 'display', 'none');\n\n      if (this.options.removeCloneOnHide && cloneEl.parentNode) {\n        cloneEl.parentNode.removeChild(cloneEl);\n      }\n\n      cloneHidden = true;\n    }\n  },\n  _showClone: function _showClone(putSortable) {\n    if (putSortable.lastPutMode !== 'clone') {\n      this._hideClone();\n\n      return;\n    }\n\n    if (cloneHidden) {\n      pluginEvent('showClone', this);\n      if (Sortable.eventCanceled) return; // show clone at dragEl or original position\n\n      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      } else if (nextEl) {\n        rootEl.insertBefore(cloneEl, nextEl);\n      } else {\n        rootEl.appendChild(cloneEl);\n      }\n\n      if (this.options.group.revertClone) {\n        this.animate(dragEl, cloneEl);\n      }\n\n      css(cloneEl, 'display', '');\n      cloneHidden = false;\n    }\n  }\n};\n\nfunction _globalDragOver(\n/**Event*/\nevt) {\n  if (evt.dataTransfer) {\n    evt.dataTransfer.dropEffect = 'move';\n  }\n\n  evt.cancelable && evt.preventDefault();\n}\n\nfunction _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {\n  var evt,\n      sortable = fromEl[expando],\n      onMoveFn = sortable.options.onMove,\n      retVal; // Support for new CustomEvent feature\n\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent('move', {\n      bubbles: true,\n      cancelable: true\n    });\n  } else {\n    evt = document.createEvent('Event');\n    evt.initEvent('move', true, true);\n  }\n\n  evt.to = toEl;\n  evt.from = fromEl;\n  evt.dragged = dragEl;\n  evt.draggedRect = dragRect;\n  evt.related = targetEl || toEl;\n  evt.relatedRect = targetRect || getRect(toEl);\n  evt.willInsertAfter = willInsertAfter;\n  evt.originalEvent = originalEvent;\n  fromEl.dispatchEvent(evt);\n\n  if (onMoveFn) {\n    retVal = onMoveFn.call(sortable, evt, originalEvent);\n  }\n\n  return retVal;\n}\n\nfunction _disableDraggable(el) {\n  el.draggable = false;\n}\n\nfunction _unsilent() {\n  _silent = false;\n}\n\nfunction _ghostIsFirst(evt, vertical, sortable) {\n  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));\n  var spacer = 10;\n  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;\n}\n\nfunction _ghostIsLast(evt, vertical, sortable) {\n  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));\n  var spacer = 10;\n  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;\n}\n\nfunction _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {\n  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,\n      targetLength = vertical ? targetRect.height : targetRect.width,\n      targetS1 = vertical ? targetRect.top : targetRect.left,\n      targetS2 = vertical ? targetRect.bottom : targetRect.right,\n      invert = false;\n\n  if (!invertSwap) {\n    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\n    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {\n      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\n      // check if past first invert threshold on side opposite of lastDirection\n      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {\n        // past first invert threshold, do not restrict inverted threshold to dragEl shadow\n        pastFirstInvertThresh = true;\n      }\n\n      if (!pastFirstInvertThresh) {\n        // dragEl shadow (target move distance shadow)\n        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\n        : mouseOnAxis > targetS2 - targetMoveDistance) {\n          return -lastDirection;\n        }\n      } else {\n        invert = true;\n      }\n    } else {\n      // Regular\n      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {\n        return _getInsertDirection(target);\n      }\n    }\n  }\n\n  invert = invert || invertSwap;\n\n  if (invert) {\n    // Invert of regular\n    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {\n      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;\n    }\n  }\n\n  return 0;\n}\n/**\n * Gets the direction dragEl must be swapped relative to target in order to make it\n * seem that dragEl has been \"inserted\" into that element's position\n * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\n * @return {Number}                   Direction dragEl must be swapped\n */\n\n\nfunction _getInsertDirection(target) {\n  if (index(dragEl) < index(target)) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n/**\n * Generate id\n * @param   {HTMLElement} el\n * @returns {String}\n * @private\n */\n\n\nfunction _generateId(el) {\n  var str = el.tagName + el.className + el.src + el.href + el.textContent,\n      i = str.length,\n      sum = 0;\n\n  while (i--) {\n    sum += str.charCodeAt(i);\n  }\n\n  return sum.toString(36);\n}\n\nfunction _saveInputCheckedState(root) {\n  savedInputChecked.length = 0;\n  var inputs = root.getElementsByTagName('input');\n  var idx = inputs.length;\n\n  while (idx--) {\n    var el = inputs[idx];\n    el.checked && savedInputChecked.push(el);\n  }\n}\n\nfunction _nextTick(fn) {\n  return setTimeout(fn, 0);\n}\n\nfunction _cancelNextTick(id) {\n  return clearTimeout(id);\n} // Fixed #973:\n\n\nif (documentExists) {\n  on(document, 'touchmove', function (evt) {\n    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {\n      evt.preventDefault();\n    }\n  });\n} // Export utils\n\n\nSortable.utils = {\n  on: on,\n  off: off,\n  css: css,\n  find: find,\n  is: function is(el, selector) {\n    return !!closest(el, selector, el, false);\n  },\n  extend: extend,\n  throttle: throttle,\n  closest: closest,\n  toggleClass: toggleClass,\n  clone: clone,\n  index: index,\n  nextTick: _nextTick,\n  cancelNextTick: _cancelNextTick,\n  detectDirection: _detectDirection,\n  getChild: getChild\n};\n/**\n * Get the Sortable instance of an element\n * @param  {HTMLElement} element The element\n * @return {Sortable|undefined}         The instance of Sortable\n */\n\nSortable.get = function (element) {\n  return element[expando];\n};\n/**\n * Mount a plugin to Sortable\n * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted\n */\n\n\nSortable.mount = function () {\n  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {\n    plugins[_key] = arguments[_key];\n  }\n\n  if (plugins[0].constructor === Array) plugins = plugins[0];\n  plugins.forEach(function (plugin) {\n    if (!plugin.prototype || !plugin.prototype.constructor) {\n      throw \"Sortable: Mounted plugin must be a constructor function, not \".concat({}.toString.call(plugin));\n    }\n\n    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);\n    PluginManager.mount(plugin);\n  });\n};\n/**\n * Create sortable instance\n * @param {HTMLElement}  el\n * @param {Object}      [options]\n */\n\n\nSortable.create = function (el, options) {\n  return new Sortable(el, options);\n}; // Export\n\n\nSortable.version = version;\n\nvar autoScrolls = [],\n    scrollEl,\n    scrollRootEl,\n    scrolling = false,\n    lastAutoScrollX,\n    lastAutoScrollY,\n    touchEvt$1,\n    pointerElemChangedInterval;\n\nfunction AutoScrollPlugin() {\n  function AutoScroll() {\n    this.defaults = {\n      scroll: true,\n      forceAutoScrollFallback: false,\n      scrollSensitivity: 30,\n      scrollSpeed: 10,\n      bubbleScroll: true\n    }; // Bind all private methods\n\n    for (var fn in this) {\n      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n  }\n\n  AutoScroll.prototype = {\n    dragStarted: function dragStarted(_ref) {\n      var originalEvent = _ref.originalEvent;\n\n      if (this.sortable.nativeDraggable) {\n        on(document, 'dragover', this._handleAutoScroll);\n      } else {\n        if (this.options.supportPointer) {\n          on(document, 'pointermove', this._handleFallbackAutoScroll);\n        } else if (originalEvent.touches) {\n          on(document, 'touchmove', this._handleFallbackAutoScroll);\n        } else {\n          on(document, 'mousemove', this._handleFallbackAutoScroll);\n        }\n      }\n    },\n    dragOverCompleted: function dragOverCompleted(_ref2) {\n      var originalEvent = _ref2.originalEvent;\n\n      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)\n      if (!this.options.dragOverBubble && !originalEvent.rootEl) {\n        this._handleAutoScroll(originalEvent);\n      }\n    },\n    drop: function drop() {\n      if (this.sortable.nativeDraggable) {\n        off(document, 'dragover', this._handleAutoScroll);\n      } else {\n        off(document, 'pointermove', this._handleFallbackAutoScroll);\n        off(document, 'touchmove', this._handleFallbackAutoScroll);\n        off(document, 'mousemove', this._handleFallbackAutoScroll);\n      }\n\n      clearPointerElemChangedInterval();\n      clearAutoScrolls();\n      cancelThrottle();\n    },\n    nulling: function nulling() {\n      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;\n      autoScrolls.length = 0;\n    },\n    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {\n      this._handleAutoScroll(evt, true);\n    },\n    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {\n      var _this = this;\n\n      var x = (evt.touches ? evt.touches[0] : evt).clientX,\n          y = (evt.touches ? evt.touches[0] : evt).clientY,\n          elem = document.elementFromPoint(x, y);\n      touchEvt$1 = evt; // IE does not seem to have native autoscroll,\n      // Edge's autoscroll seems too conditional,\n      // MACOS Safari does not have autoscroll,\n      // Firefox and Chrome are good\n\n      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {\n        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change\n\n        var ogElemScroller = getParentAutoScrollElement(elem, true);\n\n        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {\n          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour\n\n          pointerElemChangedInterval = setInterval(function () {\n            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);\n\n            if (newElem !== ogElemScroller) {\n              ogElemScroller = newElem;\n              clearAutoScrolls();\n            }\n\n            autoScroll(evt, _this.options, newElem, fallback);\n          }, 10);\n          lastAutoScrollX = x;\n          lastAutoScrollY = y;\n        }\n      } else {\n        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll\n        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {\n          clearAutoScrolls();\n          return;\n        }\n\n        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);\n      }\n    }\n  };\n  return _extends(AutoScroll, {\n    pluginName: 'scroll',\n    initializeByDefault: true\n  });\n}\n\nfunction clearAutoScrolls() {\n  autoScrolls.forEach(function (autoScroll) {\n    clearInterval(autoScroll.pid);\n  });\n  autoScrolls = [];\n}\n\nfunction clearPointerElemChangedInterval() {\n  clearInterval(pointerElemChangedInterval);\n}\n\nvar autoScroll = throttle(function (evt, options, rootEl, isFallback) {\n  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521\n  if (!options.scroll) return;\n  var x = (evt.touches ? evt.touches[0] : evt).clientX,\n      y = (evt.touches ? evt.touches[0] : evt).clientY,\n      sens = options.scrollSensitivity,\n      speed = options.scrollSpeed,\n      winScroller = getWindowScrollingElement();\n  var scrollThisInstance = false,\n      scrollCustomFn; // New scroll root, set scrollEl\n\n  if (scrollRootEl !== rootEl) {\n    scrollRootEl = rootEl;\n    clearAutoScrolls();\n    scrollEl = options.scroll;\n    scrollCustomFn = options.scrollFn;\n\n    if (scrollEl === true) {\n      scrollEl = getParentAutoScrollElement(rootEl, true);\n    }\n  }\n\n  var layersOut = 0;\n  var currentParent = scrollEl;\n\n  do {\n    var el = currentParent,\n        rect = getRect(el),\n        top = rect.top,\n        bottom = rect.bottom,\n        left = rect.left,\n        right = rect.right,\n        width = rect.width,\n        height = rect.height,\n        canScrollX = void 0,\n        canScrollY = void 0,\n        scrollWidth = el.scrollWidth,\n        scrollHeight = el.scrollHeight,\n        elCSS = css(el),\n        scrollPosX = el.scrollLeft,\n        scrollPosY = el.scrollTop;\n\n    if (el === winScroller) {\n      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');\n      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');\n    } else {\n      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');\n      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');\n    }\n\n    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);\n    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);\n\n    if (!autoScrolls[layersOut]) {\n      for (var i = 0; i <= layersOut; i++) {\n        if (!autoScrolls[i]) {\n          autoScrolls[i] = {};\n        }\n      }\n    }\n\n    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {\n      autoScrolls[layersOut].el = el;\n      autoScrolls[layersOut].vx = vx;\n      autoScrolls[layersOut].vy = vy;\n      clearInterval(autoScrolls[layersOut].pid);\n\n      if (vx != 0 || vy != 0) {\n        scrollThisInstance = true;\n        /* jshint loopfunc:true */\n\n        autoScrolls[layersOut].pid = setInterval(function () {\n          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour\n          if (isFallback && this.layer === 0) {\n            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely\n\n          }\n\n          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;\n          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;\n\n          if (typeof scrollCustomFn === 'function') {\n            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {\n              return;\n            }\n          }\n\n          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);\n        }.bind({\n          layer: layersOut\n        }), 24);\n      }\n    }\n\n    layersOut++;\n  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));\n\n  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not\n}, 30);\n\nvar drop = function drop(_ref) {\n  var originalEvent = _ref.originalEvent,\n      putSortable = _ref.putSortable,\n      dragEl = _ref.dragEl,\n      activeSortable = _ref.activeSortable,\n      dispatchSortableEvent = _ref.dispatchSortableEvent,\n      hideGhostForTarget = _ref.hideGhostForTarget,\n      unhideGhostForTarget = _ref.unhideGhostForTarget;\n  if (!originalEvent) return;\n  var toSortable = putSortable || activeSortable;\n  hideGhostForTarget();\n  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;\n  var target = document.elementFromPoint(touch.clientX, touch.clientY);\n  unhideGhostForTarget();\n\n  if (toSortable && !toSortable.el.contains(target)) {\n    dispatchSortableEvent('spill');\n    this.onSpill({\n      dragEl: dragEl,\n      putSortable: putSortable\n    });\n  }\n};\n\nfunction Revert() {}\n\nRevert.prototype = {\n  startIndex: null,\n  dragStart: function dragStart(_ref2) {\n    var oldDraggableIndex = _ref2.oldDraggableIndex;\n    this.startIndex = oldDraggableIndex;\n  },\n  onSpill: function onSpill(_ref3) {\n    var dragEl = _ref3.dragEl,\n        putSortable = _ref3.putSortable;\n    this.sortable.captureAnimationState();\n\n    if (putSortable) {\n      putSortable.captureAnimationState();\n    }\n\n    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);\n\n    if (nextSibling) {\n      this.sortable.el.insertBefore(dragEl, nextSibling);\n    } else {\n      this.sortable.el.appendChild(dragEl);\n    }\n\n    this.sortable.animateAll();\n\n    if (putSortable) {\n      putSortable.animateAll();\n    }\n  },\n  drop: drop\n};\n\n_extends(Revert, {\n  pluginName: 'revertOnSpill'\n});\n\nfunction Remove() {}\n\nRemove.prototype = {\n  onSpill: function onSpill(_ref4) {\n    var dragEl = _ref4.dragEl,\n        putSortable = _ref4.putSortable;\n    var parentSortable = putSortable || this.sortable;\n    parentSortable.captureAnimationState();\n    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);\n    parentSortable.animateAll();\n  },\n  drop: drop\n};\n\n_extends(Remove, {\n  pluginName: 'removeOnSpill'\n});\n\nvar lastSwapEl;\n\nfunction SwapPlugin() {\n  function Swap() {\n    this.defaults = {\n      swapClass: 'sortable-swap-highlight'\n    };\n  }\n\n  Swap.prototype = {\n    dragStart: function dragStart(_ref) {\n      var dragEl = _ref.dragEl;\n      lastSwapEl = dragEl;\n    },\n    dragOverValid: function dragOverValid(_ref2) {\n      var completed = _ref2.completed,\n          target = _ref2.target,\n          onMove = _ref2.onMove,\n          activeSortable = _ref2.activeSortable,\n          changed = _ref2.changed,\n          cancel = _ref2.cancel;\n      if (!activeSortable.options.swap) return;\n      var el = this.sortable.el,\n          options = this.options;\n\n      if (target && target !== el) {\n        var prevSwapEl = lastSwapEl;\n\n        if (onMove(target) !== false) {\n          toggleClass(target, options.swapClass, true);\n          lastSwapEl = target;\n        } else {\n          lastSwapEl = null;\n        }\n\n        if (prevSwapEl && prevSwapEl !== lastSwapEl) {\n          toggleClass(prevSwapEl, options.swapClass, false);\n        }\n      }\n\n      changed();\n      completed(true);\n      cancel();\n    },\n    drop: function drop(_ref3) {\n      var activeSortable = _ref3.activeSortable,\n          putSortable = _ref3.putSortable,\n          dragEl = _ref3.dragEl;\n      var toSortable = putSortable || this.sortable;\n      var options = this.options;\n      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);\n\n      if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {\n        if (dragEl !== lastSwapEl) {\n          toSortable.captureAnimationState();\n          if (toSortable !== activeSortable) activeSortable.captureAnimationState();\n          swapNodes(dragEl, lastSwapEl);\n          toSortable.animateAll();\n          if (toSortable !== activeSortable) activeSortable.animateAll();\n        }\n      }\n    },\n    nulling: function nulling() {\n      lastSwapEl = null;\n    }\n  };\n  return _extends(Swap, {\n    pluginName: 'swap',\n    eventProperties: function eventProperties() {\n      return {\n        swapItem: lastSwapEl\n      };\n    }\n  });\n}\n\nfunction swapNodes(n1, n2) {\n  var p1 = n1.parentNode,\n      p2 = n2.parentNode,\n      i1,\n      i2;\n  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;\n  i1 = index(n1);\n  i2 = index(n2);\n\n  if (p1.isEqualNode(p2) && i1 < i2) {\n    i2++;\n  }\n\n  p1.insertBefore(n2, p1.children[i1]);\n  p2.insertBefore(n1, p2.children[i2]);\n}\n\nvar multiDragElements = (/* unused pure expression or super */ null && ([])),\n    multiDragClones = (/* unused pure expression or super */ null && ([])),\n    lastMultiDragSelect,\n    // for selection with modifier key down (SHIFT)\nmultiDragSortable,\n    initialFolding = false,\n    // Initial multi-drag fold when drag started\nfolding = false,\n    // Folding any other time\ndragStarted = false,\n    dragEl$1,\n    clonesFromRect,\n    clonesHidden;\n\nfunction MultiDragPlugin() {\n  function MultiDrag(sortable) {\n    // Bind all private methods\n    for (var fn in this) {\n      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n\n    if (sortable.options.supportPointer) {\n      on(document, 'pointerup', this._deselectMultiDrag);\n    } else {\n      on(document, 'mouseup', this._deselectMultiDrag);\n      on(document, 'touchend', this._deselectMultiDrag);\n    }\n\n    on(document, 'keydown', this._checkKeyDown);\n    on(document, 'keyup', this._checkKeyUp);\n    this.defaults = {\n      selectedClass: 'sortable-selected',\n      multiDragKey: null,\n      setData: function setData(dataTransfer, dragEl) {\n        var data = '';\n\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          multiDragElements.forEach(function (multiDragElement, i) {\n            data += (!i ? '' : ', ') + multiDragElement.textContent;\n          });\n        } else {\n          data = dragEl.textContent;\n        }\n\n        dataTransfer.setData('Text', data);\n      }\n    };\n  }\n\n  MultiDrag.prototype = {\n    multiDragKeyDown: false,\n    isMultiDrag: false,\n    delayStartGlobal: function delayStartGlobal(_ref) {\n      var dragged = _ref.dragEl;\n      dragEl$1 = dragged;\n    },\n    delayEnded: function delayEnded() {\n      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);\n    },\n    setupClone: function setupClone(_ref2) {\n      var sortable = _ref2.sortable,\n          cancel = _ref2.cancel;\n      if (!this.isMultiDrag) return;\n\n      for (var i = 0; i < multiDragElements.length; i++) {\n        multiDragClones.push(clone(multiDragElements[i]));\n        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;\n        multiDragClones[i].draggable = false;\n        multiDragClones[i].style['will-change'] = '';\n        toggleClass(multiDragClones[i], this.options.selectedClass, false);\n        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);\n      }\n\n      sortable._hideClone();\n\n      cancel();\n    },\n    clone: function clone(_ref3) {\n      var sortable = _ref3.sortable,\n          rootEl = _ref3.rootEl,\n          dispatchSortableEvent = _ref3.dispatchSortableEvent,\n          cancel = _ref3.cancel;\n      if (!this.isMultiDrag) return;\n\n      if (!this.options.removeCloneOnHide) {\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          insertMultiDragClones(true, rootEl);\n          dispatchSortableEvent('clone');\n          cancel();\n        }\n      }\n    },\n    showClone: function showClone(_ref4) {\n      var cloneNowShown = _ref4.cloneNowShown,\n          rootEl = _ref4.rootEl,\n          cancel = _ref4.cancel;\n      if (!this.isMultiDrag) return;\n      insertMultiDragClones(false, rootEl);\n      multiDragClones.forEach(function (clone) {\n        css(clone, 'display', '');\n      });\n      cloneNowShown();\n      clonesHidden = false;\n      cancel();\n    },\n    hideClone: function hideClone(_ref5) {\n      var _this = this;\n\n      var sortable = _ref5.sortable,\n          cloneNowHidden = _ref5.cloneNowHidden,\n          cancel = _ref5.cancel;\n      if (!this.isMultiDrag) return;\n      multiDragClones.forEach(function (clone) {\n        css(clone, 'display', 'none');\n\n        if (_this.options.removeCloneOnHide && clone.parentNode) {\n          clone.parentNode.removeChild(clone);\n        }\n      });\n      cloneNowHidden();\n      clonesHidden = true;\n      cancel();\n    },\n    dragStartGlobal: function dragStartGlobal(_ref6) {\n      var sortable = _ref6.sortable;\n\n      if (!this.isMultiDrag && multiDragSortable) {\n        multiDragSortable.multiDrag._deselectMultiDrag();\n      }\n\n      multiDragElements.forEach(function (multiDragElement) {\n        multiDragElement.sortableIndex = index(multiDragElement);\n      }); // Sort multi-drag elements\n\n      multiDragElements = multiDragElements.sort(function (a, b) {\n        return a.sortableIndex - b.sortableIndex;\n      });\n      dragStarted = true;\n    },\n    dragStarted: function dragStarted(_ref7) {\n      var _this2 = this;\n\n      var sortable = _ref7.sortable;\n      if (!this.isMultiDrag) return;\n\n      if (this.options.sort) {\n        // Capture rects,\n        // hide multi drag elements (by positioning them absolute),\n        // set multi drag elements rects to dragRect,\n        // show multi drag elements,\n        // animate to rects,\n        // unset rects & remove from DOM\n        sortable.captureAnimationState();\n\n        if (this.options.animation) {\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            css(multiDragElement, 'position', 'absolute');\n          });\n          var dragRect = getRect(dragEl$1, false, true, true);\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            setRect(multiDragElement, dragRect);\n          });\n          folding = true;\n          initialFolding = true;\n        }\n      }\n\n      sortable.animateAll(function () {\n        folding = false;\n        initialFolding = false;\n\n        if (_this2.options.animation) {\n          multiDragElements.forEach(function (multiDragElement) {\n            unsetRect(multiDragElement);\n          });\n        } // Remove all auxiliary multidrag items from el, if sorting enabled\n\n\n        if (_this2.options.sort) {\n          removeMultiDragElements();\n        }\n      });\n    },\n    dragOver: function dragOver(_ref8) {\n      var target = _ref8.target,\n          completed = _ref8.completed,\n          cancel = _ref8.cancel;\n\n      if (folding && ~multiDragElements.indexOf(target)) {\n        completed(false);\n        cancel();\n      }\n    },\n    revert: function revert(_ref9) {\n      var fromSortable = _ref9.fromSortable,\n          rootEl = _ref9.rootEl,\n          sortable = _ref9.sortable,\n          dragRect = _ref9.dragRect;\n\n      if (multiDragElements.length > 1) {\n        // Setup unfold animation\n        multiDragElements.forEach(function (multiDragElement) {\n          sortable.addAnimationState({\n            target: multiDragElement,\n            rect: folding ? getRect(multiDragElement) : dragRect\n          });\n          unsetRect(multiDragElement);\n          multiDragElement.fromRect = dragRect;\n          fromSortable.removeAnimationState(multiDragElement);\n        });\n        folding = false;\n        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);\n      }\n    },\n    dragOverCompleted: function dragOverCompleted(_ref10) {\n      var sortable = _ref10.sortable,\n          isOwner = _ref10.isOwner,\n          insertion = _ref10.insertion,\n          activeSortable = _ref10.activeSortable,\n          parentEl = _ref10.parentEl,\n          putSortable = _ref10.putSortable;\n      var options = this.options;\n\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        }\n\n        initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location\n\n        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {\n          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible\n          var dragRectAbsolute = getRect(dragEl$1, false, true, true);\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted\n            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable\n\n            parentEl.appendChild(multiDragElement);\n          });\n          folding = true;\n        } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out\n\n\n        if (!isOwner) {\n          // Only remove if not folding (folding will remove them anyways)\n          if (!folding) {\n            removeMultiDragElements();\n          }\n\n          if (multiDragElements.length > 1) {\n            var clonesHiddenBefore = clonesHidden;\n\n            activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden\n\n\n            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {\n              multiDragClones.forEach(function (clone) {\n                activeSortable.addAnimationState({\n                  target: clone,\n                  rect: clonesFromRect\n                });\n                clone.fromRect = clonesFromRect;\n                clone.thisAnimationDuration = null;\n              });\n            }\n          } else {\n            activeSortable._showClone(sortable);\n          }\n        }\n      }\n    },\n    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {\n      var dragRect = _ref11.dragRect,\n          isOwner = _ref11.isOwner,\n          activeSortable = _ref11.activeSortable;\n      multiDragElements.forEach(function (multiDragElement) {\n        multiDragElement.thisAnimationDuration = null;\n      });\n\n      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {\n        clonesFromRect = _extends({}, dragRect);\n        var dragMatrix = matrix(dragEl$1, true);\n        clonesFromRect.top -= dragMatrix.f;\n        clonesFromRect.left -= dragMatrix.e;\n      }\n    },\n    dragOverAnimationComplete: function dragOverAnimationComplete() {\n      if (folding) {\n        folding = false;\n        removeMultiDragElements();\n      }\n    },\n    drop: function drop(_ref12) {\n      var evt = _ref12.originalEvent,\n          rootEl = _ref12.rootEl,\n          parentEl = _ref12.parentEl,\n          sortable = _ref12.sortable,\n          dispatchSortableEvent = _ref12.dispatchSortableEvent,\n          oldIndex = _ref12.oldIndex,\n          putSortable = _ref12.putSortable;\n      var toSortable = putSortable || this.sortable;\n      if (!evt) return;\n      var options = this.options,\n          children = parentEl.children; // Multi-drag selection\n\n      if (!dragStarted) {\n        if (options.multiDragKey && !this.multiDragKeyDown) {\n          this._deselectMultiDrag();\n        }\n\n        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));\n\n        if (!~multiDragElements.indexOf(dragEl$1)) {\n          multiDragElements.push(dragEl$1);\n          dispatchEvent({\n            sortable: sortable,\n            rootEl: rootEl,\n            name: 'select',\n            targetEl: dragEl$1,\n            originalEvt: evt\n          }); // Modifier activated, select from last to dragEl\n\n          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {\n            var lastIndex = index(lastMultiDragSelect),\n                currentIndex = index(dragEl$1);\n\n            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {\n              // Must include lastMultiDragSelect (select it), in case modified selection from no selection\n              // (but previous selection existed)\n              var n, i;\n\n              if (currentIndex > lastIndex) {\n                i = lastIndex;\n                n = currentIndex;\n              } else {\n                i = currentIndex;\n                n = lastIndex + 1;\n              }\n\n              for (; i < n; i++) {\n                if (~multiDragElements.indexOf(children[i])) continue;\n                toggleClass(children[i], options.selectedClass, true);\n                multiDragElements.push(children[i]);\n                dispatchEvent({\n                  sortable: sortable,\n                  rootEl: rootEl,\n                  name: 'select',\n                  targetEl: children[i],\n                  originalEvt: evt\n                });\n              }\n            }\n          } else {\n            lastMultiDragSelect = dragEl$1;\n          }\n\n          multiDragSortable = toSortable;\n        } else {\n          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);\n          lastMultiDragSelect = null;\n          dispatchEvent({\n            sortable: sortable,\n            rootEl: rootEl,\n            name: 'deselect',\n            targetEl: dragEl$1,\n            originalEvt: evt\n          });\n        }\n      } // Multi-drag drop\n\n\n      if (dragStarted && this.isMultiDrag) {\n        folding = false; // Do not \"unfold\" after around dragEl if reverted\n\n        if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {\n          var dragRect = getRect(dragEl$1),\n              multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');\n          if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;\n          toSortable.captureAnimationState();\n\n          if (!initialFolding) {\n            if (options.animation) {\n              dragEl$1.fromRect = dragRect;\n              multiDragElements.forEach(function (multiDragElement) {\n                multiDragElement.thisAnimationDuration = null;\n\n                if (multiDragElement !== dragEl$1) {\n                  var rect = folding ? getRect(multiDragElement) : dragRect;\n                  multiDragElement.fromRect = rect; // Prepare unfold animation\n\n                  toSortable.addAnimationState({\n                    target: multiDragElement,\n                    rect: rect\n                  });\n                }\n              });\n            } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert\n            // properly they must all be removed\n\n\n            removeMultiDragElements();\n            multiDragElements.forEach(function (multiDragElement) {\n              if (children[multiDragIndex]) {\n                parentEl.insertBefore(multiDragElement, children[multiDragIndex]);\n              } else {\n                parentEl.appendChild(multiDragElement);\n              }\n\n              multiDragIndex++;\n            }); // If initial folding is done, the elements may have changed position because they are now\n            // unfolding around dragEl, even though dragEl may not have his index changed, so update event\n            // must be fired here as Sortable will not.\n\n            if (oldIndex === index(dragEl$1)) {\n              var update = false;\n              multiDragElements.forEach(function (multiDragElement) {\n                if (multiDragElement.sortableIndex !== index(multiDragElement)) {\n                  update = true;\n                  return;\n                }\n              });\n\n              if (update) {\n                dispatchSortableEvent('update');\n              }\n            }\n          } // Must be done after capturing individual rects (scroll bar)\n\n\n          multiDragElements.forEach(function (multiDragElement) {\n            unsetRect(multiDragElement);\n          });\n          toSortable.animateAll();\n        }\n\n        multiDragSortable = toSortable;\n      } // Remove clones if necessary\n\n\n      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n        multiDragClones.forEach(function (clone) {\n          clone.parentNode && clone.parentNode.removeChild(clone);\n        });\n      }\n    },\n    nullingGlobal: function nullingGlobal() {\n      this.isMultiDrag = dragStarted = false;\n      multiDragClones.length = 0;\n    },\n    destroyGlobal: function destroyGlobal() {\n      this._deselectMultiDrag();\n\n      off(document, 'pointerup', this._deselectMultiDrag);\n      off(document, 'mouseup', this._deselectMultiDrag);\n      off(document, 'touchend', this._deselectMultiDrag);\n      off(document, 'keydown', this._checkKeyDown);\n      off(document, 'keyup', this._checkKeyUp);\n    },\n    _deselectMultiDrag: function _deselectMultiDrag(evt) {\n      if (typeof dragStarted !== \"undefined\" && dragStarted) return; // Only deselect if selection is in this sortable\n\n      if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable\n\n      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click\n\n      if (evt && evt.button !== 0) return;\n\n      while (multiDragElements.length) {\n        var el = multiDragElements[0];\n        toggleClass(el, this.options.selectedClass, false);\n        multiDragElements.shift();\n        dispatchEvent({\n          sortable: this.sortable,\n          rootEl: this.sortable.el,\n          name: 'deselect',\n          targetEl: el,\n          originalEvt: evt\n        });\n      }\n    },\n    _checkKeyDown: function _checkKeyDown(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = true;\n      }\n    },\n    _checkKeyUp: function _checkKeyUp(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = false;\n      }\n    }\n  };\n  return _extends(MultiDrag, {\n    // Static methods & properties\n    pluginName: 'multiDrag',\n    utils: {\n      /**\n       * Selects the provided multi-drag item\n       * @param  {HTMLElement} el    The element to be selected\n       */\n      select: function select(el) {\n        var sortable = el.parentNode[expando];\n        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;\n\n        if (multiDragSortable && multiDragSortable !== sortable) {\n          multiDragSortable.multiDrag._deselectMultiDrag();\n\n          multiDragSortable = sortable;\n        }\n\n        toggleClass(el, sortable.options.selectedClass, true);\n        multiDragElements.push(el);\n      },\n\n      /**\n       * Deselects the provided multi-drag item\n       * @param  {HTMLElement} el    The element to be deselected\n       */\n      deselect: function deselect(el) {\n        var sortable = el.parentNode[expando],\n            index = multiDragElements.indexOf(el);\n        if (!sortable || !sortable.options.multiDrag || !~index) return;\n        toggleClass(el, sortable.options.selectedClass, false);\n        multiDragElements.splice(index, 1);\n      }\n    },\n    eventProperties: function eventProperties() {\n      var _this3 = this;\n\n      var oldIndicies = [],\n          newIndicies = [];\n      multiDragElements.forEach(function (multiDragElement) {\n        oldIndicies.push({\n          multiDragElement: multiDragElement,\n          index: multiDragElement.sortableIndex\n        }); // multiDragElements will already be sorted if folding\n\n        var newIndex;\n\n        if (folding && multiDragElement !== dragEl$1) {\n          newIndex = -1;\n        } else if (folding) {\n          newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');\n        } else {\n          newIndex = index(multiDragElement);\n        }\n\n        newIndicies.push({\n          multiDragElement: multiDragElement,\n          index: newIndex\n        });\n      });\n      return {\n        items: _toConsumableArray(multiDragElements),\n        clones: [].concat(multiDragClones),\n        oldIndicies: oldIndicies,\n        newIndicies: newIndicies\n      };\n    },\n    optionListeners: {\n      multiDragKey: function multiDragKey(key) {\n        key = key.toLowerCase();\n\n        if (key === 'ctrl') {\n          key = 'Control';\n        } else if (key.length > 1) {\n          key = key.charAt(0).toUpperCase() + key.substr(1);\n        }\n\n        return key;\n      }\n    }\n  });\n}\n\nfunction insertMultiDragElements(clonesInserted, rootEl) {\n  multiDragElements.forEach(function (multiDragElement, i) {\n    var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];\n\n    if (target) {\n      rootEl.insertBefore(multiDragElement, target);\n    } else {\n      rootEl.appendChild(multiDragElement);\n    }\n  });\n}\n/**\n * Insert multi-drag clones\n * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted\n * @param  {HTMLElement} rootEl\n */\n\n\nfunction insertMultiDragClones(elementsInserted, rootEl) {\n  multiDragClones.forEach(function (clone, i) {\n    var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];\n\n    if (target) {\n      rootEl.insertBefore(clone, target);\n    } else {\n      rootEl.appendChild(clone);\n    }\n  });\n}\n\nfunction removeMultiDragElements() {\n  multiDragElements.forEach(function (multiDragElement) {\n    if (multiDragElement === dragEl$1) return;\n    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);\n  });\n}\n\nSortable.mount(new AutoScrollPlugin());\nSortable.mount(Remove, Revert);\n\n/* harmony default export */ var sortable_esm = (Sortable);\n\n\n;// CONCATENATED MODULE: ./public/src/components/sortable.js\n\n\n\nfunction sortable(selector) {\n  let el = common_$(selector)[0];\n\n  if (el) {\n    let sortable = sortable_esm.create(el, {\n      animation: 150,\n      onEnd: function (evt) {\n        let oldI = evt.oldIndex;\n        let newI = evt.newIndex;\n\n        if (oldI > newI) {\n          let questions = question_question.questions();\n\n          question_question.sort(oldI);\n        } else {\n          let questions = question_question.questions();\n\n          question_question.sort(newI);\n        }\n      }\n    });\n  }\n}\n;// CONCATENATED MODULE: ./public/src/components/select/WDSSelect.js\n\n\nclass WDSSelect {\n  constructor(el) {\n    if (!el) return false;\n    if (el.multiple) return false;\n    this.title = el.title ?? '';\n    this.field = el.dataset['field'];\n    this.options = getFormattedOptions(el.querySelectorAll(\"option\"));\n    this.sel = document.createElement(\"div\");\n    if (el.className) this.sel.classList.add(el.className);\n    this.label = document.createElement(\"span\");\n    this.ul = document.createElement(\"ul\");\n    setup(this);\n    el.style.display = \"none\";\n    el.after(this.sel);\n  }\n\n  get selectedOption() {\n    return this.options.find(option => option.selected);\n  }\n\n  get selectedOptionIndex() {\n    return this.options.indexOf(this.selectedOption);\n  }\n\n  selectValue(value) {\n    const newSelectedOption = this.options.find(option => {\n      return option.value === value;\n    });\n    const prevSelectedOption = this.selectedOption;\n    prevSelectedOption.selected = false;\n    prevSelectedOption.element.selected = false;\n    newSelectedOption.selected = true;\n    newSelectedOption.element.selected = true;\n    this.label.innerText = newSelectedOption.label;\n    this.label.closest('.custom-select').dataset['id'] = newSelectedOption.value;\n    this.ul.querySelector(`[data-value=\"${prevSelectedOption.value}\"]`).classList.remove(\"selected\");\n    const newCustomElement = this.ul.querySelector(`[data-value=\"${newSelectedOption.value}\"]`);\n    newCustomElement.classList.add(\"selected\");\n    newCustomElement.scrollIntoView({\n      block: \"nearest\"\n    });\n  }\n\n}\n\nfunction setup(select) {\n  if (select.title) {\n    select.titleElement = document.createElement(\"div\");\n    select.titleElement.classList.add(\"custom-select-title\");\n    select.titleElement.innerText = select.title;\n    select.sel.append(select.titleElement);\n  }\n\n  select.sel.classList.add(\"custom-select\");\n  select.sel.dataset['field'] = select.field; // debugger\n\n  select.sel.dataset['id'] = select.selectedOption.value;\n  select.sel.tabIndex = 0; // debugger\n\n  select.label.classList.add(\"custom-select-value\");\n  select.label.innerText = select.selectedOption.label;\n  select.sel.append(select.label);\n  select.ul.classList.add(\"custom-select-options\");\n  select.options.forEach(option => {\n    setOption(option);\n  });\n\n  function setOption(option) {\n    const li = document.createElement(\"li\");\n    li.classList.add(\"custom-select-option\");\n    li.classList.toggle(\"selected\", option.selected);\n    li.innerText = option.label;\n    li.dataset.value = option.value;\n    li.addEventListener(\"click\", () => {\n      select.selectValue(option.value);\n      select.ul.classList.remove(\"show\");\n    });\n    select.ul.append(li);\n  }\n\n  select.sel.append(select.ul);\n  select.label.addEventListener(\"click\", () => {\n    select.ul.classList.toggle(\"show\");\n  });\n  select.sel.addEventListener(\"blur\", () => {\n    select.ul.classList.remove(\"show\");\n  });\n  let debounceTimeout;\n  let searchTerm = \"\";\n  select.sel.addEventListener(\"keydown\", e => {\n    switch (e.code) {\n      case \"Space\":\n        select.ul.classList.toggle(\"show\");\n        break;\n\n      case \"ArrowUp\":\n        {\n          const prevOption = select.options[select.selectedOptionIndex - 1];\n\n          if (prevOption) {\n            select.selectValue(prevOption.value);\n          }\n\n          break;\n        }\n\n      case \"ArrowDown\":\n        {\n          const nextOption = select.options[select.selectedOptionIndex + 1];\n\n          if (nextOption) {\n            select.selectValue(nextOption.value);\n          }\n\n          break;\n        }\n\n      case \"Enter\":\n      case \"Escape\":\n        select.ul.classList.remove(\"show\");\n        break;\n\n      default:\n        {\n          clearTimeout(debounceTimeout);\n          searchTerm += e.key;\n          debounceTimeout = setTimeout(() => {\n            searchTerm = \"\";\n          }, 500);\n          const searchedOption = select.options.find(option => {\n            return option.label.toLowerCase().startsWith(searchTerm);\n          });\n\n          if (searchedOption) {\n            select.selectValue(searchedOption.value);\n          }\n        }\n    }\n  });\n}\n\nfunction getFormattedOptions(options) {\n  return [...options].map(option => {\n    return {\n      value: option.value,\n      label: option.label,\n      selected: option.selected,\n      element: option\n    };\n  });\n}\n;// CONCATENATED MODULE: ./public/src/Test/accordion-show.js\n\nfunction accordionShow() {\n  let currentTestId = common_$(`[data-testid]`)[0];\n\n  if (currentTestId) {\n    currentTestId = +currentTestId.dataset['testid'];\n    let menuItemCollection = common_$('.test-edit.accordion a');\n    Array.from(menuItemCollection).filter(a => {\n      if (+a.dataset.id === currentTestId) {\n        a.classList.add('current');\n      }\n    });\n  }\n\n  let button = common_$('.test-edit__menu-toggle')[0];\n\n  if (button) {\n    common_$(button).on('click', function () {\n      let menu = common_$('.test-edit__accordion')[0];\n      menu.classList.toggle('open');\n    });\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Test/testEditActions.js\n\n\n\nfunction testEditActions(target, type) {\n  if (type === 'click') {\n    switch (true) {\n      case target.classList.contains('test-path__update'):\n        {\n          _test.update();\n\n          break;\n        }\n\n      case target.classList.contains('test__update'):\n        {\n          _test.update();\n\n          break;\n        }\n\n      case target.classList.contains('test__save'):\n        {\n          _test.update();\n\n          break;\n        }\n\n      case target.classList.contains('test__delete'):\n        {\n          _test[\"delete\"]();\n\n          break;\n        }\n\n      case target.classList.contains('test-path__create'):\n        {\n          _test.path_create();\n\n          break;\n        }\n\n      case target.classList.contains('test__create'):\n        {\n          _test.create();\n\n          break;\n        }\n\n      case !!target.closest('.question__save'):\n        {\n          question_question.save(target);\n\n          break;\n        }\n\n      case !!target.closest('.question__show-answers'):\n        {\n          question_question.showAnswers(target);\n\n          break;\n        }\n\n      case !!target.closest('.question__delete'):\n        {\n          question_question[\"delete\"](target);\n\n          break;\n        }\n\n      case target.classList.contains('question__create-button'):\n        {\n          question_question.create();\n\n          break;\n        }\n\n      case !!target.closest('.answer__delete'):\n        {\n          answer_answer.del(target);\n\n          break;\n        }\n\n      case target.classList.contains('answer__create-button'):\n        {\n          answer_answer.create(target);\n\n          break;\n        }\n    }\n  }\n\n  if (type === 'change') {\n    // debugger\n    switch (true) {\n      case !!target.closest('.question-edit__parent-select'):\n        {\n          question_question.changeParent(target);\n\n          break;\n        }\n    }\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Test/test-edit.js\n\n\n\n\n\n // import './path-create'\n\n\n\n\n\n\n\n\nfunction testEdit() {\n  tooltips();\n  sortable('.questions');\n  accordionShow(); // debugger\n\n  let customSelects = common_$('[custom-select]');\n  [].forEach.call(customSelects, function (select) {\n    new WDSSelect(select);\n  }); // при создании нового теста показать пустой вопрос\n\n  if (!question_question.questions().length && /\\/adminsc\\/test\\/edit/.test(window.location.pathname)) {\n    question_question.showFirst();\n  } // debugger\n\n\n  let testEditWrapper = common_$('.test-edit-wrapper')[0];\n\n  if (testEditWrapper) {\n    testEditWrapper.addEventListener('click', _ref => {\n      let {\n        target\n      } = _ref;\n      testEditActions(target, 'click');\n    });\n    testEditWrapper.addEventListener('change', _ref2 => {\n      let {\n        target\n      } = _ref2;\n      testEditActions(target, 'change');\n    });\n  } // addTooltip({\n  //   els: $('.question__delete'),\n  //   message: 'Удалить вопросы и ответы'\n  // })\n\n}\n;// CONCATENATED MODULE: ./public/src/components/test-pagination/test-pagination.js\n\n\n\n // Показать первую кнопку\n\ncommon_$('[data-pagination]:first-child').addClass('nav-active'); // $('.test-edit__content').addClass('flex1')\n//// add question\n\ncommon_$('.pagination').on('click', function (e) {\n  if (e.target.classList.contains('add-question')) {\n    debugger;\n    show();\n    return;\n  } //// paginate\n\n\n  if (e.target.getAttribute('data-pagination')) {\n    paginate(e.target);\n    return;\n  }\n});\n\nfunction paginate(self) {\n  /// get clicked button Return if clicked is active\n  if (self.classList.contains('nav-active')) return;\n  let active_btn = common_$('.pagination .nav-active')[0]; //// change active button\n\n  active_btn.classList.remove('nav-active');\n  self.classList.add('nav-active'); //// hide the card\n\n  let id_to_hide = active_btn.dataset['pagination'];\n  common_$(`#question-${id_to_hide}`).removeClass('flex1'); //// show the card\n\n  let id_to_show = self.dataset['pagination'];\n  common_$(`#question-${id_to_show}`).addClass('flex1');\n} //// добавление вопроса\n\n\nasync function show(e) {\n  let testid = +common_$('.test-name').value();\n  let questCount = common_$(\"[data-pagination]\").count();\n  let res = await post('/question/show', {\n    testid,\n    questCount\n  });\n  res = JSON.parse(res);\n  let Block = res.block;\n  let blocks = common_$('.blocks')[0];\n  blocks.insertAdjacentHTML('afterBegin', Block);\n  let newBlock = common_$('.blocks .block:first-child')[0];\n  document.querySelector('.flex1').classList.remove('flex1');\n  common_$(newBlock).addClass('flex1');\n  let save_button = common_$(newBlock).find('.question__save');\n  common_$(save_button).on('click', question_question().save);\n}\n\nfunction showHidePaginBtn(pagItem) {\n  let activePaginBtn = $('.pagination .nav-active')[0];\n\n  if (activePaginBtn) {\n    activePaginBtn.classList.remove('nav-active');\n  }\n\n  $('.add-question')[0].insertAdjacentHTML('beforeBegin', pagItem);\n}\n\nfunction appendBlock() {\n  let block = $('.overlay').find('.block');\n  $('.blocks').append(block);\n  $(block).addClass('flex1');\n  $('.a-add').on('click', _answer.create);\n  $('.q-delete').on('click', _question().delete());\n  $('.a-del').on('click', _answer.delete());\n}\n\nfunction navInit() {\n  let nav_buttons = common_$('[data-pagination]');\n  if (!nav_buttons[0]) return false;\n  Array.from(nav_buttons).map(el => {\n    el.classList.remove('nav-active');\n  });\n  nav_buttons[0].classList.add('nav-active');\n}\n\n\n;// CONCATENATED MODULE: ./public/src/Test/do.js\n\n\n\n\nfunction testDo() {\n  //Скрыть все вопросы\n  common_$('.question').removeClass(\"flex1\"); //Показть первый вопрос\n\n  common_$('.question:first-child').addClass(\"flex1\"); // Нажать первуюкнопку navigation\n\n  navInit();\n  common_$('.test-do__content [type=\"checkbox\"]').on('click', function (e) {\n    let a = e.target.labels[0];\n    a.classList.toggle('pushed');\n  });\n  common_$('#prev').on('click', _test.prevQ);\n  common_$('#next').on('click', _test.nextQ); /////////////////////////////////////////////////////////////////////////////\n  ///////////  RESULTS  TEST  Закончить тест/////////////////////////////\n  /////////////////////////////////////////////////////////////////////////////\n  // если это результат теста, деактивирукм кнопку Закончить тест\n\n  let button = common_$('.test-do__finish-btn')[0];\n\n  if (button) {\n    if (window.location.pathname.match('^/test/result/.?')) {\n      button.classList.add('inactive');\n    }\n  }\n\n  common_$('.test-do__finish-btn').on('click', async function (e) {\n    let button = e.target;\n    if (button.classList.contains('inactive')) return false;\n    if (button.id !== 'btnn') return false;\n\n    if (button.text == \"ПРОЙТИ ТЕСТ ЗАНОВО\") {\n      location.reload();\n      return;\n    }\n\n    let corrAnswers = await post('/test/getCorrectAnswers', {});\n    corrAnswers = JSON.parse(corrAnswers);\n    let errorCnt = colorView(corrAnswers);\n    let data = objToServer(errorCnt);\n    let res = await post('/adminsc/testresult/cachePageSendEmail', data);\n\n    if (res) {\n      common_$(\"#btnn\")[0].href = location.href;\n      common_$(\"#btnn\")[0].text = \"ПРОЙТИ ТЕСТ ЗАНОВО\";\n    }\n  });\n\n  function objToServer(errorCnt) {\n    return {\n      token: document.querySelector('meta[name=\"token\"]').getAttribute('content'),\n      questionCnt: common_$('.question').length,\n      errorCnt: errorCnt,\n      html: `<!DOCTYPE ${document.doctype.name}>` + document.documentElement.outerHTML,\n      testid: common_$('[data-test-id]')[0].dataset.testId,\n      testname: common_$('.test-name')[0].innerText,\n      user: common_$('.user-menu__fio')[0].innerText\n    };\n  }\n\n  function colorView(correctAnswers) {\n    let q = common_$('.question');\n    Array.from(q).map((question, i) => {\n      let answers = question.querySelectorAll('.a'),\n          errors = [];\n      Array.from(answers).map(answer => {\n        let input = answer.getElementsByTagName('input')[0],\n            answerId = input.id.replace(\"answer-\", \"\"),\n            // id question\n        label = answer.getElementsByTagName('label')[0],\n            // Чтобы прикрепить зеленый значек к этому элементу\n        correctAnser = correctAnswers.indexOf(answerId) !== -1;\n\n        if (!checkCorrectAnswers(correctAnser, input, label)) {\n          errors.push(true);\n        }\n      });\n      let questId = +question.dataset['id'],\n          // id question\n      paginItem = common_$('.pagination [data-pagination=\"' + questId + '\"]')[0];\n\n      if (errors.length) {\n        common_$(paginItem).addClass('redShadow');\n      } else {\n        common_$(paginItem).addClass('greenShadow');\n      }\n    });\n    return common_$('.redShadow').length;\n  }\n\n  function checkCorrectAnswers(correctAnser, input, label) {\n    if (input.checked && correctAnser) {\n      // checkbox нажат. а в correct answer нету. в correct_answers есть, его всегда подсвечиваем зеленым\n      label.classList.add('done'); //green check зеленый значек\n\n      return true;\n    } else if (input.checked && !correctAnser) {\n      // checkbox нажат,и есть в correct answer. в correct_answers нет, кнопка не нажата\n      return false;\n    } else if (!input.checked && correctAnser) {\n      // кнопка не нажата, в correct_answers есть\n      label.classList.add('done'); //green check зеленый значек\n\n      label.classList.add('done'); // green check зеленый значек\n\n      return false;\n    } else if (!input.checked && !correctAnser) {\n      // кнопка не нажата, в correct_answers нет\n      return true;\n    }\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Admin/Settings/users.js\n\nfunction init() {}\n;// CONCATENATED MODULE: ./public/src/Admin/Settings/settings.js\n// import rights from '../Rights/rights'\n // import rights from \"./rights\";\n\nfunction settings() {\n  // rights()\n  init();\n}\n;// CONCATENATED MODULE: ./public/src/components/list/list.js\n\n\nfunction list() {\n  // debugger;\n  common_$('html').ready(function () {\n    const tables = common_$('.custom-list__wrapper');\n\n    if (tables) {\n      [].forEach.call(tables, function (table) {\n        const contenteditable = common_$('[contenteditable]');\n        const headers = table.querySelectorAll('.head');\n        const sortables = table.querySelectorAll('[data-sort]');\n        const inputs = common_$(table).findAll('.head input');\n        const ids = common_$(table)[0].querySelectorAll('.id:not(.head');\n        const modelName = table.dataset['model'];\n        const rows = [];\n        common_$(table).on('click', handleClick.bind(this));\n        common_$(table).on('keyup', handleKeyUp.bind(this)); /// DEBOUNCE\n\n        const debounce = function (fn) {\n          let time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 700;\n          let timeout;\n          return function () {\n            const functionCall = () => fn.apply(this, arguments);\n\n            clearTimeout(timeout);\n            timeout = setTimeout(functionCall, time);\n          };\n        };\n\n        let debouncedInput = debounce(handleInput);\n\n        function handleKeyUp(_ref) {\n          let {\n            target\n          } = _ref;\n\n          // contenteditable\n          if (target.hasAttribute('contenteditable')) {\n            debouncedInput(table, contenteditable, target); /// search\n          } else if (target.closest('.head')) {\n            let header = target.closest('.head');\n            let index = [].findIndex.call(headers, (el, i, inputs) => {\n              return el === header;\n            });\n            search(index, target);\n          }\n        }\n\n        function handleClick(_ref2) {\n          let {\n            target\n          } = _ref2;\n\n          /// create\n          if (target.className === 'add-model') {\n            modelCreate(modelName); /// delete\n          } else if (target.className === '.del:not(.head)' || target.closest('.del:not(.head)')) {\n            modelDel(target.closest('.del:not(.head)')); /// edit\n          } else if (target.className === '.edit:not(.head)' || target.closest('.edit:not(.head)')) {\n            let id = target.closest('.edit:not(.head)').dataset['id'];\n            window.location = `/adminsc/${modelName}/edit/${id}`; /// sort\n          } else if (target.classList.contains('head')) {\n            let header = target.closest('.head');\n            let index = [].findIndex.call(headers, (el, i, inputs) => {\n              return el === header;\n            });\n            sortColumn(index);\n          }\n        } // DELETE\n\n\n        async function modelDel(el) {\n          // debugger\n          let id = el.dataset['id'];\n          let res = await post(`/adminsc/${modelName}/delete`, {\n            id\n          });\n          res = JSON.parse(res);\n\n          if (res.msg === 'ok') {\n            delView(id);\n            popup.show(`id : ${id} удалено`);\n          }\n        }\n\n        function delView(id) {\n          let arr = common_$(`[data-id='${id}']`);\n          [].forEach.call(arr, function (el) {\n            el.remove();\n          });\n        } // CREATE\n\n\n        async function modelCreate(modelName, e) {\n          let res = await post(`/adminsc/${modelName}/create`, {});\n          res = JSON.parse(res);\n\n          if (res.id) {\n            newRow(res.id - 1);\n          }\n        }\n\n        function newRow(id) {\n          let Row = [...rows[0]];\n          [].forEach.call(Row, function (el) {\n            let newEl = el.cloneNode(true);\n            let tableContent = common_$(table).find('.custom-list');\n            tableContent.appendChild(newEl);\n\n            if (['id'].includes(newEl.className)) {\n              newEl.innerText = id;\n            } else if (!['del', 'edit', 'save'].includes(newEl.className)) {\n              newEl.innerText = '';\n            }\n\n            newEl.dataset['id'] = id;\n          });\n        } /// SEARCH\n\n\n        function showAllRows() {\n          [].forEach.call(rows, row => {\n            [].forEach.call(row, el => {\n              el.style.display = 'flex';\n            });\n          });\n        }\n\n        function search(index, input) {\n          showAllRows();\n          const value = input.value;\n          [].forEach.call(inputs, inp => {\n            if (inp !== input) inp.value = '';\n          });\n          [].forEach.call(rows, function (row) {\n            const str = row[index].innerText;\n            const regexp = new RegExp(`${value}`, 'gi');\n\n            if (!str.match(regexp)) {\n              [].forEach.call(row, el => {\n                el.style.display = 'none';\n              });\n            }\n          });\n        }\n\n        ; // SORT\n\n        function sortColumn(index) {\n          // Получить текущее направление\n          const direction = directions[index] || 'asc'; // Фактор по направлению\n\n          const multiplier = direction === 'asc' ? 1 : -1;\n          const newRows = Array.from(rows);\n          newRows.sort(function (rowA, rowB) {\n            const cellA = rowA[index].innerHTML;\n            const cellB = rowB[index].innerHTML;\n            const a = transform(index, cellA);\n            const b = transform(index, cellB);\n\n            switch (true) {\n              case a > b:\n                return 1 * multiplier;\n\n              case a < b:\n                return -1 * multiplier;\n\n              case a === b:\n                return 0;\n            }\n          }); // Удалить старые строки\n\n          [].forEach.call(rows, function (nodeList) {\n            [].forEach.call(nodeList, el => {\n              el.remove();\n            });\n          }); // Поменять направление\n\n          directions[index] = direction === 'asc' ? 'desc' : 'asc'; // Добавить новую строку\n\n          newRows.forEach(function (newRow) {\n            newRow = Array.from(newRow);\n            newRow.reverse();\n            [].forEach.call(newRow, el => {\n              headers[headers.length - 1].after(el);\n            });\n          });\n        }\n\n        ; /// get table rows array\n\n        for (let i = 0; i < ids.length; i++) {\n          let id = ids[i].dataset.id;\n          let row = common_$(table)[0].querySelectorAll(`[data-id='${id}']`);\n          rows.push(row);\n        } // Направление сортировки\n\n\n        const directions = Array.from(sortables).map(function (sortable) {\n          return '';\n        }); // Преобразовать содержимое данной ячейки в заданном столбце\n\n        function transform(index, content) {\n          // Получить тип данных столбца\n          const type = sortables[index].getAttribute('data-type');\n\n          switch (type) {\n            case 'number':\n              return parseFloat(content);\n\n            case 'string':\n            default:\n              return content;\n          }\n        }\n\n        ; /// INPUT\n\n        function handleInput(table, contenteditable, target) {\n          if (!target.hasAttribute('contenteditable')) return false;\n          let model = makeServerModel(target, modelName);\n          save(model);\n        }\n\n        async function save(model) {\n          let url = `/adminsc/${model.modelName}/update`;\n          let res = await post(url, model.model);\n          res = JSON.parse(res);\n\n          if (res.msg === 'ok') {\n            popup.show('Сохранено!');\n          }\n        }\n\n        function makeServerModel(el, modelName) {\n          let field = el.dataset['field'];\n          return {\n            model: {\n              token: common_$(),\n              id: el.dataset.id,\n              [field]: el.innerText\n            },\n            modelName\n          };\n        }\n      });\n    }\n  });\n}\n;// CONCATENATED MODULE: ./public/src/Admin/Rights/rights.js\n\n\n // import contenteditable from '../../components/contenteditable'\n\nfunction rights() {\n  // debugger\n  // contenteditable()\n  common_$('.rights-table').on('click', handle);\n\n  function handle(_ref) {\n    let {\n      target\n    } = _ref;\n    if (target.closest('.del')) del(target.closest('.del'));\n    if (target.closest('.save')) save(target.closest('.save'));\n\n    function model(el) {\n      let dataId = el.dataset.id ?? 'new';\n      let fields = common_$(`[data-id='${dataId}']`);\n      let model = {};\n      model.toServ = {};\n      model.empty = {};\n      fields.map(f => {\n        if (f.classList.contains('id')) {\n          model.id = f;\n          model.toServ.id = f.dataset.id;\n        } else if (f.classList.contains('name')) {\n          model.name = f;\n          model.toServ.name = f.innerText.trim();\n        } else if (f.classList.contains('description')) {\n          model.description = f;\n          model.toServ.description = f.innerText.trim();\n        } else if (f.classList.contains('save.svg')) {\n          model.save = f;\n        } else if (f.classList.contains('del')) {\n          model.del = f;\n        }\n      });\n      model.empty.del = model.id.previousElementSibling.cloneNode(true);\n      model.empty.save = model.id.previousElementSibling.previousElementSibling.cloneNode(true);\n      model.empty.description = model.id.previousElementSibling.previousElementSibling.previousElementSibling.cloneNode(true);\n      model.empty.name = model.id.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.cloneNode(true);\n      model.empty.id = model.id.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.cloneNode(true);\n      return model;\n    }\n\n    function del(el) {\n      let mod = model(el);\n      if (mod.toServ.id === 'new') return;\n\n      if (confirm(\"Удалить право?\")) {\n        delDom(mod);\n        delServer(mod);\n      }\n    }\n\n    async function delServer(model) {\n      let res = await post('/right/delete', {\n        id: model.toServ.id\n      });\n      res = await JSON.parse(res);\n\n      if (res.msg === 'ok') {\n        popup.show('Удалено');\n      }\n    }\n\n    function delDom(model) {\n      model.id.remove();\n      model.name.remove();\n      model.description.remove();\n      model.save.remove();\n      model.del.remove();\n    }\n\n    function save(el) {\n      let mod = model(el);\n\n      if (mod.toServ.id !== 'new') {\n        update(mod.toServ);\n      } else {\n        if (!mod.toServ.name || !mod.toServ.description) return false;\n        create(mod);\n      }\n    }\n\n    async function update(toServ) {\n      let res = await post('/right/update', toServ);\n\n      if (await JSON.parse(res).updated) {\n        popup.show('Обновлено');\n      }\n    }\n\n    function clearModel(model) {\n      model.name.innerText = \"\";\n      model.description.innerText = \"\";\n    }\n\n    function createOnDom(model) {\n      let lastElement = common_$(\".id[data-id='new']\")[0];\n      lastElement.before(model.empty.id);\n      lastElement.before(model.empty.name);\n      lastElement.before(model.empty.description);\n      lastElement.before(model.empty.save);\n      lastElement.before(model.empty.del);\n    }\n\n    function assignNewValuesOnClone(model, id) {\n      model.empty.id.dataset.id = id;\n      model.empty.id.innerText = id;\n      model.empty.name.dataset.id = id;\n      model.empty.name.innerText = model.name.innerText.trim();\n      model.empty.description.dataset.id = id;\n      model.empty.description.innerText = model.description.innerText.trim();\n      model.empty.save.dataset.id = id;\n      model.empty.del.dataset.id = id;\n    }\n\n    async function create(model) {\n      let res = await post('/right/create', model.toServ);\n      res = await JSON.parse(res);\n\n      if (res.id) {\n        assignNewValuesOnClone(model, res.id - 1);\n        createOnDom(model);\n        clearModel(model);\n        popup.show('Сохранено');\n      }\n    }\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Admin/Planning/planning.js\n\n\nfunction planning() {\n  debugger;\n}\n;// CONCATENATED MODULE: ./public/src/Admin/user/user.js\n\n\nfunction user() {// list()\n  // $('#user-update-btn').on('click', save)\n  //\n  // async function save(e) {\n  //   let rights = $('input.right:checked')\n  //   rights = rights.map((r) => r.previousElementSibling.innerHTML)\n  //   rights = rights.join(',');\n  //   let sel = $('.tabs').find('#conf')\n  //   let conf = sel.options[sel.options.selectedIndex].value\n  //\n  //   function sex() {\n  //     const f = $('[name=\"sex\"]:checked')[0]\n  //     const s = $('[name=\"sex\"]')\n  //     for (let f of s) {\n  //       if (f.checked) {\n  //         return f.value\n  //       }\n  //     }\n  //     return 'm'\n  //   }\n  //   const model = {\n  //     id: $('.tabs').find('#id').innerText.trim(),\n  //     confirm: conf,\n  //     name: $('.tabs').find('#name').innerText,\n  //     surName: $('.tabs').find('#s-name').innerText,\n  //     email: $('.tabs').find('#email').innerText.trim(),\n  //     middleName: $('.tabs').find('#m-name').innerText,\n  //     phone: $('.tabs').find('#phone').innerText,\n  //     birthDate: $('.tabs').find('#bday').value,\n  //     hired: $('.tabs').find('#hired').value,\n  //     fired: $('.tabs').find('#fired').value,\n  //     rights: rights,\n  //     sex: sex(),\n  //   }\n  //\n  //   let res = await post('/user/update', model)\n  //\n  //   if(res === 'ok'){\n  //     popup.show('Сохранено')\n  //   }\n  // }\n}\n;// CONCATENATED MODULE: ./public/src/Admin/user/users.js\n\n\nfunction users() {\n  list();\n  common_$('#users div[data-id]').on('change', function () {\n    crudUser('UPDATE', common_$(this));\n  });\n\n  function crudUser(crud, target) {\n    var data = {\n      name: common_$(target).find('.name').val(),\n      sName: common_$(target).find('.s-name').val(),\n      mName: common_$(target).find('.m-name').val(),\n      bday: common_$(target).find('.bday').val(),\n      phone: common_$(target).find('.phone').val(),\n      conf: common_$(target).find('.confirm').val(),\n      email: common_$(target).find('.email').val(),\n      hired: common_$(target).find('.hired').val(),\n      fired: common_$(target).find('.fired').val(),\n      userId: common_$(target).data('id'),\n      table: 'users',\n      crud: crud\n    };\n    var param = JSON.stringify(data);\n  }\n\n  ;\n  common_$('.wrap').on('click', '.save.svg', function () {\n    var self = common_$(this)[0];\n\n    if (self.classList.contains('new')) {\n      crudUser('INSERT', common_$(this));\n    } else {\n      crudUser('UPDATE', common_$(this));\n    }\n  });\n  common_$('.wrap').on('click', '.btnadd-user', function () {\n    var data = {\n      action: 'addUser'\n    };\n    post('/adminsc/users', data).then(function (str) {\n      common_$('tbody').append(str);\n    });\n  });\n\n  async function post(url, data) {\n    //      debugger;\n    return new Promise(function (resolve, reject) {\n      var req = new XMLHttpRequest();\n      req.open('POST', url);\n      req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n      req.setRequestHeader('Content-Type', 'application/json');\n      req.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n      req.send('param=' + JSON.stringify(data));\n\n      req.onerror = function () {\n        reject(Error(\"Network Error\"));\n      };\n\n      req.onload = function () {\n        resolve(req.response);\n      };\n    });\n  }\n}\n;// CONCATENATED MODULE: ./public/src/components/multiselect/multiselect.js\n\n\nfunction multiselect() {\n  let PHPmultiselect = common_$('.multiselect');\n\n  if (PHPmultiselect) {\n    [].forEach.call(PHPmultiselect, function (select) {\n      select.addEventListener('click', handleClick, false);\n      select.addEventListener('blur', handleBlur, false);\n\n      function handleBlur(_ref) {\n        let {\n          target\n        } = _ref;\n        let show = common_$(this).find('.show');\n\n        if (show) {\n          show.classList.remove('show');\n        }\n      }\n\n      function handleClick(_ref2) {\n        let {\n          target\n        } = _ref2;\n\n        // открыть выбор элементов\n        if (target.closest('.wrap') && target.tagName.toLowerCase() === 'svg') {\n          let multiselect = target.closest('.multiselect');\n          let ul = multiselect.querySelector('ul');\n          ul.classList.toggle('show'); // нажатие по крестику чипа\n        } else if (['del'].includes(target.className)) {\n          let id = target.closest('.chip').dataset.id;\n          toggleBackground(id);\n          let chip = target.closest('.chip');\n          chip.remove(); // выбор элемента, проверка существования чипа и его добавление\n        } else if (target.tagName.toLowerCase() === 'label') {\n          let id = target.dataset.id;\n          let m = target.closest('.multiselect');\n          let chips = m.querySelectorAll('.chip');\n          let exist = [].some.call(chips, chip => {\n            return chip.dataset.id === id;\n          });\n          let wrap = common_$(m).find('.chip-wrap');\n\n          if (!exist) {\n            target.classList.toggle('selected');\n            let chip = createChip(id);\n            wrap.append(chip);\n          } else {\n            target.classList.toggle('selected');\n            wrap.querySelector(`[data-id='${id}']`).remove();\n          }\n        }\n\n        function toggleBackground(id) {\n          let multi = target.closest('.multiselect');\n          common_$(multi).find(`label[data-id='${id}']`).classList.remove('selected');\n        }\n\n        function createChip(id) {\n          let chip = document.createElement('div');\n          chip.classList.add('chip');\n          chip.innerText = target.innerText;\n          chip.dataset['id'] = id;\n          let del = document.createElement('div');\n          del.classList.add('del');\n          del.innerText = 'X';\n          chip.append(del);\n          return chip;\n        }\n      }\n    });\n  }\n}\n;// CONCATENATED MODULE: ./public/src/Admin/admin.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nadmin_navigate(window.location.pathname); // debugger\n\ncatalogItem();\nlist();\nmultiselect(); // debugger\n\ntestEdit();\n\nfunction admin_navigate(str) {\n  // debugger\n  switch (true) {\n    case /\\/adminsc\\/settings/.test(str):\n    case /\\/adminsc\\/right\\/list/.test(str):\n    case /\\/adminsc\\/post\\/list/.test(str):\n    case /\\/adminsc\\/todo\\/list/.test(str):\n      rights();\n      common_$(\"[href='/adminsc/settings']\").addClass('current');\n      break;\n    // case /\\/adminsc\\/[a-zA-Z0-9]+\\/edit/.test(str):\n    //\n    //   list()\n\n    case /\\/adminsc\\/testresult\\/results/.test(str):\n      // debugger\n      testResults();\n      common_$(\"[href='/adminsc/test/results']\").addClass('current');\n      break;\n\n    case /\\/adminsc\\/user/.test(str):\n      user();\n      break;\n\n    case /\\/adminsc\\/user\\/list/.test(str):\n      users();\n      break;\n\n    case /\\/adminsc\\/crm/.test(str):\n      common_$(\"[href='/adminsc/crm']\").addClass('current');\n      break;\n\n    case /\\/adminsc\\/catalog/.test(str):\n      common_$(\"[href='/adminsc/catalog']\").addClass('current');\n      break;\n\n    case /\\/adminsc\\/planning/.test(str):\n      planning();\n      common_$(\"[href='/adminsc/planning']\").addClass('current');\n      break;\n    // case /\\/adminsc\\/test\\/update/.test(str):\n    // case /\\/adminsc\\/test\\/show/.test(str):\n    //   testUpdate()\n    //   break;\n\n    case /\\/adminsc\\/test\\/pathshow/.test(str):\n    case /\\/adminsc\\/test\\/edit/.test(str):\n      // debugger\n      // testEdit()\n      common_$(\"[href='/adminsc/test/edit']\").addClass('current');\n      break;\n\n    case /\\/test/.test(str) || /\\/test\\/result/.test(str):\n      testDo();\n      common_$(\"[href='/test/do']\").addClass('current');\n      break;\n\n    case /\\/adminsc\\/Sitemap/.test(str):\n      settings();\n      common_$(\"[href='/adminsc/settings']\").addClass('current');\n      break;\n\n    default:\n      common_$(\"[href='/adminsc']\").addClass('current');\n      break;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7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OztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCx3Q0FBd0MscURBQXFEOzs7QUFHN0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxjQUFjO0FBQzFCOzs7QUFHQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFOztBQUVBLGdCQUFnQjs7QUFFaEIsc0NBQXNDLFlBQVk7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7OztBQUcxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0Isa0ZBQWtGOztBQUVsRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDOzs7QUFHaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7OztBQUdWLDZDQUE2Qzs7O0FBRzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHOzs7QUFHWjtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sR0FBRzs7QUFFVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ04sR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlNQUFpTTs7QUFFak07QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsK0RBQStEOztBQUUvRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxNQUFNOzs7QUFHTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBLGlFQUFpRTs7O0FBR2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTs7O0FBR1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZOzs7QUFHWjtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw0Q0FBNEM7O0FBRTVDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0NBQXdDOzs7QUFHeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7OztBQUdoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHOzs7QUFHaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHOzs7QUFHZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QixZQUFZLDBCQUEwQjtBQUN0Qzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLFlBQVksNEJBQTRCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9DQUFvQztBQUNoRDs7O0FBR0E7QUFDQSx5RUFBeUUsYUFBYTtBQUN0RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjs7QUFFQSx1RUFBdUU7QUFDdkU7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsYUFBYTtBQUN4Qjs7O0FBR0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQ7O0FBRXZEOztBQUVBO0FBQ0EsMkVBQTJFOztBQUUzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUosa0NBQWtDO0FBQ2xDLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixrREFBRTtBQUMxQixzQkFBc0Isa0RBQUU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsOEJBQThCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7O0FBRVY7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FB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LElBQXhCLENBQTZCK1gsR0FBN0IsQ0FBTDtBQUNFO0FBQ0E7QUFDQW5YLE1BQUFBLFFBQUMsQ0FBQyw2QkFBRCxDQUFELENBQWlDNE4sUUFBakMsQ0FBMEMsU0FBMUM7QUFDQTs7QUFFRixTQUFLLFNBQVN4TyxJQUFULENBQWMrWCxHQUFkLEtBQXNCLGlCQUFpQi9YLElBQWpCLENBQXNCK1gsR0FBdEIsQ0FBM0I7QUFDRWpFLE1BQUFBLE1BQU07QUFDTmxULE1BQUFBLFFBQUMsQ0FBQyxtQkFBRCxDQUFELENBQXVCNE4sUUFBdkIsQ0FBZ0MsU0FBaEM7QUFDQTs7QUFFRixTQUFLLHFCQUFxQnhPLElBQXJCLENBQTBCK1gsR0FBMUIsQ0FBTDtBQUNFckMsTUFBQUEsUUFBUTtBQUNSOVUsTUFBQUEsUUFBQyxDQUFDLDRCQUFELENBQUQsQ0FBZ0M0TixRQUFoQyxDQUF5QyxTQUF6QztBQUNBOztBQUVGO0FBQ0U1TixNQUFBQSxRQUFDLENBQUMsbUJBQUQsQ0FBRCxDQUF1QjROLFFBQXZCLENBQWdDLFNBQWhDO0FBQ0E7QUFqRUo7QUFtRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL2NvbW1vbi5qcz81OTIxIiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvY29tcG9uZW50cy9hY2NvcmRpb24vYWNjb3JkaW9uLmpzPzI1YjUiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9BZG1pbi9tb2RlbC9jYWNoZS5qcz8xZTE3Iiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvY29tcG9uZW50cy9jYXRhbG9nLWl0ZW0vY2F0YWxvZy1pdGVtLmpzPzk2MzEiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9UZXN0L21vZGVsL190ZXN0UmVzdWx0LmpzPzE2NjgiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9UZXN0L3Rlc3RfcmVzdWx0cy90ZXN0X3Jlc3VsdHMuanM/NTM0YSIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL2NvbXBvbmVudHMvdG9vbHRpcC90b29sdGlwLmpzP2EwMTgiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9UZXN0L21vZGVsL3Rlc3QuanM/OWE2YSIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL1Rlc3QvdGVzdC11cGRhdGUuanM/NmZmZCIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL1Rlc3QvbW9kZWwvYW5zd2VyLmpzPzk5YWQiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9UZXN0L21vZGVsL3F1ZXN0aW9uLmpzPzIzZDkiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3NvcnRhYmxlanMvbW9kdWxhci9zb3J0YWJsZS5lc20uanM/YWE0NyIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL2NvbXBvbmVudHMvc29ydGFibGUuanM/ZGNmNSIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL2NvbXBvbmVudHMvc2VsZWN0L1dEU1NlbGVjdC5qcz9jNDBkIiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvVGVzdC9hY2NvcmRpb24tc2hvdy5qcz80MDFlIiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvVGVzdC90ZXN0RWRpdEFjdGlvbnMuanM/NjlmMCIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL1Rlc3QvdGVzdC1lZGl0LmpzP2FkNWEiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9jb21wb25lbnRzL3Rlc3QtcGFnaW5hdGlvbi90ZXN0LXBhZ2luYXRpb24uanM/NGFlMiIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL1Rlc3QvZG8uanM/NGMzNSIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL0FkbWluL1NldHRpbmdzL3VzZXJzLmpzPzY5ZmYiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9BZG1pbi9TZXR0aW5ncy9zZXR0aW5ncy5qcz83OWU1Iiwid2VicGFjazovL215LXdlYnBhY2stcHJvamVjdC8uL3B1YmxpYy9zcmMvY29tcG9uZW50cy9saXN0L2xpc3QuanM/ZjAyMyIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL0FkbWluL1JpZ2h0cy9yaWdodHMuanM/NmVlMyIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL0FkbWluL1BsYW5uaW5nL3BsYW5uaW5nLmpzP2JlNmYiLCJ3ZWJwYWNrOi8vbXktd2VicGFjay1wcm9qZWN0Ly4vcHVibGljL3NyYy9BZG1pbi91c2VyL3VzZXIuanM/MGQxYSIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL0FkbWluL3VzZXIvdXNlcnMuanM/NTJkNSIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL2NvbXBvbmVudHMvbXVsdGlzZWxlY3QvbXVsdGlzZWxlY3QuanM/NWE1MCIsIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9wdWJsaWMvc3JjL0FkbWluL2FkbWluLmpzPzI1YzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICcuL2NvbW1vbi5zY3NzJ1xyXG5cclxuZnVuY3Rpb24gZHJvcERvd24oZWxlbWVudElkKSB7XHJcbiAgdmFyIGRyb3Bkb3duID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudElkKTtcclxuICB0cnkge1xyXG4gICAgc2hvd0Ryb3Bkb3duKGRyb3Bkb3duKTtcclxuICB9IGNhdGNoIChlKSB7XHJcblxyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBzaG93RHJvcGRvd24oZWxlbWVudCkge1xyXG4gIHZhciBldmVudDtcclxuICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xyXG4gIGV2ZW50LmluaXRNb3VzZUV2ZW50KCdtb3VzZWRvd24nLCB0cnVlLCB0cnVlLCB3aW5kb3cpO1xyXG4gIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbn07XHJcblxyXG5cclxubGV0IHZhbGlkYXRlID0ge1xyXG4gIHNvcnQ6ICgpID0+IHtcclxuICAgIGxldCBlcnJvciA9IHRoaXMubmV4dEVsZW1lbnRTaWJsaW5nXHJcbiAgICBsZXQgYXIgPSB0aGlzLnZhbHVlLm1hdGNoKC9cXEQrLylcclxuICAgIGlmIChhcikge1xyXG4gICAgICBlcnJvci5pbm5lclRleHQgPSAn0KLQvtC70YzQutC+INGG0LjRhNGA0YsnXHJcbiAgICAgIGVycm9yLnN0eWxlLm9wYWNpdHkgPSAnMSdcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChlcnJvci5zdHlsZS5vcGFjaXR5ID09PSBcIjFcIikge1xyXG4gICAgICAgIGVycm9yLnN0eWxlLm9wYWNpdHkgPSAnMCdcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgZW1haWw6IChlbWFpbCkgPT4ge1xyXG4gICAgaWYgKCFlbWFpbCkgcmV0dXJuIGZhbHNlXHJcbiAgICBsZXQgcmUgPSAvXigoW148PigpW1xcXVxcXFwuLDs6XFxzQFwiXSsoXFwuW148PigpW1xcXVxcXFwuLDs6XFxzQFwiXSspKil8KFwiLitcIikpQCgoXFxbWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcXSl8KChbYS16QS1aXFwtMC05XStcXC4pK1thLXpBLVpdezIsfSkpJC87XHJcbiAgICByZXR1cm4gcmUudGVzdChTdHJpbmcoZW1haWwpLnRvTG93ZXJDYXNlKCkpO1xyXG4gIH0sXHJcbiAgcGFzc3dvcmQ6IChwYXNzd29yZCkgPT4ge1xyXG4gICAgaWYgKCFwYXNzd29yZCkgcmV0dXJuIGZhbHNlXHJcbiAgICBsZXQgcmUgPSAvXlthLXpBLVpcXC0wLTldezYsMjB9JC9cclxuICAgIHJldHVybiByZS50ZXN0KHBhc3N3b3JkKVxyXG4gIH1cclxufVxyXG5cclxuXHJcbi8vIGZ1bmN0aW9uIHVwKCkge1xyXG4vLyAgICB2YXIgdG9wID0gTWF0aC5tYXgoZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApO1xyXG4vLyAgICBpZiAodG9wID4gMCkge1xyXG4vLyAgICAgICB3aW5kb3cuc2Nyb2xsQnkoMCwgLTEwMCk7XHJcbi8vICAgICAgIHZhciB0ID0gc2V0VGltZW91dCgndXAoKScsIDIwKTtcclxuLy8gICAgfVxyXG4vLyAgICBlbHNlXHJcbi8vICAgICAgIGNsZWFyVGltZW91dCh0KTtcclxuLy8gICAgcmV0dXJuIGZhbHNlO1xyXG4vLyB9XHJcblxyXG5sZXQgcG9wdXAgPSB7XHJcblxyXG4gIHNob3c6IGZ1bmN0aW9uICh0eHQsIGNhbGxiYWNrKSB7XHJcbiAgICBsZXQgY2xvc2UgPSB0aGlzLmVsKCdkaXYnLCAncG9wdXBfX2Nsb3NlJylcclxuICAgIGNsb3NlLmlubmVyVGV4dCA9ICdYJ1xyXG4gICAgbGV0IHBvcHVwX19pdGVtID0gdGhpcy5lbCgnZGl2JywgJ3BvcHVwX19pdGVtJylcclxuXHJcbiAgICBwb3B1cF9faXRlbS5pbm5lclRleHQgPSB0eHRcclxuICAgIHBvcHVwX19pdGVtLmFwcGVuZChjbG9zZSlcclxuICAgIGxldCBwb3B1cCA9ICQoJy5wb3B1cCcpWzBdXHJcbiAgICBpZiAoIXBvcHVwKSB7XHJcbiAgICAgIHBvcHVwID0gdGhpcy5lbCgnZGl2JywgJ3BvcHVwJylcclxuICAgIH1cclxuICAgIHBvcHVwLmFwcGVuZChwb3B1cF9faXRlbSlcclxuICAgIHBvcHVwLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5jbG9zZSwgdHJ1ZSlcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKHBvcHVwKVxyXG4gICAgbGV0IGhpZGVEZWxheSA9IDUwMDA7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgcG9wdXBfX2l0ZW0uY2xhc3NMaXN0LnJlbW92ZSgncG9wdXBfX2l0ZW0nKVxyXG4gICAgICBwb3B1cF9faXRlbS5jbGFzc0xpc3QuYWRkKCdwb3B1cC1oaWRlJylcclxuICAgIH0sIGhpZGVEZWxheSlcclxuICAgIGxldCByZW1vdmVEZWxheSA9IGhpZGVEZWxheSArIDk1MDtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBwb3B1cF9faXRlbS5yZW1vdmUoKVxyXG4gICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICBjYWxsYmFjaygpXHJcbiAgICAgIH1cclxuICAgIH0sIHJlbW92ZURlbGF5KVxyXG4gIH0sXHJcblxyXG4gIGNsb3NlOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgaWYgKGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygncG9wdXBfX2Nsb3NlJykpIHtcclxuICAgICAgbGV0IHBvcHVwID0gdGhpcy5jbG9zZXN0KCcucG9wdXAnKS5yZW1vdmUoKVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgZWw6IGZ1bmN0aW9uICh0YWdOYW1lLCBjbGFzc05hbWUpIHtcclxuICAgIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSlcclxuICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKVxyXG4gICAgcmV0dXJuIGVsXHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCB1bmlxID0gKGFycmF5KSA9PiBBcnJheS5mcm9tKG5ldyBTZXQoYXJyYXkpKTtcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdldChrZXkpIHtcclxuICBsZXQgcCA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7XHJcbiAgcCA9IHAubWF0Y2gobmV3IFJlZ0V4cChrZXkgKyAnPShbXiY9XSspJykpO1xyXG4gIHJldHVybiBwID8gcFsxXSA6IGZhbHNlO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBwb3N0KHVybCwgZGF0YSA9IHt9KSB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgIGRhdGEudG9rZW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9XCJ0b2tlblwiXScpLmdldEF0dHJpYnV0ZSgnY29udGVudCcpXHJcbiAgICBsZXQgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICByZXEub3BlbignUE9TVCcsIHVybCwgdHJ1ZSk7XHJcbiAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihcIlgtUmVxdWVzdGVkLVdpdGhcIiwgXCJYTUxIdHRwUmVxdWVzdFwiKTtcclxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRm9ybURhdGEpIHtcclxuICAgICAgcmVxLnNlbmQoZGF0YSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xyXG4gICAgICByZXEuc2VuZCgncGFyYW09JyArIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgcmVqZWN0KEVycm9yKFwiTmV0d29yayBFcnJvclwiICsgZSkpO1xyXG4gICAgfTtcclxuICAgIHJlcS5vbmxvYWQgPSBhc3luYyBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJlc29sdmUocmVxLnJlc3BvbnNlKTtcclxuICAgIH07XHJcbiAgfSk7XHJcbn1cclxuXHJcbmNsYXNzIEVsZW1lbnRDb2xsZWN0aW9uIGV4dGVuZHMgQXJyYXkge1xyXG5cclxuICAvLyBlbCA9IHRoaXNcclxuICAvLyBlbFR5cGUgPSBmdW5jdGlvbigpe3JldHVybiB7fS50b1N0cmluZy5jYWxsKHRoaXMpfVxyXG5cclxuICBvbihldmVudCwgY2JPclNlbGVjdG9yLCBjYikge1xyXG4gICAgaWYgKHR5cGVvZiBjYk9yU2VsZWN0b3IgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy5mb3JFYWNoKGUgPT4gZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYk9yU2VsZWN0b3IpKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5mb3JFYWNoKGVsZW0gPT4ge1xyXG4gICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZSA9PiB7XHJcbiAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IGNiT3JTZWxlY3RvcikgY2IoZSlcclxuICAgICAgICB9KVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpc1swXS5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJylcclxuICB9XHJcbiAgYXR0ciA9IGZ1bmN0aW9uIChhdHRyTmFtZSwgYXR0clZhbCkge1xyXG4gICAgaWYgKGF0dHJWYWwpIHtcclxuICAgICAgdGhpc1swXS5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJWYWwpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpc1swXS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpXHJcbiAgfVxyXG4gIHNlbGVjdGVkSW5kZXhWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLmxlbmd0aClcclxuICAgICAgcmV0dXJuIHRoaXNbMF0uc2VsZWN0ZWRPcHRpb25zWzBdLnZhbHVlXHJcbiAgfVxyXG4gIG9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5sZW5ndGgpIHJldHVybiB0aGlzWzBdLm9wdGlvbnNcclxuICB9XHJcbiAgY291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sZW5ndGhcclxuICB9XHJcbiAgdGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLmxlbmd0aCkgcmV0dXJuIHRoaXNbMF0uaW5uZXJUZXh0XHJcbiAgfVxyXG4gIGNoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5sZW5ndGgpIHJldHVybiB0aGlzWzBdLmNoZWNrZWRcclxuICB9XHJcbiAgZ2V0V2l0aFN0eWxlID0gZnVuY3Rpb24gKGF0dHIsIHZhbCkge1xyXG4gICAgbGV0IGFyciA9IFtdXHJcbiAgICB0aGlzLmZvckVhY2goKHMpID0+IHtcclxuICAgICAgaWYgKHMuc3R5bGVbYXR0cl0gPT09IHZhbCkge1xyXG4gICAgICAgIGFyci5wdXNoKHMpXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgICByZXR1cm4gYXJyXHJcbiAgfVxyXG4gIGFkZENsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xyXG4gICAgdGhpcy5mb3JFYWNoKChzKSA9PiB7XHJcbiAgICAgIHMuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpXHJcbiAgICB9KVxyXG4gIH1cclxuICByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcclxuICAgIHRoaXMuZm9yRWFjaCgocykgPT4ge1xyXG4gICAgICBzLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKVxyXG4gICAgfSlcclxuICB9XHJcbiAgaGFzQ2xhc3MgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XHJcbiAgICBpZiAodGhpcy5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSkgcmV0dXJuIHRydWVcclxuICB9XHJcbiAgYXBwZW5kID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICB0aGlzWzBdLmFwcGVuZENoaWxkKGVsKVxyXG4gIH1cclxuICBmaW5kID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIHRoaXNbMF0ucXVlcnlTZWxlY3RvcihpdGVtKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGV0IGZpbHRlcmVkID0gdGhpc1swXS5maWx0ZXIoKGVsKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGVsID09PSBpdGVtXHJcbiAgICAgIH0pXHJcbiAgICAgIHJldHVybiBmaWx0ZXJlZFswXVxyXG4gICAgfVxyXG4gIH1cclxuICBmaW5kQWxsID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIHRoaXNbMF0ucXVlcnlTZWxlY3RvckFsbChpdGVtKVxyXG4gICAgfVxyXG4gIH1cclxuICBjc3MgPSBmdW5jdGlvbiAoYXR0ciwgdmFsKSB7XHJcbiAgICBpZiAoIXZhbCkge1xyXG4gICAgICByZXR1cm4gdGhpc1swXS5zdHlsZVthdHRyXVxyXG4gICAgfVxyXG4gICAgdGhpcy5mb3JFYWNoKChzKSA9PiB7XHJcbiAgICAgIHMuc3R5bGVbYXR0cl0gPSB2YWxcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICByZWFkeShjYikge1xyXG4gICAgY29uc3QgaXNSZWFkeSA9IHRoaXMuc29tZShlID0+IHtcclxuICAgICAgcmV0dXJuIGUucmVhZHlTdGF0ZSAhPSBudWxsICYmIGUucmVhZHlTdGF0ZSAhPSAnbG9hZGluZydcclxuICAgIH0pXHJcbiAgICBpZiAoaXNSZWFkeSkge1xyXG4gICAgICBjYigpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgY2IpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uICQoc2VsZWN0b3IpIHtcclxuICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJyB8fCBzZWxlY3RvciBpbnN0YW5jZW9mIFN0cmluZykge1xyXG4gICAgcmV0dXJuIG5ldyBFbGVtZW50Q29sbGVjdGlvbiguLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIG5ldyBFbGVtZW50Q29sbGVjdGlvbihzZWxlY3RvcilcclxuICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBhZGRUb29sdGlwKGFyZ3MpIHtcclxuXHJcbiAgW10uZm9yRWFjaC5jYWxsKGFyZ3MsIChlbCkgPT4ge1xyXG4gICAgZWwub25tb3VzZWVudGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBsZXQgdGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgICAgdGlwLmNsYXNzTGlzdC5hZGQoJ3RpcCcpXHJcbiAgICAgIHRpcC5pbm5lclRleHQgPSBhcmdzLm1lc3NhZ2VcclxuXHJcbiAgICAgIGVsLmFwcGVuZCh0aXApXHJcbiAgICAgIGxldCByZW1vdmUgPSAoKSA9PiB0aXAucmVtb3ZlKClcclxuICAgICAgdGlwLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHJlbW92ZS5iaW5kKHRpcCksIHRydWUpXHJcbiAgICB9LmJpbmQoYXJncylcclxuXHJcbiAgICBlbC5vbm1vdXNlbGVhdmUgPSAoKSA9PiB7XHJcbiAgICAgIGxldCB0aXAgPSBlbC5xdWVyeVNlbGVjdG9yKCcudGlwJylcclxuICAgICAgdGlwLnJlbW92ZSgpXHJcbiAgICB9XHJcbiAgfSlcclxufVxyXG5cclxuXHJcbmV4cG9ydCB7XHJcbiAgZHJvcERvd24sXHJcbiAgYWRkVG9vbHRpcCxcclxuICBwb3B1cCxcclxuICBwb3N0LCBnZXQsIHVuaXEsXHJcbiAgdmFsaWRhdGUsICRcclxufVxyXG4iLCJpbXBvcnQgJy4vYWNjb3JkaW9uLnNjc3MnXHJcbmltcG9ydCB7JH0gZnJvbSAnLi4vLi4vY29tbW9uJ1xyXG5cclxuXHJcbiQoJy5hY2NvcmRpb24gbGFiZWwnKS5vbignY2xpY2snLCBoYW5kbGVUb2dnbGUpXHJcblxyXG53aW5kb3cub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4vLyBkZWJ1Z2dlclxyXG5sZXQgY2hlY2tib3hlcyA9ICQoJy5hZG1pbi1sYXlvdXRfX3NpZGViYXIuYWNjb3JkaW9uIGlucHV0W3R5cGU9Y2hlY2tib3hdJykuZWxcclxuICBpZiAoY2hlY2tib3hlcyl7XHJcbiAgICBbLi4uY2hlY2tib3hlc10uZmlsdGVyKGNoPT57XHJcbiAgICAgIGNoLmNoZWNrZWQgPSBmYWxzZVxyXG4gICAgfSlcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZVRvZ2dsZShlKSB7XHJcblxyXG4gIGxldCBjaGVja2JveCA9IGUudGFyZ2V0LnByZXZpb3VzRWxlbWVudFNpYmxpbmdcclxuICBsZXQgcGFyZW50ID0gY2hlY2tib3guY2xvc2VzdCgndWwnKVxyXG4gIGxldCB1bCA9ICQoY2hlY2tib3gucGFyZW50Tm9kZSkuZmluZCgndWwnKVxyXG5cclxuXHJcbiAgaWYgKGNoZWNrYm94LmNoZWNrZWQpIHtcclxuICAgIHNsaWRlVXAodWwsIDAsKVxyXG4gIH0gZWxzZSB7XHJcbiAgICBwYXJlbnQuc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCJcclxuICAgIHNsaWRlRG93bih1bClcclxuICAgIGxldCB1bEhlaWdodCA9IHVsLnNjcm9sbEhlaWdodFxyXG4gICAgaW5jcmVhc2VQYXJlbnQocGFyZW50LCB1bEhlaWdodClcclxuICAgIC8vIGRlYnVnZ2VyXHJcbiAgICBjbG9zZVNpYmxpbmdzKHBhcmVudClcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluY3JlYXNlUGFyZW50KHBhcmVudCwgdWxIZWlnaHQpIHtcclxuICBpZiAoIXBhcmVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2FjY29yZGlvbicpKSB7XHJcbiAgICBsZXQgcGFyZW50SGVpZ2h0ID0gcGFyc2VJbnQocGFyZW50LnN0eWxlLm1heEhlaWdodCkgKyB1bEhlaWdodFxyXG4gICAgcGFyZW50LnN0eWxlLm1heEhlaWdodCA9IHBhcmVudEhlaWdodCArIFwicHhcIjtcclxuICB9XHJcbn1cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gc2xpZGVEb3duKHVsLCBjYWxsYmFjaykge1xyXG4gIHVsLnN0eWxlLm1heEhlaWdodCA9IHVsLnNjcm9sbEhlaWdodCArIFwicHhcIjtcclxuICBpZiAoY2FsbGJhY2spIHtcclxuICAgIGNhbGxiYWNrKClcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsb3NlU2libGluZ3MocGFyZW50KSB7XHJcbiAgQXJyYXkuZnJvbShwYXJlbnQuY2hpbGRyZW4pLm1hcCgoZWwpID0+IHtcclxuICAgICAgbGV0IGVsQXJyID0gQXJyYXkuZnJvbShlbC5jaGlsZHJlbilcclxuICAgICAgZWxBcnIubWFwKChjaCkgPT4ge1xyXG4gICAgICAgIGlmIChjaC50eXBlICYmIGNoLnR5cGUgPT09ICdjaGVja2JveCcgJiYgY2guY2hlY2tlZCkge1xyXG4gICAgICAgICAgbGV0IHVsID0gJChjaC5wYXJlbnROb2RlKS5maW5kKCd1bCcpXHJcbiAgICAgICAgICBzbGlkZVVwKHVsLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNoLmNoZWNrZWQgPSBmYWxzZVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgKVxyXG59XHJcblxyXG5mdW5jdGlvbiBzbGlkZVVwKHVsLCBpbnRlcnZhbCwgY2FsbGJhY2spIHtcclxuICB1bC5zdHlsZS5tYXhIZWlnaHQgPSAwICsgXCJweFwiO1xyXG4gIGlmIChjYWxsYmFjaykge1xyXG4gICAgY2FsbGJhY2soKVxyXG4gIH1cclxufVxyXG5cclxuXHJcblxyXG5cclxuXHJcbiIsImltcG9ydCB7JCwgcG9wdXAsIHBvc3R9IGZyb20gXCIuLi8uLi9jb21tb25cIjtcclxuaW1wb3J0IFwiLi4vLi4vY29tcG9uZW50cy9wb3B1cC5zY3NzXCI7XHJcblxyXG5cclxubGV0IF9jYWNoZSA9IHtcclxuICAgIGNsZWFyQ2FjaGU6IGFzeW5jIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCgnL2FkbWluc2MvY2xlYXJDYWNoZScsIHt9KVxyXG4gICAgICAgIGlmIChyZXM9PT0n0KPRgdC/0LXRiNC90L4nKSB7XHJcbiAgICAgICAgICAgIHBvcHVwLnNob3cocmVzKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2FjaGUoKSB7XHJcbiAgICAkKCcuY2xlYXJDYWNoZScpLm9uKCdjbGljaycsIF9jYWNoZS5jbGVhckNhY2hlKVxyXG59IiwiaW1wb3J0ICcuL2NhdGFsb2ctaXRlbS5zY3NzJztcclxuaW1wb3J0IHskLCBwb3N0LCBwb3B1cH0gZnJvbSAnLi4vLi4vY29tbW9uJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNhdGFsb2dJdGVtKCkge1xyXG4gIC8vIGRlYnVnZ2VyO1xyXG5cclxufVxyXG4iLCJpbXBvcnQgeyQsIHBvc3QsIHBvcHVwfSBmcm9tIFwiLi4vLi4vY29tbW9uXCI7XHJcblxyXG5leHBvcnQgY29uc3QgX3Rlc3RSZXN1bHQgPSB7XHJcblxyXG5cclxuICBkZWxTZXJ2ZXI6IGFzeW5jIChpZCkgPT4ge1xyXG4gICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9hZG1pbnNjL3Rlc3RyZXN1bHQvZGVsZXRlJywge2lkfSlcclxuICAgIGlmIChyZXMpIHtcclxuICAgICAgcG9wdXAuc2hvdygn0KPQtNCw0LvQtdC90L4nKVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGRlbERvbTogKHt0YXJnZXR9KSA9PiB7XHJcbiAgICBsZXQgaWQgPSB0YXJnZXQuY2xvc2VzdCgnLmRlbCcpLmRhdGFzZXRbJ3JvdyddO1xyXG4gICAgW10ubWFwLmNhbGwoJChgW2RhdGEtcm93ID0gXCIke2lkfVwiXWApLCBmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgIGkucmVtb3ZlKClcclxuICAgICAgfVxyXG4gICAgKVxyXG4gICAgcmV0dXJuIGlkXHJcbiAgfSxcclxuXHJcbiAgZGVsZXRlOiAoZSkgPT4ge1xyXG4gICAgaWYgKGNvbmZpcm0oXCLQo9C00LDQu9C40YLRjCDRgNC10LfRg9C70YzRgtCw0YIg0YLQtdGB0YLQsD9cIikpIHtcclxuICAgICAgbGV0IGlkID0gX3Rlc3RSZXN1bHQuZGVsRG9tKGUpXHJcbiAgICAgIF90ZXN0UmVzdWx0LmRlbFNlcnZlcihpZClcclxuICAgIH1cclxuICB9LFxyXG5cclxufSIsImltcG9ydCB7JH0gZnJvbSAnLi4vLi4vY29tbW9uJ1xyXG5pbXBvcnQge190ZXN0UmVzdWx0fSBmcm9tICcuLi9tb2RlbC9fdGVzdFJlc3VsdCdcclxuaW1wb3J0ICcuL3Rlc3QtcmVzdWx0c19fdGFibGUuc2NzcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRlc3RSZXN1bHRzKCkge1xyXG4gICQoJy50ZXN0LXJlc3VsdHNfX3RhYmxlIC5kZWwnKS5vbignY2xpY2snLCBfdGVzdFJlc3VsdC5kZWxldGUpXHJcbn1cclxuXHJcbiIsImltcG9ydCAnLi90b29sdGlwLnNjc3MnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0b29sdGlwcygpIHtcclxuXHJcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIHNob3dUaXAsIHRydWUpXHJcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGhpZGVUaXAsIHRydWUpXHJcblxyXG5cclxuICBmdW5jdGlvbiBzaG93VGlwKHt0YXJnZXR9KSB7XHJcbi8vIGRlYnVnZ2VyXHJcbiAgICAvLyDQtdGB0LvQuCDRgyDQvdCw0YEg0LXRgdGC0Ywg0L/QvtC00YHQutCw0LfQutCwLi4uXHJcbiAgICBpZiAoIXRhcmdldC5kYXRhc2V0fHwhdGFyZ2V0LmRhdGFzZXQudG9vbHRpcCkgcmV0dXJuO1xyXG4gICAgLy8gaWYgKCEpIHJldHVybjtcclxuXHJcbiAgICBsZXQgdG9vbHRpcEh0bWwgPSB0YXJnZXQuZGF0YXNldC50b29sdGlwXHJcbiAgICAvLyAuLi7RgdC+0LfQtNCw0LTQuNC8INGN0LvQtdC80LXQvdGCINC00LvRjyDQv9C+0LTRgdC60LDQt9C60LhcclxuICAgIGxldCB0b29sdGlwRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgdG9vbHRpcEVsZW0uY2xhc3NOYW1lID0gJ3Rvb2x0aXAnO1xyXG4gICAgdG9vbHRpcEVsZW0uaW5uZXJIVE1MID0gdG9vbHRpcEh0bWw7XHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZCh0b29sdGlwRWxlbSk7XHJcblxyXG4gICAgLy8g0YHQv9C+0LfQuNGG0LjQvtC90LjRgNGD0LXQvCDQtdCz0L4g0YHQstC10YDRhdGDINC+0YIg0LDQvdC90L7RgtC40YDRg9C10LzQvtCz0L4g0Y3Qu9C10LzQtdC90YLQsCAodG9wLWNlbnRlcilcclxuICAgIGxldCBjb29yZHMgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG4gICAgbGV0IGxlZnQgPSBjb29yZHMubGVmdCArICh0YXJnZXQub2Zmc2V0V2lkdGggLSB0b29sdGlwRWxlbS5vZmZzZXRXaWR0aCkgLyAyO1xyXG4gICAgaWYgKGxlZnQgPCAwKSBsZWZ0ID0gMDsgLy8g0L3QtSDQt9Cw0LXQt9C20LDRgtGMINC30LAg0LvQtdCy0YvQuSDQutGA0LDQuSDQvtC60L3QsFxyXG5cclxuICAgIGxldCB0b3AgPSBjb29yZHMudG9wIC0gdG9vbHRpcEVsZW0ub2Zmc2V0SGVpZ2h0IC0gNTtcclxuICAgIGlmICh0b3AgPCAwKSB7IC8vINC10YHQu9C4INC/0L7QtNGB0LrQsNC30LrQsCDQvdC1INC/0L7QvNC10YnQsNC10YLRgdGPINGB0LLQtdGA0YXRgywg0YLQviDQvtGC0L7QsdGA0LDQttCw0YLRjCDQtdGRINGB0L3QuNC30YNcclxuICAgICAgdG9wID0gY29vcmRzLnRvcCArIHRhcmdldC5vZmZzZXRIZWlnaHQgKyA1O1xyXG4gICAgfVxyXG5cclxuICAgIHRvb2x0aXBFbGVtLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcclxuICAgIHRvb2x0aXBFbGVtLnN0eWxlLnRvcCA9IHRvcCArICdweCc7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gaGlkZVRpcCgpIHtcclxuICAgIGxldCB0b29sdGlwcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy50b29sdGlwJylcclxuICAgIGlmICh0b29sdGlwcykge1xyXG4gICAgICBbXS5mb3JFYWNoLmNhbGwodG9vbHRpcHMsICh0aXApID0+IHtcclxuICAgICAgICAgIHRpcC5yZW1vdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIClcclxuICAgIH1cclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7JCwgcG9wdXAsIHBvc3R9IGZyb20gJy4uLy4uL2NvbW1vbidcclxuXHJcbmV4cG9ydCBjb25zdCBfdGVzdCA9IHtcclxuXHJcbiAgbmV4dFE6ICgpID0+IHtcclxuICAgIGxldCBjdXJyZW50ID0gX3Rlc3QuY3VycmVudFEoKVxyXG4gICAgaWYgKGN1cnJlbnQuaWQgPiBjdXJyZW50Lm5hdkxlbmd0aCAtIDIpIHJldHVybiBmYWxzZVxyXG5cclxuICAgIGxldCBhaW1OYXZJZCA9IF90ZXN0LmFpbU5hdklkRnVuY3Rpb24oY3VycmVudC5pZCwgJ25leHQnKVxyXG4gICAgbGV0IGFpbVFFbCA9IF90ZXN0LmFpbVFFbEZ1bmN0aW9uKGN1cnJlbnQsICduZXh0JylcclxuXHJcbiAgICBfdGVzdC5wdXNoTmF2KGN1cnJlbnQuaWQsIGFpbU5hdklkKVxyXG4gICAgX3Rlc3QucHVzaFEoY3VycmVudC5RRWwsIGFpbVFFbClcclxuICB9LFxyXG5cclxuICBwcmV2UTogKCkgPT4ge1xyXG4gICAgbGV0IGN1cnJlbnQgPSBfdGVzdC5jdXJyZW50USgpXHJcbiAgICBpZiAoY3VycmVudC5pZCA8IDEpIHJldHVybiBmYWxzZVxyXG5cclxuICAgIGxldCBhaW1OYXZJZCA9IF90ZXN0LmFpbU5hdklkRnVuY3Rpb24oY3VycmVudC5pZCwgJ2JhY2snKVxyXG4gICAgbGV0IGFpbVFFbCA9IF90ZXN0LmFpbVFFbEZ1bmN0aW9uKGN1cnJlbnQsICdiYWNrJylcclxuXHJcbiAgICBfdGVzdC5wdXNoTmF2KGN1cnJlbnQuaWQsIGFpbU5hdklkKVxyXG4gICAgX3Rlc3QucHVzaFEoY3VycmVudC5RRWwsIGFpbVFFbClcclxuICB9LFxyXG5cclxuICBwdXNoTmF2OiAoY3VycmVudElkLCBhaW1OYXZJZCkgPT4ge1xyXG4gICAgbGV0IGN1cnJOYXZFbCA9ICQoJ1tkYXRhLXBhZ2luYXRpb25dJylbY3VycmVudElkXVxyXG4gICAgY3Vyck5hdkVsLmNsYXNzTGlzdC50b2dnbGUoJ25hdi1hY3RpdmUnKVxyXG5cclxuICAgIGxldCBOYXZFbCA9ICQoJ1tkYXRhLXBhZ2luYXRpb25dJylbYWltTmF2SWRdXHJcbiAgICBOYXZFbC5jbGFzc0xpc3QudG9nZ2xlKCduYXYtYWN0aXZlJylcclxuICB9LFxyXG5cclxuICBwdXNoUTogKGN1cnJlbnRFbCwgYWltUUVsKSA9PiB7XHJcbiAgICBjdXJyZW50RWwuY2xhc3NMaXN0LnRvZ2dsZSgnZmxleDEnKVxyXG4gICAgYWltUUVsLmNsYXNzTGlzdC50b2dnbGUoJ2ZsZXgxJylcclxuICB9LFxyXG5cclxuICBhaW1OYXZJZEZ1bmN0aW9uOiAoY3VycmVudElkLCBkaXJlY3Rpb24pID0+IHtcclxuICAgIGxldCBkaXIgPSBjdXJyZW50SWRcclxuICAgIHN3aXRjaCAodHJ1ZSkge1xyXG4gICAgICBjYXNlIGRpcmVjdGlvbiA9PT0gJ25leHQnOlxyXG4gICAgICAgIHJldHVybiBkaXIgKz0gMVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgZGlyZWN0aW9uID09PSAnYmFjayc6XHJcbiAgICAgICAgcmV0dXJuIGRpciAtPSAxXHJcbiAgICAgICAgYnJlYWtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBhaW1RRWxGdW5jdGlvbjogKGN1cnJlbnQsIGRpcmVjdGlvbikgPT4ge1xyXG4gICAgc3dpdGNoICh0cnVlKSB7XHJcbiAgICAgIGNhc2UgZGlyZWN0aW9uID09PSAnbmV4dCc6XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQuUU5leHRFbFxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgZGlyZWN0aW9uID09PSAnYmFjayc6XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQuUVByZXZjXHJcbiAgICAgICAgYnJlYWtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBjdXJyZW50UTogKCkgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaWQ6ICQoJy5uYXYtYWN0aXZlJylbMF0uaW5uZXJUZXh0IC0gMSxcclxuICAgICAgUUVsOiAkKCcucXVlc3Rpb24uZmxleDEnKVswXSxcclxuICAgICAgbmF2TGVuZ3RoOiAkKCdbZGF0YS1wYWdpbmF0aW9uXScpLmxlbmd0aCxcclxuICAgICAgUVByZXZjOiAkKCcucXVlc3Rpb24uZmxleDEnKVswXS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLFxyXG4gICAgICBRTmV4dEVsOiAkKCcucXVlc3Rpb24uZmxleDEnKVswXS5uZXh0RWxlbWVudFNpYmxpbmcsXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcblxyXG4gIHZpZXdNb2RlbDogKCkgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaWQ6ICt3aW5kb3cubG9jYXRpb24uaHJlZi5zcGxpdCgnLycpLnBvcCgpLFxyXG4gICAgICB0ZXN0X25hbWU6ICQoJyN0ZXN0X25hbWUnKS50ZXh0KCksXHJcbiAgICAgIGVuYWJsZTogJCgnI2VuYWJsZScpWzBdLFxyXG4gICAgICBwYXJlbnQ6ICQoJ3NlbGVjdCcpLnNlbGVjdGVkSW5kZXhWYWx1ZSgpLFxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGlkOiAoaWQpID0+IHtcclxuICAgIHJldHVybiBpZCA/PyAkKCcudGVzdC1uYW1lJylbMF0uZGF0YXNldC50ZXN0aWRcclxuICB9LFxyXG4gIGNoaWxkcmVuOiAoKSA9PiB7XHJcbiAgICBsZXQgY2hpbGRyZW5MZW5naHQgPSAkKCcuY2hpbGRyZW4nKS5sZW5ndGhcclxuICAgIGlmIChjaGlsZHJlbkxlbmdodClcclxuICAgICAgcmV0dXJuIGNoaWxkcmVuTGVuZ2h0XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9LFxyXG5cclxuICBwYXRoX2NyZWF0ZTogYXN5bmMgKCkgPT4ge1xyXG4gICAgbGV0IHRlc3RfcGF0aCA9IF90ZXN0LnNlcnZlck1vZGVsKClcclxuICAgIHRlc3RfcGF0aC5pZCA9IDBcclxuICAgIHRlc3RfcGF0aC5pc1Rlc3QgPSAwXHJcbiAgICBsZXQgdXJsID0gYC90ZXN0L2NyZWF0ZWBcclxuICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KHVybCwgdGVzdF9wYXRoKVxyXG4gICAgcmVzID0gYXdhaXQgSlNPTi5wYXJzZShyZXMpXHJcbiAgICBpZiAocmVzKSB7XHJcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYC9hZG1pbnNjL3Rlc3QvZWRpdC8ke3Jlcy5pZCAtIDF9YFxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIG5hbWU6ICgpID0+IHtcclxuICAgIHJldHVybiAkKCcudGVzdC1uYW1lJylbMF0uaW5uZXJUZXh0XHJcbiAgfSxcclxuXHJcbiAgY3JlYXRlOiBhc3luYyAoKSA9PiB7XHJcbiAgICBsZXQgdGVzdCA9IF90ZXN0LnNlcnZlck1vZGVsKClcclxuICAgIHRlc3QuaWQgPSAwXHJcbiAgICB0ZXN0LmlzVGVzdCA9IDFcclxuICAgIGxldCB1cmwgPSBgL3Rlc3QvdXBkYXRlT3JDcmVhdGVgXHJcbiAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCh1cmwsIHRlc3QpXHJcbiAgICByZXMgPSBhd2FpdCBKU09OLnBhcnNlKHJlcylcclxuICAgIGRlYnVnZ2VyXHJcbiAgICBpZiAocmVzKSB7XHJcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYC9hZG1pbnNjL3Rlc3QvZWRpdC8ke3Jlcy5pZH1gXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgc2VsZWN0ZWRWYWx1ZUN1c3RvbVNlbGVjdChjbGFzc05hbWUpIHtcclxuICAgIGxldCBzZWxlY3QgPSAkKGBbZGF0YS1maWVsZD0ke2NsYXNzTmFtZX1dYClbMF1cclxuICAgIGxldCBzZWxlY3RlZCA9IFsuLi5zZWxlY3Qub3B0aW9uc10uZmlsdGVyKChvcHQpPT5vcHQuc2VsZWN0ZWQpXHJcbiAgICBpZiAoc2VsZWN0ZWQpIHtcclxuICAgICAgcmV0dXJuICtzZWxlY3RlZFswXS52YWx1ZVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHNlcnZlck1vZGVsOiAoKSA9PiB7XHJcblxyXG4gICAgbGV0IG1vZGVsID0ge1xyXG4gICAgICBpZDogK3dpbmRvdy5sb2NhdGlvbi5ocmVmLnNwbGl0KCcvJykucG9wKCksXHJcbiAgICAgIHRlc3RfbmFtZTogJCgnI3Rlc3RfbmFtZScpWzBdLnZhbHVlLFxyXG4gICAgICBpc1Rlc3Q6ICskKCdbaXNUZXN0XScpWzBdLmdldEF0dHJpYnV0ZSgnaXNUZXN0JyksXHJcbiAgICAgIC8vIGVuYWJsZTogX3Rlc3Quc2VsZWN0ZWRWYWx1ZUN1c3RvbVNlbGVjdCgnZW5hYmxlJyksXHJcbiAgICAgIC8vIHBhcmVudDogX3Rlc3Quc2VsZWN0ZWRWYWx1ZUN1c3RvbVNlbGVjdCgncGFyZW50JyksXHJcbiAgICB9XHJcbiAgICAvLyBkZWJ1Z2dlclxyXG4gICAgbGV0IGZpZWxkcyA9ICQoJy5jdXN0b20tc2VsZWN0Jyk7XHJcbiAgICBbXS5mb3JFYWNoLmNhbGwoZmllbGRzLGZ1bmN0aW9uIChmaWVsZCl7XHJcbiAgICAgIG1vZGVsW2ZpZWxkLmRhdGFzZXRbJ2ZpZWxkJ11dPWZpZWxkLmRhdGFzZXRbJ2lkJ11cclxuICAgIH0pXHJcbiAgICByZXR1cm4gbW9kZWxcclxuICB9LFxyXG5cclxuICB1cGRhdGU6IGFzeW5jICgpID0+IHtcclxuICAgIGxldCBtb2RlbCA9IF90ZXN0LnNlcnZlck1vZGVsKClcclxuICAgIGxldCB1cmwgPSBgL2FkbWluc2MvdGVzdC91cGRhdGUvJHttb2RlbC5pZH1gXHJcbiAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCh1cmwsIG1vZGVsKVxyXG4gICAgcmVzID0gYXdhaXQgSlNPTi5wYXJzZShyZXMpXHJcbiAgICBpZiAocmVzKSB7XHJcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYC9hZG1pbnNjL3Rlc3QvZWRpdC8ke21vZGVsLmlkfWBcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBkZWxldGU6IGFzeW5jIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBpZiAoX3Rlc3QuY2hpbGRyZW4oKSkge1xyXG4gICAgICBwb3B1cC5zaG93KCfQodC90LDRh9Cw0LvQsCDRg9C00LDQu9C40YLQtSDQstGB0LUg0YLQtdGB0YLRiyDQuNC3INC/0LDQv9C60LgnKVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuXHJcbiAgICBsZXQgaWQgPSBfdGVzdC5pZCgpXHJcbiAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCgnL2FkbWluc2MvdGVzdC9kZWxldGUnLCB7aWR9KVxyXG4gICAgcmVzID0gYXdhaXQgSlNPTi5wYXJzZShyZXMpXHJcbiAgICBpZiAocmVzLm5vdEFkbWluKSB7XHJcbiAgICAgIHBvcHVwLnNob3coJ9CS0LjQtNC40LzQvtGB0YLRjCDRgtC10YHRgtCwINGB0LrRgNGL0YLQsC4g0KfRgtC+0LHRiyDRg9C00LDQu9C40YLRjCDQv9C+0LvQvdC+0YHRgtGM0Y4gLSDQvtCx0YDQsNGC0LjRgtC10YHRjCDQuiDQk9CUJylcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uID0gJy9hZG1pbnNjL3Rlc3QvZWRpdC80MDAnXHJcbiAgICAgIH0sIDQwMDApXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3aW5kb3cubG9jYXRpb24gPSAnL2FkbWluc2MvdGVzdC9lZGl0LzQwMCdcclxuICAgIH1cclxuXHJcbiAgfSxcclxuXHJcbn0iLCJpbXBvcnQgJy4vdGVzdC11cGRhdGUuc2NzcydcclxuaW1wb3J0IHskfSBmcm9tICcuLi9jb21tb24nXHJcbmltcG9ydCB7X3Rlc3R9IGZyb20gJy4vbW9kZWwvdGVzdCdcclxuaW1wb3J0IFdEU1NlbGVjdCBmcm9tIFwiLi4vY29tcG9uZW50cy9zZWxlY3QvV0RTU2VsZWN0XCJcclxuLy8gaW1wb3J0IGFjY29yZGlvblNob3cgZnJvbSBcIi4vYWNjb3JkaW9uLXNob3dcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRlc3RVcGRhdGUoKSB7XHJcbiAgLy8gYWNjb3JkaW9uU2hvdygpXHJcblxyXG4gIC8vIGxldCBwYXJlbnRTZWxlY3QgPSBuZXcgV0RTU2VsZWN0KHtcclxuICAvLyAgIGVsZW1lbnQ6ICQoXCJbZGF0YS1jdXN0b20tcGFyZW50XVwiKVswXSxcclxuICAvLyAgIHRpdGxlOiAn0JvQtdC20LjRgiDQsiDQv9Cw0L/QutC1JyxcclxuICAvLyAgIGNsYXNzOiAncGFyZW50J1xyXG4gIC8vIH0pXHJcblxyXG4gIC8vIGRlYnVnZ2VyXHJcbiAgLy8gbGV0IGVuYWJsZVNlbGVjdCA9IG5ldyBXRFNTZWxlY3Qoe1xyXG4gIC8vICAgdGl0bGU6ICfQn9C+0LrQsNC30YvQstCw0YLRjCDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y/QvCcsXHJcbiAgLy8gICBjbGFzczogJ2VuYWJsZScsXHJcbiAgLy8gICBmaWVsZDogJ2VuYWJsZScsXHJcbiAgLy8gfSlcclxuICAvL1xyXG4gIC8vIGxldCBwYXJlbnRzU2VsZWN0ID0gbmV3IFdEU1NlbGVjdCh7XHJcbiAgLy8gICB0aXRsZTogJ9Cb0LXQttC40YIg0LIg0L/QsNC/0LrQtScsXHJcbiAgLy8gICBjbGFzczogJ3BhcmVudCcsXHJcbiAgLy8gICBmaWVsZDogJ3BhcmVudCcsXHJcbiAgLy8gfSlcclxuXHJcbn1cclxuIiwiaW1wb3J0IHskLCBwb3B1cCwgcG9zdH0gZnJvbSAnLi4vLi4vY29tbW9uJ1xyXG5cclxuZXhwb3J0IGxldCBfYW5zd2VyID0ge1xyXG5cclxuICBlbDogKGFkZF9idXR0b24pID0+IHtcclxuICAgIGxldCBhbnN3ZXJzID0gYWRkX2J1dHRvbi5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hbnN3ZXInKVxyXG4gICAgbGV0IHByZXZfc29ydCA9IDBcclxuICAgIGlmIChhbnN3ZXJzLmxlbmd0aCkge1xyXG4gICAgICBwcmV2X3NvcnQgPSArJChhbnN3ZXJzW2Fuc3dlcnMubGVuZ3RoIC0gMV0pLmZpbmQoJy5hbnN3ZXJfX3NvcnQnKS5pbm5lclRleHRcclxuICAgIH1cclxuICAgIGxldCBlbCA9ICQoJy5hbnN3ZXJfX2NyZWF0ZScpLmZpbmQoJy5hbnN3ZXInKS5jbG9uZU5vZGUodHJ1ZSlcclxuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2Fuc3dlcicpXHJcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdhbnN3ZXJfX2NyZWF0ZScpXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBlbDogZWwsXHJcbiAgICAgIGlkOiAnbmV3JyxcclxuICAgICAgcV9pZDogK2FkZF9idXR0b24uY2xvc2VzdCgnLnF1ZXN0aW9uLWVkaXQnKS5pZCxcclxuICAgICAgcHJldmlvdXNfc29ydDogcHJldl9zb3J0LFxyXG4gICAgICBhbnN3ZXJDbnQ6IGFuc3dlcnMubGVuZ3RoLFxyXG4gICAgICBzb3J0OiAkKGVsKS5maW5kKCcuYW5zd2VyX19zb3J0JyksXHJcbiAgICAgIGNoZWNrZWQ6ICQoZWwpLmZpbmQoJ2lucHV0JyksXHJcbiAgICAgIHRleHQ6ICQoZWwpLmZpbmQoJy5hbnN3ZXJfX3RleHQnKSxcclxuICAgICAgZGVsZXRlOiAkKCQoZWwpLmZpbmQoJy5hbnN3ZXJfX2RlbGV0ZScpKS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2Fuc3dlci5kZWwodGhpcylcclxuICAgICAgfSlcclxuICAgIH1cclxuICB9LFxyXG4gIGdldE1vZGVsRm9yU2VydmVyKGVsKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBhbnN3ZXI6ICcnLFxyXG4gICAgICBwYXJlbnRfcXVlc3Rpb246IGVsLnFfaWQsXHJcbiAgICAgIGNvcnJlY3RfYW5zd2VyOiAwLFxyXG4gICAgICBwaWNhOiAnJ1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGFzeW5jIGNyZWF0ZShidXR0b24pIHtcclxuICAgIC8vIGRlYnVnZ2VyXHJcbiAgICBsZXQgYV9pZCA9IGF3YWl0IGNyZWF0ZU9uU2VydmVyKGJ1dHRvbilcclxuICAgIHNob3coYV9pZClcclxuXHJcbiAgICBhc3luYyBmdW5jdGlvbiBjcmVhdGVPblNlcnZlcihidXR0b24pIHtcclxuICAgICAgbGV0IG5ld0VsID0gX2Fuc3dlci5nZXRNb2RlbEZvclNlcnZlcihfYW5zd2VyLmVsKGJ1dHRvbikpXHJcblxyXG4gICAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCgnL2Fuc3dlci9jcmVhdGUnLCBuZXdFbClcclxuICAgICAgcmVzID0gSlNPTi5wYXJzZShyZXMpXHJcblxyXG4gICAgICByZXR1cm4gcmVzLmlkXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2hvdyhhX2lkKSB7XHJcbiAgICAgIGxldCBlbCA9IF9hbnN3ZXIuZWwoYnV0dG9uKVxyXG5cclxuICAgICAgZWwuY2hlY2tlZC5jaGVja2VkID0gZmFsc2VcclxuICAgICAgZWwuZWwuZGF0YXNldFsnYW5zd2VySWQnXSA9IGFfaWRcclxuICAgICAgZWwudGV4dC5pbm5lclRleHQgPSAnJ1xyXG4gICAgICBlbC5zb3J0LmlubmVyVGV4dCA9IGVsLmFuc3dlckNudCArIDFcclxuXHJcbiAgICAgIGVsLmVsLnN0eWxlLmRpc3BsYXkgPSAnZmxleCdcclxuICAgICAgYnV0dG9uLmJlZm9yZShlbC5lbClcclxuICAgICAgZWwuZWwuc3R5bGUub3BhY2l0eSA9IDFcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBhc3luYyBkZWwodGFyZ2V0KSB7XHJcbiAgICBsZXQgZGVsX2J1dHRvbiA9IHRhcmdldC5jbG9zZXN0KCcuYW5zd2VyX19kZWxldGUnKVxyXG4gICAgaWYgKCFkZWxfYnV0dG9uKSByZXR1cm4gZmFsc2VcclxuICAgIGlmIChjb25maXJtKFwi0KPQtNCw0LvQuNGC0Ywg0Y3RgtC+0YIg0L7RgtCy0LXRgj9cIikpIHtcclxuICAgICAgbGV0IHJlcyA9IGF3YWl0IGRlbGV0ZUZyb21TZXJ2ZXIoZGVsX2J1dHRvbilcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBmdW5jdGlvbiBkZWxldGVGcm9tU2VydmVyKGRlbF9idXR0b24pIHtcclxuXHJcbiAgICAgIGxldCBhX2lkID0gK2RlbF9idXR0b24uY2xvc2VzdCgnLmFuc3dlcicpLmRhdGFzZXRbJ2Fuc3dlcklkJ11cclxuICAgICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9hbnN3ZXIvZGVsZXRlJywge2FfaWR9KVxyXG4gICAgICByZXMgPSBKU09OLnBhcnNlKHJlcylcclxuICAgICAgaWYgKHJlcy5tc2cgPT09ICdvaycpIHtcclxuICAgICAgICBkZWxfYnV0dG9uLmNsb3Nlc3QoJy5hbnN3ZXInKS5yZW1vdmUoKVxyXG4gICAgICAgIHBvcHVwLnNob3coJ9Ce0YLQstC10YIg0YPQtNCw0LvQtdC9JylcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbn1cclxuIiwiaW1wb3J0IHskLCBwb3B1cCwgcG9zdCwgYWRkVG9vbHRpcH0gZnJvbSBcIi4uLy4uL2NvbW1vblwiXHJcbmltcG9ydCB7X2Fuc3dlcn0gZnJvbSBcIi4vYW5zd2VyXCI7XHJcblxyXG5leHBvcnQgbGV0IF9xdWVzdGlvbiA9IHtcclxuXHJcbiAgc29ydDogYXN5bmMgZnVuY3Rpb24gKHVwVG9RZXN0aW9uTnVtYmVyKSB7XHJcbiAgICBsZXQgcXVlc3Rpb25zID0gWy4uLl9xdWVzdGlvbi5xdWVzdGlvbnMoKV1cclxuICAgIGxldCBxdWVzdGlvbnNFbHMgPSBxdWVzdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChlbCwgaSkge1xyXG4gICAgICAgIGlmIChpICsgMSA8IHVwVG9RZXN0aW9uTnVtYmVyKSByZXR1cm4gZWxcclxuICAgICAgfVxyXG4gICAgKVxyXG4gICAgbGV0IHRvQ2hhbmdlID0gcXVlc3Rpb25zRWxzLm1hcCgoZWwpID0+IHtcclxuICAgICAgcmV0dXJuIGVsLmlkXHJcbiAgICB9KVxyXG4gICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9xdWVzdGlvbi9zb3J0Jywge3RvQ2hhbmdlfSlcclxuICAgIHJlcyA9IEpTT04ucGFyc2UocmVzKVxyXG4gICAgaWYgKHJlcy5tc2cpIHtcclxuICAgICAgcG9wdXAuc2hvdyhyZXMubXNnKVxyXG4gICAgfVxyXG4gICAgcXVlc3Rpb25zRWxzLm1hcCgoZWwsIGkpID0+IHtcclxuICAgICAgJChlbCkuZmluZCgnLnF1ZXN0aW9uX19zb3J0JykuaW5uZXJUZXh0ID0gaSArIDFcclxuXHJcbiAgICB9KVxyXG4gIH0sXHJcblxyXG5cclxuICBjaGFuZ2VQYXJlbnQ6IGFzeW5jIGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgIGRlYnVnZ2VyXHJcbiAgICBsZXQgb3B0ID0gdGFyZ2V0Lm9wdGlvbnNbdGFyZ2V0LnNlbGVjdGVkSW5kZXhdXHJcbiAgICBsZXQgaWQgPSB0YXJnZXQuY2xvc2VzdCgnLnF1ZXN0aW9uLWVkaXQnKS5pZFxyXG4gICAgbGV0IHRlc3RfaWQgPSBvcHQuZGF0YXNldFsncXVlc3Rpb25QYXJlbnRJZCddXHJcbiAgICBsZXQgdGVzdF9uYW1lID0gb3B0LnZhbHVlXHJcbiAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCgnL2FkbWluc2MvcXVlc3Rpb24vY2hhbmdlUGFyZW50Jywge2lkLCB0ZXN0X2lkfSlcclxuICAgIHJlcyA9IEpTT04ucGFyc2UocmVzKVxyXG4gICAgaWYgKHJlcy5tc2cgIT09ICdvaycpIHRocm93IChlKTtcclxuICAgIGxldCBxdWVzdGlvbiA9IHRhcmdldC5jbG9zZXN0KCcucXVlc3Rpb24tZWRpdCcpXHJcbiAgICBxdWVzdGlvbi5yZW1vdmUoKVxyXG4gICAgcG9wdXAuc2hvdygn0J/QtdGA0LXQvNC10YnQtdC9INCyICcgKyB0ZXN0X25hbWUpXHJcbiAgICAvLyBkZWJ1Z2dlclxyXG4gIH0sXHJcblxyXG5cclxuICBzaG93VGlwOiAoYWN0aW9uLCBldmVudCkgPT4ge1xyXG4gICAgbGV0IGVsID0gZXZlbnQudGFyZ2V0XHJcbiAgICBsZXQgdGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxyXG5cclxuICAgIGlmIChhY3Rpb24gPT09ICdzYXZlLnN2ZycpIHtcclxuICAgICAgYWRkVG9vbHRpcChlbCwgJ9GB0L7RhdGA0LDQvdC40YLRjCcpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgc2hvd0ZpcnN0OiAoKSA9PiB7XHJcbiAgICBsZXQgcXVlc3Rpb24gPSBfcXVlc3Rpb24uY2xvbmVFbXB0eU1vZGVsKClcclxuICAgIGlmICghcXVlc3Rpb24pIHJldHVyblxyXG5cclxuICAgIGxldCBtb2RlbCA9IF9xdWVzdGlvbi52aWV3TW9kZWwocXVlc3Rpb24pXHJcbiAgICBtb2RlbC5zb3J0LmlubmVyVGV4dCA9ICcxJ1xyXG4gICAgJChtb2RlbC5zYXZlKS5vbignY2xpY2snLCBfcXVlc3Rpb24uc2F2ZSlcclxuICAgICQobW9kZWwuZGVsKS5vbignY2xpY2snLCBfcXVlc3Rpb24uZGVsZXRlKVxyXG5cclxuICAgICQocXVlc3Rpb24pLmFkZENsYXNzKCdxdWVzdGlvbi1lZGl0JylcclxuICAgICQocXVlc3Rpb24pLnJlbW92ZUNsYXNzKCdxdWVzdGlvbl9fY3JlYXRlJylcclxuXHJcbiAgICBsZXQgcXVlc3Rpb25zID0gJCgnLnF1ZXN0aW9ucycpWzBdXHJcbiAgICBxdWVzdGlvbnMucHJlcGVuZChxdWVzdGlvbilcclxuICB9LFxyXG5cclxuICBjbG9uZUVtcHR5TW9kZWw6ICgpID0+IHtcclxuICAgIGxldCBxdWVzdGlvbiA9ICQoJy5xdWVzdGlvbnMgLnF1ZXN0aW9uX19jcmVhdGUgLnF1ZXN0aW9uLWVkaXQnKVswXVxyXG4gICAgaWYgKHF1ZXN0aW9uKSByZXR1cm4gcXVlc3Rpb24uY2xvbmVOb2RlKHRydWUpXHJcbiAgfSxcclxuXHJcbiAgc2hvd0Fuc3dlcnM6ICh0YXJnZXQpID0+IHtcclxuICAgIGxldCByb3cgPSB0YXJnZXQuY2xvc2VzdCgnLnF1ZXN0aW9uLWVkaXQnKVxyXG4gICAgbGV0IGFuc3dlcnMgPSAkKHJvdykuZmluZCgnLnF1ZXN0aW9uX19hbnN3ZXJzJylcclxuICAgIGFuc3dlcnMuY2xhc3NMaXN0LnRvZ2dsZSgnaGVpZ2h0JylcclxuICAgIGFuc3dlcnMuY2xhc3NMaXN0LnRvZ2dsZSgnc2NhbGUnKVxyXG4gICAgdGFyZ2V0LmNsYXNzTGlzdC50b2dnbGUoJ3JvdGF0ZScpXHJcbiAgfSxcclxuXHJcbiAgdmlld01vZGVsOiAoZWwpID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOiArZWwuaWQsXHJcbiAgICAgIGVsOiBlbCxcclxuICAgICAgc29ydDogZWwucXVlcnlTZWxlY3RvcignLnF1ZXN0aW9uX19zb3J0JyksXHJcbiAgICAgIHNhdmU6IGVsLnF1ZXJ5U2VsZWN0b3IoJy5xdWVzdGlvbl9fc2F2ZScpLFxyXG4gICAgICB0ZXh0OiBlbC5xdWVyeVNlbGVjdG9yKCcucXVlc3Rpb25fX3RleHQnKSxcclxuICAgICAgZGVsOiBlbC5xdWVyeVNlbGVjdG9yKCcucXVlc3Rpb25fX2RlbGV0ZScpLFxyXG4gICAgICBjcmVhdGVBbnN3ZXJCdXR0b246IGVsLnF1ZXJ5U2VsZWN0b3IoJy5hbnN3ZXJfX2NyZWF0ZS1idXR0b24nKSxcclxuICAgICAgYWRkQnV0dG9uOiAkKCQoJy5xdWVzdGlvbnMnKVswXSkuZmluZCgnLnF1ZXN0aW9uX19jcmVhdGUtYnV0dG9uJyksXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgc2VydmVyTW9kZWw6ICgpID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHF1ZXN0aW9uOiB7XHJcbiAgICAgICAgaWQ6IG51bGwsXHJcbiAgICAgICAgcXVzdGlvbjogJycsXHJcbiAgICAgICAgcGFyZW50OiArd2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoJy8nKS5wb3AoKSxcclxuICAgICAgICBzb3J0OiBfcXVlc3Rpb24ubGFzdFNvcnQoKSxcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHF1ZXN0aW9uczogKCkgPT4ge1xyXG4gICAgbGV0IHFzID0gJCgnLnF1ZXN0aW9ucz4ucXVlc3Rpb24tZWRpdCcpXHJcbiAgICAvLyBkZWJ1Z2dlclxyXG4gICAgcmV0dXJuICQoJy5xdWVzdGlvbnM+LnF1ZXN0aW9uLWVkaXQnKVxyXG4gICAgLy8gcmV0dXJuICQoJy5xdWVzdGlvbnM+LnF1ZXN0aW9uLWVkaXQnKS5lbFxyXG4gIH0sXHJcblxyXG4gIHF1ZXN0aW9uc0NvdW50OiAoKSA9PiB7XHJcbiAgICByZXR1cm4gJCgnLnF1ZXN0aW9ucz4ucXVlc3Rpb24tZWRpdCcpLmVsLmxlbmd0aFxyXG4gIH0sXHJcblxyXG4gIGxhc3RTb3J0OiAoKSA9PiB7XHJcbiAgICBsZXQgcXMgPSBfcXVlc3Rpb24ucXVlc3Rpb25zKClcclxuICAgIGxldCBsZW5ndGggPSBxcy5sZW5ndGggLSAxXHJcbiAgICBsZXQgbGFzdCA9ICtfcXVlc3Rpb24udmlld01vZGVsKHFzW2xlbmd0aF0pLnNvcnQuaW5uZXJUZXh0XHJcbiAgICByZXR1cm4gbGFzdCArIDFcclxuICB9LFxyXG5cclxuICBjcmVhdGU6XHJcbiAgICBhc3luYyAoZSkgPT4ge1xyXG4gICAgICBsZXQgcV9pZCA9IGF3YWl0IF9xdWVzdGlvbi5jcmVhdGVPblNlcnZlcihlKVxyXG4gICAgICBpZiAocV9pZCkge1xyXG4gICAgICAgIF9xdWVzdGlvbi5jcmVhdGVPblZpZXcocV9pZClcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgY3JlYXRlT25TZXJ2ZXI6XHJcbiAgICBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGxldCBxdWVzdGlvbiA9IF9xdWVzdGlvbi5zZXJ2ZXJNb2RlbCgpXHJcbiAgICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KCcvcXVlc3Rpb24vdXBkYXRlT3JDcmVhdGUnLCB7cXVlc3Rpb246IHF1ZXN0aW9uLnF1ZXN0aW9uLCBhbnN3ZXJzOiB7fX0pXHJcbiAgICAgIHJlcyA9IGF3YWl0IEpTT04ucGFyc2UocmVzKVxyXG5cclxuICAgICAgcmV0dXJuIHJlcy5pZFxyXG4gICAgfSxcclxuXHJcbiAgY3JlYXRlT25WaWV3OlxyXG4gICAgKHFfaWQpID0+IHtcclxuICAgICAgbGV0IGNsb25lID0gX3F1ZXN0aW9uLmNsb25lRW1wdHlNb2RlbCgpXHJcblxyXG4gICAgICBsZXQgbW9kZWwgPSBfcXVlc3Rpb24udmlld01vZGVsKGNsb25lKVxyXG4gICAgICAvLyAkKG1vZGVsLnNhdmUpLm9uKCdjbGljaycsIF9xdWVzdGlvbi5zYXZlKVxyXG4gICAgICAvLyAkKG1vZGVsLmRlbCkub24oJ2NsaWNrJywgX3F1ZXN0aW9uLmRlbGV0ZSlcclxuICAgICAgLy8gJChtb2RlbC50ZXh0KS5vbignY2xpY2snLCBfcXVlc3Rpb24uc2hvd0Fuc3dlcnMpXHJcbiAgICAgIC8vICQobW9kZWwuY3JlYXRlQW5zd2VyQnV0dG9uKS5vbignY2xpY2snLCBfYW5zd2VyLmNyZWF0ZSlcclxuXHJcbiAgICAgIG1vZGVsLnNvcnQuaW5uZXJUZXh0ID0gX3F1ZXN0aW9uLmxhc3RTb3J0KClcclxuICAgICAgbW9kZWwudGV4dC5pbm5lclRleHQgPSAnJ1xyXG4gICAgICBtb2RlbC5lbC5pZCA9IHFfaWRcclxuXHJcbiAgICAgIG1vZGVsLmFkZEJ1dHRvbi5iZWZvcmUoY2xvbmUpXHJcbiAgICB9LFxyXG5cclxuXHJcbiAgc2F2ZTpcclxuICAgIGFzeW5jICh0YXJnZXQpID0+IHtcclxuICAgICAgbGV0IHF1ZXN0aW9uID0gdGFyZ2V0LmNsb3Nlc3QoJy5xdWVzdGlvbi1lZGl0JylcclxuICAgICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoXHJcbiAgICAgICAgJy9xdWVzdGlvbi9VcGRhdGVPckNyZWF0ZScsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcXVlc3Rpb246IF9xdWVzdGlvbi5nZXRNb2RlbEZvclNlcnZlcihxdWVzdGlvbiksXHJcbiAgICAgICAgICBhbnN3ZXJzOiBfcXVlc3Rpb24uZ2V0QW5zd2VycyhxdWVzdGlvbiksXHJcbiAgICAgICAgfSlcclxuICAgICAgcmVzID0gYXdhaXQgSlNPTi5wYXJzZShyZXMpXHJcbiAgICAgIHBvcHVwLnNob3cocmVzLm1zZylcclxuICAgIH0sXHJcblxyXG4gIGRlbGV0ZTpcclxuICAgIGFzeW5jICh0YXJnZXQpID0+IHtcclxuICAgICAgaWYgKGNvbmZpcm0oXCLQo9C00LDQu9C40YLRjCDQstC+0L/RgNC+0YEg0YHQviDQstGB0LXQvNC4INC10LPQviDQvtGC0LLQtdGC0LDQvNC4P1wiKSkge1xyXG4gICAgICAgIGxldCB2aWV3TW9kZWwgPSBfcXVlc3Rpb24udmlld01vZGVsKHRhcmdldC5jbG9zZXN0KCcucXVlc3Rpb24tZWRpdCcpKVxyXG4gICAgICAgIGxldCBpZCA9IHZpZXdNb2RlbC5pZFxyXG5cclxuICAgICAgICBsZXQgZGVsZXRlZCA9IGF3YWl0IF9xdWVzdGlvbi5kZWxldGVGcm9tU2VydmVyKGlkKVxyXG4gICAgICAgIGlmIChkZWxldGVkKSB7XHJcbiAgICAgICAgICBfcXVlc3Rpb24uZGVsZXRlRnJvbVZpZXcodmlld01vZGVsKVxyXG4gICAgICAgICAgcG9wdXAuc2hvdyhkZWxldGVkLm1zZylcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gIGRlbGV0ZUZyb21WaWV3OlxyXG4gICAgYXN5bmMgKHZpZXdNb2RlbCkgPT4ge1xyXG4gICAgICB2aWV3TW9kZWwuZWwucmVtb3ZlKClcclxuICAgIH0sXHJcblxyXG4gIGRlbGV0ZUZyb21TZXJ2ZXI6XHJcbiAgICBhc3luYyAocV9pZCkgPT4ge1xyXG4gICAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCgnL3F1ZXN0aW9uL2RlbGV0ZScsIHtxX2lkfSlcclxuICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzKVxyXG4gICAgfSxcclxuXHJcbiAgZ2V0TW9kZWxGb3JTZXJ2ZXI6XHJcbiAgICAocXVlc3Rpb24pID0+IHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogK3F1ZXN0aW9uLmlkLFxyXG4gICAgICAgIHBhcmVudDogKyQoJy50ZXN0LW5hbWUnKVswXS5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJyksXHJcbiAgICAgICAgcGljcTogJycsXHJcbiAgICAgICAgcXVzdGlvbjogJChxdWVzdGlvbikuZmluZCgnLnF1ZXN0aW9uX190ZXh0JykuaW5uZXJUZXh0LFxyXG4gICAgICAgIHNvcnQ6ICskKHF1ZXN0aW9uKS5maW5kKCcucXVlc3Rpb25fX3NvcnQnKS5pbm5lclRleHQsXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgZ2V0QW5zd2VyczpcclxuICAgIChxdWVzdGlvbikgPT4ge1xyXG4gICAgICBsZXQgYW5zd2VyQmxvY2tzID0gcXVlc3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnLmFuc3dlcicpXHJcbiAgICAgIHJldHVybiBbLi4uYW5zd2VyQmxvY2tzXS5tYXAoKGEpID0+IHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgaWQ6ICthLmRhdGFzZXRbJ2Fuc3dlcklkJ10sXHJcbiAgICAgICAgICBhbnN3ZXI6IGEucXVlcnlTZWxlY3RvcignLmFuc3dlcl9fdGV4dCcpLmlubmVyVGV4dCxcclxuICAgICAgICAgIGNvcnJlY3RfYW5zd2VyOiArYS5xdWVyeVNlbGVjdG9yKCdbdHlwZT1cImNoZWNrYm94XCJdJykuY2hlY2tlZCxcclxuICAgICAgICAgIHBhcmVudF9xdWVzdGlvbjogK3F1ZXN0aW9uLmlkLFxyXG4gICAgICAgICAgcGljYTogJycsXHJcbiAgICAgICAgfVxyXG4gICAgICB9LCBxdWVzdGlvbilcclxuICAgIH0sXHJcbn1cclxuXHJcbiIsIi8qKiFcbiAqIFNvcnRhYmxlIDEuMTQuMFxuICogQGF1dGhvclx0UnViYVhhICAgPHRyYXNoQHJ1YmF4YS5vcmc+XG4gKiBAYXV0aG9yXHRvd2VubSAgICA8b3dlbjIzMzU1QGdtYWlsLmNvbT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG5cbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHtcbiAgICAgIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcblxuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbnZhciB2ZXJzaW9uID0gXCIxLjE0LjBcIjtcblxuZnVuY3Rpb24gdXNlckFnZW50KHBhdHRlcm4pIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uYXZpZ2F0b3IpIHtcbiAgICByZXR1cm4gISEgLypAX19QVVJFX18qL25hdmlnYXRvci51c2VyQWdlbnQubWF0Y2gocGF0dGVybik7XG4gIH1cbn1cblxudmFyIElFMTFPckxlc3MgPSB1c2VyQWdlbnQoLyg/OlRyaWRlbnQuKnJ2WyA6XT8xMVxcLnxtc2llfGllbW9iaWxlfFdpbmRvd3MgUGhvbmUpL2kpO1xudmFyIEVkZ2UgPSB1c2VyQWdlbnQoL0VkZ2UvaSk7XG52YXIgRmlyZUZveCA9IHVzZXJBZ2VudCgvZmlyZWZveC9pKTtcbnZhciBTYWZhcmkgPSB1c2VyQWdlbnQoL3NhZmFyaS9pKSAmJiAhdXNlckFnZW50KC9jaHJvbWUvaSkgJiYgIXVzZXJBZ2VudCgvYW5kcm9pZC9pKTtcbnZhciBJT1MgPSB1c2VyQWdlbnQoL2lQKGFkfG9kfGhvbmUpL2kpO1xudmFyIENocm9tZUZvckFuZHJvaWQgPSB1c2VyQWdlbnQoL2Nocm9tZS9pKSAmJiB1c2VyQWdlbnQoL2FuZHJvaWQvaSk7XG5cbnZhciBjYXB0dXJlTW9kZSA9IHtcbiAgY2FwdHVyZTogZmFsc2UsXG4gIHBhc3NpdmU6IGZhbHNlXG59O1xuXG5mdW5jdGlvbiBvbihlbCwgZXZlbnQsIGZuKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCAhSUUxMU9yTGVzcyAmJiBjYXB0dXJlTW9kZSk7XG59XG5cbmZ1bmN0aW9uIG9mZihlbCwgZXZlbnQsIGZuKSB7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCAhSUUxMU9yTGVzcyAmJiBjYXB0dXJlTW9kZSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMoXG4vKipIVE1MRWxlbWVudCovXG5lbCxcbi8qKlN0cmluZyovXG5zZWxlY3Rvcikge1xuICBpZiAoIXNlbGVjdG9yKSByZXR1cm47XG4gIHNlbGVjdG9yWzBdID09PSAnPicgJiYgKHNlbGVjdG9yID0gc2VsZWN0b3Iuc3Vic3RyaW5nKDEpKTtcblxuICBpZiAoZWwpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGVsLm1hdGNoZXMpIHtcbiAgICAgICAgcmV0dXJuIGVsLm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgICAgfSBlbHNlIGlmIChlbC5tc01hdGNoZXNTZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gZWwubXNNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgfSBlbHNlIGlmIChlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50T3JIb3N0KGVsKSB7XG4gIHJldHVybiBlbC5ob3N0ICYmIGVsICE9PSBkb2N1bWVudCAmJiBlbC5ob3N0Lm5vZGVUeXBlID8gZWwuaG9zdCA6IGVsLnBhcmVudE5vZGU7XG59XG5cbmZ1bmN0aW9uIGNsb3Nlc3QoXG4vKipIVE1MRWxlbWVudCovXG5lbCxcbi8qKlN0cmluZyovXG5zZWxlY3Rvcixcbi8qKkhUTUxFbGVtZW50Ki9cbmN0eCwgaW5jbHVkZUNUWCkge1xuICBpZiAoZWwpIHtcbiAgICBjdHggPSBjdHggfHwgZG9jdW1lbnQ7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoc2VsZWN0b3IgIT0gbnVsbCAmJiAoc2VsZWN0b3JbMF0gPT09ICc+JyA/IGVsLnBhcmVudE5vZGUgPT09IGN0eCAmJiBtYXRjaGVzKGVsLCBzZWxlY3RvcikgOiBtYXRjaGVzKGVsLCBzZWxlY3RvcikpIHx8IGluY2x1ZGVDVFggJiYgZWwgPT09IGN0eCkge1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbCA9PT0gY3R4KSBicmVhaztcbiAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cbiAgICB9IHdoaWxlIChlbCA9IGdldFBhcmVudE9ySG9zdChlbCkpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSX1NQQUNFID0gL1xccysvZztcblxuZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWwsIG5hbWUsIHN0YXRlKSB7XG4gIGlmIChlbCAmJiBuYW1lKSB7XG4gICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgZWwuY2xhc3NMaXN0W3N0YXRlID8gJ2FkZCcgOiAncmVtb3ZlJ10obmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjbGFzc05hbWUgPSAoJyAnICsgZWwuY2xhc3NOYW1lICsgJyAnKS5yZXBsYWNlKFJfU1BBQ0UsICcgJykucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpO1xuICAgICAgZWwuY2xhc3NOYW1lID0gKGNsYXNzTmFtZSArIChzdGF0ZSA/ICcgJyArIG5hbWUgOiAnJykpLnJlcGxhY2UoUl9TUEFDRSwgJyAnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3NzKGVsLCBwcm9wLCB2YWwpIHtcbiAgdmFyIHN0eWxlID0gZWwgJiYgZWwuc3R5bGU7XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgICAgICB2YWwgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCAnJyk7XG4gICAgICB9IGVsc2UgaWYgKGVsLmN1cnJlbnRTdHlsZSkge1xuICAgICAgICB2YWwgPSBlbC5jdXJyZW50U3R5bGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9wID09PSB2b2lkIDAgPyB2YWwgOiB2YWxbcHJvcF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKHByb3AgaW4gc3R5bGUpICYmIHByb3AuaW5kZXhPZignd2Via2l0JykgPT09IC0xKSB7XG4gICAgICAgIHByb3AgPSAnLXdlYmtpdC0nICsgcHJvcDtcbiAgICAgIH1cblxuICAgICAgc3R5bGVbcHJvcF0gPSB2YWwgKyAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyAnJyA6ICdweCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRyaXgoZWwsIHNlbGZPbmx5KSB7XG4gIHZhciBhcHBsaWVkVHJhbnNmb3JtcyA9ICcnO1xuXG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgYXBwbGllZFRyYW5zZm9ybXMgPSBlbDtcbiAgfSBlbHNlIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gY3NzKGVsLCAndHJhbnNmb3JtJyk7XG5cbiAgICAgIGlmICh0cmFuc2Zvcm0gJiYgdHJhbnNmb3JtICE9PSAnbm9uZScpIHtcbiAgICAgICAgYXBwbGllZFRyYW5zZm9ybXMgPSB0cmFuc2Zvcm0gKyAnICcgKyBhcHBsaWVkVHJhbnNmb3JtcztcbiAgICAgIH1cbiAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cblxuICAgIH0gd2hpbGUgKCFzZWxmT25seSAmJiAoZWwgPSBlbC5wYXJlbnROb2RlKSk7XG4gIH1cblxuICB2YXIgbWF0cml4Rm4gPSB3aW5kb3cuRE9NTWF0cml4IHx8IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXggfHwgd2luZG93LkNTU01hdHJpeCB8fCB3aW5kb3cuTVNDU1NNYXRyaXg7XG4gIC8qanNoaW50IC1XMDU2ICovXG5cbiAgcmV0dXJuIG1hdHJpeEZuICYmIG5ldyBtYXRyaXhGbihhcHBsaWVkVHJhbnNmb3Jtcyk7XG59XG5cbmZ1bmN0aW9uIGZpbmQoY3R4LCB0YWdOYW1lLCBpdGVyYXRvcikge1xuICBpZiAoY3R4KSB7XG4gICAgdmFyIGxpc3QgPSBjdHguZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSksXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBuID0gbGlzdC5sZW5ndGg7XG5cbiAgICBpZiAoaXRlcmF0b3IpIHtcbiAgICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdG9yKGxpc3RbaV0sIGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xuICB9XG5cbiAgcmV0dXJuIFtdO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCkge1xuICB2YXIgc2Nyb2xsaW5nRWxlbWVudCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQ7XG5cbiAgaWYgKHNjcm9sbGluZ0VsZW1lbnQpIHtcbiAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG59XG4vKipcbiAqIFJldHVybnMgdGhlIFwiYm91bmRpbmcgY2xpZW50IHJlY3RcIiBvZiBnaXZlbiBlbGVtZW50XG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgICAgICAgICAgICAgICAgICAgIFRoZSBlbGVtZW50IHdob3NlIGJvdW5kaW5nQ2xpZW50UmVjdCBpcyB3YW50ZWRcbiAqIEBwYXJhbSAge1tCb29sZWFuXX0gcmVsYXRpdmVUb0NvbnRhaW5pbmdCbG9jayAgV2hldGhlciB0aGUgcmVjdCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5pbmcgYmxvY2sgb2YgKGluY2x1ZGluZykgdGhlIGNvbnRhaW5lclxuICogQHBhcmFtICB7W0Jvb2xlYW5dfSByZWxhdGl2ZVRvTm9uU3RhdGljUGFyZW50ICBXaGV0aGVyIHRoZSByZWN0IHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgcmVsYXRpdmUgcGFyZW50IG9mIChpbmNsdWRpbmcpIHRoZSBjb250YWllbnJcbiAqIEBwYXJhbSAge1tCb29sZWFuXX0gdW5kb1NjYWxlICAgICAgICAgICAgICAgICAgV2hldGhlciB0aGUgY29udGFpbmVyJ3Mgc2NhbGUoKSBzaG91bGQgYmUgdW5kb25lXG4gKiBAcGFyYW0gIHtbSFRNTEVsZW1lbnRdfSBjb250YWluZXIgICAgICAgICAgICAgIFRoZSBwYXJlbnQgdGhlIGVsZW1lbnQgd2lsbCBiZSBwbGFjZWQgaW5cbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGJvdW5kaW5nQ2xpZW50UmVjdCBvZiBlbCwgd2l0aCBzcGVjaWZpZWQgYWRqdXN0bWVudHNcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFJlY3QoZWwsIHJlbGF0aXZlVG9Db250YWluaW5nQmxvY2ssIHJlbGF0aXZlVG9Ob25TdGF0aWNQYXJlbnQsIHVuZG9TY2FsZSwgY29udGFpbmVyKSB7XG4gIGlmICghZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIGVsICE9PSB3aW5kb3cpIHJldHVybjtcbiAgdmFyIGVsUmVjdCwgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBoZWlnaHQsIHdpZHRoO1xuXG4gIGlmIChlbCAhPT0gd2luZG93ICYmIGVsLnBhcmVudE5vZGUgJiYgZWwgIT09IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKSkge1xuICAgIGVsUmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRvcCA9IGVsUmVjdC50b3A7XG4gICAgbGVmdCA9IGVsUmVjdC5sZWZ0O1xuICAgIGJvdHRvbSA9IGVsUmVjdC5ib3R0b207XG4gICAgcmlnaHQgPSBlbFJlY3QucmlnaHQ7XG4gICAgaGVpZ2h0ID0gZWxSZWN0LmhlaWdodDtcbiAgICB3aWR0aCA9IGVsUmVjdC53aWR0aDtcbiAgfSBlbHNlIHtcbiAgICB0b3AgPSAwO1xuICAgIGxlZnQgPSAwO1xuICAgIGJvdHRvbSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICByaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICB9XG5cbiAgaWYgKChyZWxhdGl2ZVRvQ29udGFpbmluZ0Jsb2NrIHx8IHJlbGF0aXZlVG9Ob25TdGF0aWNQYXJlbnQpICYmIGVsICE9PSB3aW5kb3cpIHtcbiAgICAvLyBBZGp1c3QgZm9yIHRyYW5zbGF0ZSgpXG4gICAgY29udGFpbmVyID0gY29udGFpbmVyIHx8IGVsLnBhcmVudE5vZGU7IC8vIHNvbHZlcyAjMTEyMyAoc2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzc5NTM4MDYvNjA4ODMxMilcbiAgICAvLyBOb3QgbmVlZGVkIG9uIDw9IElFMTFcblxuICAgIGlmICghSUUxMU9yTGVzcykge1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgKGNzcyhjb250YWluZXIsICd0cmFuc2Zvcm0nKSAhPT0gJ25vbmUnIHx8IHJlbGF0aXZlVG9Ob25TdGF0aWNQYXJlbnQgJiYgY3NzKGNvbnRhaW5lciwgJ3Bvc2l0aW9uJykgIT09ICdzdGF0aWMnKSkge1xuICAgICAgICAgIHZhciBjb250YWluZXJSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBTZXQgcmVsYXRpdmUgdG8gZWRnZXMgb2YgcGFkZGluZyBib3ggb2YgY29udGFpbmVyXG5cbiAgICAgICAgICB0b3AgLT0gY29udGFpbmVyUmVjdC50b3AgKyBwYXJzZUludChjc3MoY29udGFpbmVyLCAnYm9yZGVyLXRvcC13aWR0aCcpKTtcbiAgICAgICAgICBsZWZ0IC09IGNvbnRhaW5lclJlY3QubGVmdCArIHBhcnNlSW50KGNzcyhjb250YWluZXIsICdib3JkZXItbGVmdC13aWR0aCcpKTtcbiAgICAgICAgICBib3R0b20gPSB0b3AgKyBlbFJlY3QuaGVpZ2h0O1xuICAgICAgICAgIHJpZ2h0ID0gbGVmdCArIGVsUmVjdC53aWR0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cbiAgICAgIH0gd2hpbGUgKGNvbnRhaW5lciA9IGNvbnRhaW5lci5wYXJlbnROb2RlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodW5kb1NjYWxlICYmIGVsICE9PSB3aW5kb3cpIHtcbiAgICAvLyBBZGp1c3QgZm9yIHNjYWxlKClcbiAgICB2YXIgZWxNYXRyaXggPSBtYXRyaXgoY29udGFpbmVyIHx8IGVsKSxcbiAgICAgICAgc2NhbGVYID0gZWxNYXRyaXggJiYgZWxNYXRyaXguYSxcbiAgICAgICAgc2NhbGVZID0gZWxNYXRyaXggJiYgZWxNYXRyaXguZDtcblxuICAgIGlmIChlbE1hdHJpeCkge1xuICAgICAgdG9wIC89IHNjYWxlWTtcbiAgICAgIGxlZnQgLz0gc2NhbGVYO1xuICAgICAgd2lkdGggLz0gc2NhbGVYO1xuICAgICAgaGVpZ2h0IC89IHNjYWxlWTtcbiAgICAgIGJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgICAgIHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiB0b3AsXG4gICAgbGVmdDogbGVmdCxcbiAgICBib3R0b206IGJvdHRvbSxcbiAgICByaWdodDogcmlnaHQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59XG4vKipcbiAqIENoZWNrcyBpZiBhIHNpZGUgb2YgYW4gZWxlbWVudCBpcyBzY3JvbGxlZCBwYXN0IGEgc2lkZSBvZiBpdHMgcGFyZW50c1xuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9ICBlbCAgICAgICAgICAgVGhlIGVsZW1lbnQgd2hvJ3Mgc2lkZSBiZWluZyBzY3JvbGxlZCBvdXQgb2YgdmlldyBpcyBpbiBxdWVzdGlvblxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICBlbFNpZGUgICAgICAgU2lkZSBvZiB0aGUgZWxlbWVudCBpbiBxdWVzdGlvbiAoJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdHRvbScpXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIHBhcmVudFNpZGUgICBTaWRlIG9mIHRoZSBwYXJlbnQgaW4gcXVlc3Rpb24gKCd0b3AnLCAnbGVmdCcsICdyaWdodCcsICdib3R0b20nKVxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9ICAgICAgICAgICAgICAgVGhlIHBhcmVudCBzY3JvbGwgZWxlbWVudCB0aGF0IHRoZSBlbCdzIHNpZGUgaXMgc2Nyb2xsZWQgcGFzdCwgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBzdWNoIGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzU2Nyb2xsZWRQYXN0KGVsLCBlbFNpZGUsIHBhcmVudFNpZGUpIHtcbiAgdmFyIHBhcmVudCA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsLCB0cnVlKSxcbiAgICAgIGVsU2lkZVZhbCA9IGdldFJlY3QoZWwpW2VsU2lkZV07XG4gIC8qIGpzaGludCBib3NzOnRydWUgKi9cblxuICB3aGlsZSAocGFyZW50KSB7XG4gICAgdmFyIHBhcmVudFNpZGVWYWwgPSBnZXRSZWN0KHBhcmVudClbcGFyZW50U2lkZV0sXG4gICAgICAgIHZpc2libGUgPSB2b2lkIDA7XG5cbiAgICBpZiAocGFyZW50U2lkZSA9PT0gJ3RvcCcgfHwgcGFyZW50U2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICB2aXNpYmxlID0gZWxTaWRlVmFsID49IHBhcmVudFNpZGVWYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpc2libGUgPSBlbFNpZGVWYWwgPD0gcGFyZW50U2lkZVZhbDtcbiAgICB9XG5cbiAgICBpZiAoIXZpc2libGUpIHJldHVybiBwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCA9PT0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpKSBicmVhaztcbiAgICBwYXJlbnQgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChwYXJlbnQsIGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogR2V0cyBudGggY2hpbGQgb2YgZWwsIGlnbm9yaW5nIGhpZGRlbiBjaGlsZHJlbiwgc29ydGFibGUncyBlbGVtZW50cyAoZG9lcyBub3QgaWdub3JlIGNsb25lIGlmIGl0J3MgdmlzaWJsZSlcbiAqIGFuZCBub24tZHJhZ2dhYmxlIGVsZW1lbnRzXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgICAgVGhlIHBhcmVudCBlbGVtZW50XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNoaWxkTnVtICAgICAgVGhlIGluZGV4IG9mIHRoZSBjaGlsZFxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zICAgICAgIFBhcmVudCBTb3J0YWJsZSdzIG9wdGlvbnNcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgICAgICAgICBUaGUgY2hpbGQgYXQgaW5kZXggY2hpbGROdW0sIG9yIG51bGwgaWYgbm90IGZvdW5kXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRDaGlsZChlbCwgY2hpbGROdW0sIG9wdGlvbnMsIGluY2x1ZGVEcmFnRWwpIHtcbiAgdmFyIGN1cnJlbnRDaGlsZCA9IDAsXG4gICAgICBpID0gMCxcbiAgICAgIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG5cbiAgd2hpbGUgKGkgPCBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBpZiAoY2hpbGRyZW5baV0uc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnICYmIGNoaWxkcmVuW2ldICE9PSBTb3J0YWJsZS5naG9zdCAmJiAoaW5jbHVkZURyYWdFbCB8fCBjaGlsZHJlbltpXSAhPT0gU29ydGFibGUuZHJhZ2dlZCkgJiYgY2xvc2VzdChjaGlsZHJlbltpXSwgb3B0aW9ucy5kcmFnZ2FibGUsIGVsLCBmYWxzZSkpIHtcbiAgICAgIGlmIChjdXJyZW50Q2hpbGQgPT09IGNoaWxkTnVtKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbltpXTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudENoaWxkKys7XG4gICAgfVxuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEdldHMgdGhlIGxhc3QgY2hpbGQgaW4gdGhlIGVsLCBpZ25vcmluZyBnaG9zdEVsIG9yIGludmlzaWJsZSBlbGVtZW50cyAoY2xvbmVzKVxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgICAgIFBhcmVudCBlbGVtZW50XG4gKiBAcGFyYW0gIHtzZWxlY3Rvcn0gc2VsZWN0b3IgICAgQW55IG90aGVyIGVsZW1lbnRzIHRoYXQgc2hvdWxkIGJlIGlnbm9yZWRcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgICAgICAgICBUaGUgbGFzdCBjaGlsZCwgaWdub3JpbmcgZ2hvc3RFbFxuICovXG5cblxuZnVuY3Rpb24gbGFzdENoaWxkKGVsLCBzZWxlY3Rvcikge1xuICB2YXIgbGFzdCA9IGVsLmxhc3RFbGVtZW50Q2hpbGQ7XG5cbiAgd2hpbGUgKGxhc3QgJiYgKGxhc3QgPT09IFNvcnRhYmxlLmdob3N0IHx8IGNzcyhsYXN0LCAnZGlzcGxheScpID09PSAnbm9uZScgfHwgc2VsZWN0b3IgJiYgIW1hdGNoZXMobGFzdCwgc2VsZWN0b3IpKSkge1xuICAgIGxhc3QgPSBsYXN0LnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbGFzdCB8fCBudWxsO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbmRleCBvZiBhbiBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50IGZvciBhIHNlbGVjdGVkIHNldCBvZlxuICogZWxlbWVudHNcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbFxuICogQHBhcmFtICB7c2VsZWN0b3J9IHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBpbmRleChlbCwgc2VsZWN0b3IpIHtcbiAgdmFyIGluZGV4ID0gMDtcblxuICBpZiAoIWVsIHx8ICFlbC5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIC8qIGpzaGludCBib3NzOnRydWUgKi9cblxuXG4gIHdoaWxlIChlbCA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHtcbiAgICBpZiAoZWwubm9kZU5hbWUudG9VcHBlckNhc2UoKSAhPT0gJ1RFTVBMQVRFJyAmJiBlbCAhPT0gU29ydGFibGUuY2xvbmUgJiYgKCFzZWxlY3RvciB8fCBtYXRjaGVzKGVsLCBzZWxlY3RvcikpKSB7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgc2Nyb2xsIG9mZnNldCBvZiB0aGUgZ2l2ZW4gZWxlbWVudCwgYWRkZWQgd2l0aCBhbGwgdGhlIHNjcm9sbCBvZmZzZXRzIG9mIHBhcmVudCBlbGVtZW50cy5cbiAqIFRoZSB2YWx1ZSBpcyByZXR1cm5lZCBpbiByZWFsIHBpeGVscy5cbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbFxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgIE9mZnNldHMgaW4gdGhlIGZvcm1hdCBvZiBbbGVmdCwgdG9wXVxuICovXG5cblxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVTY3JvbGxPZmZzZXQoZWwpIHtcbiAgdmFyIG9mZnNldExlZnQgPSAwLFxuICAgICAgb2Zmc2V0VG9wID0gMCxcbiAgICAgIHdpblNjcm9sbGVyID0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuXG4gIGlmIChlbCkge1xuICAgIGRvIHtcbiAgICAgIHZhciBlbE1hdHJpeCA9IG1hdHJpeChlbCksXG4gICAgICAgICAgc2NhbGVYID0gZWxNYXRyaXguYSxcbiAgICAgICAgICBzY2FsZVkgPSBlbE1hdHJpeC5kO1xuICAgICAgb2Zmc2V0TGVmdCArPSBlbC5zY3JvbGxMZWZ0ICogc2NhbGVYO1xuICAgICAgb2Zmc2V0VG9wICs9IGVsLnNjcm9sbFRvcCAqIHNjYWxlWTtcbiAgICB9IHdoaWxlIChlbCAhPT0gd2luU2Nyb2xsZXIgJiYgKGVsID0gZWwucGFyZW50Tm9kZSkpO1xuICB9XG5cbiAgcmV0dXJuIFtvZmZzZXRMZWZ0LCBvZmZzZXRUb3BdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgb2JqZWN0IHdpdGhpbiB0aGUgZ2l2ZW4gYXJyYXlcbiAqIEBwYXJhbSAge0FycmF5fSBhcnIgICBBcnJheSB0aGF0IG1heSBvciBtYXkgbm90IGhvbGQgdGhlIG9iamVjdFxuICogQHBhcmFtICB7T2JqZWN0fSBvYmogIEFuIG9iamVjdCB0aGF0IGhhcyBhIGtleS12YWx1ZSBwYWlyIHVuaXF1ZSB0byBhbmQgaWRlbnRpY2FsIHRvIGEga2V5LXZhbHVlIHBhaXIgaW4gdGhlIG9iamVjdCB5b3Ugd2FudCB0byBmaW5kXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgVGhlIGluZGV4IG9mIHRoZSBvYmplY3QgaW4gdGhlIGFycmF5LCBvciAtMVxuICovXG5cblxuZnVuY3Rpb24gaW5kZXhPZk9iamVjdChhcnIsIG9iaikge1xuICBmb3IgKHZhciBpIGluIGFycikge1xuICAgIGlmICghYXJyLmhhc093blByb3BlcnR5KGkpKSBjb250aW51ZTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiBvYmpba2V5XSA9PT0gYXJyW2ldW2tleV0pIHJldHVybiBOdW1iZXIoaSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbCwgaW5jbHVkZVNlbGYpIHtcbiAgLy8gc2tpcCB0byB3aW5kb3dcbiAgaWYgKCFlbCB8fCAhZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSByZXR1cm4gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICB2YXIgZWxlbSA9IGVsO1xuICB2YXIgZ290U2VsZiA9IGZhbHNlO1xuXG4gIGRvIHtcbiAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIGdldCBlbGVtIGNzcyBpZiBpdCBpc24ndCBldmVuIG92ZXJmbG93aW5nIGluIHRoZSBmaXJzdCBwbGFjZSAocGVyZm9ybWFuY2UpXG4gICAgaWYgKGVsZW0uY2xpZW50V2lkdGggPCBlbGVtLnNjcm9sbFdpZHRoIHx8IGVsZW0uY2xpZW50SGVpZ2h0IDwgZWxlbS5zY3JvbGxIZWlnaHQpIHtcbiAgICAgIHZhciBlbGVtQ1NTID0gY3NzKGVsZW0pO1xuXG4gICAgICBpZiAoZWxlbS5jbGllbnRXaWR0aCA8IGVsZW0uc2Nyb2xsV2lkdGggJiYgKGVsZW1DU1Mub3ZlcmZsb3dYID09ICdhdXRvJyB8fCBlbGVtQ1NTLm92ZXJmbG93WCA9PSAnc2Nyb2xsJykgfHwgZWxlbS5jbGllbnRIZWlnaHQgPCBlbGVtLnNjcm9sbEhlaWdodCAmJiAoZWxlbUNTUy5vdmVyZmxvd1kgPT0gJ2F1dG8nIHx8IGVsZW1DU1Mub3ZlcmZsb3dZID09ICdzY3JvbGwnKSkge1xuICAgICAgICBpZiAoIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHx8IGVsZW0gPT09IGRvY3VtZW50LmJvZHkpIHJldHVybiBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gICAgICAgIGlmIChnb3RTZWxmIHx8IGluY2x1ZGVTZWxmKSByZXR1cm4gZWxlbTtcbiAgICAgICAgZ290U2VsZiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cblxuICB9IHdoaWxlIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKTtcblxuICByZXR1cm4gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoZHN0LCBzcmMpIHtcbiAgaWYgKGRzdCAmJiBzcmMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgZHN0W2tleV0gPSBzcmNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZHN0O1xufVxuXG5mdW5jdGlvbiBpc1JlY3RFcXVhbChyZWN0MSwgcmVjdDIpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQocmVjdDEudG9wKSA9PT0gTWF0aC5yb3VuZChyZWN0Mi50b3ApICYmIE1hdGgucm91bmQocmVjdDEubGVmdCkgPT09IE1hdGgucm91bmQocmVjdDIubGVmdCkgJiYgTWF0aC5yb3VuZChyZWN0MS5oZWlnaHQpID09PSBNYXRoLnJvdW5kKHJlY3QyLmhlaWdodCkgJiYgTWF0aC5yb3VuZChyZWN0MS53aWR0aCkgPT09IE1hdGgucm91bmQocmVjdDIud2lkdGgpO1xufVxuXG52YXIgX3Rocm90dGxlVGltZW91dDtcblxuZnVuY3Rpb24gdGhyb3R0bGUoY2FsbGJhY2ssIG1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFfdGhyb3R0bGVUaW1lb3V0KSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKF90aGlzLCBhcmdzWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KF90aGlzLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgX3Rocm90dGxlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhyb3R0bGVUaW1lb3V0ID0gdm9pZCAwO1xuICAgICAgfSwgbXMpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FuY2VsVGhyb3R0bGUoKSB7XG4gIGNsZWFyVGltZW91dChfdGhyb3R0bGVUaW1lb3V0KTtcbiAgX3Rocm90dGxlVGltZW91dCA9IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gc2Nyb2xsQnkoZWwsIHgsIHkpIHtcbiAgZWwuc2Nyb2xsTGVmdCArPSB4O1xuICBlbC5zY3JvbGxUb3AgKz0geTtcbn1cblxuZnVuY3Rpb24gY2xvbmUoZWwpIHtcbiAgdmFyIFBvbHltZXIgPSB3aW5kb3cuUG9seW1lcjtcbiAgdmFyICQgPSB3aW5kb3cualF1ZXJ5IHx8IHdpbmRvdy5aZXB0bztcblxuICBpZiAoUG9seW1lciAmJiBQb2x5bWVyLmRvbSkge1xuICAgIHJldHVybiBQb2x5bWVyLmRvbShlbCkuY2xvbmVOb2RlKHRydWUpO1xuICB9IGVsc2UgaWYgKCQpIHtcbiAgICByZXR1cm4gJChlbCkuY2xvbmUodHJ1ZSlbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsLmNsb25lTm9kZSh0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRSZWN0KGVsLCByZWN0KSB7XG4gIGNzcyhlbCwgJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJyk7XG4gIGNzcyhlbCwgJ3RvcCcsIHJlY3QudG9wKTtcbiAgY3NzKGVsLCAnbGVmdCcsIHJlY3QubGVmdCk7XG4gIGNzcyhlbCwgJ3dpZHRoJywgcmVjdC53aWR0aCk7XG4gIGNzcyhlbCwgJ2hlaWdodCcsIHJlY3QuaGVpZ2h0KTtcbn1cblxuZnVuY3Rpb24gdW5zZXRSZWN0KGVsKSB7XG4gIGNzcyhlbCwgJ3Bvc2l0aW9uJywgJycpO1xuICBjc3MoZWwsICd0b3AnLCAnJyk7XG4gIGNzcyhlbCwgJ2xlZnQnLCAnJyk7XG4gIGNzcyhlbCwgJ3dpZHRoJywgJycpO1xuICBjc3MoZWwsICdoZWlnaHQnLCAnJyk7XG59XG5cbnZhciBleHBhbmRvID0gJ1NvcnRhYmxlJyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG5mdW5jdGlvbiBBbmltYXRpb25TdGF0ZU1hbmFnZXIoKSB7XG4gIHZhciBhbmltYXRpb25TdGF0ZXMgPSBbXSxcbiAgICAgIGFuaW1hdGlvbkNhbGxiYWNrSWQ7XG4gIHJldHVybiB7XG4gICAgY2FwdHVyZUFuaW1hdGlvblN0YXRlOiBmdW5jdGlvbiBjYXB0dXJlQW5pbWF0aW9uU3RhdGUoKSB7XG4gICAgICBhbmltYXRpb25TdGF0ZXMgPSBbXTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmFuaW1hdGlvbikgcmV0dXJuO1xuICAgICAgdmFyIGNoaWxkcmVuID0gW10uc2xpY2UuY2FsbCh0aGlzLmVsLmNoaWxkcmVuKTtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmIChjc3MoY2hpbGQsICdkaXNwbGF5JykgPT09ICdub25lJyB8fCBjaGlsZCA9PT0gU29ydGFibGUuZ2hvc3QpIHJldHVybjtcbiAgICAgICAgYW5pbWF0aW9uU3RhdGVzLnB1c2goe1xuICAgICAgICAgIHRhcmdldDogY2hpbGQsXG4gICAgICAgICAgcmVjdDogZ2V0UmVjdChjaGlsZClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGZyb21SZWN0ID0gX29iamVjdFNwcmVhZDIoe30sIGFuaW1hdGlvblN0YXRlc1thbmltYXRpb25TdGF0ZXMubGVuZ3RoIC0gMV0ucmVjdCk7IC8vIElmIGFuaW1hdGluZzogY29tcGVuc2F0ZSBmb3IgY3VycmVudCBhbmltYXRpb25cblxuXG4gICAgICAgIGlmIChjaGlsZC50aGlzQW5pbWF0aW9uRHVyYXRpb24pIHtcbiAgICAgICAgICB2YXIgY2hpbGRNYXRyaXggPSBtYXRyaXgoY2hpbGQsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKGNoaWxkTWF0cml4KSB7XG4gICAgICAgICAgICBmcm9tUmVjdC50b3AgLT0gY2hpbGRNYXRyaXguZjtcbiAgICAgICAgICAgIGZyb21SZWN0LmxlZnQgLT0gY2hpbGRNYXRyaXguZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZC5mcm9tUmVjdCA9IGZyb21SZWN0O1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBhZGRBbmltYXRpb25TdGF0ZTogZnVuY3Rpb24gYWRkQW5pbWF0aW9uU3RhdGUoc3RhdGUpIHtcbiAgICAgIGFuaW1hdGlvblN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICB9LFxuICAgIHJlbW92ZUFuaW1hdGlvblN0YXRlOiBmdW5jdGlvbiByZW1vdmVBbmltYXRpb25TdGF0ZSh0YXJnZXQpIHtcbiAgICAgIGFuaW1hdGlvblN0YXRlcy5zcGxpY2UoaW5kZXhPZk9iamVjdChhbmltYXRpb25TdGF0ZXMsIHtcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICAgIH0pLCAxKTtcbiAgICB9LFxuICAgIGFuaW1hdGVBbGw6IGZ1bmN0aW9uIGFuaW1hdGVBbGwoY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgICBjbGVhclRpbWVvdXQoYW5pbWF0aW9uQ2FsbGJhY2tJZCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGFuaW1hdGluZyA9IGZhbHNlLFxuICAgICAgICAgIGFuaW1hdGlvblRpbWUgPSAwO1xuICAgICAgYW5pbWF0aW9uU3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciB0aW1lID0gMCxcbiAgICAgICAgICAgIHRhcmdldCA9IHN0YXRlLnRhcmdldCxcbiAgICAgICAgICAgIGZyb21SZWN0ID0gdGFyZ2V0LmZyb21SZWN0LFxuICAgICAgICAgICAgdG9SZWN0ID0gZ2V0UmVjdCh0YXJnZXQpLFxuICAgICAgICAgICAgcHJldkZyb21SZWN0ID0gdGFyZ2V0LnByZXZGcm9tUmVjdCxcbiAgICAgICAgICAgIHByZXZUb1JlY3QgPSB0YXJnZXQucHJldlRvUmVjdCxcbiAgICAgICAgICAgIGFuaW1hdGluZ1JlY3QgPSBzdGF0ZS5yZWN0LFxuICAgICAgICAgICAgdGFyZ2V0TWF0cml4ID0gbWF0cml4KHRhcmdldCwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHRhcmdldE1hdHJpeCkge1xuICAgICAgICAgIC8vIENvbXBlbnNhdGUgZm9yIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgICAgICAgdG9SZWN0LnRvcCAtPSB0YXJnZXRNYXRyaXguZjtcbiAgICAgICAgICB0b1JlY3QubGVmdCAtPSB0YXJnZXRNYXRyaXguZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldC50b1JlY3QgPSB0b1JlY3Q7XG5cbiAgICAgICAgaWYgKHRhcmdldC50aGlzQW5pbWF0aW9uRHVyYXRpb24pIHtcbiAgICAgICAgICAvLyBDb3VsZCBhbHNvIGNoZWNrIGlmIGFuaW1hdGluZ1JlY3QgaXMgYmV0d2VlbiBmcm9tUmVjdCBhbmQgdG9SZWN0XG4gICAgICAgICAgaWYgKGlzUmVjdEVxdWFsKHByZXZGcm9tUmVjdCwgdG9SZWN0KSAmJiAhaXNSZWN0RXF1YWwoZnJvbVJlY3QsIHRvUmVjdCkgJiYgLy8gTWFrZSBzdXJlIGFuaW1hdGluZ1JlY3QgaXMgb24gbGluZSBiZXR3ZWVuIHRvUmVjdCAmIGZyb21SZWN0XG4gICAgICAgICAgKGFuaW1hdGluZ1JlY3QudG9wIC0gdG9SZWN0LnRvcCkgLyAoYW5pbWF0aW5nUmVjdC5sZWZ0IC0gdG9SZWN0LmxlZnQpID09PSAoZnJvbVJlY3QudG9wIC0gdG9SZWN0LnRvcCkgLyAoZnJvbVJlY3QubGVmdCAtIHRvUmVjdC5sZWZ0KSkge1xuICAgICAgICAgICAgLy8gSWYgcmV0dXJuaW5nIHRvIHNhbWUgcGxhY2UgYXMgc3RhcnRlZCBmcm9tIGFuaW1hdGlvbiBhbmQgb24gc2FtZSBheGlzXG4gICAgICAgICAgICB0aW1lID0gY2FsY3VsYXRlUmVhbFRpbWUoYW5pbWF0aW5nUmVjdCwgcHJldkZyb21SZWN0LCBwcmV2VG9SZWN0LCBfdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gaWYgZnJvbVJlY3QgIT0gdG9SZWN0OiBhbmltYXRlXG5cblxuICAgICAgICBpZiAoIWlzUmVjdEVxdWFsKHRvUmVjdCwgZnJvbVJlY3QpKSB7XG4gICAgICAgICAgdGFyZ2V0LnByZXZGcm9tUmVjdCA9IGZyb21SZWN0O1xuICAgICAgICAgIHRhcmdldC5wcmV2VG9SZWN0ID0gdG9SZWN0O1xuXG4gICAgICAgICAgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgICB0aW1lID0gX3RoaXMub3B0aW9ucy5hbmltYXRpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMuYW5pbWF0ZSh0YXJnZXQsIGFuaW1hdGluZ1JlY3QsIHRvUmVjdCwgdGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGltZSkge1xuICAgICAgICAgIGFuaW1hdGluZyA9IHRydWU7XG4gICAgICAgICAgYW5pbWF0aW9uVGltZSA9IE1hdGgubWF4KGFuaW1hdGlvblRpbWUsIHRpbWUpO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0YXJnZXQuYW5pbWF0aW9uUmVzZXRUaW1lcik7XG4gICAgICAgICAgdGFyZ2V0LmFuaW1hdGlvblJlc2V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRhcmdldC5hbmltYXRpb25UaW1lID0gMDtcbiAgICAgICAgICAgIHRhcmdldC5wcmV2RnJvbVJlY3QgPSBudWxsO1xuICAgICAgICAgICAgdGFyZ2V0LmZyb21SZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRhcmdldC5wcmV2VG9SZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRhcmdldC50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSBudWxsO1xuICAgICAgICAgIH0sIHRpbWUpO1xuICAgICAgICAgIHRhcmdldC50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSB0aW1lO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNsZWFyVGltZW91dChhbmltYXRpb25DYWxsYmFja0lkKTtcblxuICAgICAgaWYgKCFhbmltYXRpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuaW1hdGlvbkNhbGxiYWNrSWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuICAgICAgICB9LCBhbmltYXRpb25UaW1lKTtcbiAgICAgIH1cblxuICAgICAgYW5pbWF0aW9uU3RhdGVzID0gW107XG4gICAgfSxcbiAgICBhbmltYXRlOiBmdW5jdGlvbiBhbmltYXRlKHRhcmdldCwgY3VycmVudFJlY3QsIHRvUmVjdCwgZHVyYXRpb24pIHtcbiAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNpdGlvbicsICcnKTtcbiAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zZm9ybScsICcnKTtcbiAgICAgICAgdmFyIGVsTWF0cml4ID0gbWF0cml4KHRoaXMuZWwpLFxuICAgICAgICAgICAgc2NhbGVYID0gZWxNYXRyaXggJiYgZWxNYXRyaXguYSxcbiAgICAgICAgICAgIHNjYWxlWSA9IGVsTWF0cml4ICYmIGVsTWF0cml4LmQsXG4gICAgICAgICAgICB0cmFuc2xhdGVYID0gKGN1cnJlbnRSZWN0LmxlZnQgLSB0b1JlY3QubGVmdCkgLyAoc2NhbGVYIHx8IDEpLFxuICAgICAgICAgICAgdHJhbnNsYXRlWSA9IChjdXJyZW50UmVjdC50b3AgLSB0b1JlY3QudG9wKSAvIChzY2FsZVkgfHwgMSk7XG4gICAgICAgIHRhcmdldC5hbmltYXRpbmdYID0gISF0cmFuc2xhdGVYO1xuICAgICAgICB0YXJnZXQuYW5pbWF0aW5nWSA9ICEhdHJhbnNsYXRlWTtcbiAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUzZCgnICsgdHJhbnNsYXRlWCArICdweCwnICsgdHJhbnNsYXRlWSArICdweCwwKScpO1xuICAgICAgICB0aGlzLmZvclJlcGFpbnREdW1teSA9IHJlcGFpbnQodGFyZ2V0KTsgLy8gcmVwYWludFxuXG4gICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2l0aW9uJywgJ3RyYW5zZm9ybSAnICsgZHVyYXRpb24gKyAnbXMnICsgKHRoaXMub3B0aW9ucy5lYXNpbmcgPyAnICcgKyB0aGlzLm9wdGlvbnMuZWFzaW5nIDogJycpKTtcbiAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUzZCgwLDAsMCknKTtcbiAgICAgICAgdHlwZW9mIHRhcmdldC5hbmltYXRlZCA9PT0gJ251bWJlcicgJiYgY2xlYXJUaW1lb3V0KHRhcmdldC5hbmltYXRlZCk7XG4gICAgICAgIHRhcmdldC5hbmltYXRlZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2l0aW9uJywgJycpO1xuICAgICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgICAgICAgdGFyZ2V0LmFuaW1hdGVkID0gZmFsc2U7XG4gICAgICAgICAgdGFyZ2V0LmFuaW1hdGluZ1ggPSBmYWxzZTtcbiAgICAgICAgICB0YXJnZXQuYW5pbWF0aW5nWSA9IGZhbHNlO1xuICAgICAgICB9LCBkdXJhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiByZXBhaW50KHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0Lm9mZnNldFdpZHRoO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVSZWFsVGltZShhbmltYXRpbmdSZWN0LCBmcm9tUmVjdCwgdG9SZWN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZnJvbVJlY3QudG9wIC0gYW5pbWF0aW5nUmVjdC50b3AsIDIpICsgTWF0aC5wb3coZnJvbVJlY3QubGVmdCAtIGFuaW1hdGluZ1JlY3QubGVmdCwgMikpIC8gTWF0aC5zcXJ0KE1hdGgucG93KGZyb21SZWN0LnRvcCAtIHRvUmVjdC50b3AsIDIpICsgTWF0aC5wb3coZnJvbVJlY3QubGVmdCAtIHRvUmVjdC5sZWZ0LCAyKSkgKiBvcHRpb25zLmFuaW1hdGlvbjtcbn1cblxudmFyIHBsdWdpbnMgPSBbXTtcbnZhciBkZWZhdWx0cyA9IHtcbiAgaW5pdGlhbGl6ZUJ5RGVmYXVsdDogdHJ1ZVxufTtcbnZhciBQbHVnaW5NYW5hZ2VyID0ge1xuICBtb3VudDogZnVuY3Rpb24gbW91bnQocGx1Z2luKSB7XG4gICAgLy8gU2V0IGRlZmF1bHQgc3RhdGljIHByb3BlcnRpZXNcbiAgICBmb3IgKHZhciBvcHRpb24gaW4gZGVmYXVsdHMpIHtcbiAgICAgIGlmIChkZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pICYmICEob3B0aW9uIGluIHBsdWdpbikpIHtcbiAgICAgICAgcGx1Z2luW29wdGlvbl0gPSBkZWZhdWx0c1tvcHRpb25dO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgaWYgKHAucGx1Z2luTmFtZSA9PT0gcGx1Z2luLnBsdWdpbk5hbWUpIHtcbiAgICAgICAgdGhyb3cgXCJTb3J0YWJsZTogQ2Fubm90IG1vdW50IHBsdWdpbiBcIi5jb25jYXQocGx1Z2luLnBsdWdpbk5hbWUsIFwiIG1vcmUgdGhhbiBvbmNlXCIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHBsdWdpbnMucHVzaChwbHVnaW4pO1xuICB9LFxuICBwbHVnaW5FdmVudDogZnVuY3Rpb24gcGx1Z2luRXZlbnQoZXZlbnROYW1lLCBzb3J0YWJsZSwgZXZ0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuZXZlbnRDYW5jZWxlZCA9IGZhbHNlO1xuXG4gICAgZXZ0LmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmV2ZW50Q2FuY2VsZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgZXZlbnROYW1lR2xvYmFsID0gZXZlbnROYW1lICsgJ0dsb2JhbCc7XG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIGlmICghc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdKSByZXR1cm47IC8vIEZpcmUgZ2xvYmFsIGV2ZW50cyBpZiBpdCBleGlzdHMgaW4gdGhpcyBzb3J0YWJsZVxuXG4gICAgICBpZiAoc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdW2V2ZW50TmFtZUdsb2JhbF0pIHtcbiAgICAgICAgc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdW2V2ZW50TmFtZUdsb2JhbF0oX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZVxuICAgICAgICB9LCBldnQpKTtcbiAgICAgIH0gLy8gT25seSBmaXJlIHBsdWdpbiBldmVudCBpZiBwbHVnaW4gaXMgZW5hYmxlZCBpbiB0aGlzIHNvcnRhYmxlLFxuICAgICAgLy8gYW5kIHBsdWdpbiBoYXMgZXZlbnQgZGVmaW5lZFxuXG5cbiAgICAgIGlmIChzb3J0YWJsZS5vcHRpb25zW3BsdWdpbi5wbHVnaW5OYW1lXSAmJiBzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV1bZXZlbnROYW1lXSkge1xuICAgICAgICBzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV1bZXZlbnROYW1lXShfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlXG4gICAgICAgIH0sIGV2dCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBpbml0aWFsaXplUGx1Z2luczogZnVuY3Rpb24gaW5pdGlhbGl6ZVBsdWdpbnMoc29ydGFibGUsIGVsLCBkZWZhdWx0cywgb3B0aW9ucykge1xuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICB2YXIgcGx1Z2luTmFtZSA9IHBsdWdpbi5wbHVnaW5OYW1lO1xuICAgICAgaWYgKCFzb3J0YWJsZS5vcHRpb25zW3BsdWdpbk5hbWVdICYmICFwbHVnaW4uaW5pdGlhbGl6ZUJ5RGVmYXVsdCkgcmV0dXJuO1xuICAgICAgdmFyIGluaXRpYWxpemVkID0gbmV3IHBsdWdpbihzb3J0YWJsZSwgZWwsIHNvcnRhYmxlLm9wdGlvbnMpO1xuICAgICAgaW5pdGlhbGl6ZWQuc29ydGFibGUgPSBzb3J0YWJsZTtcbiAgICAgIGluaXRpYWxpemVkLm9wdGlvbnMgPSBzb3J0YWJsZS5vcHRpb25zO1xuICAgICAgc29ydGFibGVbcGx1Z2luTmFtZV0gPSBpbml0aWFsaXplZDsgLy8gQWRkIGRlZmF1bHQgb3B0aW9ucyBmcm9tIHBsdWdpblxuXG4gICAgICBfZXh0ZW5kcyhkZWZhdWx0cywgaW5pdGlhbGl6ZWQuZGVmYXVsdHMpO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgb3B0aW9uIGluIHNvcnRhYmxlLm9wdGlvbnMpIHtcbiAgICAgIGlmICghc29ydGFibGUub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSBjb250aW51ZTtcbiAgICAgIHZhciBtb2RpZmllZCA9IHRoaXMubW9kaWZ5T3B0aW9uKHNvcnRhYmxlLCBvcHRpb24sIHNvcnRhYmxlLm9wdGlvbnNbb3B0aW9uXSk7XG5cbiAgICAgIGlmICh0eXBlb2YgbW9kaWZpZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNvcnRhYmxlLm9wdGlvbnNbb3B0aW9uXSA9IG1vZGlmaWVkO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZ2V0RXZlbnRQcm9wZXJ0aWVzOiBmdW5jdGlvbiBnZXRFdmVudFByb3BlcnRpZXMobmFtZSwgc29ydGFibGUpIHtcbiAgICB2YXIgZXZlbnRQcm9wZXJ0aWVzID0ge307XG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIGlmICh0eXBlb2YgcGx1Z2luLmV2ZW50UHJvcGVydGllcyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuXG4gICAgICBfZXh0ZW5kcyhldmVudFByb3BlcnRpZXMsIHBsdWdpbi5ldmVudFByb3BlcnRpZXMuY2FsbChzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV0sIG5hbWUpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXZlbnRQcm9wZXJ0aWVzO1xuICB9LFxuICBtb2RpZnlPcHRpb246IGZ1bmN0aW9uIG1vZGlmeU9wdGlvbihzb3J0YWJsZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgbW9kaWZpZWRWYWx1ZTtcbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgLy8gUGx1Z2luIG11c3QgZXhpc3Qgb24gdGhlIFNvcnRhYmxlXG4gICAgICBpZiAoIXNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXSkgcmV0dXJuOyAvLyBJZiBzdGF0aWMgb3B0aW9uIGxpc3RlbmVyIGV4aXN0cyBmb3IgdGhpcyBvcHRpb24sIGNhbGwgaW4gdGhlIGNvbnRleHQgb2YgdGhlIFNvcnRhYmxlJ3MgaW5zdGFuY2Ugb2YgdGhpcyBwbHVnaW5cblxuICAgICAgaWYgKHBsdWdpbi5vcHRpb25MaXN0ZW5lcnMgJiYgdHlwZW9mIHBsdWdpbi5vcHRpb25MaXN0ZW5lcnNbbmFtZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbW9kaWZpZWRWYWx1ZSA9IHBsdWdpbi5vcHRpb25MaXN0ZW5lcnNbbmFtZV0uY2FsbChzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbW9kaWZpZWRWYWx1ZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChfcmVmKSB7XG4gIHZhciBzb3J0YWJsZSA9IF9yZWYuc29ydGFibGUsXG4gICAgICByb290RWwgPSBfcmVmLnJvb3RFbCxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICB0YXJnZXRFbCA9IF9yZWYudGFyZ2V0RWwsXG4gICAgICBjbG9uZUVsID0gX3JlZi5jbG9uZUVsLFxuICAgICAgdG9FbCA9IF9yZWYudG9FbCxcbiAgICAgIGZyb21FbCA9IF9yZWYuZnJvbUVsLFxuICAgICAgb2xkSW5kZXggPSBfcmVmLm9sZEluZGV4LFxuICAgICAgbmV3SW5kZXggPSBfcmVmLm5ld0luZGV4LFxuICAgICAgb2xkRHJhZ2dhYmxlSW5kZXggPSBfcmVmLm9sZERyYWdnYWJsZUluZGV4LFxuICAgICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBfcmVmLm5ld0RyYWdnYWJsZUluZGV4LFxuICAgICAgb3JpZ2luYWxFdmVudCA9IF9yZWYub3JpZ2luYWxFdmVudCxcbiAgICAgIHB1dFNvcnRhYmxlID0gX3JlZi5wdXRTb3J0YWJsZSxcbiAgICAgIGV4dHJhRXZlbnRQcm9wZXJ0aWVzID0gX3JlZi5leHRyYUV2ZW50UHJvcGVydGllcztcbiAgc29ydGFibGUgPSBzb3J0YWJsZSB8fCByb290RWwgJiYgcm9vdEVsW2V4cGFuZG9dO1xuICBpZiAoIXNvcnRhYmxlKSByZXR1cm47XG4gIHZhciBldnQsXG4gICAgICBvcHRpb25zID0gc29ydGFibGUub3B0aW9ucyxcbiAgICAgIG9uTmFtZSA9ICdvbicgKyBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSk7IC8vIFN1cHBvcnQgZm9yIG5ldyBDdXN0b21FdmVudCBmZWF0dXJlXG5cbiAgaWYgKHdpbmRvdy5DdXN0b21FdmVudCAmJiAhSUUxMU9yTGVzcyAmJiAhRWRnZSkge1xuICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudChuYW1lLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2dC5pbml0RXZlbnQobmFtZSwgdHJ1ZSwgdHJ1ZSk7XG4gIH1cblxuICBldnQudG8gPSB0b0VsIHx8IHJvb3RFbDtcbiAgZXZ0LmZyb20gPSBmcm9tRWwgfHwgcm9vdEVsO1xuICBldnQuaXRlbSA9IHRhcmdldEVsIHx8IHJvb3RFbDtcbiAgZXZ0LmNsb25lID0gY2xvbmVFbDtcbiAgZXZ0Lm9sZEluZGV4ID0gb2xkSW5kZXg7XG4gIGV2dC5uZXdJbmRleCA9IG5ld0luZGV4O1xuICBldnQub2xkRHJhZ2dhYmxlSW5kZXggPSBvbGREcmFnZ2FibGVJbmRleDtcbiAgZXZ0Lm5ld0RyYWdnYWJsZUluZGV4ID0gbmV3RHJhZ2dhYmxlSW5kZXg7XG4gIGV2dC5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgZXZ0LnB1bGxNb2RlID0gcHV0U29ydGFibGUgPyBwdXRTb3J0YWJsZS5sYXN0UHV0TW9kZSA6IHVuZGVmaW5lZDtcblxuICB2YXIgYWxsRXZlbnRQcm9wZXJ0aWVzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGV4dHJhRXZlbnRQcm9wZXJ0aWVzKSwgUGx1Z2luTWFuYWdlci5nZXRFdmVudFByb3BlcnRpZXMobmFtZSwgc29ydGFibGUpKTtcblxuICBmb3IgKHZhciBvcHRpb24gaW4gYWxsRXZlbnRQcm9wZXJ0aWVzKSB7XG4gICAgZXZ0W29wdGlvbl0gPSBhbGxFdmVudFByb3BlcnRpZXNbb3B0aW9uXTtcbiAgfVxuXG4gIGlmIChyb290RWwpIHtcbiAgICByb290RWwuZGlzcGF0Y2hFdmVudChldnQpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnNbb25OYW1lXSkge1xuICAgIG9wdGlvbnNbb25OYW1lXS5jYWxsKHNvcnRhYmxlLCBldnQpO1xuICB9XG59XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJldnRcIl07XG5cbnZhciBwbHVnaW5FdmVudCA9IGZ1bmN0aW9uIHBsdWdpbkV2ZW50KGV2ZW50TmFtZSwgc29ydGFibGUpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgICAgb3JpZ2luYWxFdmVudCA9IF9yZWYuZXZ0LFxuICAgICAgZGF0YSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQpO1xuXG4gIFBsdWdpbk1hbmFnZXIucGx1Z2luRXZlbnQuYmluZChTb3J0YWJsZSkoZXZlbnROYW1lLCBzb3J0YWJsZSwgX29iamVjdFNwcmVhZDIoe1xuICAgIGRyYWdFbDogZHJhZ0VsLFxuICAgIHBhcmVudEVsOiBwYXJlbnRFbCxcbiAgICBnaG9zdEVsOiBnaG9zdEVsLFxuICAgIHJvb3RFbDogcm9vdEVsLFxuICAgIG5leHRFbDogbmV4dEVsLFxuICAgIGxhc3REb3duRWw6IGxhc3REb3duRWwsXG4gICAgY2xvbmVFbDogY2xvbmVFbCxcbiAgICBjbG9uZUhpZGRlbjogY2xvbmVIaWRkZW4sXG4gICAgZHJhZ1N0YXJ0ZWQ6IG1vdmVkLFxuICAgIHB1dFNvcnRhYmxlOiBwdXRTb3J0YWJsZSxcbiAgICBhY3RpdmVTb3J0YWJsZTogU29ydGFibGUuYWN0aXZlLFxuICAgIG9yaWdpbmFsRXZlbnQ6IG9yaWdpbmFsRXZlbnQsXG4gICAgb2xkSW5kZXg6IG9sZEluZGV4LFxuICAgIG9sZERyYWdnYWJsZUluZGV4OiBvbGREcmFnZ2FibGVJbmRleCxcbiAgICBuZXdJbmRleDogbmV3SW5kZXgsXG4gICAgbmV3RHJhZ2dhYmxlSW5kZXg6IG5ld0RyYWdnYWJsZUluZGV4LFxuICAgIGhpZGVHaG9zdEZvclRhcmdldDogX2hpZGVHaG9zdEZvclRhcmdldCxcbiAgICB1bmhpZGVHaG9zdEZvclRhcmdldDogX3VuaGlkZUdob3N0Rm9yVGFyZ2V0LFxuICAgIGNsb25lTm93SGlkZGVuOiBmdW5jdGlvbiBjbG9uZU5vd0hpZGRlbigpIHtcbiAgICAgIGNsb25lSGlkZGVuID0gdHJ1ZTtcbiAgICB9LFxuICAgIGNsb25lTm93U2hvd246IGZ1bmN0aW9uIGNsb25lTm93U2hvd24oKSB7XG4gICAgICBjbG9uZUhpZGRlbiA9IGZhbHNlO1xuICAgIH0sXG4gICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50OiBmdW5jdGlvbiBkaXNwYXRjaFNvcnRhYmxlRXZlbnQobmFtZSkge1xuICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICBzb3J0YWJsZTogc29ydGFibGUsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IG9yaWdpbmFsRXZlbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgZGF0YSkpO1xufTtcblxuZnVuY3Rpb24gX2Rpc3BhdGNoRXZlbnQoaW5mbykge1xuICBkaXNwYXRjaEV2ZW50KF9vYmplY3RTcHJlYWQyKHtcbiAgICBwdXRTb3J0YWJsZTogcHV0U29ydGFibGUsXG4gICAgY2xvbmVFbDogY2xvbmVFbCxcbiAgICB0YXJnZXRFbDogZHJhZ0VsLFxuICAgIHJvb3RFbDogcm9vdEVsLFxuICAgIG9sZEluZGV4OiBvbGRJbmRleCxcbiAgICBvbGREcmFnZ2FibGVJbmRleDogb2xkRHJhZ2dhYmxlSW5kZXgsXG4gICAgbmV3SW5kZXg6IG5ld0luZGV4LFxuICAgIG5ld0RyYWdnYWJsZUluZGV4OiBuZXdEcmFnZ2FibGVJbmRleFxuICB9LCBpbmZvKSk7XG59XG5cbnZhciBkcmFnRWwsXG4gICAgcGFyZW50RWwsXG4gICAgZ2hvc3RFbCxcbiAgICByb290RWwsXG4gICAgbmV4dEVsLFxuICAgIGxhc3REb3duRWwsXG4gICAgY2xvbmVFbCxcbiAgICBjbG9uZUhpZGRlbixcbiAgICBvbGRJbmRleCxcbiAgICBuZXdJbmRleCxcbiAgICBvbGREcmFnZ2FibGVJbmRleCxcbiAgICBuZXdEcmFnZ2FibGVJbmRleCxcbiAgICBhY3RpdmVHcm91cCxcbiAgICBwdXRTb3J0YWJsZSxcbiAgICBhd2FpdGluZ0RyYWdTdGFydGVkID0gZmFsc2UsXG4gICAgaWdub3JlTmV4dENsaWNrID0gZmFsc2UsXG4gICAgc29ydGFibGVzID0gW10sXG4gICAgdGFwRXZ0LFxuICAgIHRvdWNoRXZ0LFxuICAgIGxhc3REeCxcbiAgICBsYXN0RHksXG4gICAgdGFwRGlzdGFuY2VMZWZ0LFxuICAgIHRhcERpc3RhbmNlVG9wLFxuICAgIG1vdmVkLFxuICAgIGxhc3RUYXJnZXQsXG4gICAgbGFzdERpcmVjdGlvbixcbiAgICBwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggPSBmYWxzZSxcbiAgICBpc0NpcmN1bXN0YW50aWFsSW52ZXJ0ID0gZmFsc2UsXG4gICAgdGFyZ2V0TW92ZURpc3RhbmNlLFxuICAgIC8vIEZvciBwb3NpdGlvbmluZyBnaG9zdCBhYnNvbHV0ZWx5XG5naG9zdFJlbGF0aXZlUGFyZW50LFxuICAgIGdob3N0UmVsYXRpdmVQYXJlbnRJbml0aWFsU2Nyb2xsID0gW10sXG4gICAgLy8gKGxlZnQsIHRvcClcbl9zaWxlbnQgPSBmYWxzZSxcbiAgICBzYXZlZElucHV0Q2hlY2tlZCA9IFtdO1xuLyoqIEBjb25zdCAqL1xuXG52YXIgZG9jdW1lbnRFeGlzdHMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnLFxuICAgIFBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5ID0gSU9TLFxuICAgIENTU0Zsb2F0UHJvcGVydHkgPSBFZGdlIHx8IElFMTFPckxlc3MgPyAnY3NzRmxvYXQnIDogJ2Zsb2F0JyxcbiAgICAvLyBUaGlzIHdpbGwgbm90IHBhc3MgZm9yIElFOSwgYmVjYXVzZSBJRTkgRG5EIG9ubHkgd29ya3Mgb24gYW5jaG9yc1xuc3VwcG9ydERyYWdnYWJsZSA9IGRvY3VtZW50RXhpc3RzICYmICFDaHJvbWVGb3JBbmRyb2lkICYmICFJT1MgJiYgJ2RyYWdnYWJsZScgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgc3VwcG9ydENzc1BvaW50ZXJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghZG9jdW1lbnRFeGlzdHMpIHJldHVybjsgLy8gZmFsc2Ugd2hlbiA8PSBJRTExXG5cbiAgaWYgKElFMTFPckxlc3MpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd4Jyk7XG4gIGVsLnN0eWxlLmNzc1RleHQgPSAncG9pbnRlci1ldmVudHM6YXV0byc7XG4gIHJldHVybiBlbC5zdHlsZS5wb2ludGVyRXZlbnRzID09PSAnYXV0byc7XG59KCksXG4gICAgX2RldGVjdERpcmVjdGlvbiA9IGZ1bmN0aW9uIF9kZXRlY3REaXJlY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgdmFyIGVsQ1NTID0gY3NzKGVsKSxcbiAgICAgIGVsV2lkdGggPSBwYXJzZUludChlbENTUy53aWR0aCkgLSBwYXJzZUludChlbENTUy5wYWRkaW5nTGVmdCkgLSBwYXJzZUludChlbENTUy5wYWRkaW5nUmlnaHQpIC0gcGFyc2VJbnQoZWxDU1MuYm9yZGVyTGVmdFdpZHRoKSAtIHBhcnNlSW50KGVsQ1NTLmJvcmRlclJpZ2h0V2lkdGgpLFxuICAgICAgY2hpbGQxID0gZ2V0Q2hpbGQoZWwsIDAsIG9wdGlvbnMpLFxuICAgICAgY2hpbGQyID0gZ2V0Q2hpbGQoZWwsIDEsIG9wdGlvbnMpLFxuICAgICAgZmlyc3RDaGlsZENTUyA9IGNoaWxkMSAmJiBjc3MoY2hpbGQxKSxcbiAgICAgIHNlY29uZENoaWxkQ1NTID0gY2hpbGQyICYmIGNzcyhjaGlsZDIpLFxuICAgICAgZmlyc3RDaGlsZFdpZHRoID0gZmlyc3RDaGlsZENTUyAmJiBwYXJzZUludChmaXJzdENoaWxkQ1NTLm1hcmdpbkxlZnQpICsgcGFyc2VJbnQoZmlyc3RDaGlsZENTUy5tYXJnaW5SaWdodCkgKyBnZXRSZWN0KGNoaWxkMSkud2lkdGgsXG4gICAgICBzZWNvbmRDaGlsZFdpZHRoID0gc2Vjb25kQ2hpbGRDU1MgJiYgcGFyc2VJbnQoc2Vjb25kQ2hpbGRDU1MubWFyZ2luTGVmdCkgKyBwYXJzZUludChzZWNvbmRDaGlsZENTUy5tYXJnaW5SaWdodCkgKyBnZXRSZWN0KGNoaWxkMikud2lkdGg7XG5cbiAgaWYgKGVsQ1NTLmRpc3BsYXkgPT09ICdmbGV4Jykge1xuICAgIHJldHVybiBlbENTUy5mbGV4RGlyZWN0aW9uID09PSAnY29sdW1uJyB8fCBlbENTUy5mbGV4RGlyZWN0aW9uID09PSAnY29sdW1uLXJldmVyc2UnID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgfVxuXG4gIGlmIChlbENTUy5kaXNwbGF5ID09PSAnZ3JpZCcpIHtcbiAgICByZXR1cm4gZWxDU1MuZ3JpZFRlbXBsYXRlQ29sdW1ucy5zcGxpdCgnICcpLmxlbmd0aCA8PSAxID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgfVxuXG4gIGlmIChjaGlsZDEgJiYgZmlyc3RDaGlsZENTU1tcImZsb2F0XCJdICYmIGZpcnN0Q2hpbGRDU1NbXCJmbG9hdFwiXSAhPT0gJ25vbmUnKSB7XG4gICAgdmFyIHRvdWNoaW5nU2lkZUNoaWxkMiA9IGZpcnN0Q2hpbGRDU1NbXCJmbG9hdFwiXSA9PT0gJ2xlZnQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICByZXR1cm4gY2hpbGQyICYmIChzZWNvbmRDaGlsZENTUy5jbGVhciA9PT0gJ2JvdGgnIHx8IHNlY29uZENoaWxkQ1NTLmNsZWFyID09PSB0b3VjaGluZ1NpZGVDaGlsZDIpID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgfVxuXG4gIHJldHVybiBjaGlsZDEgJiYgKGZpcnN0Q2hpbGRDU1MuZGlzcGxheSA9PT0gJ2Jsb2NrJyB8fCBmaXJzdENoaWxkQ1NTLmRpc3BsYXkgPT09ICdmbGV4JyB8fCBmaXJzdENoaWxkQ1NTLmRpc3BsYXkgPT09ICd0YWJsZScgfHwgZmlyc3RDaGlsZENTUy5kaXNwbGF5ID09PSAnZ3JpZCcgfHwgZmlyc3RDaGlsZFdpZHRoID49IGVsV2lkdGggJiYgZWxDU1NbQ1NTRmxvYXRQcm9wZXJ0eV0gPT09ICdub25lJyB8fCBjaGlsZDIgJiYgZWxDU1NbQ1NTRmxvYXRQcm9wZXJ0eV0gPT09ICdub25lJyAmJiBmaXJzdENoaWxkV2lkdGggKyBzZWNvbmRDaGlsZFdpZHRoID4gZWxXaWR0aCkgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xufSxcbiAgICBfZHJhZ0VsSW5Sb3dDb2x1bW4gPSBmdW5jdGlvbiBfZHJhZ0VsSW5Sb3dDb2x1bW4oZHJhZ1JlY3QsIHRhcmdldFJlY3QsIHZlcnRpY2FsKSB7XG4gIHZhciBkcmFnRWxTMU9wcCA9IHZlcnRpY2FsID8gZHJhZ1JlY3QubGVmdCA6IGRyYWdSZWN0LnRvcCxcbiAgICAgIGRyYWdFbFMyT3BwID0gdmVydGljYWwgPyBkcmFnUmVjdC5yaWdodCA6IGRyYWdSZWN0LmJvdHRvbSxcbiAgICAgIGRyYWdFbE9wcExlbmd0aCA9IHZlcnRpY2FsID8gZHJhZ1JlY3Qud2lkdGggOiBkcmFnUmVjdC5oZWlnaHQsXG4gICAgICB0YXJnZXRTMU9wcCA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC5sZWZ0IDogdGFyZ2V0UmVjdC50b3AsXG4gICAgICB0YXJnZXRTMk9wcCA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC5yaWdodCA6IHRhcmdldFJlY3QuYm90dG9tLFxuICAgICAgdGFyZ2V0T3BwTGVuZ3RoID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LndpZHRoIDogdGFyZ2V0UmVjdC5oZWlnaHQ7XG4gIHJldHVybiBkcmFnRWxTMU9wcCA9PT0gdGFyZ2V0UzFPcHAgfHwgZHJhZ0VsUzJPcHAgPT09IHRhcmdldFMyT3BwIHx8IGRyYWdFbFMxT3BwICsgZHJhZ0VsT3BwTGVuZ3RoIC8gMiA9PT0gdGFyZ2V0UzFPcHAgKyB0YXJnZXRPcHBMZW5ndGggLyAyO1xufSxcblxuLyoqXG4gKiBEZXRlY3RzIGZpcnN0IG5lYXJlc3QgZW1wdHkgc29ydGFibGUgdG8gWCBhbmQgWSBwb3NpdGlvbiB1c2luZyBlbXB0eUluc2VydFRocmVzaG9sZC5cbiAqIEBwYXJhbSAge051bWJlcn0geCAgICAgIFggcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0geSAgICAgIFkgcG9zaXRpb25cbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgIEVsZW1lbnQgb2YgdGhlIGZpcnN0IGZvdW5kIG5lYXJlc3QgU29ydGFibGVcbiAqL1xuX2RldGVjdE5lYXJlc3RFbXB0eVNvcnRhYmxlID0gZnVuY3Rpb24gX2RldGVjdE5lYXJlc3RFbXB0eVNvcnRhYmxlKHgsIHkpIHtcbiAgdmFyIHJldDtcbiAgc29ydGFibGVzLnNvbWUoZnVuY3Rpb24gKHNvcnRhYmxlKSB7XG4gICAgdmFyIHRocmVzaG9sZCA9IHNvcnRhYmxlW2V4cGFuZG9dLm9wdGlvbnMuZW1wdHlJbnNlcnRUaHJlc2hvbGQ7XG4gICAgaWYgKCF0aHJlc2hvbGQgfHwgbGFzdENoaWxkKHNvcnRhYmxlKSkgcmV0dXJuO1xuICAgIHZhciByZWN0ID0gZ2V0UmVjdChzb3J0YWJsZSksXG4gICAgICAgIGluc2lkZUhvcml6b250YWxseSA9IHggPj0gcmVjdC5sZWZ0IC0gdGhyZXNob2xkICYmIHggPD0gcmVjdC5yaWdodCArIHRocmVzaG9sZCxcbiAgICAgICAgaW5zaWRlVmVydGljYWxseSA9IHkgPj0gcmVjdC50b3AgLSB0aHJlc2hvbGQgJiYgeSA8PSByZWN0LmJvdHRvbSArIHRocmVzaG9sZDtcblxuICAgIGlmIChpbnNpZGVIb3Jpem9udGFsbHkgJiYgaW5zaWRlVmVydGljYWxseSkge1xuICAgICAgcmV0dXJuIHJldCA9IHNvcnRhYmxlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXQ7XG59LFxuICAgIF9wcmVwYXJlR3JvdXAgPSBmdW5jdGlvbiBfcHJlcGFyZUdyb3VwKG9wdGlvbnMpIHtcbiAgZnVuY3Rpb24gdG9Gbih2YWx1ZSwgcHVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodG8sIGZyb20sIGRyYWdFbCwgZXZ0KSB7XG4gICAgICB2YXIgc2FtZUdyb3VwID0gdG8ub3B0aW9ucy5ncm91cC5uYW1lICYmIGZyb20ub3B0aW9ucy5ncm91cC5uYW1lICYmIHRvLm9wdGlvbnMuZ3JvdXAubmFtZSA9PT0gZnJvbS5vcHRpb25zLmdyb3VwLm5hbWU7XG5cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmIChwdWxsIHx8IHNhbWVHcm91cCkpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBwdWxsIHZhbHVlXG4gICAgICAgIC8vIERlZmF1bHQgcHVsbCBhbmQgcHV0IHZhbHVlIGlmIHNhbWUgZ3JvdXBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAocHVsbCAmJiB2YWx1ZSA9PT0gJ2Nsb25lJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdG9Gbih2YWx1ZSh0bywgZnJvbSwgZHJhZ0VsLCBldnQpLCBwdWxsKSh0bywgZnJvbSwgZHJhZ0VsLCBldnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG90aGVyR3JvdXAgPSAocHVsbCA/IHRvIDogZnJvbSkub3B0aW9ucy5ncm91cC5uYW1lO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZSA9PT0gb3RoZXJHcm91cCB8fCB2YWx1ZS5qb2luICYmIHZhbHVlLmluZGV4T2Yob3RoZXJHcm91cCkgPiAtMTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGdyb3VwID0ge307XG4gIHZhciBvcmlnaW5hbEdyb3VwID0gb3B0aW9ucy5ncm91cDtcblxuICBpZiAoIW9yaWdpbmFsR3JvdXAgfHwgX3R5cGVvZihvcmlnaW5hbEdyb3VwKSAhPSAnb2JqZWN0Jykge1xuICAgIG9yaWdpbmFsR3JvdXAgPSB7XG4gICAgICBuYW1lOiBvcmlnaW5hbEdyb3VwXG4gICAgfTtcbiAgfVxuXG4gIGdyb3VwLm5hbWUgPSBvcmlnaW5hbEdyb3VwLm5hbWU7XG4gIGdyb3VwLmNoZWNrUHVsbCA9IHRvRm4ob3JpZ2luYWxHcm91cC5wdWxsLCB0cnVlKTtcbiAgZ3JvdXAuY2hlY2tQdXQgPSB0b0ZuKG9yaWdpbmFsR3JvdXAucHV0KTtcbiAgZ3JvdXAucmV2ZXJ0Q2xvbmUgPSBvcmlnaW5hbEdyb3VwLnJldmVydENsb25lO1xuICBvcHRpb25zLmdyb3VwID0gZ3JvdXA7XG59LFxuICAgIF9oaWRlR2hvc3RGb3JUYXJnZXQgPSBmdW5jdGlvbiBfaGlkZUdob3N0Rm9yVGFyZ2V0KCkge1xuICBpZiAoIXN1cHBvcnRDc3NQb2ludGVyRXZlbnRzICYmIGdob3N0RWwpIHtcbiAgICBjc3MoZ2hvc3RFbCwgJ2Rpc3BsYXknLCAnbm9uZScpO1xuICB9XG59LFxuICAgIF91bmhpZGVHaG9zdEZvclRhcmdldCA9IGZ1bmN0aW9uIF91bmhpZGVHaG9zdEZvclRhcmdldCgpIHtcbiAgaWYgKCFzdXBwb3J0Q3NzUG9pbnRlckV2ZW50cyAmJiBnaG9zdEVsKSB7XG4gICAgY3NzKGdob3N0RWwsICdkaXNwbGF5JywgJycpO1xuICB9XG59OyAvLyAjMTE4NCBmaXggLSBQcmV2ZW50IGNsaWNrIGV2ZW50IG9uIGZhbGxiYWNrIGlmIGRyYWdnZWQgYnV0IGl0ZW0gbm90IGNoYW5nZWQgcG9zaXRpb25cblxuXG5pZiAoZG9jdW1lbnRFeGlzdHMpIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgaWYgKGlnbm9yZU5leHRDbGljaykge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uICYmIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2dC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gJiYgZXZ0LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgaWdub3JlTmV4dENsaWNrID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB0cnVlKTtcbn1cblxudmFyIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50ID0gZnVuY3Rpb24gbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQoZXZ0KSB7XG4gIGlmIChkcmFnRWwpIHtcbiAgICBldnQgPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0O1xuXG4gICAgdmFyIG5lYXJlc3QgPSBfZGV0ZWN0TmVhcmVzdEVtcHR5U29ydGFibGUoZXZ0LmNsaWVudFgsIGV2dC5jbGllbnRZKTtcblxuICAgIGlmIChuZWFyZXN0KSB7XG4gICAgICAvLyBDcmVhdGUgaW1pdGF0aW9uIGV2ZW50XG4gICAgICB2YXIgZXZlbnQgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSBpbiBldnQpIHtcbiAgICAgICAgaWYgKGV2dC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIGV2ZW50W2ldID0gZXZ0W2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnRhcmdldCA9IGV2ZW50LnJvb3RFbCA9IG5lYXJlc3Q7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IHZvaWQgMDtcblxuICAgICAgbmVhcmVzdFtleHBhbmRvXS5fb25EcmFnT3ZlcihldmVudCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgX2NoZWNrT3V0c2lkZVRhcmdldEVsID0gZnVuY3Rpb24gX2NoZWNrT3V0c2lkZVRhcmdldEVsKGV2dCkge1xuICBpZiAoZHJhZ0VsKSB7XG4gICAgZHJhZ0VsLnBhcmVudE5vZGVbZXhwYW5kb10uX2lzT3V0c2lkZVRoaXNFbChldnQudGFyZ2V0KTtcbiAgfVxufTtcbi8qKlxuICogQGNsYXNzICBTb3J0YWJsZVxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9ICBlbFxuICogQHBhcmFtICB7T2JqZWN0fSAgICAgICBbb3B0aW9uc11cbiAqL1xuXG5cbmZ1bmN0aW9uIFNvcnRhYmxlKGVsLCBvcHRpb25zKSB7XG4gIGlmICghKGVsICYmIGVsLm5vZGVUeXBlICYmIGVsLm5vZGVUeXBlID09PSAxKSkge1xuICAgIHRocm93IFwiU29ydGFibGU6IGBlbGAgbXVzdCBiZSBhbiBIVE1MRWxlbWVudCwgbm90IFwiLmNvbmNhdCh7fS50b1N0cmluZy5jYWxsKGVsKSk7XG4gIH1cblxuICB0aGlzLmVsID0gZWw7IC8vIHJvb3QgZWxlbWVudFxuXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgb3B0aW9ucyk7IC8vIEV4cG9ydCBpbnN0YW5jZVxuXG4gIGVsW2V4cGFuZG9dID0gdGhpcztcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGdyb3VwOiBudWxsLFxuICAgIHNvcnQ6IHRydWUsXG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgIHN0b3JlOiBudWxsLFxuICAgIGhhbmRsZTogbnVsbCxcbiAgICBkcmFnZ2FibGU6IC9eW3VvXWwkL2kudGVzdChlbC5ub2RlTmFtZSkgPyAnPmxpJyA6ICc+KicsXG4gICAgc3dhcFRocmVzaG9sZDogMSxcbiAgICAvLyBwZXJjZW50YWdlOyAwIDw9IHggPD0gMVxuICAgIGludmVydFN3YXA6IGZhbHNlLFxuICAgIC8vIGludmVydCBhbHdheXNcbiAgICBpbnZlcnRlZFN3YXBUaHJlc2hvbGQ6IG51bGwsXG4gICAgLy8gd2lsbCBiZSBzZXQgdG8gc2FtZSBhcyBzd2FwVGhyZXNob2xkIGlmIGRlZmF1bHRcbiAgICByZW1vdmVDbG9uZU9uSGlkZTogdHJ1ZSxcbiAgICBkaXJlY3Rpb246IGZ1bmN0aW9uIGRpcmVjdGlvbigpIHtcbiAgICAgIHJldHVybiBfZGV0ZWN0RGlyZWN0aW9uKGVsLCB0aGlzLm9wdGlvbnMpO1xuICAgIH0sXG4gICAgZ2hvc3RDbGFzczogJ3NvcnRhYmxlLWdob3N0JyxcbiAgICBjaG9zZW5DbGFzczogJ3NvcnRhYmxlLWNob3NlbicsXG4gICAgZHJhZ0NsYXNzOiAnc29ydGFibGUtZHJhZycsXG4gICAgaWdub3JlOiAnYSwgaW1nJyxcbiAgICBmaWx0ZXI6IG51bGwsXG4gICAgcHJldmVudE9uRmlsdGVyOiB0cnVlLFxuICAgIGFuaW1hdGlvbjogMCxcbiAgICBlYXNpbmc6IG51bGwsXG4gICAgc2V0RGF0YTogZnVuY3Rpb24gc2V0RGF0YShkYXRhVHJhbnNmZXIsIGRyYWdFbCkge1xuICAgICAgZGF0YVRyYW5zZmVyLnNldERhdGEoJ1RleHQnLCBkcmFnRWwudGV4dENvbnRlbnQpO1xuICAgIH0sXG4gICAgZHJvcEJ1YmJsZTogZmFsc2UsXG4gICAgZHJhZ292ZXJCdWJibGU6IGZhbHNlLFxuICAgIGRhdGFJZEF0dHI6ICdkYXRhLWlkJyxcbiAgICBkZWxheTogMCxcbiAgICBkZWxheU9uVG91Y2hPbmx5OiBmYWxzZSxcbiAgICB0b3VjaFN0YXJ0VGhyZXNob2xkOiAoTnVtYmVyLnBhcnNlSW50ID8gTnVtYmVyIDogd2luZG93KS5wYXJzZUludCh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbywgMTApIHx8IDEsXG4gICAgZm9yY2VGYWxsYmFjazogZmFsc2UsXG4gICAgZmFsbGJhY2tDbGFzczogJ3NvcnRhYmxlLWZhbGxiYWNrJyxcbiAgICBmYWxsYmFja09uQm9keTogZmFsc2UsXG4gICAgZmFsbGJhY2tUb2xlcmFuY2U6IDAsXG4gICAgZmFsbGJhY2tPZmZzZXQ6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSxcbiAgICBzdXBwb3J0UG9pbnRlcjogU29ydGFibGUuc3VwcG9ydFBvaW50ZXIgIT09IGZhbHNlICYmICdQb2ludGVyRXZlbnQnIGluIHdpbmRvdyAmJiAhU2FmYXJpLFxuICAgIGVtcHR5SW5zZXJ0VGhyZXNob2xkOiA1XG4gIH07XG4gIFBsdWdpbk1hbmFnZXIuaW5pdGlhbGl6ZVBsdWdpbnModGhpcywgZWwsIGRlZmF1bHRzKTsgLy8gU2V0IGRlZmF1bHQgb3B0aW9uc1xuXG4gIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdHMpIHtcbiAgICAhKG5hbWUgaW4gb3B0aW9ucykgJiYgKG9wdGlvbnNbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXSk7XG4gIH1cblxuICBfcHJlcGFyZUdyb3VwKG9wdGlvbnMpOyAvLyBCaW5kIGFsbCBwcml2YXRlIG1ldGhvZHNcblxuXG4gIGZvciAodmFyIGZuIGluIHRoaXMpIHtcbiAgICBpZiAoZm4uY2hhckF0KDApID09PSAnXycgJiYgdHlwZW9mIHRoaXNbZm5dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ZuXSA9IHRoaXNbZm5dLmJpbmQodGhpcyk7XG4gICAgfVxuICB9IC8vIFNldHVwIGRyYWcgbW9kZVxuXG5cbiAgdGhpcy5uYXRpdmVEcmFnZ2FibGUgPSBvcHRpb25zLmZvcmNlRmFsbGJhY2sgPyBmYWxzZSA6IHN1cHBvcnREcmFnZ2FibGU7XG5cbiAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgLy8gVG91Y2ggc3RhcnQgdGhyZXNob2xkIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gdGhlIG5hdGl2ZSBkcmFnc3RhcnQgdGhyZXNob2xkXG4gICAgdGhpcy5vcHRpb25zLnRvdWNoU3RhcnRUaHJlc2hvbGQgPSAxO1xuICB9IC8vIEJpbmQgZXZlbnRzXG5cblxuICBpZiAob3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgIG9uKGVsLCAncG9pbnRlcmRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgfSBlbHNlIHtcbiAgICBvbihlbCwgJ21vdXNlZG93bicsIHRoaXMuX29uVGFwU3RhcnQpO1xuICAgIG9uKGVsLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVGFwU3RhcnQpO1xuICB9XG5cbiAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgb24oZWwsICdkcmFnb3ZlcicsIHRoaXMpO1xuICAgIG9uKGVsLCAnZHJhZ2VudGVyJywgdGhpcyk7XG4gIH1cblxuICBzb3J0YWJsZXMucHVzaCh0aGlzLmVsKTsgLy8gUmVzdG9yZSBzb3J0aW5nXG5cbiAgb3B0aW9ucy5zdG9yZSAmJiBvcHRpb25zLnN0b3JlLmdldCAmJiB0aGlzLnNvcnQob3B0aW9ucy5zdG9yZS5nZXQodGhpcykgfHwgW10pOyAvLyBBZGQgYW5pbWF0aW9uIHN0YXRlIG1hbmFnZXJcblxuICBfZXh0ZW5kcyh0aGlzLCBBbmltYXRpb25TdGF0ZU1hbmFnZXIoKSk7XG59XG5cblNvcnRhYmxlLnByb3RvdHlwZSA9XG4vKiogQGxlbmRzIFNvcnRhYmxlLnByb3RvdHlwZSAqL1xue1xuICBjb25zdHJ1Y3RvcjogU29ydGFibGUsXG4gIF9pc091dHNpZGVUaGlzRWw6IGZ1bmN0aW9uIF9pc091dHNpZGVUaGlzRWwodGFyZ2V0KSB7XG4gICAgaWYgKCF0aGlzLmVsLmNvbnRhaW5zKHRhcmdldCkgJiYgdGFyZ2V0ICE9PSB0aGlzLmVsKSB7XG4gICAgICBsYXN0VGFyZ2V0ID0gbnVsbDtcbiAgICB9XG4gIH0sXG4gIF9nZXREaXJlY3Rpb246IGZ1bmN0aW9uIF9nZXREaXJlY3Rpb24oZXZ0LCB0YXJnZXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMub3B0aW9ucy5kaXJlY3Rpb24gPT09ICdmdW5jdGlvbicgPyB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uLmNhbGwodGhpcywgZXZ0LCB0YXJnZXQsIGRyYWdFbCkgOiB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICB9LFxuICBfb25UYXBTdGFydDogZnVuY3Rpb24gX29uVGFwU3RhcnQoXG4gIC8qKiBFdmVudHxUb3VjaEV2ZW50ICovXG4gIGV2dCkge1xuICAgIGlmICghZXZ0LmNhbmNlbGFibGUpIHJldHVybjtcblxuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIGVsID0gdGhpcy5lbCxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgcHJldmVudE9uRmlsdGVyID0gb3B0aW9ucy5wcmV2ZW50T25GaWx0ZXIsXG4gICAgICAgIHR5cGUgPSBldnQudHlwZSxcbiAgICAgICAgdG91Y2ggPSBldnQudG91Y2hlcyAmJiBldnQudG91Y2hlc1swXSB8fCBldnQucG9pbnRlclR5cGUgJiYgZXZ0LnBvaW50ZXJUeXBlID09PSAndG91Y2gnICYmIGV2dCxcbiAgICAgICAgdGFyZ2V0ID0gKHRvdWNoIHx8IGV2dCkudGFyZ2V0LFxuICAgICAgICBvcmlnaW5hbFRhcmdldCA9IGV2dC50YXJnZXQuc2hhZG93Um9vdCAmJiAoZXZ0LnBhdGggJiYgZXZ0LnBhdGhbMF0gfHwgZXZ0LmNvbXBvc2VkUGF0aCAmJiBldnQuY29tcG9zZWRQYXRoKClbMF0pIHx8IHRhcmdldCxcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG5cbiAgICBfc2F2ZUlucHV0Q2hlY2tlZFN0YXRlKGVsKTsgLy8gRG9uJ3QgdHJpZ2dlciBzdGFydCBldmVudCB3aGVuIGFuIGVsZW1lbnQgaXMgYmVlbiBkcmFnZ2VkLCBvdGhlcndpc2UgdGhlIGV2dC5vbGRpbmRleCBhbHdheXMgd3Jvbmcgd2hlbiBzZXQgb3B0aW9uLmdyb3VwLlxuXG5cbiAgICBpZiAoZHJhZ0VsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKC9tb3VzZWRvd258cG9pbnRlcmRvd24vLnRlc3QodHlwZSkgJiYgZXZ0LmJ1dHRvbiAhPT0gMCB8fCBvcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47IC8vIG9ubHkgbGVmdCBidXR0b24gYW5kIGVuYWJsZWRcbiAgICB9IC8vIGNhbmNlbCBkbmQgaWYgb3JpZ2luYWwgdGFyZ2V0IGlzIGNvbnRlbnQgZWRpdGFibGVcblxuXG4gICAgaWYgKG9yaWdpbmFsVGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBTYWZhcmkgaWdub3JlcyBmdXJ0aGVyIGV2ZW50IGhhbmRsaW5nIGFmdGVyIG1vdXNlZG93blxuXG5cbiAgICBpZiAoIXRoaXMubmF0aXZlRHJhZ2dhYmxlICYmIFNhZmFyaSAmJiB0YXJnZXQgJiYgdGFyZ2V0LnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSBjbG9zZXN0KHRhcmdldCwgb3B0aW9ucy5kcmFnZ2FibGUsIGVsLCBmYWxzZSk7XG5cbiAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5hbmltYXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsYXN0RG93bkVsID09PSB0YXJnZXQpIHtcbiAgICAgIC8vIElnbm9yaW5nIGR1cGxpY2F0ZSBgZG93bmBcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGRyYWdnZWQgZWxlbWVudCB3aXRoaW4gaXRzIHBhcmVudFxuXG5cbiAgICBvbGRJbmRleCA9IGluZGV4KHRhcmdldCk7XG4gICAgb2xkRHJhZ2dhYmxlSW5kZXggPSBpbmRleCh0YXJnZXQsIG9wdGlvbnMuZHJhZ2dhYmxlKTsgLy8gQ2hlY2sgZmlsdGVyXG5cbiAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGZpbHRlci5jYWxsKHRoaXMsIGV2dCwgdGFyZ2V0LCB0aGlzKSkge1xuICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgc29ydGFibGU6IF90aGlzLFxuICAgICAgICAgIHJvb3RFbDogb3JpZ2luYWxUYXJnZXQsXG4gICAgICAgICAgbmFtZTogJ2ZpbHRlcicsXG4gICAgICAgICAgdGFyZ2V0RWw6IHRhcmdldCxcbiAgICAgICAgICB0b0VsOiBlbCxcbiAgICAgICAgICBmcm9tRWw6IGVsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBsdWdpbkV2ZW50KCdmaWx0ZXInLCBfdGhpcywge1xuICAgICAgICAgIGV2dDogZXZ0XG4gICAgICAgIH0pO1xuICAgICAgICBwcmV2ZW50T25GaWx0ZXIgJiYgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjsgLy8gY2FuY2VsIGRuZFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZmlsdGVyKSB7XG4gICAgICBmaWx0ZXIgPSBmaWx0ZXIuc3BsaXQoJywnKS5zb21lKGZ1bmN0aW9uIChjcml0ZXJpYSkge1xuICAgICAgICBjcml0ZXJpYSA9IGNsb3Nlc3Qob3JpZ2luYWxUYXJnZXQsIGNyaXRlcmlhLnRyaW0oKSwgZWwsIGZhbHNlKTtcblxuICAgICAgICBpZiAoY3JpdGVyaWEpIHtcbiAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgICAgICByb290RWw6IGNyaXRlcmlhLFxuICAgICAgICAgICAgbmFtZTogJ2ZpbHRlcicsXG4gICAgICAgICAgICB0YXJnZXRFbDogdGFyZ2V0LFxuICAgICAgICAgICAgZnJvbUVsOiBlbCxcbiAgICAgICAgICAgIHRvRWw6IGVsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBwbHVnaW5FdmVudCgnZmlsdGVyJywgX3RoaXMsIHtcbiAgICAgICAgICAgIGV2dDogZXZ0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgIHByZXZlbnRPbkZpbHRlciAmJiBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuOyAvLyBjYW5jZWwgZG5kXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaGFuZGxlICYmICFjbG9zZXN0KG9yaWdpbmFsVGFyZ2V0LCBvcHRpb25zLmhhbmRsZSwgZWwsIGZhbHNlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gUHJlcGFyZSBgZHJhZ3N0YXJ0YFxuXG5cbiAgICB0aGlzLl9wcmVwYXJlRHJhZ1N0YXJ0KGV2dCwgdG91Y2gsIHRhcmdldCk7XG4gIH0sXG4gIF9wcmVwYXJlRHJhZ1N0YXJ0OiBmdW5jdGlvbiBfcHJlcGFyZURyYWdTdGFydChcbiAgLyoqIEV2ZW50ICovXG4gIGV2dCxcbiAgLyoqIFRvdWNoICovXG4gIHRvdWNoLFxuICAvKiogSFRNTEVsZW1lbnQgKi9cbiAgdGFyZ2V0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgZWwgPSBfdGhpcy5lbCxcbiAgICAgICAgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnMsXG4gICAgICAgIG93bmVyRG9jdW1lbnQgPSBlbC5vd25lckRvY3VtZW50LFxuICAgICAgICBkcmFnU3RhcnRGbjtcblxuICAgIGlmICh0YXJnZXQgJiYgIWRyYWdFbCAmJiB0YXJnZXQucGFyZW50Tm9kZSA9PT0gZWwpIHtcbiAgICAgIHZhciBkcmFnUmVjdCA9IGdldFJlY3QodGFyZ2V0KTtcbiAgICAgIHJvb3RFbCA9IGVsO1xuICAgICAgZHJhZ0VsID0gdGFyZ2V0O1xuICAgICAgcGFyZW50RWwgPSBkcmFnRWwucGFyZW50Tm9kZTtcbiAgICAgIG5leHRFbCA9IGRyYWdFbC5uZXh0U2libGluZztcbiAgICAgIGxhc3REb3duRWwgPSB0YXJnZXQ7XG4gICAgICBhY3RpdmVHcm91cCA9IG9wdGlvbnMuZ3JvdXA7XG4gICAgICBTb3J0YWJsZS5kcmFnZ2VkID0gZHJhZ0VsO1xuICAgICAgdGFwRXZ0ID0ge1xuICAgICAgICB0YXJnZXQ6IGRyYWdFbCxcbiAgICAgICAgY2xpZW50WDogKHRvdWNoIHx8IGV2dCkuY2xpZW50WCxcbiAgICAgICAgY2xpZW50WTogKHRvdWNoIHx8IGV2dCkuY2xpZW50WVxuICAgICAgfTtcbiAgICAgIHRhcERpc3RhbmNlTGVmdCA9IHRhcEV2dC5jbGllbnRYIC0gZHJhZ1JlY3QubGVmdDtcbiAgICAgIHRhcERpc3RhbmNlVG9wID0gdGFwRXZ0LmNsaWVudFkgLSBkcmFnUmVjdC50b3A7XG4gICAgICB0aGlzLl9sYXN0WCA9ICh0b3VjaCB8fCBldnQpLmNsaWVudFg7XG4gICAgICB0aGlzLl9sYXN0WSA9ICh0b3VjaCB8fCBldnQpLmNsaWVudFk7XG4gICAgICBkcmFnRWwuc3R5bGVbJ3dpbGwtY2hhbmdlJ10gPSAnYWxsJztcblxuICAgICAgZHJhZ1N0YXJ0Rm4gPSBmdW5jdGlvbiBkcmFnU3RhcnRGbigpIHtcbiAgICAgICAgcGx1Z2luRXZlbnQoJ2RlbGF5RW5kZWQnLCBfdGhpcywge1xuICAgICAgICAgIGV2dDogZXZ0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICAgICAgX3RoaXMuX29uRHJvcCgpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIERlbGF5ZWQgZHJhZyBoYXMgYmVlbiB0cmlnZ2VyZWRcbiAgICAgICAgLy8gd2UgY2FuIHJlLWVuYWJsZSB0aGUgZXZlbnRzOiB0b3VjaG1vdmUvbW91c2Vtb3ZlXG5cblxuICAgICAgICBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnRXZlbnRzKCk7XG5cbiAgICAgICAgaWYgKCFGaXJlRm94ICYmIF90aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICAgIGRyYWdFbC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICB9IC8vIEJpbmQgdGhlIGV2ZW50czogZHJhZ3N0YXJ0L2RyYWdlbmRcblxuXG4gICAgICAgIF90aGlzLl90cmlnZ2VyRHJhZ1N0YXJ0KGV2dCwgdG91Y2gpOyAvLyBEcmFnIHN0YXJ0IGV2ZW50XG5cblxuICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgc29ydGFibGU6IF90aGlzLFxuICAgICAgICAgIG5hbWU6ICdjaG9vc2UnLFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICB9KTsgLy8gQ2hvc2VuIGl0ZW1cblxuXG4gICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5jaG9zZW5DbGFzcywgdHJ1ZSk7XG4gICAgICB9OyAvLyBEaXNhYmxlIFwiZHJhZ2dhYmxlXCJcblxuXG4gICAgICBvcHRpb25zLmlnbm9yZS5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24gKGNyaXRlcmlhKSB7XG4gICAgICAgIGZpbmQoZHJhZ0VsLCBjcml0ZXJpYS50cmltKCksIF9kaXNhYmxlRHJhZ2dhYmxlKTtcbiAgICAgIH0pO1xuICAgICAgb24ob3duZXJEb2N1bWVudCwgJ2RyYWdvdmVyJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgICAgb24ob3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaG1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgICBvbihvd25lckRvY3VtZW50LCAnbW91c2V1cCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCBfdGhpcy5fb25Ecm9wKTsgLy8gTWFrZSBkcmFnRWwgZHJhZ2dhYmxlIChtdXN0IGJlIGJlZm9yZSBkZWxheSBmb3IgRmlyZUZveClcblxuICAgICAgaWYgKEZpcmVGb3ggJiYgdGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnRvdWNoU3RhcnRUaHJlc2hvbGQgPSA0O1xuICAgICAgICBkcmFnRWwuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcGx1Z2luRXZlbnQoJ2RlbGF5U3RhcnQnLCB0aGlzLCB7XG4gICAgICAgIGV2dDogZXZ0XG4gICAgICB9KTsgLy8gRGVsYXkgaXMgaW1wb3NzaWJsZSBmb3IgbmF0aXZlIERuRCBpbiBFZGdlIG9yIElFXG5cbiAgICAgIGlmIChvcHRpb25zLmRlbGF5ICYmICghb3B0aW9ucy5kZWxheU9uVG91Y2hPbmx5IHx8IHRvdWNoKSAmJiAoIXRoaXMubmF0aXZlRHJhZ2dhYmxlIHx8ICEoRWRnZSB8fCBJRTExT3JMZXNzKSkpIHtcbiAgICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgICAgICB0aGlzLl9vbkRyb3AoKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBJZiB0aGUgdXNlciBtb3ZlcyB0aGUgcG9pbnRlciBvciBsZXQgZ28gdGhlIGNsaWNrIG9yIHRvdWNoXG4gICAgICAgIC8vIGJlZm9yZSB0aGUgZGVsYXkgaGFzIGJlZW4gcmVhY2hlZDpcbiAgICAgICAgLy8gZGlzYWJsZSB0aGUgZGVsYXllZCBkcmFnXG5cblxuICAgICAgICBvbihvd25lckRvY3VtZW50LCAnbW91c2V1cCcsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBfdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNobW92ZScsIF90aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgICAgICBvcHRpb25zLnN1cHBvcnRQb2ludGVyICYmIG9uKG93bmVyRG9jdW1lbnQsICdwb2ludGVybW92ZScsIF90aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgICAgICBfdGhpcy5fZHJhZ1N0YXJ0VGltZXIgPSBzZXRUaW1lb3V0KGRyYWdTdGFydEZuLCBvcHRpb25zLmRlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyYWdTdGFydEZuKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBfZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyOiBmdW5jdGlvbiBfZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKFxuICAvKiogVG91Y2hFdmVudHxQb2ludGVyRXZlbnQgKiovXG4gIGUpIHtcbiAgICB2YXIgdG91Y2ggPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlO1xuXG4gICAgaWYgKE1hdGgubWF4KE1hdGguYWJzKHRvdWNoLmNsaWVudFggLSB0aGlzLl9sYXN0WCksIE1hdGguYWJzKHRvdWNoLmNsaWVudFkgLSB0aGlzLl9sYXN0WSkpID49IE1hdGguZmxvb3IodGhpcy5vcHRpb25zLnRvdWNoU3RhcnRUaHJlc2hvbGQgLyAodGhpcy5uYXRpdmVEcmFnZ2FibGUgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkpKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcoKTtcbiAgICB9XG4gIH0sXG4gIF9kaXNhYmxlRGVsYXllZERyYWc6IGZ1bmN0aW9uIF9kaXNhYmxlRGVsYXllZERyYWcoKSB7XG4gICAgZHJhZ0VsICYmIF9kaXNhYmxlRHJhZ2dhYmxlKGRyYWdFbCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2RyYWdTdGFydFRpbWVyKTtcblxuICAgIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cygpO1xuICB9LFxuICBfZGlzYWJsZURlbGF5ZWREcmFnRXZlbnRzOiBmdW5jdGlvbiBfZGlzYWJsZURlbGF5ZWREcmFnRXZlbnRzKCkge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gdGhpcy5lbC5vd25lckRvY3VtZW50O1xuICAgIG9mZihvd25lckRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgfSxcbiAgX3RyaWdnZXJEcmFnU3RhcnQ6IGZ1bmN0aW9uIF90cmlnZ2VyRHJhZ1N0YXJ0KFxuICAvKiogRXZlbnQgKi9cbiAgZXZ0LFxuICAvKiogVG91Y2ggKi9cbiAgdG91Y2gpIHtcbiAgICB0b3VjaCA9IHRvdWNoIHx8IGV2dC5wb2ludGVyVHlwZSA9PSAndG91Y2gnICYmIGV2dDtcblxuICAgIGlmICghdGhpcy5uYXRpdmVEcmFnZ2FibGUgfHwgdG91Y2gpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICAgIH0gZWxzZSBpZiAodG91Y2gpIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb24oZHJhZ0VsLCAnZHJhZ2VuZCcsIHRoaXMpO1xuICAgICAgb24ocm9vdEVsLCAnZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgICAgIC8vIFRpbWVvdXQgbmVjY2Vzc2FyeSBmb3IgSUU5XG4gICAgICAgIF9uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZG9jdW1lbnQuc2VsZWN0aW9uLmVtcHR5KCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge31cbiAgfSxcbiAgX2RyYWdTdGFydGVkOiBmdW5jdGlvbiBfZHJhZ1N0YXJ0ZWQoZmFsbGJhY2ssIGV2dCkge1xuXG4gICAgYXdhaXRpbmdEcmFnU3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKHJvb3RFbCAmJiBkcmFnRWwpIHtcbiAgICAgIHBsdWdpbkV2ZW50KCdkcmFnU3RhcnRlZCcsIHRoaXMsIHtcbiAgICAgICAgZXZ0OiBldnRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdkcmFnb3ZlcicsIF9jaGVja091dHNpZGVUYXJnZXRFbCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zOyAvLyBBcHBseSBlZmZlY3RcblxuICAgICAgIWZhbGxiYWNrICYmIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5kcmFnQ2xhc3MsIGZhbHNlKTtcbiAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5naG9zdENsYXNzLCB0cnVlKTtcbiAgICAgIFNvcnRhYmxlLmFjdGl2ZSA9IHRoaXM7XG4gICAgICBmYWxsYmFjayAmJiB0aGlzLl9hcHBlbmRHaG9zdCgpOyAvLyBEcmFnIHN0YXJ0IGV2ZW50XG5cbiAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgIG5hbWU6ICdzdGFydCcsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX251bGxpbmcoKTtcbiAgICB9XG4gIH0sXG4gIF9lbXVsYXRlRHJhZ092ZXI6IGZ1bmN0aW9uIF9lbXVsYXRlRHJhZ092ZXIoKSB7XG4gICAgaWYgKHRvdWNoRXZ0KSB7XG4gICAgICB0aGlzLl9sYXN0WCA9IHRvdWNoRXZ0LmNsaWVudFg7XG4gICAgICB0aGlzLl9sYXN0WSA9IHRvdWNoRXZ0LmNsaWVudFk7XG5cbiAgICAgIF9oaWRlR2hvc3RGb3JUYXJnZXQoKTtcblxuICAgICAgdmFyIHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2hFdnQuY2xpZW50WCwgdG91Y2hFdnQuY2xpZW50WSk7XG4gICAgICB2YXIgcGFyZW50ID0gdGFyZ2V0O1xuXG4gICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldC5zaGFkb3dSb290KSB7XG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5zaGFkb3dSb290LmVsZW1lbnRGcm9tUG9pbnQodG91Y2hFdnQuY2xpZW50WCwgdG91Y2hFdnQuY2xpZW50WSk7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IHBhcmVudCkgYnJlYWs7XG4gICAgICAgIHBhcmVudCA9IHRhcmdldDtcbiAgICAgIH1cblxuICAgICAgZHJhZ0VsLnBhcmVudE5vZGVbZXhwYW5kb10uX2lzT3V0c2lkZVRoaXNFbCh0YXJnZXQpO1xuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAocGFyZW50W2V4cGFuZG9dKSB7XG4gICAgICAgICAgICB2YXIgaW5zZXJ0ZWQgPSB2b2lkIDA7XG4gICAgICAgICAgICBpbnNlcnRlZCA9IHBhcmVudFtleHBhbmRvXS5fb25EcmFnT3Zlcih7XG4gICAgICAgICAgICAgIGNsaWVudFg6IHRvdWNoRXZ0LmNsaWVudFgsXG4gICAgICAgICAgICAgIGNsaWVudFk6IHRvdWNoRXZ0LmNsaWVudFksXG4gICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICByb290RWw6IHBhcmVudFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChpbnNlcnRlZCAmJiAhdGhpcy5vcHRpb25zLmRyYWdvdmVyQnViYmxlKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRhcmdldCA9IHBhcmVudDsgLy8gc3RvcmUgbGFzdCBlbGVtZW50XG4gICAgICAgIH1cbiAgICAgICAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuICAgICAgICB3aGlsZSAocGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUpO1xuICAgICAgfVxuXG4gICAgICBfdW5oaWRlR2hvc3RGb3JUYXJnZXQoKTtcbiAgICB9XG4gIH0sXG4gIF9vblRvdWNoTW92ZTogZnVuY3Rpb24gX29uVG91Y2hNb3ZlKFxuICAvKipUb3VjaEV2ZW50Ki9cbiAgZXZ0KSB7XG4gICAgaWYgKHRhcEV2dCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgZmFsbGJhY2tUb2xlcmFuY2UgPSBvcHRpb25zLmZhbGxiYWNrVG9sZXJhbmNlLFxuICAgICAgICAgIGZhbGxiYWNrT2Zmc2V0ID0gb3B0aW9ucy5mYWxsYmFja09mZnNldCxcbiAgICAgICAgICB0b3VjaCA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQsXG4gICAgICAgICAgZ2hvc3RNYXRyaXggPSBnaG9zdEVsICYmIG1hdHJpeChnaG9zdEVsLCB0cnVlKSxcbiAgICAgICAgICBzY2FsZVggPSBnaG9zdEVsICYmIGdob3N0TWF0cml4ICYmIGdob3N0TWF0cml4LmEsXG4gICAgICAgICAgc2NhbGVZID0gZ2hvc3RFbCAmJiBnaG9zdE1hdHJpeCAmJiBnaG9zdE1hdHJpeC5kLFxuICAgICAgICAgIHJlbGF0aXZlU2Nyb2xsT2Zmc2V0ID0gUG9zaXRpb25HaG9zdEFic29sdXRlbHkgJiYgZ2hvc3RSZWxhdGl2ZVBhcmVudCAmJiBnZXRSZWxhdGl2ZVNjcm9sbE9mZnNldChnaG9zdFJlbGF0aXZlUGFyZW50KSxcbiAgICAgICAgICBkeCA9ICh0b3VjaC5jbGllbnRYIC0gdGFwRXZ0LmNsaWVudFggKyBmYWxsYmFja09mZnNldC54KSAvIChzY2FsZVggfHwgMSkgKyAocmVsYXRpdmVTY3JvbGxPZmZzZXQgPyByZWxhdGl2ZVNjcm9sbE9mZnNldFswXSAtIGdob3N0UmVsYXRpdmVQYXJlbnRJbml0aWFsU2Nyb2xsWzBdIDogMCkgLyAoc2NhbGVYIHx8IDEpLFxuICAgICAgICAgIGR5ID0gKHRvdWNoLmNsaWVudFkgLSB0YXBFdnQuY2xpZW50WSArIGZhbGxiYWNrT2Zmc2V0LnkpIC8gKHNjYWxlWSB8fCAxKSArIChyZWxhdGl2ZVNjcm9sbE9mZnNldCA/IHJlbGF0aXZlU2Nyb2xsT2Zmc2V0WzFdIC0gZ2hvc3RSZWxhdGl2ZVBhcmVudEluaXRpYWxTY3JvbGxbMV0gOiAwKSAvIChzY2FsZVkgfHwgMSk7IC8vIG9ubHkgc2V0IHRoZSBzdGF0dXMgdG8gZHJhZ2dpbmcsIHdoZW4gd2UgYXJlIGFjdHVhbGx5IGRyYWdnaW5nXG5cbiAgICAgIGlmICghU29ydGFibGUuYWN0aXZlICYmICFhd2FpdGluZ0RyYWdTdGFydGVkKSB7XG4gICAgICAgIGlmIChmYWxsYmFja1RvbGVyYW5jZSAmJiBNYXRoLm1heChNYXRoLmFicyh0b3VjaC5jbGllbnRYIC0gdGhpcy5fbGFzdFgpLCBNYXRoLmFicyh0b3VjaC5jbGllbnRZIC0gdGhpcy5fbGFzdFkpKSA8IGZhbGxiYWNrVG9sZXJhbmNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb25EcmFnU3RhcnQoZXZ0LCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdob3N0RWwpIHtcbiAgICAgICAgaWYgKGdob3N0TWF0cml4KSB7XG4gICAgICAgICAgZ2hvc3RNYXRyaXguZSArPSBkeCAtIChsYXN0RHggfHwgMCk7XG4gICAgICAgICAgZ2hvc3RNYXRyaXguZiArPSBkeSAtIChsYXN0RHkgfHwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2hvc3RNYXRyaXggPSB7XG4gICAgICAgICAgICBhOiAxLFxuICAgICAgICAgICAgYjogMCxcbiAgICAgICAgICAgIGM6IDAsXG4gICAgICAgICAgICBkOiAxLFxuICAgICAgICAgICAgZTogZHgsXG4gICAgICAgICAgICBmOiBkeVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3NzTWF0cml4ID0gXCJtYXRyaXgoXCIuY29uY2F0KGdob3N0TWF0cml4LmEsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguYiwgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5jLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmQsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguZSwgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5mLCBcIilcIik7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAnd2Via2l0VHJhbnNmb3JtJywgY3NzTWF0cml4KTtcbiAgICAgICAgY3NzKGdob3N0RWwsICdtb3pUcmFuc2Zvcm0nLCBjc3NNYXRyaXgpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ21zVHJhbnNmb3JtJywgY3NzTWF0cml4KTtcbiAgICAgICAgY3NzKGdob3N0RWwsICd0cmFuc2Zvcm0nLCBjc3NNYXRyaXgpO1xuICAgICAgICBsYXN0RHggPSBkeDtcbiAgICAgICAgbGFzdER5ID0gZHk7XG4gICAgICAgIHRvdWNoRXZ0ID0gdG91Y2g7XG4gICAgICB9XG5cbiAgICAgIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSxcbiAgX2FwcGVuZEdob3N0OiBmdW5jdGlvbiBfYXBwZW5kR2hvc3QoKSB7XG4gICAgLy8gQnVnIGlmIHVzaW5nIHNjYWxlKCk6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI2MzcwNThcbiAgICAvLyBOb3QgYmVpbmcgYWRqdXN0ZWQgZm9yXG4gICAgaWYgKCFnaG9zdEVsKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmZhbGxiYWNrT25Cb2R5ID8gZG9jdW1lbnQuYm9keSA6IHJvb3RFbCxcbiAgICAgICAgICByZWN0ID0gZ2V0UmVjdChkcmFnRWwsIHRydWUsIFBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5LCB0cnVlLCBjb250YWluZXIpLFxuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7IC8vIFBvc2l0aW9uIGFic29sdXRlbHlcblxuICAgICAgaWYgKFBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5KSB7XG4gICAgICAgIC8vIEdldCByZWxhdGl2ZWx5IHBvc2l0aW9uZWQgcGFyZW50XG4gICAgICAgIGdob3N0UmVsYXRpdmVQYXJlbnQgPSBjb250YWluZXI7XG5cbiAgICAgICAgd2hpbGUgKGNzcyhnaG9zdFJlbGF0aXZlUGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycgJiYgY3NzKGdob3N0UmVsYXRpdmVQYXJlbnQsICd0cmFuc2Zvcm0nKSA9PT0gJ25vbmUnICYmIGdob3N0UmVsYXRpdmVQYXJlbnQgIT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgZ2hvc3RSZWxhdGl2ZVBhcmVudCA9IGdob3N0UmVsYXRpdmVQYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnaG9zdFJlbGF0aXZlUGFyZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmIGdob3N0UmVsYXRpdmVQYXJlbnQgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgIGlmIChnaG9zdFJlbGF0aXZlUGFyZW50ID09PSBkb2N1bWVudCkgZ2hvc3RSZWxhdGl2ZVBhcmVudCA9IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgICAgICAgICByZWN0LnRvcCArPSBnaG9zdFJlbGF0aXZlUGFyZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICByZWN0LmxlZnQgKz0gZ2hvc3RSZWxhdGl2ZVBhcmVudC5zY3JvbGxMZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdob3N0UmVsYXRpdmVQYXJlbnQgPSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbCA9IGdldFJlbGF0aXZlU2Nyb2xsT2Zmc2V0KGdob3N0UmVsYXRpdmVQYXJlbnQpO1xuICAgICAgfVxuXG4gICAgICBnaG9zdEVsID0gZHJhZ0VsLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIHRvZ2dsZUNsYXNzKGdob3N0RWwsIG9wdGlvbnMuZ2hvc3RDbGFzcywgZmFsc2UpO1xuICAgICAgdG9nZ2xlQ2xhc3MoZ2hvc3RFbCwgb3B0aW9ucy5mYWxsYmFja0NsYXNzLCB0cnVlKTtcbiAgICAgIHRvZ2dsZUNsYXNzKGdob3N0RWwsIG9wdGlvbnMuZHJhZ0NsYXNzLCB0cnVlKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAndHJhbnNpdGlvbicsICcnKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAndHJhbnNmb3JtJywgJycpO1xuICAgICAgY3NzKGdob3N0RWwsICdib3gtc2l6aW5nJywgJ2JvcmRlci1ib3gnKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAnbWFyZ2luJywgMCk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3RvcCcsIHJlY3QudG9wKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAnbGVmdCcsIHJlY3QubGVmdCk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3dpZHRoJywgcmVjdC53aWR0aCk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ2hlaWdodCcsIHJlY3QuaGVpZ2h0KTtcbiAgICAgIGNzcyhnaG9zdEVsLCAnb3BhY2l0eScsICcwLjgnKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAncG9zaXRpb24nLCBQb3NpdGlvbkdob3N0QWJzb2x1dGVseSA/ICdhYnNvbHV0ZScgOiAnZml4ZWQnKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAnekluZGV4JywgJzEwMDAwMCcpO1xuICAgICAgY3NzKGdob3N0RWwsICdwb2ludGVyRXZlbnRzJywgJ25vbmUnKTtcbiAgICAgIFNvcnRhYmxlLmdob3N0ID0gZ2hvc3RFbDtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChnaG9zdEVsKTsgLy8gU2V0IHRyYW5zZm9ybS1vcmlnaW5cblxuICAgICAgY3NzKGdob3N0RWwsICd0cmFuc2Zvcm0tb3JpZ2luJywgdGFwRGlzdGFuY2VMZWZ0IC8gcGFyc2VJbnQoZ2hvc3RFbC5zdHlsZS53aWR0aCkgKiAxMDAgKyAnJSAnICsgdGFwRGlzdGFuY2VUb3AgLyBwYXJzZUludChnaG9zdEVsLnN0eWxlLmhlaWdodCkgKiAxMDAgKyAnJScpO1xuICAgIH1cbiAgfSxcbiAgX29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiBfb25EcmFnU3RhcnQoXG4gIC8qKkV2ZW50Ki9cbiAgZXZ0LFxuICAvKipib29sZWFuKi9cbiAgZmFsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGRhdGFUcmFuc2ZlciA9IGV2dC5kYXRhVHJhbnNmZXI7XG4gICAgdmFyIG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zO1xuICAgIHBsdWdpbkV2ZW50KCdkcmFnU3RhcnQnLCB0aGlzLCB7XG4gICAgICBldnQ6IGV2dFxuICAgIH0pO1xuXG4gICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgIHRoaXMuX29uRHJvcCgpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGx1Z2luRXZlbnQoJ3NldHVwQ2xvbmUnLCB0aGlzKTtcblxuICAgIGlmICghU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgY2xvbmVFbCA9IGNsb25lKGRyYWdFbCk7XG4gICAgICBjbG9uZUVsLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgY2xvbmVFbC5zdHlsZVsnd2lsbC1jaGFuZ2UnXSA9ICcnO1xuXG4gICAgICB0aGlzLl9oaWRlQ2xvbmUoKTtcblxuICAgICAgdG9nZ2xlQ2xhc3MoY2xvbmVFbCwgdGhpcy5vcHRpb25zLmNob3NlbkNsYXNzLCBmYWxzZSk7XG4gICAgICBTb3J0YWJsZS5jbG9uZSA9IGNsb25lRWw7XG4gICAgfSAvLyAjMTE0MzogSUZyYW1lIHN1cHBvcnQgd29ya2Fyb3VuZFxuXG5cbiAgICBfdGhpcy5jbG9uZUlkID0gX25leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHBsdWdpbkV2ZW50KCdjbG9uZScsIF90aGlzKTtcbiAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm47XG5cbiAgICAgIGlmICghX3RoaXMub3B0aW9ucy5yZW1vdmVDbG9uZU9uSGlkZSkge1xuICAgICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGNsb25lRWwsIGRyYWdFbCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLl9oaWRlQ2xvbmUoKTtcblxuICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgIG5hbWU6ICdjbG9uZSdcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgICFmYWxsYmFjayAmJiB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuZHJhZ0NsYXNzLCB0cnVlKTsgLy8gU2V0IHByb3BlciBkcm9wIGV2ZW50c1xuXG4gICAgaWYgKGZhbGxiYWNrKSB7XG4gICAgICBpZ25vcmVOZXh0Q2xpY2sgPSB0cnVlO1xuICAgICAgX3RoaXMuX2xvb3BJZCA9IHNldEludGVydmFsKF90aGlzLl9lbXVsYXRlRHJhZ092ZXIsIDUwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVW5kbyB3aGF0IHdhcyBzZXQgaW4gX3ByZXBhcmVEcmFnU3RhcnQgYmVmb3JlIGRyYWcgc3RhcnRlZFxuICAgICAgb2ZmKGRvY3VtZW50LCAnbW91c2V1cCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgb2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCBfdGhpcy5fb25Ecm9wKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgX3RoaXMuX29uRHJvcCk7XG5cbiAgICAgIGlmIChkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSAnbW92ZSc7XG4gICAgICAgIG9wdGlvbnMuc2V0RGF0YSAmJiBvcHRpb25zLnNldERhdGEuY2FsbChfdGhpcywgZGF0YVRyYW5zZmVyLCBkcmFnRWwpO1xuICAgICAgfVxuXG4gICAgICBvbihkb2N1bWVudCwgJ2Ryb3AnLCBfdGhpcyk7IC8vICMxMjc2IGZpeDpcblxuICAgICAgY3NzKGRyYWdFbCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGVaKDApJyk7XG4gICAgfVxuXG4gICAgYXdhaXRpbmdEcmFnU3RhcnRlZCA9IHRydWU7XG4gICAgX3RoaXMuX2RyYWdTdGFydElkID0gX25leHRUaWNrKF90aGlzLl9kcmFnU3RhcnRlZC5iaW5kKF90aGlzLCBmYWxsYmFjaywgZXZ0KSk7XG4gICAgb24oZG9jdW1lbnQsICdzZWxlY3RzdGFydCcsIF90aGlzKTtcbiAgICBtb3ZlZCA9IHRydWU7XG5cbiAgICBpZiAoU2FmYXJpKSB7XG4gICAgICBjc3MoZG9jdW1lbnQuYm9keSwgJ3VzZXItc2VsZWN0JywgJ25vbmUnKTtcbiAgICB9XG4gIH0sXG4gIC8vIFJldHVybnMgdHJ1ZSAtIGlmIG5vIGZ1cnRoZXIgYWN0aW9uIGlzIG5lZWRlZCAoZWl0aGVyIGluc2VydGVkIG9yIGFub3RoZXIgY29uZGl0aW9uKVxuICBfb25EcmFnT3ZlcjogZnVuY3Rpb24gX29uRHJhZ092ZXIoXG4gIC8qKkV2ZW50Ki9cbiAgZXZ0KSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbCxcbiAgICAgICAgdGFyZ2V0ID0gZXZ0LnRhcmdldCxcbiAgICAgICAgZHJhZ1JlY3QsXG4gICAgICAgIHRhcmdldFJlY3QsXG4gICAgICAgIHJldmVydCxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZ3JvdXAgPSBvcHRpb25zLmdyb3VwLFxuICAgICAgICBhY3RpdmVTb3J0YWJsZSA9IFNvcnRhYmxlLmFjdGl2ZSxcbiAgICAgICAgaXNPd25lciA9IGFjdGl2ZUdyb3VwID09PSBncm91cCxcbiAgICAgICAgY2FuU29ydCA9IG9wdGlvbnMuc29ydCxcbiAgICAgICAgZnJvbVNvcnRhYmxlID0gcHV0U29ydGFibGUgfHwgYWN0aXZlU29ydGFibGUsXG4gICAgICAgIHZlcnRpY2FsLFxuICAgICAgICBfdGhpcyA9IHRoaXMsXG4gICAgICAgIGNvbXBsZXRlZEZpcmVkID0gZmFsc2U7XG5cbiAgICBpZiAoX3NpbGVudCkgcmV0dXJuO1xuXG4gICAgZnVuY3Rpb24gZHJhZ092ZXJFdmVudChuYW1lLCBleHRyYSkge1xuICAgICAgcGx1Z2luRXZlbnQobmFtZSwgX3RoaXMsIF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgZXZ0OiBldnQsXG4gICAgICAgIGlzT3duZXI6IGlzT3duZXIsXG4gICAgICAgIGF4aXM6IHZlcnRpY2FsID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJyxcbiAgICAgICAgcmV2ZXJ0OiByZXZlcnQsXG4gICAgICAgIGRyYWdSZWN0OiBkcmFnUmVjdCxcbiAgICAgICAgdGFyZ2V0UmVjdDogdGFyZ2V0UmVjdCxcbiAgICAgICAgY2FuU29ydDogY2FuU29ydCxcbiAgICAgICAgZnJvbVNvcnRhYmxlOiBmcm9tU29ydGFibGUsXG4gICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICBjb21wbGV0ZWQ6IGNvbXBsZXRlZCxcbiAgICAgICAgb25Nb3ZlOiBmdW5jdGlvbiBvbk1vdmUodGFyZ2V0LCBhZnRlcikge1xuICAgICAgICAgIHJldHVybiBfb25Nb3ZlKHJvb3RFbCwgZWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldCwgZ2V0UmVjdCh0YXJnZXQpLCBldnQsIGFmdGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2hhbmdlZDogY2hhbmdlZFxuICAgICAgfSwgZXh0cmEpKTtcbiAgICB9IC8vIENhcHR1cmUgYW5pbWF0aW9uIHN0YXRlXG5cblxuICAgIGZ1bmN0aW9uIGNhcHR1cmUoKSB7XG4gICAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlckFuaW1hdGlvbkNhcHR1cmUnKTtcblxuICAgICAgX3RoaXMuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG5cbiAgICAgIGlmIChfdGhpcyAhPT0gZnJvbVNvcnRhYmxlKSB7XG4gICAgICAgIGZyb21Tb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICAgIH1cbiAgICB9IC8vIFJldHVybiBpbnZvY2F0aW9uIHdoZW4gZHJhZ0VsIGlzIGluc2VydGVkIChvciBjb21wbGV0ZWQpXG5cblxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlZChpbnNlcnRpb24pIHtcbiAgICAgIGRyYWdPdmVyRXZlbnQoJ2RyYWdPdmVyQ29tcGxldGVkJywge1xuICAgICAgICBpbnNlcnRpb246IGluc2VydGlvblxuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbnNlcnRpb24pIHtcbiAgICAgICAgLy8gQ2xvbmVzIG11c3QgYmUgaGlkZGVuIGJlZm9yZSBmb2xkaW5nIGFuaW1hdGlvbiB0byBjYXB0dXJlIGRyYWdSZWN0QWJzb2x1dGUgcHJvcGVybHlcbiAgICAgICAgaWYgKGlzT3duZXIpIHtcbiAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5faGlkZUNsb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWN0aXZlU29ydGFibGUuX3Nob3dDbG9uZShfdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXMgIT09IGZyb21Tb3J0YWJsZSkge1xuICAgICAgICAgIC8vIFNldCBnaG9zdCBjbGFzcyB0byBuZXcgc29ydGFibGUncyBnaG9zdCBjbGFzc1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgcHV0U29ydGFibGUgPyBwdXRTb3J0YWJsZS5vcHRpb25zLmdob3N0Q2xhc3MgOiBhY3RpdmVTb3J0YWJsZS5vcHRpb25zLmdob3N0Q2xhc3MsIGZhbHNlKTtcbiAgICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuZ2hvc3RDbGFzcywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHV0U29ydGFibGUgIT09IF90aGlzICYmIF90aGlzICE9PSBTb3J0YWJsZS5hY3RpdmUpIHtcbiAgICAgICAgICBwdXRTb3J0YWJsZSA9IF90aGlzO1xuICAgICAgICB9IGVsc2UgaWYgKF90aGlzID09PSBTb3J0YWJsZS5hY3RpdmUgJiYgcHV0U29ydGFibGUpIHtcbiAgICAgICAgICBwdXRTb3J0YWJsZSA9IG51bGw7XG4gICAgICAgIH0gLy8gQW5pbWF0aW9uXG5cblxuICAgICAgICBpZiAoZnJvbVNvcnRhYmxlID09PSBfdGhpcykge1xuICAgICAgICAgIF90aGlzLl9pZ25vcmVXaGlsZUFuaW1hdGluZyA9IHRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmFuaW1hdGVBbGwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRyYWdPdmVyRXZlbnQoJ2RyYWdPdmVyQW5pbWF0aW9uQ29tcGxldGUnKTtcbiAgICAgICAgICBfdGhpcy5faWdub3JlV2hpbGVBbmltYXRpbmcgPSBudWxsO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoX3RoaXMgIT09IGZyb21Tb3J0YWJsZSkge1xuICAgICAgICAgIGZyb21Tb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gICAgICAgICAgZnJvbVNvcnRhYmxlLl9pZ25vcmVXaGlsZUFuaW1hdGluZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gTnVsbCBsYXN0VGFyZ2V0IGlmIGl0IGlzIG5vdCBpbnNpZGUgYSBwcmV2aW91c2x5IHN3YXBwZWQgZWxlbWVudFxuXG5cbiAgICAgIGlmICh0YXJnZXQgPT09IGRyYWdFbCAmJiAhZHJhZ0VsLmFuaW1hdGVkIHx8IHRhcmdldCA9PT0gZWwgJiYgIXRhcmdldC5hbmltYXRlZCkge1xuICAgICAgICBsYXN0VGFyZ2V0ID0gbnVsbDtcbiAgICAgIH0gLy8gbm8gYnViYmxpbmcgYW5kIG5vdCBmYWxsYmFja1xuXG5cbiAgICAgIGlmICghb3B0aW9ucy5kcmFnb3ZlckJ1YmJsZSAmJiAhZXZ0LnJvb3RFbCAmJiB0YXJnZXQgIT09IGRvY3VtZW50KSB7XG4gICAgICAgIGRyYWdFbC5wYXJlbnROb2RlW2V4cGFuZG9dLl9pc091dHNpZGVUaGlzRWwoZXZ0LnRhcmdldCk7IC8vIERvIG5vdCBkZXRlY3QgZm9yIGVtcHR5IGluc2VydCBpZiBhbHJlYWR5IGluc2VydGVkXG5cblxuICAgICAgICAhaW5zZXJ0aW9uICYmIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KGV2dCk7XG4gICAgICB9XG5cbiAgICAgICFvcHRpb25zLmRyYWdvdmVyQnViYmxlICYmIGV2dC5zdG9wUHJvcGFnYXRpb24gJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgcmV0dXJuIGNvbXBsZXRlZEZpcmVkID0gdHJ1ZTtcbiAgICB9IC8vIENhbGwgd2hlbiBkcmFnRWwgaGFzIGJlZW4gaW5zZXJ0ZWRcblxuXG4gICAgZnVuY3Rpb24gY2hhbmdlZCgpIHtcbiAgICAgIG5ld0luZGV4ID0gaW5kZXgoZHJhZ0VsKTtcbiAgICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gaW5kZXgoZHJhZ0VsLCBvcHRpb25zLmRyYWdnYWJsZSk7XG5cbiAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgc29ydGFibGU6IF90aGlzLFxuICAgICAgICBuYW1lOiAnY2hhbmdlJyxcbiAgICAgICAgdG9FbDogZWwsXG4gICAgICAgIG5ld0luZGV4OiBuZXdJbmRleCxcbiAgICAgICAgbmV3RHJhZ2dhYmxlSW5kZXg6IG5ld0RyYWdnYWJsZUluZGV4LFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChldnQucHJldmVudERlZmF1bHQgIT09IHZvaWQgMCkge1xuICAgICAgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gY2xvc2VzdCh0YXJnZXQsIG9wdGlvbnMuZHJhZ2dhYmxlLCBlbCwgdHJ1ZSk7XG4gICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXInKTtcbiAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuIGNvbXBsZXRlZEZpcmVkO1xuXG4gICAgaWYgKGRyYWdFbC5jb250YWlucyhldnQudGFyZ2V0KSB8fCB0YXJnZXQuYW5pbWF0ZWQgJiYgdGFyZ2V0LmFuaW1hdGluZ1ggJiYgdGFyZ2V0LmFuaW1hdGluZ1kgfHwgX3RoaXMuX2lnbm9yZVdoaWxlQW5pbWF0aW5nID09PSB0YXJnZXQpIHtcbiAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgIH1cblxuICAgIGlnbm9yZU5leHRDbGljayA9IGZhbHNlO1xuXG4gICAgaWYgKGFjdGl2ZVNvcnRhYmxlICYmICFvcHRpb25zLmRpc2FibGVkICYmIChpc093bmVyID8gY2FuU29ydCB8fCAocmV2ZXJ0ID0gcGFyZW50RWwgIT09IHJvb3RFbCkgLy8gUmV2ZXJ0aW5nIGl0ZW0gaW50byB0aGUgb3JpZ2luYWwgbGlzdFxuICAgIDogcHV0U29ydGFibGUgPT09IHRoaXMgfHwgKHRoaXMubGFzdFB1dE1vZGUgPSBhY3RpdmVHcm91cC5jaGVja1B1bGwodGhpcywgYWN0aXZlU29ydGFibGUsIGRyYWdFbCwgZXZ0KSkgJiYgZ3JvdXAuY2hlY2tQdXQodGhpcywgYWN0aXZlU29ydGFibGUsIGRyYWdFbCwgZXZ0KSkpIHtcbiAgICAgIHZlcnRpY2FsID0gdGhpcy5fZ2V0RGlyZWN0aW9uKGV2dCwgdGFyZ2V0KSA9PT0gJ3ZlcnRpY2FsJztcbiAgICAgIGRyYWdSZWN0ID0gZ2V0UmVjdChkcmFnRWwpO1xuICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXJWYWxpZCcpO1xuICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybiBjb21wbGV0ZWRGaXJlZDtcblxuICAgICAgaWYgKHJldmVydCkge1xuICAgICAgICBwYXJlbnRFbCA9IHJvb3RFbDsgLy8gYWN0dWFsaXphdGlvblxuXG4gICAgICAgIGNhcHR1cmUoKTtcblxuICAgICAgICB0aGlzLl9oaWRlQ2xvbmUoKTtcblxuICAgICAgICBkcmFnT3ZlckV2ZW50KCdyZXZlcnQnKTtcblxuICAgICAgICBpZiAoIVNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgICAgICBpZiAobmV4dEVsKSB7XG4gICAgICAgICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgbmV4dEVsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm9vdEVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlZCh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsTGFzdENoaWxkID0gbGFzdENoaWxkKGVsLCBvcHRpb25zLmRyYWdnYWJsZSk7XG5cbiAgICAgIGlmICghZWxMYXN0Q2hpbGQgfHwgX2dob3N0SXNMYXN0KGV2dCwgdmVydGljYWwsIHRoaXMpICYmICFlbExhc3RDaGlsZC5hbmltYXRlZCkge1xuICAgICAgICAvLyBJbnNlcnQgdG8gZW5kIG9mIGxpc3RcbiAgICAgICAgLy8gSWYgYWxyZWFkeSBhdCBlbmQgb2YgbGlzdDogRG8gbm90IGluc2VydFxuICAgICAgICBpZiAoZWxMYXN0Q2hpbGQgPT09IGRyYWdFbCkge1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgICB9IC8vIGlmIHRoZXJlIGlzIGEgbGFzdCBlbGVtZW50LCBpdCBpcyB0aGUgdGFyZ2V0XG5cblxuICAgICAgICBpZiAoZWxMYXN0Q2hpbGQgJiYgZWwgPT09IGV2dC50YXJnZXQpIHtcbiAgICAgICAgICB0YXJnZXQgPSBlbExhc3RDaGlsZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICB0YXJnZXRSZWN0ID0gZ2V0UmVjdCh0YXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9vbk1vdmUocm9vdEVsLCBlbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCBldnQsICEhdGFyZ2V0KSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBjYXB0dXJlKCk7XG4gICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICAgICAgICBwYXJlbnRFbCA9IGVsOyAvLyBhY3R1YWxpemF0aW9uXG5cbiAgICAgICAgICBjaGFuZ2VkKCk7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbExhc3RDaGlsZCAmJiBfZ2hvc3RJc0ZpcnN0KGV2dCwgdmVydGljYWwsIHRoaXMpKSB7XG4gICAgICAgIC8vIEluc2VydCB0byBzdGFydCBvZiBsaXN0XG4gICAgICAgIHZhciBmaXJzdENoaWxkID0gZ2V0Q2hpbGQoZWwsIDAsIG9wdGlvbnMsIHRydWUpO1xuXG4gICAgICAgIGlmIChmaXJzdENoaWxkID09PSBkcmFnRWwpIHtcbiAgICAgICAgICByZXR1cm4gY29tcGxldGVkKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldCA9IGZpcnN0Q2hpbGQ7XG4gICAgICAgIHRhcmdldFJlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG5cbiAgICAgICAgaWYgKF9vbk1vdmUocm9vdEVsLCBlbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCBldnQsIGZhbHNlKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBjYXB0dXJlKCk7XG4gICAgICAgICAgZWwuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgZmlyc3RDaGlsZCk7XG4gICAgICAgICAgcGFyZW50RWwgPSBlbDsgLy8gYWN0dWFsaXphdGlvblxuXG4gICAgICAgICAgY2hhbmdlZCgpO1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LnBhcmVudE5vZGUgPT09IGVsKSB7XG4gICAgICAgIHRhcmdldFJlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSAwLFxuICAgICAgICAgICAgdGFyZ2V0QmVmb3JlRmlyc3RTd2FwLFxuICAgICAgICAgICAgZGlmZmVyZW50TGV2ZWwgPSBkcmFnRWwucGFyZW50Tm9kZSAhPT0gZWwsXG4gICAgICAgICAgICBkaWZmZXJlbnRSb3dDb2wgPSAhX2RyYWdFbEluUm93Q29sdW1uKGRyYWdFbC5hbmltYXRlZCAmJiBkcmFnRWwudG9SZWN0IHx8IGRyYWdSZWN0LCB0YXJnZXQuYW5pbWF0ZWQgJiYgdGFyZ2V0LnRvUmVjdCB8fCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCksXG4gICAgICAgICAgICBzaWRlMSA9IHZlcnRpY2FsID8gJ3RvcCcgOiAnbGVmdCcsXG4gICAgICAgICAgICBzY3JvbGxlZFBhc3RUb3AgPSBpc1Njcm9sbGVkUGFzdCh0YXJnZXQsICd0b3AnLCAndG9wJykgfHwgaXNTY3JvbGxlZFBhc3QoZHJhZ0VsLCAndG9wJywgJ3RvcCcpLFxuICAgICAgICAgICAgc2Nyb2xsQmVmb3JlID0gc2Nyb2xsZWRQYXN0VG9wID8gc2Nyb2xsZWRQYXN0VG9wLnNjcm9sbFRvcCA6IHZvaWQgMDtcblxuICAgICAgICBpZiAobGFzdFRhcmdldCAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgdGFyZ2V0QmVmb3JlRmlyc3RTd2FwID0gdGFyZ2V0UmVjdFtzaWRlMV07XG4gICAgICAgICAgcGFzdEZpcnN0SW52ZXJ0VGhyZXNoID0gZmFsc2U7XG4gICAgICAgICAgaXNDaXJjdW1zdGFudGlhbEludmVydCA9ICFkaWZmZXJlbnRSb3dDb2wgJiYgb3B0aW9ucy5pbnZlcnRTd2FwIHx8IGRpZmZlcmVudExldmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlyZWN0aW9uID0gX2dldFN3YXBEaXJlY3Rpb24oZXZ0LCB0YXJnZXQsIHRhcmdldFJlY3QsIHZlcnRpY2FsLCBkaWZmZXJlbnRSb3dDb2wgPyAxIDogb3B0aW9ucy5zd2FwVGhyZXNob2xkLCBvcHRpb25zLmludmVydGVkU3dhcFRocmVzaG9sZCA9PSBudWxsID8gb3B0aW9ucy5zd2FwVGhyZXNob2xkIDogb3B0aW9ucy5pbnZlcnRlZFN3YXBUaHJlc2hvbGQsIGlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQsIGxhc3RUYXJnZXQgPT09IHRhcmdldCk7XG4gICAgICAgIHZhciBzaWJsaW5nO1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gIT09IDApIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgYmVzaWRlIGRyYWdFbCBpbiByZXNwZWN0aXZlIGRpcmVjdGlvbiAoaWdub3JpbmcgaGlkZGVuIGVsZW1lbnRzKVxuICAgICAgICAgIHZhciBkcmFnSW5kZXggPSBpbmRleChkcmFnRWwpO1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgZHJhZ0luZGV4IC09IGRpcmVjdGlvbjtcbiAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnRFbC5jaGlsZHJlbltkcmFnSW5kZXhdO1xuICAgICAgICAgIH0gd2hpbGUgKHNpYmxpbmcgJiYgKGNzcyhzaWJsaW5nLCAnZGlzcGxheScpID09PSAnbm9uZScgfHwgc2libGluZyA9PT0gZ2hvc3RFbCkpO1xuICAgICAgICB9IC8vIElmIGRyYWdFbCBpcyBhbHJlYWR5IGJlc2lkZSB0YXJnZXQ6IERvIG5vdCBpbnNlcnRcblxuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IDAgfHwgc2libGluZyA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0VGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICBsYXN0RGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSB0YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nLFxuICAgICAgICAgICAgYWZ0ZXIgPSBmYWxzZTtcbiAgICAgICAgYWZ0ZXIgPSBkaXJlY3Rpb24gPT09IDE7XG5cbiAgICAgICAgdmFyIG1vdmVWZWN0b3IgPSBfb25Nb3ZlKHJvb3RFbCwgZWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldCwgdGFyZ2V0UmVjdCwgZXZ0LCBhZnRlcik7XG5cbiAgICAgICAgaWYgKG1vdmVWZWN0b3IgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKG1vdmVWZWN0b3IgPT09IDEgfHwgbW92ZVZlY3RvciA9PT0gLTEpIHtcbiAgICAgICAgICAgIGFmdGVyID0gbW92ZVZlY3RvciA9PT0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfc2lsZW50ID0gdHJ1ZTtcbiAgICAgICAgICBzZXRUaW1lb3V0KF91bnNpbGVudCwgMzApO1xuICAgICAgICAgIGNhcHR1cmUoKTtcblxuICAgICAgICAgIGlmIChhZnRlciAmJiAhbmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkcmFnRWwsIGFmdGVyID8gbmV4dFNpYmxpbmcgOiB0YXJnZXQpO1xuICAgICAgICAgIH0gLy8gVW5kbyBjaHJvbWUncyBzY3JvbGwgYWRqdXN0bWVudCAoaGFzIG5vIGVmZmVjdCBvbiBvdGhlciBicm93c2VycylcblxuXG4gICAgICAgICAgaWYgKHNjcm9sbGVkUGFzdFRvcCkge1xuICAgICAgICAgICAgc2Nyb2xsQnkoc2Nyb2xsZWRQYXN0VG9wLCAwLCBzY3JvbGxCZWZvcmUgLSBzY3JvbGxlZFBhc3RUb3Auc2Nyb2xsVG9wKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJlbnRFbCA9IGRyYWdFbC5wYXJlbnROb2RlOyAvLyBhY3R1YWxpemF0aW9uXG4gICAgICAgICAgLy8gbXVzdCBiZSBkb25lIGJlZm9yZSBhbmltYXRpb25cblxuICAgICAgICAgIGlmICh0YXJnZXRCZWZvcmVGaXJzdFN3YXAgIT09IHVuZGVmaW5lZCAmJiAhaXNDaXJjdW1zdGFudGlhbEludmVydCkge1xuICAgICAgICAgICAgdGFyZ2V0TW92ZURpc3RhbmNlID0gTWF0aC5hYnModGFyZ2V0QmVmb3JlRmlyc3RTd2FwIC0gZ2V0UmVjdCh0YXJnZXQpW3NpZGUxXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hhbmdlZCgpO1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVsLmNvbnRhaW5zKGRyYWdFbCkpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBfaWdub3JlV2hpbGVBbmltYXRpbmc6IG51bGwsXG4gIF9vZmZNb3ZlRXZlbnRzOiBmdW5jdGlvbiBfb2ZmTW92ZUV2ZW50cygpIHtcbiAgICBvZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgb2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgIG9mZihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgIG9mZihkb2N1bWVudCwgJ2RyYWdvdmVyJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgIG9mZihkb2N1bWVudCwgJ21vdXNlbW92ZScsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICBvZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gIH0sXG4gIF9vZmZVcEV2ZW50czogZnVuY3Rpb24gX29mZlVwRXZlbnRzKCkge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gdGhpcy5lbC5vd25lckRvY3VtZW50O1xuICAgIG9mZihvd25lckRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX29uRHJvcCk7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uRHJvcCk7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICdwb2ludGVydXAnLCB0aGlzLl9vbkRyb3ApO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCB0aGlzLl9vbkRyb3ApO1xuICAgIG9mZihkb2N1bWVudCwgJ3NlbGVjdHN0YXJ0JywgdGhpcyk7XG4gIH0sXG4gIF9vbkRyb3A6IGZ1bmN0aW9uIF9vbkRyb3AoXG4gIC8qKkV2ZW50Ki9cbiAgZXZ0KSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbCxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9uczsgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50XG5cbiAgICBuZXdJbmRleCA9IGluZGV4KGRyYWdFbCk7XG4gICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBpbmRleChkcmFnRWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcbiAgICBwbHVnaW5FdmVudCgnZHJvcCcsIHRoaXMsIHtcbiAgICAgIGV2dDogZXZ0XG4gICAgfSk7XG4gICAgcGFyZW50RWwgPSBkcmFnRWwgJiYgZHJhZ0VsLnBhcmVudE5vZGU7IC8vIEdldCBhZ2FpbiBhZnRlciBwbHVnaW4gZXZlbnRcblxuICAgIG5ld0luZGV4ID0gaW5kZXgoZHJhZ0VsKTtcbiAgICBuZXdEcmFnZ2FibGVJbmRleCA9IGluZGV4KGRyYWdFbCwgb3B0aW9ucy5kcmFnZ2FibGUpO1xuXG4gICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgIHRoaXMuX251bGxpbmcoKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGF3YWl0aW5nRHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICBpc0NpcmN1bXN0YW50aWFsSW52ZXJ0ID0gZmFsc2U7XG4gICAgcGFzdEZpcnN0SW52ZXJ0VGhyZXNoID0gZmFsc2U7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9sb29wSWQpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9kcmFnU3RhcnRUaW1lcik7XG5cbiAgICBfY2FuY2VsTmV4dFRpY2sodGhpcy5jbG9uZUlkKTtcblxuICAgIF9jYW5jZWxOZXh0VGljayh0aGlzLl9kcmFnU3RhcnRJZCk7IC8vIFVuYmluZCBldmVudHNcblxuXG4gICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICBvZmYoZG9jdW1lbnQsICdkcm9wJywgdGhpcyk7XG4gICAgICBvZmYoZWwsICdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgfVxuXG4gICAgdGhpcy5fb2ZmTW92ZUV2ZW50cygpO1xuXG4gICAgdGhpcy5fb2ZmVXBFdmVudHMoKTtcblxuICAgIGlmIChTYWZhcmkpIHtcbiAgICAgIGNzcyhkb2N1bWVudC5ib2R5LCAndXNlci1zZWxlY3QnLCAnJyk7XG4gICAgfVxuXG4gICAgY3NzKGRyYWdFbCwgJ3RyYW5zZm9ybScsICcnKTtcblxuICAgIGlmIChldnQpIHtcbiAgICAgIGlmIChtb3ZlZCkge1xuICAgICAgICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgIW9wdGlvbnMuZHJvcEJ1YmJsZSAmJiBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIGdob3N0RWwgJiYgZ2hvc3RFbC5wYXJlbnROb2RlICYmIGdob3N0RWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChnaG9zdEVsKTtcblxuICAgICAgaWYgKHJvb3RFbCA9PT0gcGFyZW50RWwgfHwgcHV0U29ydGFibGUgJiYgcHV0U29ydGFibGUubGFzdFB1dE1vZGUgIT09ICdjbG9uZScpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGNsb25lKHMpXG4gICAgICAgIGNsb25lRWwgJiYgY2xvbmVFbC5wYXJlbnROb2RlICYmIGNsb25lRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZUVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRyYWdFbCkge1xuICAgICAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgICBvZmYoZHJhZ0VsLCAnZHJhZ2VuZCcsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2Rpc2FibGVEcmFnZ2FibGUoZHJhZ0VsKTtcblxuICAgICAgICBkcmFnRWwuc3R5bGVbJ3dpbGwtY2hhbmdlJ10gPSAnJzsgLy8gUmVtb3ZlIGNsYXNzZXNcbiAgICAgICAgLy8gZ2hvc3RDbGFzcyBpcyBhZGRlZCBpbiBkcmFnU3RhcnRlZFxuXG4gICAgICAgIGlmIChtb3ZlZCAmJiAhYXdhaXRpbmdEcmFnU3RhcnRlZCkge1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgcHV0U29ydGFibGUgPyBwdXRTb3J0YWJsZS5vcHRpb25zLmdob3N0Q2xhc3MgOiB0aGlzLm9wdGlvbnMuZ2hvc3RDbGFzcywgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCB0aGlzLm9wdGlvbnMuY2hvc2VuQ2xhc3MsIGZhbHNlKTsgLy8gRHJhZyBzdG9wIGV2ZW50XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgIG5hbWU6ICd1bmNob29zZScsXG4gICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgbmV3SW5kZXg6IG51bGwsXG4gICAgICAgICAgbmV3RHJhZ2dhYmxlSW5kZXg6IG51bGwsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyb290RWwgIT09IHBhcmVudEVsKSB7XG4gICAgICAgICAgaWYgKG5ld0luZGV4ID49IDApIHtcbiAgICAgICAgICAgIC8vIEFkZCBldmVudFxuICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICByb290RWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBuYW1lOiAnYWRkJyxcbiAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIGZyb21FbDogcm9vdEVsLFxuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgIH0pOyAvLyBSZW1vdmUgZXZlbnRcblxuXG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICBuYW1lOiAncmVtb3ZlJyxcbiAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgfSk7IC8vIGRyYWcgZnJvbSBvbmUgbGlzdCBhbmQgZHJvcCBpbnRvIGFub3RoZXJcblxuXG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHJvb3RFbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIG5hbWU6ICdzb3J0JyxcbiAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIGZyb21FbDogcm9vdEVsLFxuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICBuYW1lOiAnc29ydCcsXG4gICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLnNhdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobmV3SW5kZXggIT09IG9sZEluZGV4KSB7XG4gICAgICAgICAgICBpZiAobmV3SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAvLyBkcmFnICYgZHJvcCB3aXRoaW4gdGhlIHNhbWUgbGlzdFxuICAgICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3VwZGF0ZScsXG4gICAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc29ydCcsXG4gICAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChTb3J0YWJsZS5hY3RpdmUpIHtcbiAgICAgICAgICAvKiBqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgICAgICAgICBpZiAobmV3SW5kZXggPT0gbnVsbCB8fCBuZXdJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5ld0luZGV4ID0gb2xkSW5kZXg7XG4gICAgICAgICAgICBuZXdEcmFnZ2FibGVJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgbmFtZTogJ2VuZCcsXG4gICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgIH0pOyAvLyBTYXZlIHNvcnRpbmdcblxuXG4gICAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9udWxsaW5nKCk7XG4gIH0sXG4gIF9udWxsaW5nOiBmdW5jdGlvbiBfbnVsbGluZygpIHtcbiAgICBwbHVnaW5FdmVudCgnbnVsbGluZycsIHRoaXMpO1xuICAgIHJvb3RFbCA9IGRyYWdFbCA9IHBhcmVudEVsID0gZ2hvc3RFbCA9IG5leHRFbCA9IGNsb25lRWwgPSBsYXN0RG93bkVsID0gY2xvbmVIaWRkZW4gPSB0YXBFdnQgPSB0b3VjaEV2dCA9IG1vdmVkID0gbmV3SW5kZXggPSBuZXdEcmFnZ2FibGVJbmRleCA9IG9sZEluZGV4ID0gb2xkRHJhZ2dhYmxlSW5kZXggPSBsYXN0VGFyZ2V0ID0gbGFzdERpcmVjdGlvbiA9IHB1dFNvcnRhYmxlID0gYWN0aXZlR3JvdXAgPSBTb3J0YWJsZS5kcmFnZ2VkID0gU29ydGFibGUuZ2hvc3QgPSBTb3J0YWJsZS5jbG9uZSA9IFNvcnRhYmxlLmFjdGl2ZSA9IG51bGw7XG4gICAgc2F2ZWRJbnB1dENoZWNrZWQuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGVsLmNoZWNrZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHNhdmVkSW5wdXRDaGVja2VkLmxlbmd0aCA9IGxhc3REeCA9IGxhc3REeSA9IDA7XG4gIH0sXG4gIGhhbmRsZUV2ZW50OiBmdW5jdGlvbiBoYW5kbGVFdmVudChcbiAgLyoqRXZlbnQqL1xuICBldnQpIHtcbiAgICBzd2l0Y2ggKGV2dC50eXBlKSB7XG4gICAgICBjYXNlICdkcm9wJzpcbiAgICAgIGNhc2UgJ2RyYWdlbmQnOlxuICAgICAgICB0aGlzLl9vbkRyb3AoZXZ0KTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZHJhZ2VudGVyJzpcbiAgICAgIGNhc2UgJ2RyYWdvdmVyJzpcbiAgICAgICAgaWYgKGRyYWdFbCkge1xuICAgICAgICAgIHRoaXMuX29uRHJhZ092ZXIoZXZ0KTtcblxuICAgICAgICAgIF9nbG9iYWxEcmFnT3ZlcihldnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3NlbGVjdHN0YXJ0JzpcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgaXRlbSBpbnRvIGFuIGFycmF5IG9mIHN0cmluZy5cbiAgICogQHJldHVybnMge1N0cmluZ1tdfVxuICAgKi9cbiAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICB2YXIgb3JkZXIgPSBbXSxcbiAgICAgICAgZWwsXG4gICAgICAgIGNoaWxkcmVuID0gdGhpcy5lbC5jaGlsZHJlbixcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIG4gPSBjaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgZWwgPSBjaGlsZHJlbltpXTtcblxuICAgICAgaWYgKGNsb3Nlc3QoZWwsIG9wdGlvbnMuZHJhZ2dhYmxlLCB0aGlzLmVsLCBmYWxzZSkpIHtcbiAgICAgICAgb3JkZXIucHVzaChlbC5nZXRBdHRyaWJ1dGUob3B0aW9ucy5kYXRhSWRBdHRyKSB8fCBfZ2VuZXJhdGVJZChlbCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcmRlcjtcbiAgfSxcblxuICAvKipcbiAgICogU29ydHMgdGhlIGVsZW1lbnRzIGFjY29yZGluZyB0byB0aGUgYXJyYXkuXG4gICAqIEBwYXJhbSAge1N0cmluZ1tdfSAgb3JkZXIgIG9yZGVyIG9mIHRoZSBpdGVtc1xuICAgKi9cbiAgc29ydDogZnVuY3Rpb24gc29ydChvcmRlciwgdXNlQW5pbWF0aW9uKSB7XG4gICAgdmFyIGl0ZW1zID0ge30sXG4gICAgICAgIHJvb3RFbCA9IHRoaXMuZWw7XG4gICAgdGhpcy50b0FycmF5KCkuZm9yRWFjaChmdW5jdGlvbiAoaWQsIGkpIHtcbiAgICAgIHZhciBlbCA9IHJvb3RFbC5jaGlsZHJlbltpXTtcblxuICAgICAgaWYgKGNsb3Nlc3QoZWwsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUsIHJvb3RFbCwgZmFsc2UpKSB7XG4gICAgICAgIGl0ZW1zW2lkXSA9IGVsO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHVzZUFuaW1hdGlvbiAmJiB0aGlzLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgIG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICBpZiAoaXRlbXNbaWRdKSB7XG4gICAgICAgIHJvb3RFbC5yZW1vdmVDaGlsZChpdGVtc1tpZF0pO1xuICAgICAgICByb290RWwuYXBwZW5kQ2hpbGQoaXRlbXNbaWRdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1c2VBbmltYXRpb24gJiYgdGhpcy5hbmltYXRlQWxsKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhdmUgdGhlIGN1cnJlbnQgc29ydGluZ1xuICAgKi9cbiAgc2F2ZTogZnVuY3Rpb24gc2F2ZSgpIHtcbiAgICB2YXIgc3RvcmUgPSB0aGlzLm9wdGlvbnMuc3RvcmU7XG4gICAgc3RvcmUgJiYgc3RvcmUuc2V0ICYmIHN0b3JlLnNldCh0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LCBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3RvciBieSB0ZXN0aW5nIHRoZSBlbGVtZW50IGl0c2VsZiBhbmQgdHJhdmVyc2luZyB1cCB0aHJvdWdoIGl0cyBhbmNlc3RvcnMgaW4gdGhlIERPTSB0cmVlLlxuICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICBlbFxuICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICAgICBbc2VsZWN0b3JdICBkZWZhdWx0OiBgb3B0aW9ucy5kcmFnZ2FibGVgXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudHxudWxsfVxuICAgKi9cbiAgY2xvc2VzdDogZnVuY3Rpb24gY2xvc2VzdCQxKGVsLCBzZWxlY3Rvcikge1xuICAgIHJldHVybiBjbG9zZXN0KGVsLCBzZWxlY3RvciB8fCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlLCB0aGlzLmVsLCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldC9nZXQgb3B0aW9uXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtICAgeyp9ICAgICAgW3ZhbHVlXVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIG9wdGlvbjogZnVuY3Rpb24gb3B0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnNbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtb2RpZmllZFZhbHVlID0gUGx1Z2luTWFuYWdlci5tb2RpZnlPcHRpb24odGhpcywgbmFtZSwgdmFsdWUpO1xuXG4gICAgICBpZiAodHlwZW9mIG1vZGlmaWVkVmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdGlvbnNbbmFtZV0gPSBtb2RpZmllZFZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9uc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICBfcHJlcGFyZUdyb3VwKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVzdHJveVxuICAgKi9cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBwbHVnaW5FdmVudCgnZGVzdHJveScsIHRoaXMpO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgZWxbZXhwYW5kb10gPSBudWxsO1xuICAgIG9mZihlbCwgJ21vdXNlZG93bicsIHRoaXMuX29uVGFwU3RhcnQpO1xuICAgIG9mZihlbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgICBvZmYoZWwsICdwb2ludGVyZG93bicsIHRoaXMuX29uVGFwU3RhcnQpO1xuXG4gICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICBvZmYoZWwsICdkcmFnb3ZlcicsIHRoaXMpO1xuICAgICAgb2ZmKGVsLCAnZHJhZ2VudGVyJywgdGhpcyk7XG4gICAgfSAvLyBSZW1vdmUgZHJhZ2dhYmxlIGF0dHJpYnV0ZXNcblxuXG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChlbC5xdWVyeVNlbGVjdG9yQWxsKCdbZHJhZ2dhYmxlXScpLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnZHJhZ2dhYmxlJyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9vbkRyb3AoKTtcblxuICAgIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cygpO1xuXG4gICAgc29ydGFibGVzLnNwbGljZShzb3J0YWJsZXMuaW5kZXhPZih0aGlzLmVsKSwgMSk7XG4gICAgdGhpcy5lbCA9IGVsID0gbnVsbDtcbiAgfSxcbiAgX2hpZGVDbG9uZTogZnVuY3Rpb24gX2hpZGVDbG9uZSgpIHtcbiAgICBpZiAoIWNsb25lSGlkZGVuKSB7XG4gICAgICBwbHVnaW5FdmVudCgnaGlkZUNsb25lJywgdGhpcyk7XG4gICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuO1xuICAgICAgY3NzKGNsb25lRWwsICdkaXNwbGF5JywgJ25vbmUnKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVDbG9uZU9uSGlkZSAmJiBjbG9uZUVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgY2xvbmVFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNsb25lRWwpO1xuICAgICAgfVxuXG4gICAgICBjbG9uZUhpZGRlbiA9IHRydWU7XG4gICAgfVxuICB9LFxuICBfc2hvd0Nsb25lOiBmdW5jdGlvbiBfc2hvd0Nsb25lKHB1dFNvcnRhYmxlKSB7XG4gICAgaWYgKHB1dFNvcnRhYmxlLmxhc3RQdXRNb2RlICE9PSAnY2xvbmUnKSB7XG4gICAgICB0aGlzLl9oaWRlQ2xvbmUoKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjbG9uZUhpZGRlbikge1xuICAgICAgcGx1Z2luRXZlbnQoJ3Nob3dDbG9uZScsIHRoaXMpO1xuICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybjsgLy8gc2hvdyBjbG9uZSBhdCBkcmFnRWwgb3Igb3JpZ2luYWwgcG9zaXRpb25cblxuICAgICAgaWYgKGRyYWdFbC5wYXJlbnROb2RlID09IHJvb3RFbCAmJiAhdGhpcy5vcHRpb25zLmdyb3VwLnJldmVydENsb25lKSB7XG4gICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmVFbCwgZHJhZ0VsKTtcbiAgICAgIH0gZWxzZSBpZiAobmV4dEVsKSB7XG4gICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmVFbCwgbmV4dEVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChjbG9uZUVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ncm91cC5yZXZlcnRDbG9uZSkge1xuICAgICAgICB0aGlzLmFuaW1hdGUoZHJhZ0VsLCBjbG9uZUVsKTtcbiAgICAgIH1cblxuICAgICAgY3NzKGNsb25lRWwsICdkaXNwbGF5JywgJycpO1xuICAgICAgY2xvbmVIaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9nbG9iYWxEcmFnT3Zlcihcbi8qKkV2ZW50Ki9cbmV2dCkge1xuICBpZiAoZXZ0LmRhdGFUcmFuc2Zlcikge1xuICAgIGV2dC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdtb3ZlJztcbiAgfVxuXG4gIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG5mdW5jdGlvbiBfb25Nb3ZlKGZyb21FbCwgdG9FbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0RWwsIHRhcmdldFJlY3QsIG9yaWdpbmFsRXZlbnQsIHdpbGxJbnNlcnRBZnRlcikge1xuICB2YXIgZXZ0LFxuICAgICAgc29ydGFibGUgPSBmcm9tRWxbZXhwYW5kb10sXG4gICAgICBvbk1vdmVGbiA9IHNvcnRhYmxlLm9wdGlvbnMub25Nb3ZlLFxuICAgICAgcmV0VmFsOyAvLyBTdXBwb3J0IGZvciBuZXcgQ3VzdG9tRXZlbnQgZmVhdHVyZVxuXG4gIGlmICh3aW5kb3cuQ3VzdG9tRXZlbnQgJiYgIUlFMTFPckxlc3MgJiYgIUVkZ2UpIHtcbiAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ21vdmUnLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2dC5pbml0RXZlbnQoJ21vdmUnLCB0cnVlLCB0cnVlKTtcbiAgfVxuXG4gIGV2dC50byA9IHRvRWw7XG4gIGV2dC5mcm9tID0gZnJvbUVsO1xuICBldnQuZHJhZ2dlZCA9IGRyYWdFbDtcbiAgZXZ0LmRyYWdnZWRSZWN0ID0gZHJhZ1JlY3Q7XG4gIGV2dC5yZWxhdGVkID0gdGFyZ2V0RWwgfHwgdG9FbDtcbiAgZXZ0LnJlbGF0ZWRSZWN0ID0gdGFyZ2V0UmVjdCB8fCBnZXRSZWN0KHRvRWwpO1xuICBldnQud2lsbEluc2VydEFmdGVyID0gd2lsbEluc2VydEFmdGVyO1xuICBldnQub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gIGZyb21FbC5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cbiAgaWYgKG9uTW92ZUZuKSB7XG4gICAgcmV0VmFsID0gb25Nb3ZlRm4uY2FsbChzb3J0YWJsZSwgZXZ0LCBvcmlnaW5hbEV2ZW50KTtcbiAgfVxuXG4gIHJldHVybiByZXRWYWw7XG59XG5cbmZ1bmN0aW9uIF9kaXNhYmxlRHJhZ2dhYmxlKGVsKSB7XG4gIGVsLmRyYWdnYWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfdW5zaWxlbnQoKSB7XG4gIF9zaWxlbnQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX2dob3N0SXNGaXJzdChldnQsIHZlcnRpY2FsLCBzb3J0YWJsZSkge1xuICB2YXIgcmVjdCA9IGdldFJlY3QoZ2V0Q2hpbGQoc29ydGFibGUuZWwsIDAsIHNvcnRhYmxlLm9wdGlvbnMsIHRydWUpKTtcbiAgdmFyIHNwYWNlciA9IDEwO1xuICByZXR1cm4gdmVydGljYWwgPyBldnQuY2xpZW50WCA8IHJlY3QubGVmdCAtIHNwYWNlciB8fCBldnQuY2xpZW50WSA8IHJlY3QudG9wICYmIGV2dC5jbGllbnRYIDwgcmVjdC5yaWdodCA6IGV2dC5jbGllbnRZIDwgcmVjdC50b3AgLSBzcGFjZXIgfHwgZXZ0LmNsaWVudFkgPCByZWN0LmJvdHRvbSAmJiBldnQuY2xpZW50WCA8IHJlY3QubGVmdDtcbn1cblxuZnVuY3Rpb24gX2dob3N0SXNMYXN0KGV2dCwgdmVydGljYWwsIHNvcnRhYmxlKSB7XG4gIHZhciByZWN0ID0gZ2V0UmVjdChsYXN0Q2hpbGQoc29ydGFibGUuZWwsIHNvcnRhYmxlLm9wdGlvbnMuZHJhZ2dhYmxlKSk7XG4gIHZhciBzcGFjZXIgPSAxMDtcbiAgcmV0dXJuIHZlcnRpY2FsID8gZXZ0LmNsaWVudFggPiByZWN0LnJpZ2h0ICsgc3BhY2VyIHx8IGV2dC5jbGllbnRYIDw9IHJlY3QucmlnaHQgJiYgZXZ0LmNsaWVudFkgPiByZWN0LmJvdHRvbSAmJiBldnQuY2xpZW50WCA+PSByZWN0LmxlZnQgOiBldnQuY2xpZW50WCA+IHJlY3QucmlnaHQgJiYgZXZ0LmNsaWVudFkgPiByZWN0LnRvcCB8fCBldnQuY2xpZW50WCA8PSByZWN0LnJpZ2h0ICYmIGV2dC5jbGllbnRZID4gcmVjdC5ib3R0b20gKyBzcGFjZXI7XG59XG5cbmZ1bmN0aW9uIF9nZXRTd2FwRGlyZWN0aW9uKGV2dCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCwgc3dhcFRocmVzaG9sZCwgaW52ZXJ0ZWRTd2FwVGhyZXNob2xkLCBpbnZlcnRTd2FwLCBpc0xhc3RUYXJnZXQpIHtcbiAgdmFyIG1vdXNlT25BeGlzID0gdmVydGljYWwgPyBldnQuY2xpZW50WSA6IGV2dC5jbGllbnRYLFxuICAgICAgdGFyZ2V0TGVuZ3RoID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LmhlaWdodCA6IHRhcmdldFJlY3Qud2lkdGgsXG4gICAgICB0YXJnZXRTMSA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC50b3AgOiB0YXJnZXRSZWN0LmxlZnQsXG4gICAgICB0YXJnZXRTMiA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC5ib3R0b20gOiB0YXJnZXRSZWN0LnJpZ2h0LFxuICAgICAgaW52ZXJ0ID0gZmFsc2U7XG5cbiAgaWYgKCFpbnZlcnRTd2FwKSB7XG4gICAgLy8gTmV2ZXIgaW52ZXJ0IG9yIGNyZWF0ZSBkcmFnRWwgc2hhZG93IHdoZW4gdGFyZ2V0IG1vdmVtZW5ldCBjYXVzZXMgbW91c2UgdG8gbW92ZSBwYXN0IHRoZSBlbmQgb2YgcmVndWxhciBzd2FwVGhyZXNob2xkXG4gICAgaWYgKGlzTGFzdFRhcmdldCAmJiB0YXJnZXRNb3ZlRGlzdGFuY2UgPCB0YXJnZXRMZW5ndGggKiBzd2FwVGhyZXNob2xkKSB7XG4gICAgICAvLyBtdWx0aXBsaWVkIG9ubHkgYnkgc3dhcFRocmVzaG9sZCBiZWNhdXNlIG1vdXNlIHdpbGwgYWxyZWFkeSBiZSBpbnNpZGUgdGFyZ2V0IGJ5ICgxIC0gdGhyZXNob2xkKSAqIHRhcmdldExlbmd0aCAvIDJcbiAgICAgIC8vIGNoZWNrIGlmIHBhc3QgZmlyc3QgaW52ZXJ0IHRocmVzaG9sZCBvbiBzaWRlIG9wcG9zaXRlIG9mIGxhc3REaXJlY3Rpb25cbiAgICAgIGlmICghcGFzdEZpcnN0SW52ZXJ0VGhyZXNoICYmIChsYXN0RGlyZWN0aW9uID09PSAxID8gbW91c2VPbkF4aXMgPiB0YXJnZXRTMSArIHRhcmdldExlbmd0aCAqIGludmVydGVkU3dhcFRocmVzaG9sZCAvIDIgOiBtb3VzZU9uQXhpcyA8IHRhcmdldFMyIC0gdGFyZ2V0TGVuZ3RoICogaW52ZXJ0ZWRTd2FwVGhyZXNob2xkIC8gMikpIHtcbiAgICAgICAgLy8gcGFzdCBmaXJzdCBpbnZlcnQgdGhyZXNob2xkLCBkbyBub3QgcmVzdHJpY3QgaW52ZXJ0ZWQgdGhyZXNob2xkIHRvIGRyYWdFbCBzaGFkb3dcbiAgICAgICAgcGFzdEZpcnN0SW52ZXJ0VGhyZXNoID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXN0Rmlyc3RJbnZlcnRUaHJlc2gpIHtcbiAgICAgICAgLy8gZHJhZ0VsIHNoYWRvdyAodGFyZ2V0IG1vdmUgZGlzdGFuY2Ugc2hhZG93KVxuICAgICAgICBpZiAobGFzdERpcmVjdGlvbiA9PT0gMSA/IG1vdXNlT25BeGlzIDwgdGFyZ2V0UzEgKyB0YXJnZXRNb3ZlRGlzdGFuY2UgLy8gb3ZlciBkcmFnRWwgc2hhZG93XG4gICAgICAgIDogbW91c2VPbkF4aXMgPiB0YXJnZXRTMiAtIHRhcmdldE1vdmVEaXN0YW5jZSkge1xuICAgICAgICAgIHJldHVybiAtbGFzdERpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52ZXJ0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVndWxhclxuICAgICAgaWYgKG1vdXNlT25BeGlzID4gdGFyZ2V0UzEgKyB0YXJnZXRMZW5ndGggKiAoMSAtIHN3YXBUaHJlc2hvbGQpIC8gMiAmJiBtb3VzZU9uQXhpcyA8IHRhcmdldFMyIC0gdGFyZ2V0TGVuZ3RoICogKDEgLSBzd2FwVGhyZXNob2xkKSAvIDIpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRJbnNlcnREaXJlY3Rpb24odGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpbnZlcnQgPSBpbnZlcnQgfHwgaW52ZXJ0U3dhcDtcblxuICBpZiAoaW52ZXJ0KSB7XG4gICAgLy8gSW52ZXJ0IG9mIHJlZ3VsYXJcbiAgICBpZiAobW91c2VPbkF4aXMgPCB0YXJnZXRTMSArIHRhcmdldExlbmd0aCAqIGludmVydGVkU3dhcFRocmVzaG9sZCAvIDIgfHwgbW91c2VPbkF4aXMgPiB0YXJnZXRTMiAtIHRhcmdldExlbmd0aCAqIGludmVydGVkU3dhcFRocmVzaG9sZCAvIDIpIHtcbiAgICAgIHJldHVybiBtb3VzZU9uQXhpcyA+IHRhcmdldFMxICsgdGFyZ2V0TGVuZ3RoIC8gMiA/IDEgOiAtMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cbi8qKlxuICogR2V0cyB0aGUgZGlyZWN0aW9uIGRyYWdFbCBtdXN0IGJlIHN3YXBwZWQgcmVsYXRpdmUgdG8gdGFyZ2V0IGluIG9yZGVyIHRvIG1ha2UgaXRcbiAqIHNlZW0gdGhhdCBkcmFnRWwgaGFzIGJlZW4gXCJpbnNlcnRlZFwiIGludG8gdGhhdCBlbGVtZW50J3MgcG9zaXRpb25cbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSB0YXJnZXQgICAgICAgVGhlIHRhcmdldCB3aG9zZSBwb3NpdGlvbiBkcmFnRWwgaXMgYmVpbmcgaW5zZXJ0ZWQgYXRcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgRGlyZWN0aW9uIGRyYWdFbCBtdXN0IGJlIHN3YXBwZWRcbiAqL1xuXG5cbmZ1bmN0aW9uIF9nZXRJbnNlcnREaXJlY3Rpb24odGFyZ2V0KSB7XG4gIGlmIChpbmRleChkcmFnRWwpIDwgaW5kZXgodGFyZ2V0KSkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAtMTtcbiAgfVxufVxuLyoqXG4gKiBHZW5lcmF0ZSBpZFxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBlbFxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBfZ2VuZXJhdGVJZChlbCkge1xuICB2YXIgc3RyID0gZWwudGFnTmFtZSArIGVsLmNsYXNzTmFtZSArIGVsLnNyYyArIGVsLmhyZWYgKyBlbC50ZXh0Q29udGVudCxcbiAgICAgIGkgPSBzdHIubGVuZ3RoLFxuICAgICAgc3VtID0gMDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgc3VtICs9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG5cbiAgcmV0dXJuIHN1bS50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIF9zYXZlSW5wdXRDaGVja2VkU3RhdGUocm9vdCkge1xuICBzYXZlZElucHV0Q2hlY2tlZC5sZW5ndGggPSAwO1xuICB2YXIgaW5wdXRzID0gcm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5wdXQnKTtcbiAgdmFyIGlkeCA9IGlucHV0cy5sZW5ndGg7XG5cbiAgd2hpbGUgKGlkeC0tKSB7XG4gICAgdmFyIGVsID0gaW5wdXRzW2lkeF07XG4gICAgZWwuY2hlY2tlZCAmJiBzYXZlZElucHV0Q2hlY2tlZC5wdXNoKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfbmV4dFRpY2soZm4pIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoZm4sIDApO1xufVxuXG5mdW5jdGlvbiBfY2FuY2VsTmV4dFRpY2soaWQpIHtcbiAgcmV0dXJuIGNsZWFyVGltZW91dChpZCk7XG59IC8vIEZpeGVkICM5NzM6XG5cblxuaWYgKGRvY3VtZW50RXhpc3RzKSB7XG4gIG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgZnVuY3Rpb24gKGV2dCkge1xuICAgIGlmICgoU29ydGFibGUuYWN0aXZlIHx8IGF3YWl0aW5nRHJhZ1N0YXJ0ZWQpICYmIGV2dC5jYW5jZWxhYmxlKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0pO1xufSAvLyBFeHBvcnQgdXRpbHNcblxuXG5Tb3J0YWJsZS51dGlscyA9IHtcbiAgb246IG9uLFxuICBvZmY6IG9mZixcbiAgY3NzOiBjc3MsXG4gIGZpbmQ6IGZpbmQsXG4gIGlzOiBmdW5jdGlvbiBpcyhlbCwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gISFjbG9zZXN0KGVsLCBzZWxlY3RvciwgZWwsIGZhbHNlKTtcbiAgfSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRocm90dGxlOiB0aHJvdHRsZSxcbiAgY2xvc2VzdDogY2xvc2VzdCxcbiAgdG9nZ2xlQ2xhc3M6IHRvZ2dsZUNsYXNzLFxuICBjbG9uZTogY2xvbmUsXG4gIGluZGV4OiBpbmRleCxcbiAgbmV4dFRpY2s6IF9uZXh0VGljayxcbiAgY2FuY2VsTmV4dFRpY2s6IF9jYW5jZWxOZXh0VGljayxcbiAgZGV0ZWN0RGlyZWN0aW9uOiBfZGV0ZWN0RGlyZWN0aW9uLFxuICBnZXRDaGlsZDogZ2V0Q2hpbGRcbn07XG4vKipcbiAqIEdldCB0aGUgU29ydGFibGUgaW5zdGFuY2Ugb2YgYW4gZWxlbWVudFxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnRcbiAqIEByZXR1cm4ge1NvcnRhYmxlfHVuZGVmaW5lZH0gICAgICAgICBUaGUgaW5zdGFuY2Ugb2YgU29ydGFibGVcbiAqL1xuXG5Tb3J0YWJsZS5nZXQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudFtleHBhbmRvXTtcbn07XG4vKipcbiAqIE1vdW50IGEgcGx1Z2luIHRvIFNvcnRhYmxlXG4gKiBAcGFyYW0gIHsuLi5Tb3J0YWJsZVBsdWdpbnxTb3J0YWJsZVBsdWdpbltdfSBwbHVnaW5zICAgICAgIFBsdWdpbnMgYmVpbmcgbW91bnRlZFxuICovXG5cblxuU29ydGFibGUubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHBsdWdpbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAocGx1Z2luc1swXS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHBsdWdpbnMgPSBwbHVnaW5zWzBdO1xuICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIGlmICghcGx1Z2luLnByb3RvdHlwZSB8fCAhcGx1Z2luLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgdGhyb3cgXCJTb3J0YWJsZTogTW91bnRlZCBwbHVnaW4gbXVzdCBiZSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCBub3QgXCIuY29uY2F0KHt9LnRvU3RyaW5nLmNhbGwocGx1Z2luKSk7XG4gICAgfVxuXG4gICAgaWYgKHBsdWdpbi51dGlscykgU29ydGFibGUudXRpbHMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgU29ydGFibGUudXRpbHMpLCBwbHVnaW4udXRpbHMpO1xuICAgIFBsdWdpbk1hbmFnZXIubW91bnQocGx1Z2luKTtcbiAgfSk7XG59O1xuLyoqXG4gKiBDcmVhdGUgc29ydGFibGUgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICBlbFxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgW29wdGlvbnNdXG4gKi9cblxuXG5Tb3J0YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBTb3J0YWJsZShlbCwgb3B0aW9ucyk7XG59OyAvLyBFeHBvcnRcblxuXG5Tb3J0YWJsZS52ZXJzaW9uID0gdmVyc2lvbjtcblxudmFyIGF1dG9TY3JvbGxzID0gW10sXG4gICAgc2Nyb2xsRWwsXG4gICAgc2Nyb2xsUm9vdEVsLFxuICAgIHNjcm9sbGluZyA9IGZhbHNlLFxuICAgIGxhc3RBdXRvU2Nyb2xsWCxcbiAgICBsYXN0QXV0b1Njcm9sbFksXG4gICAgdG91Y2hFdnQkMSxcbiAgICBwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbDtcblxuZnVuY3Rpb24gQXV0b1Njcm9sbFBsdWdpbigpIHtcbiAgZnVuY3Rpb24gQXV0b1Njcm9sbCgpIHtcbiAgICB0aGlzLmRlZmF1bHRzID0ge1xuICAgICAgc2Nyb2xsOiB0cnVlLFxuICAgICAgZm9yY2VBdXRvU2Nyb2xsRmFsbGJhY2s6IGZhbHNlLFxuICAgICAgc2Nyb2xsU2Vuc2l0aXZpdHk6IDMwLFxuICAgICAgc2Nyb2xsU3BlZWQ6IDEwLFxuICAgICAgYnViYmxlU2Nyb2xsOiB0cnVlXG4gICAgfTsgLy8gQmluZCBhbGwgcHJpdmF0ZSBtZXRob2RzXG5cbiAgICBmb3IgKHZhciBmbiBpbiB0aGlzKSB7XG4gICAgICBpZiAoZm4uY2hhckF0KDApID09PSAnXycgJiYgdHlwZW9mIHRoaXNbZm5dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXNbZm5dID0gdGhpc1tmbl0uYmluZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBBdXRvU2Nyb2xsLnByb3RvdHlwZSA9IHtcbiAgICBkcmFnU3RhcnRlZDogZnVuY3Rpb24gZHJhZ1N0YXJ0ZWQoX3JlZikge1xuICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBfcmVmLm9yaWdpbmFsRXZlbnQ7XG5cbiAgICAgIGlmICh0aGlzLnNvcnRhYmxlLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICBvbihkb2N1bWVudCwgJ2RyYWdvdmVyJywgdGhpcy5faGFuZGxlQXV0b1Njcm9sbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN1cHBvcnRQb2ludGVyKSB7XG4gICAgICAgICAgb24oZG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3JpZ2luYWxFdmVudC50b3VjaGVzKSB7XG4gICAgICAgICAgb24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZHJhZ092ZXJDb21wbGV0ZWQ6IGZ1bmN0aW9uIGRyYWdPdmVyQ29tcGxldGVkKF9yZWYyKSB7XG4gICAgICB2YXIgb3JpZ2luYWxFdmVudCA9IF9yZWYyLm9yaWdpbmFsRXZlbnQ7XG5cbiAgICAgIC8vIEZvciB3aGVuIGJ1YmJsaW5nIGlzIGNhbmNlbGVkIGFuZCB1c2luZyBmYWxsYmFjayAoZmFsbGJhY2sgJ3RvdWNobW92ZScgYWx3YXlzIHJlYWNoZWQpXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5kcmFnT3ZlckJ1YmJsZSAmJiAhb3JpZ2luYWxFdmVudC5yb290RWwpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlQXV0b1Njcm9sbChvcmlnaW5hbEV2ZW50KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyb3A6IGZ1bmN0aW9uIGRyb3AoKSB7XG4gICAgICBpZiAodGhpcy5zb3J0YWJsZS5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCAnZHJhZ292ZXInLCB0aGlzLl9oYW5kbGVBdXRvU2Nyb2xsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgIH1cblxuICAgICAgY2xlYXJQb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCgpO1xuICAgICAgY2xlYXJBdXRvU2Nyb2xscygpO1xuICAgICAgY2FuY2VsVGhyb3R0bGUoKTtcbiAgICB9LFxuICAgIG51bGxpbmc6IGZ1bmN0aW9uIG51bGxpbmcoKSB7XG4gICAgICB0b3VjaEV2dCQxID0gc2Nyb2xsUm9vdEVsID0gc2Nyb2xsRWwgPSBzY3JvbGxpbmcgPSBwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCA9IGxhc3RBdXRvU2Nyb2xsWCA9IGxhc3RBdXRvU2Nyb2xsWSA9IG51bGw7XG4gICAgICBhdXRvU2Nyb2xscy5sZW5ndGggPSAwO1xuICAgIH0sXG4gICAgX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbDogZnVuY3Rpb24gX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbChldnQpIHtcbiAgICAgIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwoZXZ0LCB0cnVlKTtcbiAgICB9LFxuICAgIF9oYW5kbGVBdXRvU2Nyb2xsOiBmdW5jdGlvbiBfaGFuZGxlQXV0b1Njcm9sbChldnQsIGZhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgeCA9IChldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0KS5jbGllbnRYLFxuICAgICAgICAgIHkgPSAoZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCkuY2xpZW50WSxcbiAgICAgICAgICBlbGVtID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgIHRvdWNoRXZ0JDEgPSBldnQ7IC8vIElFIGRvZXMgbm90IHNlZW0gdG8gaGF2ZSBuYXRpdmUgYXV0b3Njcm9sbCxcbiAgICAgIC8vIEVkZ2UncyBhdXRvc2Nyb2xsIHNlZW1zIHRvbyBjb25kaXRpb25hbCxcbiAgICAgIC8vIE1BQ09TIFNhZmFyaSBkb2VzIG5vdCBoYXZlIGF1dG9zY3JvbGwsXG4gICAgICAvLyBGaXJlZm94IGFuZCBDaHJvbWUgYXJlIGdvb2RcblxuICAgICAgaWYgKGZhbGxiYWNrIHx8IHRoaXMub3B0aW9ucy5mb3JjZUF1dG9TY3JvbGxGYWxsYmFjayB8fCBFZGdlIHx8IElFMTFPckxlc3MgfHwgU2FmYXJpKSB7XG4gICAgICAgIGF1dG9TY3JvbGwoZXZ0LCB0aGlzLm9wdGlvbnMsIGVsZW0sIGZhbGxiYWNrKTsgLy8gTGlzdGVuZXIgZm9yIHBvaW50ZXIgZWxlbWVudCBjaGFuZ2VcblxuICAgICAgICB2YXIgb2dFbGVtU2Nyb2xsZXIgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbGVtLCB0cnVlKTtcblxuICAgICAgICBpZiAoc2Nyb2xsaW5nICYmICghcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgfHwgeCAhPT0gbGFzdEF1dG9TY3JvbGxYIHx8IHkgIT09IGxhc3RBdXRvU2Nyb2xsWSkpIHtcbiAgICAgICAgICBwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCAmJiBjbGVhclBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKCk7IC8vIERldGVjdCBmb3IgcG9pbnRlciBlbGVtIGNoYW5nZSwgZW11bGF0aW5nIG5hdGl2ZSBEbkQgYmVoYXZpb3VyXG5cbiAgICAgICAgICBwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXdFbGVtID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmIChuZXdFbGVtICE9PSBvZ0VsZW1TY3JvbGxlcikge1xuICAgICAgICAgICAgICBvZ0VsZW1TY3JvbGxlciA9IG5ld0VsZW07XG4gICAgICAgICAgICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXV0b1Njcm9sbChldnQsIF90aGlzLm9wdGlvbnMsIG5ld0VsZW0sIGZhbGxiYWNrKTtcbiAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgbGFzdEF1dG9TY3JvbGxYID0geDtcbiAgICAgICAgICBsYXN0QXV0b1Njcm9sbFkgPSB5O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBEbkQgaXMgZW5hYmxlZCAoYW5kIGJyb3dzZXIgaGFzIGdvb2QgYXV0b3Njcm9sbGluZyksIGZpcnN0IGF1dG9zY3JvbGwgd2lsbCBhbHJlYWR5IHNjcm9sbCwgc28gZ2V0IHBhcmVudCBhdXRvc2Nyb2xsIG9mIGZpcnN0IGF1dG9zY3JvbGxcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYnViYmxlU2Nyb2xsIHx8IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsZW0sIHRydWUpID09PSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCkpIHtcbiAgICAgICAgICBjbGVhckF1dG9TY3JvbGxzKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXV0b1Njcm9sbChldnQsIHRoaXMub3B0aW9ucywgZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWxlbSwgZmFsc2UpLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gX2V4dGVuZHMoQXV0b1Njcm9sbCwge1xuICAgIHBsdWdpbk5hbWU6ICdzY3JvbGwnLFxuICAgIGluaXRpYWxpemVCeURlZmF1bHQ6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyQXV0b1Njcm9sbHMoKSB7XG4gIGF1dG9TY3JvbGxzLmZvckVhY2goZnVuY3Rpb24gKGF1dG9TY3JvbGwpIHtcbiAgICBjbGVhckludGVydmFsKGF1dG9TY3JvbGwucGlkKTtcbiAgfSk7XG4gIGF1dG9TY3JvbGxzID0gW107XG59XG5cbmZ1bmN0aW9uIGNsZWFyUG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwoKSB7XG4gIGNsZWFySW50ZXJ2YWwocG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwpO1xufVxuXG52YXIgYXV0b1Njcm9sbCA9IHRocm90dGxlKGZ1bmN0aW9uIChldnQsIG9wdGlvbnMsIHJvb3RFbCwgaXNGYWxsYmFjaykge1xuICAvLyBCdWc6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTUwNTUyMVxuICBpZiAoIW9wdGlvbnMuc2Nyb2xsKSByZXR1cm47XG4gIHZhciB4ID0gKGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpLmNsaWVudFgsXG4gICAgICB5ID0gKGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpLmNsaWVudFksXG4gICAgICBzZW5zID0gb3B0aW9ucy5zY3JvbGxTZW5zaXRpdml0eSxcbiAgICAgIHNwZWVkID0gb3B0aW9ucy5zY3JvbGxTcGVlZCxcbiAgICAgIHdpblNjcm9sbGVyID0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICB2YXIgc2Nyb2xsVGhpc0luc3RhbmNlID0gZmFsc2UsXG4gICAgICBzY3JvbGxDdXN0b21GbjsgLy8gTmV3IHNjcm9sbCByb290LCBzZXQgc2Nyb2xsRWxcblxuICBpZiAoc2Nyb2xsUm9vdEVsICE9PSByb290RWwpIHtcbiAgICBzY3JvbGxSb290RWwgPSByb290RWw7XG4gICAgY2xlYXJBdXRvU2Nyb2xscygpO1xuICAgIHNjcm9sbEVsID0gb3B0aW9ucy5zY3JvbGw7XG4gICAgc2Nyb2xsQ3VzdG9tRm4gPSBvcHRpb25zLnNjcm9sbEZuO1xuXG4gICAgaWYgKHNjcm9sbEVsID09PSB0cnVlKSB7XG4gICAgICBzY3JvbGxFbCA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KHJvb3RFbCwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxheWVyc091dCA9IDA7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gc2Nyb2xsRWw7XG5cbiAgZG8ge1xuICAgIHZhciBlbCA9IGN1cnJlbnRQYXJlbnQsXG4gICAgICAgIHJlY3QgPSBnZXRSZWN0KGVsKSxcbiAgICAgICAgdG9wID0gcmVjdC50b3AsXG4gICAgICAgIGJvdHRvbSA9IHJlY3QuYm90dG9tLFxuICAgICAgICBsZWZ0ID0gcmVjdC5sZWZ0LFxuICAgICAgICByaWdodCA9IHJlY3QucmlnaHQsXG4gICAgICAgIHdpZHRoID0gcmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQsXG4gICAgICAgIGNhblNjcm9sbFggPSB2b2lkIDAsXG4gICAgICAgIGNhblNjcm9sbFkgPSB2b2lkIDAsXG4gICAgICAgIHNjcm9sbFdpZHRoID0gZWwuc2Nyb2xsV2lkdGgsXG4gICAgICAgIHNjcm9sbEhlaWdodCA9IGVsLnNjcm9sbEhlaWdodCxcbiAgICAgICAgZWxDU1MgPSBjc3MoZWwpLFxuICAgICAgICBzY3JvbGxQb3NYID0gZWwuc2Nyb2xsTGVmdCxcbiAgICAgICAgc2Nyb2xsUG9zWSA9IGVsLnNjcm9sbFRvcDtcblxuICAgIGlmIChlbCA9PT0gd2luU2Nyb2xsZXIpIHtcbiAgICAgIGNhblNjcm9sbFggPSB3aWR0aCA8IHNjcm9sbFdpZHRoICYmIChlbENTUy5vdmVyZmxvd1ggPT09ICdhdXRvJyB8fCBlbENTUy5vdmVyZmxvd1ggPT09ICdzY3JvbGwnIHx8IGVsQ1NTLm92ZXJmbG93WCA9PT0gJ3Zpc2libGUnKTtcbiAgICAgIGNhblNjcm9sbFkgPSBoZWlnaHQgPCBzY3JvbGxIZWlnaHQgJiYgKGVsQ1NTLm92ZXJmbG93WSA9PT0gJ2F1dG8nIHx8IGVsQ1NTLm92ZXJmbG93WSA9PT0gJ3Njcm9sbCcgfHwgZWxDU1Mub3ZlcmZsb3dZID09PSAndmlzaWJsZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW5TY3JvbGxYID0gd2lkdGggPCBzY3JvbGxXaWR0aCAmJiAoZWxDU1Mub3ZlcmZsb3dYID09PSAnYXV0bycgfHwgZWxDU1Mub3ZlcmZsb3dYID09PSAnc2Nyb2xsJyk7XG4gICAgICBjYW5TY3JvbGxZID0gaGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0ICYmIChlbENTUy5vdmVyZmxvd1kgPT09ICdhdXRvJyB8fCBlbENTUy5vdmVyZmxvd1kgPT09ICdzY3JvbGwnKTtcbiAgICB9XG5cbiAgICB2YXIgdnggPSBjYW5TY3JvbGxYICYmIChNYXRoLmFicyhyaWdodCAtIHgpIDw9IHNlbnMgJiYgc2Nyb2xsUG9zWCArIHdpZHRoIDwgc2Nyb2xsV2lkdGgpIC0gKE1hdGguYWJzKGxlZnQgLSB4KSA8PSBzZW5zICYmICEhc2Nyb2xsUG9zWCk7XG4gICAgdmFyIHZ5ID0gY2FuU2Nyb2xsWSAmJiAoTWF0aC5hYnMoYm90dG9tIC0geSkgPD0gc2VucyAmJiBzY3JvbGxQb3NZICsgaGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0KSAtIChNYXRoLmFicyh0b3AgLSB5KSA8PSBzZW5zICYmICEhc2Nyb2xsUG9zWSk7XG5cbiAgICBpZiAoIWF1dG9TY3JvbGxzW2xheWVyc091dF0pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGxheWVyc091dDsgaSsrKSB7XG4gICAgICAgIGlmICghYXV0b1Njcm9sbHNbaV0pIHtcbiAgICAgICAgICBhdXRvU2Nyb2xsc1tpXSA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGF1dG9TY3JvbGxzW2xheWVyc091dF0udnggIT0gdnggfHwgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS52eSAhPSB2eSB8fCBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLmVsICE9PSBlbCkge1xuICAgICAgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5lbCA9IGVsO1xuICAgICAgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS52eCA9IHZ4O1xuICAgICAgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS52eSA9IHZ5O1xuICAgICAgY2xlYXJJbnRlcnZhbChhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnBpZCk7XG5cbiAgICAgIGlmICh2eCAhPSAwIHx8IHZ5ICE9IDApIHtcbiAgICAgICAgc2Nyb2xsVGhpc0luc3RhbmNlID0gdHJ1ZTtcbiAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOnRydWUgKi9cblxuICAgICAgICBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnBpZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBlbXVsYXRlIGRyYWcgb3ZlciBkdXJpbmcgYXV0b3Njcm9sbCAoZmFsbGJhY2spLCBlbXVsYXRpbmcgbmF0aXZlIERuRCBiZWhhdmlvdXJcbiAgICAgICAgICBpZiAoaXNGYWxsYmFjayAmJiB0aGlzLmxheWVyID09PSAwKSB7XG4gICAgICAgICAgICBTb3J0YWJsZS5hY3RpdmUuX29uVG91Y2hNb3ZlKHRvdWNoRXZ0JDEpOyAvLyBUbyBtb3ZlIGdob3N0IGlmIGl0IGlzIHBvc2l0aW9uZWQgYWJzb2x1dGVseVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNjcm9sbE9mZnNldFkgPSBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS52eSA/IGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLnZ5ICogc3BlZWQgOiAwO1xuICAgICAgICAgIHZhciBzY3JvbGxPZmZzZXRYID0gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnggPyBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS52eCAqIHNwZWVkIDogMDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygc2Nyb2xsQ3VzdG9tRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChzY3JvbGxDdXN0b21Gbi5jYWxsKFNvcnRhYmxlLmRyYWdnZWQucGFyZW50Tm9kZVtleHBhbmRvXSwgc2Nyb2xsT2Zmc2V0WCwgc2Nyb2xsT2Zmc2V0WSwgZXZ0LCB0b3VjaEV2dCQxLCBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS5lbCkgIT09ICdjb250aW51ZScpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNjcm9sbEJ5KGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLmVsLCBzY3JvbGxPZmZzZXRYLCBzY3JvbGxPZmZzZXRZKTtcbiAgICAgICAgfS5iaW5kKHtcbiAgICAgICAgICBsYXllcjogbGF5ZXJzT3V0XG4gICAgICAgIH0pLCAyNCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGF5ZXJzT3V0Kys7XG4gIH0gd2hpbGUgKG9wdGlvbnMuYnViYmxlU2Nyb2xsICYmIGN1cnJlbnRQYXJlbnQgIT09IHdpblNjcm9sbGVyICYmIChjdXJyZW50UGFyZW50ID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoY3VycmVudFBhcmVudCwgZmFsc2UpKSk7XG5cbiAgc2Nyb2xsaW5nID0gc2Nyb2xsVGhpc0luc3RhbmNlOyAvLyBpbiBjYXNlIGFub3RoZXIgZnVuY3Rpb24gY2F0Y2hlcyBzY3JvbGxpbmcgYXMgZmFsc2UgaW4gYmV0d2VlbiB3aGVuIGl0IGlzIG5vdFxufSwgMzApO1xuXG52YXIgZHJvcCA9IGZ1bmN0aW9uIGRyb3AoX3JlZikge1xuICB2YXIgb3JpZ2luYWxFdmVudCA9IF9yZWYub3JpZ2luYWxFdmVudCxcbiAgICAgIHB1dFNvcnRhYmxlID0gX3JlZi5wdXRTb3J0YWJsZSxcbiAgICAgIGRyYWdFbCA9IF9yZWYuZHJhZ0VsLFxuICAgICAgYWN0aXZlU29ydGFibGUgPSBfcmVmLmFjdGl2ZVNvcnRhYmxlLFxuICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50ID0gX3JlZi5kaXNwYXRjaFNvcnRhYmxlRXZlbnQsXG4gICAgICBoaWRlR2hvc3RGb3JUYXJnZXQgPSBfcmVmLmhpZGVHaG9zdEZvclRhcmdldCxcbiAgICAgIHVuaGlkZUdob3N0Rm9yVGFyZ2V0ID0gX3JlZi51bmhpZGVHaG9zdEZvclRhcmdldDtcbiAgaWYgKCFvcmlnaW5hbEV2ZW50KSByZXR1cm47XG4gIHZhciB0b1NvcnRhYmxlID0gcHV0U29ydGFibGUgfHwgYWN0aXZlU29ydGFibGU7XG4gIGhpZGVHaG9zdEZvclRhcmdldCgpO1xuICB2YXIgdG91Y2ggPSBvcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIG9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID8gb3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IG9yaWdpbmFsRXZlbnQ7XG4gIHZhciB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpO1xuICB1bmhpZGVHaG9zdEZvclRhcmdldCgpO1xuXG4gIGlmICh0b1NvcnRhYmxlICYmICF0b1NvcnRhYmxlLmVsLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQoJ3NwaWxsJyk7XG4gICAgdGhpcy5vblNwaWxsKHtcbiAgICAgIGRyYWdFbDogZHJhZ0VsLFxuICAgICAgcHV0U29ydGFibGU6IHB1dFNvcnRhYmxlXG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFJldmVydCgpIHt9XG5cblJldmVydC5wcm90b3R5cGUgPSB7XG4gIHN0YXJ0SW5kZXg6IG51bGwsXG4gIGRyYWdTdGFydDogZnVuY3Rpb24gZHJhZ1N0YXJ0KF9yZWYyKSB7XG4gICAgdmFyIG9sZERyYWdnYWJsZUluZGV4ID0gX3JlZjIub2xkRHJhZ2dhYmxlSW5kZXg7XG4gICAgdGhpcy5zdGFydEluZGV4ID0gb2xkRHJhZ2dhYmxlSW5kZXg7XG4gIH0sXG4gIG9uU3BpbGw6IGZ1bmN0aW9uIG9uU3BpbGwoX3JlZjMpIHtcbiAgICB2YXIgZHJhZ0VsID0gX3JlZjMuZHJhZ0VsLFxuICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWYzLnB1dFNvcnRhYmxlO1xuICAgIHRoaXMuc29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG5cbiAgICBpZiAocHV0U29ydGFibGUpIHtcbiAgICAgIHB1dFNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgIH1cblxuICAgIHZhciBuZXh0U2libGluZyA9IGdldENoaWxkKHRoaXMuc29ydGFibGUuZWwsIHRoaXMuc3RhcnRJbmRleCwgdGhpcy5vcHRpb25zKTtcblxuICAgIGlmIChuZXh0U2libGluZykge1xuICAgICAgdGhpcy5zb3J0YWJsZS5lbC5pbnNlcnRCZWZvcmUoZHJhZ0VsLCBuZXh0U2libGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc29ydGFibGUuZWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICB9XG5cbiAgICB0aGlzLnNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcblxuICAgIGlmIChwdXRTb3J0YWJsZSkge1xuICAgICAgcHV0U29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICAgIH1cbiAgfSxcbiAgZHJvcDogZHJvcFxufTtcblxuX2V4dGVuZHMoUmV2ZXJ0LCB7XG4gIHBsdWdpbk5hbWU6ICdyZXZlcnRPblNwaWxsJ1xufSk7XG5cbmZ1bmN0aW9uIFJlbW92ZSgpIHt9XG5cblJlbW92ZS5wcm90b3R5cGUgPSB7XG4gIG9uU3BpbGw6IGZ1bmN0aW9uIG9uU3BpbGwoX3JlZjQpIHtcbiAgICB2YXIgZHJhZ0VsID0gX3JlZjQuZHJhZ0VsLFxuICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWY0LnB1dFNvcnRhYmxlO1xuICAgIHZhciBwYXJlbnRTb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IHRoaXMuc29ydGFibGU7XG4gICAgcGFyZW50U29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG4gICAgZHJhZ0VsLnBhcmVudE5vZGUgJiYgZHJhZ0VsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZHJhZ0VsKTtcbiAgICBwYXJlbnRTb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gIH0sXG4gIGRyb3A6IGRyb3Bcbn07XG5cbl9leHRlbmRzKFJlbW92ZSwge1xuICBwbHVnaW5OYW1lOiAncmVtb3ZlT25TcGlsbCdcbn0pO1xuXG52YXIgbGFzdFN3YXBFbDtcblxuZnVuY3Rpb24gU3dhcFBsdWdpbigpIHtcbiAgZnVuY3Rpb24gU3dhcCgpIHtcbiAgICB0aGlzLmRlZmF1bHRzID0ge1xuICAgICAgc3dhcENsYXNzOiAnc29ydGFibGUtc3dhcC1oaWdobGlnaHQnXG4gICAgfTtcbiAgfVxuXG4gIFN3YXAucHJvdG90eXBlID0ge1xuICAgIGRyYWdTdGFydDogZnVuY3Rpb24gZHJhZ1N0YXJ0KF9yZWYpIHtcbiAgICAgIHZhciBkcmFnRWwgPSBfcmVmLmRyYWdFbDtcbiAgICAgIGxhc3RTd2FwRWwgPSBkcmFnRWw7XG4gICAgfSxcbiAgICBkcmFnT3ZlclZhbGlkOiBmdW5jdGlvbiBkcmFnT3ZlclZhbGlkKF9yZWYyKSB7XG4gICAgICB2YXIgY29tcGxldGVkID0gX3JlZjIuY29tcGxldGVkLFxuICAgICAgICAgIHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgICAgICBvbk1vdmUgPSBfcmVmMi5vbk1vdmUsXG4gICAgICAgICAgYWN0aXZlU29ydGFibGUgPSBfcmVmMi5hY3RpdmVTb3J0YWJsZSxcbiAgICAgICAgICBjaGFuZ2VkID0gX3JlZjIuY2hhbmdlZCxcbiAgICAgICAgICBjYW5jZWwgPSBfcmVmMi5jYW5jZWw7XG4gICAgICBpZiAoIWFjdGl2ZVNvcnRhYmxlLm9wdGlvbnMuc3dhcCkgcmV0dXJuO1xuICAgICAgdmFyIGVsID0gdGhpcy5zb3J0YWJsZS5lbCxcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgdmFyIHByZXZTd2FwRWwgPSBsYXN0U3dhcEVsO1xuXG4gICAgICAgIGlmIChvbk1vdmUodGFyZ2V0KSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB0b2dnbGVDbGFzcyh0YXJnZXQsIG9wdGlvbnMuc3dhcENsYXNzLCB0cnVlKTtcbiAgICAgICAgICBsYXN0U3dhcEVsID0gdGFyZ2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RTd2FwRWwgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXZTd2FwRWwgJiYgcHJldlN3YXBFbCAhPT0gbGFzdFN3YXBFbCkge1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKHByZXZTd2FwRWwsIG9wdGlvbnMuc3dhcENsYXNzLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hhbmdlZCgpO1xuICAgICAgY29tcGxldGVkKHRydWUpO1xuICAgICAgY2FuY2VsKCk7XG4gICAgfSxcbiAgICBkcm9wOiBmdW5jdGlvbiBkcm9wKF9yZWYzKSB7XG4gICAgICB2YXIgYWN0aXZlU29ydGFibGUgPSBfcmVmMy5hY3RpdmVTb3J0YWJsZSxcbiAgICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWYzLnB1dFNvcnRhYmxlLFxuICAgICAgICAgIGRyYWdFbCA9IF9yZWYzLmRyYWdFbDtcbiAgICAgIHZhciB0b1NvcnRhYmxlID0gcHV0U29ydGFibGUgfHwgdGhpcy5zb3J0YWJsZTtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgbGFzdFN3YXBFbCAmJiB0b2dnbGVDbGFzcyhsYXN0U3dhcEVsLCBvcHRpb25zLnN3YXBDbGFzcywgZmFsc2UpO1xuXG4gICAgICBpZiAobGFzdFN3YXBFbCAmJiAob3B0aW9ucy5zd2FwIHx8IHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLm9wdGlvbnMuc3dhcCkpIHtcbiAgICAgICAgaWYgKGRyYWdFbCAhPT0gbGFzdFN3YXBFbCkge1xuICAgICAgICAgIHRvU29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG4gICAgICAgICAgaWYgKHRvU29ydGFibGUgIT09IGFjdGl2ZVNvcnRhYmxlKSBhY3RpdmVTb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICAgICAgICBzd2FwTm9kZXMoZHJhZ0VsLCBsYXN0U3dhcEVsKTtcbiAgICAgICAgICB0b1NvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICAgICAgICBpZiAodG9Tb3J0YWJsZSAhPT0gYWN0aXZlU29ydGFibGUpIGFjdGl2ZVNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbnVsbGluZzogZnVuY3Rpb24gbnVsbGluZygpIHtcbiAgICAgIGxhc3RTd2FwRWwgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzKFN3YXAsIHtcbiAgICBwbHVnaW5OYW1lOiAnc3dhcCcsXG4gICAgZXZlbnRQcm9wZXJ0aWVzOiBmdW5jdGlvbiBldmVudFByb3BlcnRpZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzd2FwSXRlbTogbGFzdFN3YXBFbFxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzd2FwTm9kZXMobjEsIG4yKSB7XG4gIHZhciBwMSA9IG4xLnBhcmVudE5vZGUsXG4gICAgICBwMiA9IG4yLnBhcmVudE5vZGUsXG4gICAgICBpMSxcbiAgICAgIGkyO1xuICBpZiAoIXAxIHx8ICFwMiB8fCBwMS5pc0VxdWFsTm9kZShuMikgfHwgcDIuaXNFcXVhbE5vZGUobjEpKSByZXR1cm47XG4gIGkxID0gaW5kZXgobjEpO1xuICBpMiA9IGluZGV4KG4yKTtcblxuICBpZiAocDEuaXNFcXVhbE5vZGUocDIpICYmIGkxIDwgaTIpIHtcbiAgICBpMisrO1xuICB9XG5cbiAgcDEuaW5zZXJ0QmVmb3JlKG4yLCBwMS5jaGlsZHJlbltpMV0pO1xuICBwMi5pbnNlcnRCZWZvcmUobjEsIHAyLmNoaWxkcmVuW2kyXSk7XG59XG5cbnZhciBtdWx0aURyYWdFbGVtZW50cyA9IFtdLFxuICAgIG11bHRpRHJhZ0Nsb25lcyA9IFtdLFxuICAgIGxhc3RNdWx0aURyYWdTZWxlY3QsXG4gICAgLy8gZm9yIHNlbGVjdGlvbiB3aXRoIG1vZGlmaWVyIGtleSBkb3duIChTSElGVClcbm11bHRpRHJhZ1NvcnRhYmxlLFxuICAgIGluaXRpYWxGb2xkaW5nID0gZmFsc2UsXG4gICAgLy8gSW5pdGlhbCBtdWx0aS1kcmFnIGZvbGQgd2hlbiBkcmFnIHN0YXJ0ZWRcbmZvbGRpbmcgPSBmYWxzZSxcbiAgICAvLyBGb2xkaW5nIGFueSBvdGhlciB0aW1lXG5kcmFnU3RhcnRlZCA9IGZhbHNlLFxuICAgIGRyYWdFbCQxLFxuICAgIGNsb25lc0Zyb21SZWN0LFxuICAgIGNsb25lc0hpZGRlbjtcblxuZnVuY3Rpb24gTXVsdGlEcmFnUGx1Z2luKCkge1xuICBmdW5jdGlvbiBNdWx0aURyYWcoc29ydGFibGUpIHtcbiAgICAvLyBCaW5kIGFsbCBwcml2YXRlIG1ldGhvZHNcbiAgICBmb3IgKHZhciBmbiBpbiB0aGlzKSB7XG4gICAgICBpZiAoZm4uY2hhckF0KDApID09PSAnXycgJiYgdHlwZW9mIHRoaXNbZm5dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXNbZm5dID0gdGhpc1tmbl0uYmluZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc29ydGFibGUub3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgICAgb24oZG9jdW1lbnQsICdwb2ludGVydXAnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKTtcbiAgICAgIG9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgfVxuXG4gICAgb24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fY2hlY2tLZXlEb3duKTtcbiAgICBvbihkb2N1bWVudCwgJ2tleXVwJywgdGhpcy5fY2hlY2tLZXlVcCk7XG4gICAgdGhpcy5kZWZhdWx0cyA9IHtcbiAgICAgIHNlbGVjdGVkQ2xhc3M6ICdzb3J0YWJsZS1zZWxlY3RlZCcsXG4gICAgICBtdWx0aURyYWdLZXk6IG51bGwsXG4gICAgICBzZXREYXRhOiBmdW5jdGlvbiBzZXREYXRhKGRhdGFUcmFuc2ZlciwgZHJhZ0VsKSB7XG4gICAgICAgIHZhciBkYXRhID0gJyc7XG5cbiAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCAmJiBtdWx0aURyYWdTb3J0YWJsZSA9PT0gc29ydGFibGUpIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50LCBpKSB7XG4gICAgICAgICAgICBkYXRhICs9ICghaSA/ICcnIDogJywgJykgKyBtdWx0aURyYWdFbGVtZW50LnRleHRDb250ZW50O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEgPSBkcmFnRWwudGV4dENvbnRlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhVHJhbnNmZXIuc2V0RGF0YSgnVGV4dCcsIGRhdGEpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBNdWx0aURyYWcucHJvdG90eXBlID0ge1xuICAgIG11bHRpRHJhZ0tleURvd246IGZhbHNlLFxuICAgIGlzTXVsdGlEcmFnOiBmYWxzZSxcbiAgICBkZWxheVN0YXJ0R2xvYmFsOiBmdW5jdGlvbiBkZWxheVN0YXJ0R2xvYmFsKF9yZWYpIHtcbiAgICAgIHZhciBkcmFnZ2VkID0gX3JlZi5kcmFnRWw7XG4gICAgICBkcmFnRWwkMSA9IGRyYWdnZWQ7XG4gICAgfSxcbiAgICBkZWxheUVuZGVkOiBmdW5jdGlvbiBkZWxheUVuZGVkKCkge1xuICAgICAgdGhpcy5pc011bHRpRHJhZyA9IH5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGRyYWdFbCQxKTtcbiAgICB9LFxuICAgIHNldHVwQ2xvbmU6IGZ1bmN0aW9uIHNldHVwQ2xvbmUoX3JlZjIpIHtcbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWYyLnNvcnRhYmxlLFxuICAgICAgICAgIGNhbmNlbCA9IF9yZWYyLmNhbmNlbDtcbiAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZykgcmV0dXJuO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG11bHRpRHJhZ0Nsb25lcy5wdXNoKGNsb25lKG11bHRpRHJhZ0VsZW1lbnRzW2ldKSk7XG4gICAgICAgIG11bHRpRHJhZ0Nsb25lc1tpXS5zb3J0YWJsZUluZGV4ID0gbXVsdGlEcmFnRWxlbWVudHNbaV0uc29ydGFibGVJbmRleDtcbiAgICAgICAgbXVsdGlEcmFnQ2xvbmVzW2ldLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICBtdWx0aURyYWdDbG9uZXNbaV0uc3R5bGVbJ3dpbGwtY2hhbmdlJ10gPSAnJztcbiAgICAgICAgdG9nZ2xlQ2xhc3MobXVsdGlEcmFnQ2xvbmVzW2ldLCB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgZmFsc2UpO1xuICAgICAgICBtdWx0aURyYWdFbGVtZW50c1tpXSA9PT0gZHJhZ0VsJDEgJiYgdG9nZ2xlQ2xhc3MobXVsdGlEcmFnQ2xvbmVzW2ldLCB0aGlzLm9wdGlvbnMuY2hvc2VuQ2xhc3MsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgc29ydGFibGUuX2hpZGVDbG9uZSgpO1xuXG4gICAgICBjYW5jZWwoKTtcbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbiBjbG9uZShfcmVmMykge1xuICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjMuc29ydGFibGUsXG4gICAgICAgICAgcm9vdEVsID0gX3JlZjMucm9vdEVsLFxuICAgICAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCA9IF9yZWYzLmRpc3BhdGNoU29ydGFibGVFdmVudCxcbiAgICAgICAgICBjYW5jZWwgPSBfcmVmMy5jYW5jZWw7XG4gICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUpIHtcbiAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCAmJiBtdWx0aURyYWdTb3J0YWJsZSA9PT0gc29ydGFibGUpIHtcbiAgICAgICAgICBpbnNlcnRNdWx0aURyYWdDbG9uZXModHJ1ZSwgcm9vdEVsKTtcbiAgICAgICAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQoJ2Nsb25lJyk7XG4gICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3dDbG9uZTogZnVuY3Rpb24gc2hvd0Nsb25lKF9yZWY0KSB7XG4gICAgICB2YXIgY2xvbmVOb3dTaG93biA9IF9yZWY0LmNsb25lTm93U2hvd24sXG4gICAgICAgICAgcm9vdEVsID0gX3JlZjQucm9vdEVsLFxuICAgICAgICAgIGNhbmNlbCA9IF9yZWY0LmNhbmNlbDtcbiAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZykgcmV0dXJuO1xuICAgICAgaW5zZXJ0TXVsdGlEcmFnQ2xvbmVzKGZhbHNlLCByb290RWwpO1xuICAgICAgbXVsdGlEcmFnQ2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgIGNzcyhjbG9uZSwgJ2Rpc3BsYXknLCAnJyk7XG4gICAgICB9KTtcbiAgICAgIGNsb25lTm93U2hvd24oKTtcbiAgICAgIGNsb25lc0hpZGRlbiA9IGZhbHNlO1xuICAgICAgY2FuY2VsKCk7XG4gICAgfSxcbiAgICBoaWRlQ2xvbmU6IGZ1bmN0aW9uIGhpZGVDbG9uZShfcmVmNSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjUuc29ydGFibGUsXG4gICAgICAgICAgY2xvbmVOb3dIaWRkZW4gPSBfcmVmNS5jbG9uZU5vd0hpZGRlbixcbiAgICAgICAgICBjYW5jZWwgPSBfcmVmNS5jYW5jZWw7XG4gICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcbiAgICAgIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICBjc3MoY2xvbmUsICdkaXNwbGF5JywgJ25vbmUnKTtcblxuICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5yZW1vdmVDbG9uZU9uSGlkZSAmJiBjbG9uZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgY2xvbmUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY2xvbmVOb3dIaWRkZW4oKTtcbiAgICAgIGNsb25lc0hpZGRlbiA9IHRydWU7XG4gICAgICBjYW5jZWwoKTtcbiAgICB9LFxuICAgIGRyYWdTdGFydEdsb2JhbDogZnVuY3Rpb24gZHJhZ1N0YXJ0R2xvYmFsKF9yZWY2KSB7XG4gICAgICB2YXIgc29ydGFibGUgPSBfcmVmNi5zb3J0YWJsZTtcblxuICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnICYmIG11bHRpRHJhZ1NvcnRhYmxlKSB7XG4gICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlLm11bHRpRHJhZy5fZGVzZWxlY3RNdWx0aURyYWcoKTtcbiAgICAgIH1cblxuICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICBtdWx0aURyYWdFbGVtZW50LnNvcnRhYmxlSW5kZXggPSBpbmRleChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgIH0pOyAvLyBTb3J0IG11bHRpLWRyYWcgZWxlbWVudHNcblxuICAgICAgbXVsdGlEcmFnRWxlbWVudHMgPSBtdWx0aURyYWdFbGVtZW50cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnNvcnRhYmxlSW5kZXggLSBiLnNvcnRhYmxlSW5kZXg7XG4gICAgICB9KTtcbiAgICAgIGRyYWdTdGFydGVkID0gdHJ1ZTtcbiAgICB9LFxuICAgIGRyYWdTdGFydGVkOiBmdW5jdGlvbiBkcmFnU3RhcnRlZChfcmVmNykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWY3LnNvcnRhYmxlO1xuICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnKSByZXR1cm47XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc29ydCkge1xuICAgICAgICAvLyBDYXB0dXJlIHJlY3RzLFxuICAgICAgICAvLyBoaWRlIG11bHRpIGRyYWcgZWxlbWVudHMgKGJ5IHBvc2l0aW9uaW5nIHRoZW0gYWJzb2x1dGUpLFxuICAgICAgICAvLyBzZXQgbXVsdGkgZHJhZyBlbGVtZW50cyByZWN0cyB0byBkcmFnUmVjdCxcbiAgICAgICAgLy8gc2hvdyBtdWx0aSBkcmFnIGVsZW1lbnRzLFxuICAgICAgICAvLyBhbmltYXRlIHRvIHJlY3RzLFxuICAgICAgICAvLyB1bnNldCByZWN0cyAmIHJlbW92ZSBmcm9tIERPTVxuICAgICAgICBzb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50ID09PSBkcmFnRWwkMSkgcmV0dXJuO1xuICAgICAgICAgICAgY3NzKG11bHRpRHJhZ0VsZW1lbnQsICdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBkcmFnUmVjdCA9IGdldFJlY3QoZHJhZ0VsJDEsIGZhbHNlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudCA9PT0gZHJhZ0VsJDEpIHJldHVybjtcbiAgICAgICAgICAgIHNldFJlY3QobXVsdGlEcmFnRWxlbWVudCwgZHJhZ1JlY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvbGRpbmcgPSB0cnVlO1xuICAgICAgICAgIGluaXRpYWxGb2xkaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzb3J0YWJsZS5hbmltYXRlQWxsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9sZGluZyA9IGZhbHNlO1xuICAgICAgICBpbml0aWFsRm9sZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICB1bnNldFJlY3QobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gUmVtb3ZlIGFsbCBhdXhpbGlhcnkgbXVsdGlkcmFnIGl0ZW1zIGZyb20gZWwsIGlmIHNvcnRpbmcgZW5hYmxlZFxuXG5cbiAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zLnNvcnQpIHtcbiAgICAgICAgICByZW1vdmVNdWx0aURyYWdFbGVtZW50cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRyYWdPdmVyOiBmdW5jdGlvbiBkcmFnT3ZlcihfcmVmOCkge1xuICAgICAgdmFyIHRhcmdldCA9IF9yZWY4LnRhcmdldCxcbiAgICAgICAgICBjb21wbGV0ZWQgPSBfcmVmOC5jb21wbGV0ZWQsXG4gICAgICAgICAgY2FuY2VsID0gX3JlZjguY2FuY2VsO1xuXG4gICAgICBpZiAoZm9sZGluZyAmJiB+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZih0YXJnZXQpKSB7XG4gICAgICAgIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmV2ZXJ0OiBmdW5jdGlvbiByZXZlcnQoX3JlZjkpIHtcbiAgICAgIHZhciBmcm9tU29ydGFibGUgPSBfcmVmOS5mcm9tU29ydGFibGUsXG4gICAgICAgICAgcm9vdEVsID0gX3JlZjkucm9vdEVsLFxuICAgICAgICAgIHNvcnRhYmxlID0gX3JlZjkuc29ydGFibGUsXG4gICAgICAgICAgZHJhZ1JlY3QgPSBfcmVmOS5kcmFnUmVjdDtcblxuICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gU2V0dXAgdW5mb2xkIGFuaW1hdGlvblxuICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgc29ydGFibGUuYWRkQW5pbWF0aW9uU3RhdGUoe1xuICAgICAgICAgICAgdGFyZ2V0OiBtdWx0aURyYWdFbGVtZW50LFxuICAgICAgICAgICAgcmVjdDogZm9sZGluZyA/IGdldFJlY3QobXVsdGlEcmFnRWxlbWVudCkgOiBkcmFnUmVjdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHVuc2V0UmVjdChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50LmZyb21SZWN0ID0gZHJhZ1JlY3Q7XG4gICAgICAgICAgZnJvbVNvcnRhYmxlLnJlbW92ZUFuaW1hdGlvblN0YXRlKG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9sZGluZyA9IGZhbHNlO1xuICAgICAgICBpbnNlcnRNdWx0aURyYWdFbGVtZW50cyghdGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlLCByb290RWwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZHJhZ092ZXJDb21wbGV0ZWQ6IGZ1bmN0aW9uIGRyYWdPdmVyQ29tcGxldGVkKF9yZWYxMCkge1xuICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjEwLnNvcnRhYmxlLFxuICAgICAgICAgIGlzT3duZXIgPSBfcmVmMTAuaXNPd25lcixcbiAgICAgICAgICBpbnNlcnRpb24gPSBfcmVmMTAuaW5zZXJ0aW9uLFxuICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlID0gX3JlZjEwLmFjdGl2ZVNvcnRhYmxlLFxuICAgICAgICAgIHBhcmVudEVsID0gX3JlZjEwLnBhcmVudEVsLFxuICAgICAgICAgIHB1dFNvcnRhYmxlID0gX3JlZjEwLnB1dFNvcnRhYmxlO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgIGlmIChpbnNlcnRpb24pIHtcbiAgICAgICAgLy8gQ2xvbmVzIG11c3QgYmUgaGlkZGVuIGJlZm9yZSBmb2xkaW5nIGFuaW1hdGlvbiB0byBjYXB0dXJlIGRyYWdSZWN0QWJzb2x1dGUgcHJvcGVybHlcbiAgICAgICAgaWYgKGlzT3duZXIpIHtcbiAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5faGlkZUNsb25lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbml0aWFsRm9sZGluZyA9IGZhbHNlOyAvLyBJZiBsZWF2aW5nIHNvcnQ6ZmFsc2Ugcm9vdCwgb3IgYWxyZWFkeSBmb2xkaW5nIC0gRm9sZCB0byBuZXcgbG9jYXRpb25cblxuICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gJiYgbXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoID4gMSAmJiAoZm9sZGluZyB8fCAhaXNPd25lciAmJiAhYWN0aXZlU29ydGFibGUub3B0aW9ucy5zb3J0ICYmICFwdXRTb3J0YWJsZSkpIHtcbiAgICAgICAgICAvLyBGb2xkOiBTZXQgYWxsIG11bHRpIGRyYWcgZWxlbWVudHMncyByZWN0cyB0byBkcmFnRWwncyByZWN0IHdoZW4gbXVsdGktZHJhZyBlbGVtZW50cyBhcmUgaW52aXNpYmxlXG4gICAgICAgICAgdmFyIGRyYWdSZWN0QWJzb2x1dGUgPSBnZXRSZWN0KGRyYWdFbCQxLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQgPT09IGRyYWdFbCQxKSByZXR1cm47XG4gICAgICAgICAgICBzZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQsIGRyYWdSZWN0QWJzb2x1dGUpOyAvLyBNb3ZlIGVsZW1lbnQocykgdG8gZW5kIG9mIHBhcmVudEVsIHNvIHRoYXQgaXQgZG9lcyBub3QgaW50ZXJmZXJlIHdpdGggbXVsdGktZHJhZyBjbG9uZXMgaW5zZXJ0aW9uIGlmIHRoZXkgYXJlIGluc2VydGVkXG4gICAgICAgICAgICAvLyB3aGlsZSBmb2xkaW5nLCBhbmQgc28gdGhhdCB3ZSBjYW4gY2FwdHVyZSB0aGVtIGFnYWluIGJlY2F1c2Ugb2xkIHNvcnRhYmxlIHdpbGwgbm8gbG9uZ2VyIGJlIGZyb21Tb3J0YWJsZVxuXG4gICAgICAgICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb2xkaW5nID0gdHJ1ZTtcbiAgICAgICAgfSAvLyBDbG9uZXMgbXVzdCBiZSBzaG93biAoYW5kIGNoZWNrIHRvIHJlbW92ZSBtdWx0aSBkcmFncykgYWZ0ZXIgZm9sZGluZyB3aGVuIGludGVyZmVyaW5nIG11bHRpRHJhZ0VsZW1lbnRzIGFyZSBtb3ZlZCBvdXRcblxuXG4gICAgICAgIGlmICghaXNPd25lcikge1xuICAgICAgICAgIC8vIE9ubHkgcmVtb3ZlIGlmIG5vdCBmb2xkaW5nIChmb2xkaW5nIHdpbGwgcmVtb3ZlIHRoZW0gYW55d2F5cylcbiAgICAgICAgICBpZiAoIWZvbGRpbmcpIHtcbiAgICAgICAgICAgIHJlbW92ZU11bHRpRHJhZ0VsZW1lbnRzKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBjbG9uZXNIaWRkZW5CZWZvcmUgPSBjbG9uZXNIaWRkZW47XG5cbiAgICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlLl9zaG93Q2xvbmUoc29ydGFibGUpOyAvLyBVbmZvbGQgYW5pbWF0aW9uIGZvciBjbG9uZXMgaWYgc2hvd2luZyBmcm9tIGhpZGRlblxuXG5cbiAgICAgICAgICAgIGlmIChhY3RpdmVTb3J0YWJsZS5vcHRpb25zLmFuaW1hdGlvbiAmJiAhY2xvbmVzSGlkZGVuICYmIGNsb25lc0hpZGRlbkJlZm9yZSkge1xuICAgICAgICAgICAgICBtdWx0aURyYWdDbG9uZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5hZGRBbmltYXRpb25TdGF0ZSh7XG4gICAgICAgICAgICAgICAgICB0YXJnZXQ6IGNsb25lLFxuICAgICAgICAgICAgICAgICAgcmVjdDogY2xvbmVzRnJvbVJlY3RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjbG9uZS5mcm9tUmVjdCA9IGNsb25lc0Zyb21SZWN0O1xuICAgICAgICAgICAgICAgIGNsb25lLnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5fc2hvd0Nsb25lKHNvcnRhYmxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdPdmVyQW5pbWF0aW9uQ2FwdHVyZTogZnVuY3Rpb24gZHJhZ092ZXJBbmltYXRpb25DYXB0dXJlKF9yZWYxMSkge1xuICAgICAgdmFyIGRyYWdSZWN0ID0gX3JlZjExLmRyYWdSZWN0LFxuICAgICAgICAgIGlzT3duZXIgPSBfcmVmMTEuaXNPd25lcixcbiAgICAgICAgICBhY3RpdmVTb3J0YWJsZSA9IF9yZWYxMS5hY3RpdmVTb3J0YWJsZTtcbiAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudC50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSBudWxsO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChhY3RpdmVTb3J0YWJsZS5vcHRpb25zLmFuaW1hdGlvbiAmJiAhaXNPd25lciAmJiBhY3RpdmVTb3J0YWJsZS5tdWx0aURyYWcuaXNNdWx0aURyYWcpIHtcbiAgICAgICAgY2xvbmVzRnJvbVJlY3QgPSBfZXh0ZW5kcyh7fSwgZHJhZ1JlY3QpO1xuICAgICAgICB2YXIgZHJhZ01hdHJpeCA9IG1hdHJpeChkcmFnRWwkMSwgdHJ1ZSk7XG4gICAgICAgIGNsb25lc0Zyb21SZWN0LnRvcCAtPSBkcmFnTWF0cml4LmY7XG4gICAgICAgIGNsb25lc0Zyb21SZWN0LmxlZnQgLT0gZHJhZ01hdHJpeC5lO1xuICAgICAgfVxuICAgIH0sXG4gICAgZHJhZ092ZXJBbmltYXRpb25Db21wbGV0ZTogZnVuY3Rpb24gZHJhZ092ZXJBbmltYXRpb25Db21wbGV0ZSgpIHtcbiAgICAgIGlmIChmb2xkaW5nKSB7XG4gICAgICAgIGZvbGRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmVtb3ZlTXVsdGlEcmFnRWxlbWVudHMoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyb3A6IGZ1bmN0aW9uIGRyb3AoX3JlZjEyKSB7XG4gICAgICB2YXIgZXZ0ID0gX3JlZjEyLm9yaWdpbmFsRXZlbnQsXG4gICAgICAgICAgcm9vdEVsID0gX3JlZjEyLnJvb3RFbCxcbiAgICAgICAgICBwYXJlbnRFbCA9IF9yZWYxMi5wYXJlbnRFbCxcbiAgICAgICAgICBzb3J0YWJsZSA9IF9yZWYxMi5zb3J0YWJsZSxcbiAgICAgICAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQgPSBfcmVmMTIuZGlzcGF0Y2hTb3J0YWJsZUV2ZW50LFxuICAgICAgICAgIG9sZEluZGV4ID0gX3JlZjEyLm9sZEluZGV4LFxuICAgICAgICAgIHB1dFNvcnRhYmxlID0gX3JlZjEyLnB1dFNvcnRhYmxlO1xuICAgICAgdmFyIHRvU29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCB0aGlzLnNvcnRhYmxlO1xuICAgICAgaWYgKCFldnQpIHJldHVybjtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIGNoaWxkcmVuID0gcGFyZW50RWwuY2hpbGRyZW47IC8vIE11bHRpLWRyYWcgc2VsZWN0aW9uXG5cbiAgICAgIGlmICghZHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubXVsdGlEcmFnS2V5ICYmICF0aGlzLm11bHRpRHJhZ0tleURvd24pIHtcbiAgICAgICAgICB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsJDEsIG9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgIX5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGRyYWdFbCQxKSk7XG5cbiAgICAgICAgaWYgKCF+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihkcmFnRWwkMSkpIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5wdXNoKGRyYWdFbCQxKTtcbiAgICAgICAgICBkaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgICAgIHJvb3RFbDogcm9vdEVsLFxuICAgICAgICAgICAgbmFtZTogJ3NlbGVjdCcsXG4gICAgICAgICAgICB0YXJnZXRFbDogZHJhZ0VsJDEsXG4gICAgICAgICAgICBvcmlnaW5hbEV2dDogZXZ0XG4gICAgICAgICAgfSk7IC8vIE1vZGlmaWVyIGFjdGl2YXRlZCwgc2VsZWN0IGZyb20gbGFzdCB0byBkcmFnRWxcblxuICAgICAgICAgIGlmIChldnQuc2hpZnRLZXkgJiYgbGFzdE11bHRpRHJhZ1NlbGVjdCAmJiBzb3J0YWJsZS5lbC5jb250YWlucyhsYXN0TXVsdGlEcmFnU2VsZWN0KSkge1xuICAgICAgICAgICAgdmFyIGxhc3RJbmRleCA9IGluZGV4KGxhc3RNdWx0aURyYWdTZWxlY3QpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IGluZGV4KGRyYWdFbCQxKTtcblxuICAgICAgICAgICAgaWYgKH5sYXN0SW5kZXggJiYgfmN1cnJlbnRJbmRleCAmJiBsYXN0SW5kZXggIT09IGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgICAvLyBNdXN0IGluY2x1ZGUgbGFzdE11bHRpRHJhZ1NlbGVjdCAoc2VsZWN0IGl0KSwgaW4gY2FzZSBtb2RpZmllZCBzZWxlY3Rpb24gZnJvbSBubyBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgLy8gKGJ1dCBwcmV2aW91cyBzZWxlY3Rpb24gZXhpc3RlZClcbiAgICAgICAgICAgICAgdmFyIG4sIGk7XG5cbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgIGkgPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgbiA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpID0gY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgIG4gPSBsYXN0SW5kZXggKyAxO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAofm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoY2hpbGRyZW5baV0pKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhjaGlsZHJlbltpXSwgb3B0aW9ucy5zZWxlY3RlZENsYXNzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgICAgICAgICAgIHJvb3RFbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgICAgbmFtZTogJ3NlbGVjdCcsXG4gICAgICAgICAgICAgICAgICB0YXJnZXRFbDogY2hpbGRyZW5baV0sXG4gICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2dDogZXZ0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdE11bHRpRHJhZ1NlbGVjdCA9IGRyYWdFbCQxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlID0gdG9Tb3J0YWJsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5zcGxpY2UobXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihkcmFnRWwkMSksIDEpO1xuICAgICAgICAgIGxhc3RNdWx0aURyYWdTZWxlY3QgPSBudWxsO1xuICAgICAgICAgIGRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlLFxuICAgICAgICAgICAgcm9vdEVsOiByb290RWwsXG4gICAgICAgICAgICBuYW1lOiAnZGVzZWxlY3QnLFxuICAgICAgICAgICAgdGFyZ2V0RWw6IGRyYWdFbCQxLFxuICAgICAgICAgICAgb3JpZ2luYWxFdnQ6IGV2dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IC8vIE11bHRpLWRyYWcgZHJvcFxuXG5cbiAgICAgIGlmIChkcmFnU3RhcnRlZCAmJiB0aGlzLmlzTXVsdGlEcmFnKSB7XG4gICAgICAgIGZvbGRpbmcgPSBmYWxzZTsgLy8gRG8gbm90IFwidW5mb2xkXCIgYWZ0ZXIgYXJvdW5kIGRyYWdFbCBpZiByZXZlcnRlZFxuXG4gICAgICAgIGlmICgocGFyZW50RWxbZXhwYW5kb10ub3B0aW9ucy5zb3J0IHx8IHBhcmVudEVsICE9PSByb290RWwpICYmIG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB2YXIgZHJhZ1JlY3QgPSBnZXRSZWN0KGRyYWdFbCQxKSxcbiAgICAgICAgICAgICAgbXVsdGlEcmFnSW5kZXggPSBpbmRleChkcmFnRWwkMSwgJzpub3QoLicgKyB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcyArICcpJyk7XG4gICAgICAgICAgaWYgKCFpbml0aWFsRm9sZGluZyAmJiBvcHRpb25zLmFuaW1hdGlvbikgZHJhZ0VsJDEudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgICB0b1NvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuXG4gICAgICAgICAgaWYgKCFpbml0aWFsRm9sZGluZykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgIGRyYWdFbCQxLmZyb21SZWN0ID0gZHJhZ1JlY3Q7XG4gICAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50LnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudCAhPT0gZHJhZ0VsJDEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gZm9sZGluZyA/IGdldFJlY3QobXVsdGlEcmFnRWxlbWVudCkgOiBkcmFnUmVjdDtcbiAgICAgICAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnQuZnJvbVJlY3QgPSByZWN0OyAvLyBQcmVwYXJlIHVuZm9sZCBhbmltYXRpb25cblxuICAgICAgICAgICAgICAgICAgdG9Tb3J0YWJsZS5hZGRBbmltYXRpb25TdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogbXVsdGlEcmFnRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgcmVjdDogcmVjdFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gLy8gTXVsdGkgZHJhZyBlbGVtZW50cyBhcmUgbm90IG5lY2Vzc2FyaWx5IHJlbW92ZWQgZnJvbSB0aGUgRE9NIG9uIGRyb3AsIHNvIHRvIHJlaW5zZXJ0XG4gICAgICAgICAgICAvLyBwcm9wZXJseSB0aGV5IG11c3QgYWxsIGJlIHJlbW92ZWRcblxuXG4gICAgICAgICAgICByZW1vdmVNdWx0aURyYWdFbGVtZW50cygpO1xuICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgICBpZiAoY2hpbGRyZW5bbXVsdGlEcmFnSW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50RWwuaW5zZXJ0QmVmb3JlKG11bHRpRHJhZ0VsZW1lbnQsIGNoaWxkcmVuW211bHRpRHJhZ0luZGV4XSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBtdWx0aURyYWdJbmRleCsrO1xuICAgICAgICAgICAgfSk7IC8vIElmIGluaXRpYWwgZm9sZGluZyBpcyBkb25lLCB0aGUgZWxlbWVudHMgbWF5IGhhdmUgY2hhbmdlZCBwb3NpdGlvbiBiZWNhdXNlIHRoZXkgYXJlIG5vd1xuICAgICAgICAgICAgLy8gdW5mb2xkaW5nIGFyb3VuZCBkcmFnRWwsIGV2ZW4gdGhvdWdoIGRyYWdFbCBtYXkgbm90IGhhdmUgaGlzIGluZGV4IGNoYW5nZWQsIHNvIHVwZGF0ZSBldmVudFxuICAgICAgICAgICAgLy8gbXVzdCBiZSBmaXJlZCBoZXJlIGFzIFNvcnRhYmxlIHdpbGwgbm90LlxuXG4gICAgICAgICAgICBpZiAob2xkSW5kZXggPT09IGluZGV4KGRyYWdFbCQxKSkge1xuICAgICAgICAgICAgICB2YXIgdXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudC5zb3J0YWJsZUluZGV4ICE9PSBpbmRleChtdWx0aURyYWdFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgdXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQoJ3VwZGF0ZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBNdXN0IGJlIGRvbmUgYWZ0ZXIgY2FwdHVyaW5nIGluZGl2aWR1YWwgcmVjdHMgKHNjcm9sbCBiYXIpXG5cblxuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHVuc2V0UmVjdChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0b1NvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlID0gdG9Tb3J0YWJsZTtcbiAgICAgIH0gLy8gUmVtb3ZlIGNsb25lcyBpZiBuZWNlc3NhcnlcblxuXG4gICAgICBpZiAocm9vdEVsID09PSBwYXJlbnRFbCB8fCBwdXRTb3J0YWJsZSAmJiBwdXRTb3J0YWJsZS5sYXN0UHV0TW9kZSAhPT0gJ2Nsb25lJykge1xuICAgICAgICBtdWx0aURyYWdDbG9uZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgICBjbG9uZS5wYXJlbnROb2RlICYmIGNsb25lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG51bGxpbmdHbG9iYWw6IGZ1bmN0aW9uIG51bGxpbmdHbG9iYWwoKSB7XG4gICAgICB0aGlzLmlzTXVsdGlEcmFnID0gZHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIG11bHRpRHJhZ0Nsb25lcy5sZW5ndGggPSAwO1xuICAgIH0sXG4gICAgZGVzdHJveUdsb2JhbDogZnVuY3Rpb24gZGVzdHJveUdsb2JhbCgpIHtcbiAgICAgIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKCk7XG5cbiAgICAgIG9mZihkb2N1bWVudCwgJ3BvaW50ZXJ1cCcsIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICBvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9jaGVja0tleURvd24pO1xuICAgICAgb2ZmKGRvY3VtZW50LCAna2V5dXAnLCB0aGlzLl9jaGVja0tleVVwKTtcbiAgICB9LFxuICAgIF9kZXNlbGVjdE11bHRpRHJhZzogZnVuY3Rpb24gX2Rlc2VsZWN0TXVsdGlEcmFnKGV2dCkge1xuICAgICAgaWYgKHR5cGVvZiBkcmFnU3RhcnRlZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkcmFnU3RhcnRlZCkgcmV0dXJuOyAvLyBPbmx5IGRlc2VsZWN0IGlmIHNlbGVjdGlvbiBpcyBpbiB0aGlzIHNvcnRhYmxlXG5cbiAgICAgIGlmIChtdWx0aURyYWdTb3J0YWJsZSAhPT0gdGhpcy5zb3J0YWJsZSkgcmV0dXJuOyAvLyBPbmx5IGRlc2VsZWN0IGlmIHRhcmdldCBpcyBub3QgaXRlbSBpbiB0aGlzIHNvcnRhYmxlXG5cbiAgICAgIGlmIChldnQgJiYgY2xvc2VzdChldnQudGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlLCB0aGlzLnNvcnRhYmxlLmVsLCBmYWxzZSkpIHJldHVybjsgLy8gT25seSBkZXNlbGVjdCBpZiBsZWZ0IGNsaWNrXG5cbiAgICAgIGlmIChldnQgJiYgZXZ0LmJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuXG4gICAgICB3aGlsZSAobXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbCA9IG11bHRpRHJhZ0VsZW1lbnRzWzBdO1xuICAgICAgICB0b2dnbGVDbGFzcyhlbCwgdGhpcy5vcHRpb25zLnNlbGVjdGVkQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuc2hpZnQoKTtcbiAgICAgICAgZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgc29ydGFibGU6IHRoaXMuc29ydGFibGUsXG4gICAgICAgICAgcm9vdEVsOiB0aGlzLnNvcnRhYmxlLmVsLFxuICAgICAgICAgIG5hbWU6ICdkZXNlbGVjdCcsXG4gICAgICAgICAgdGFyZ2V0RWw6IGVsLFxuICAgICAgICAgIG9yaWdpbmFsRXZ0OiBldnRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfY2hlY2tLZXlEb3duOiBmdW5jdGlvbiBfY2hlY2tLZXlEb3duKGV2dCkge1xuICAgICAgaWYgKGV2dC5rZXkgPT09IHRoaXMub3B0aW9ucy5tdWx0aURyYWdLZXkpIHtcbiAgICAgICAgdGhpcy5tdWx0aURyYWdLZXlEb3duID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9jaGVja0tleVVwOiBmdW5jdGlvbiBfY2hlY2tLZXlVcChldnQpIHtcbiAgICAgIGlmIChldnQua2V5ID09PSB0aGlzLm9wdGlvbnMubXVsdGlEcmFnS2V5KSB7XG4gICAgICAgIHRoaXMubXVsdGlEcmFnS2V5RG93biA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzKE11bHRpRHJhZywge1xuICAgIC8vIFN0YXRpYyBtZXRob2RzICYgcHJvcGVydGllc1xuICAgIHBsdWdpbk5hbWU6ICdtdWx0aURyYWcnLFxuICAgIHV0aWxzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNlbGVjdHMgdGhlIHByb3ZpZGVkIG11bHRpLWRyYWcgaXRlbVxuICAgICAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgIFRoZSBlbGVtZW50IHRvIGJlIHNlbGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0KGVsKSB7XG4gICAgICAgIHZhciBzb3J0YWJsZSA9IGVsLnBhcmVudE5vZGVbZXhwYW5kb107XG4gICAgICAgIGlmICghc29ydGFibGUgfHwgIXNvcnRhYmxlLm9wdGlvbnMubXVsdGlEcmFnIHx8IH5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGVsKSkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChtdWx0aURyYWdTb3J0YWJsZSAmJiBtdWx0aURyYWdTb3J0YWJsZSAhPT0gc29ydGFibGUpIHtcbiAgICAgICAgICBtdWx0aURyYWdTb3J0YWJsZS5tdWx0aURyYWcuX2Rlc2VsZWN0TXVsdGlEcmFnKCk7XG5cbiAgICAgICAgICBtdWx0aURyYWdTb3J0YWJsZSA9IHNvcnRhYmxlO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHNvcnRhYmxlLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgdHJ1ZSk7XG4gICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLnB1c2goZWwpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBEZXNlbGVjdHMgdGhlIHByb3ZpZGVkIG11bHRpLWRyYWcgaXRlbVxuICAgICAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgIFRoZSBlbGVtZW50IHRvIGJlIGRlc2VsZWN0ZWRcbiAgICAgICAqL1xuICAgICAgZGVzZWxlY3Q6IGZ1bmN0aW9uIGRlc2VsZWN0KGVsKSB7XG4gICAgICAgIHZhciBzb3J0YWJsZSA9IGVsLnBhcmVudE5vZGVbZXhwYW5kb10sXG4gICAgICAgICAgICBpbmRleCA9IG11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZWwpO1xuICAgICAgICBpZiAoIXNvcnRhYmxlIHx8ICFzb3J0YWJsZS5vcHRpb25zLm11bHRpRHJhZyB8fCAhfmluZGV4KSByZXR1cm47XG4gICAgICAgIHRvZ2dsZUNsYXNzKGVsLCBzb3J0YWJsZS5vcHRpb25zLnNlbGVjdGVkQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV2ZW50UHJvcGVydGllczogZnVuY3Rpb24gZXZlbnRQcm9wZXJ0aWVzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBvbGRJbmRpY2llcyA9IFtdLFxuICAgICAgICAgIG5ld0luZGljaWVzID0gW107XG4gICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgIG9sZEluZGljaWVzLnB1c2goe1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnQ6IG11bHRpRHJhZ0VsZW1lbnQsXG4gICAgICAgICAgaW5kZXg6IG11bHRpRHJhZ0VsZW1lbnQuc29ydGFibGVJbmRleFxuICAgICAgICB9KTsgLy8gbXVsdGlEcmFnRWxlbWVudHMgd2lsbCBhbHJlYWR5IGJlIHNvcnRlZCBpZiBmb2xkaW5nXG5cbiAgICAgICAgdmFyIG5ld0luZGV4O1xuXG4gICAgICAgIGlmIChmb2xkaW5nICYmIG11bHRpRHJhZ0VsZW1lbnQgIT09IGRyYWdFbCQxKSB7XG4gICAgICAgICAgbmV3SW5kZXggPSAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChmb2xkaW5nKSB7XG4gICAgICAgICAgbmV3SW5kZXggPSBpbmRleChtdWx0aURyYWdFbGVtZW50LCAnOm5vdCguJyArIF90aGlzMy5vcHRpb25zLnNlbGVjdGVkQ2xhc3MgKyAnKScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0luZGV4ID0gaW5kZXgobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdJbmRpY2llcy5wdXNoKHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50OiBtdWx0aURyYWdFbGVtZW50LFxuICAgICAgICAgIGluZGV4OiBuZXdJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXRlbXM6IF90b0NvbnN1bWFibGVBcnJheShtdWx0aURyYWdFbGVtZW50cyksXG4gICAgICAgIGNsb25lczogW10uY29uY2F0KG11bHRpRHJhZ0Nsb25lcyksXG4gICAgICAgIG9sZEluZGljaWVzOiBvbGRJbmRpY2llcyxcbiAgICAgICAgbmV3SW5kaWNpZXM6IG5ld0luZGljaWVzXG4gICAgICB9O1xuICAgIH0sXG4gICAgb3B0aW9uTGlzdGVuZXJzOiB7XG4gICAgICBtdWx0aURyYWdLZXk6IGZ1bmN0aW9uIG11bHRpRHJhZ0tleShrZXkpIHtcbiAgICAgICAga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2N0cmwnKSB7XG4gICAgICAgICAga2V5ID0gJ0NvbnRyb2wnO1xuICAgICAgICB9IGVsc2UgaWYgKGtleS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAga2V5ID0ga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cigxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0TXVsdGlEcmFnRWxlbWVudHMoY2xvbmVzSW5zZXJ0ZWQsIHJvb3RFbCkge1xuICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50LCBpKSB7XG4gICAgdmFyIHRhcmdldCA9IHJvb3RFbC5jaGlsZHJlblttdWx0aURyYWdFbGVtZW50LnNvcnRhYmxlSW5kZXggKyAoY2xvbmVzSW5zZXJ0ZWQgPyBOdW1iZXIoaSkgOiAwKV07XG5cbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICByb290RWwuaW5zZXJ0QmVmb3JlKG11bHRpRHJhZ0VsZW1lbnQsIHRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChtdWx0aURyYWdFbGVtZW50KTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBJbnNlcnQgbXVsdGktZHJhZyBjbG9uZXNcbiAqIEBwYXJhbSAge1tCb29sZWFuXX0gZWxlbWVudHNJbnNlcnRlZCAgV2hldGhlciB0aGUgbXVsdGktZHJhZyBlbGVtZW50cyBhcmUgaW5zZXJ0ZWRcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSByb290RWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGluc2VydE11bHRpRHJhZ0Nsb25lcyhlbGVtZW50c0luc2VydGVkLCByb290RWwpIHtcbiAgbXVsdGlEcmFnQ2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKGNsb25lLCBpKSB7XG4gICAgdmFyIHRhcmdldCA9IHJvb3RFbC5jaGlsZHJlbltjbG9uZS5zb3J0YWJsZUluZGV4ICsgKGVsZW1lbnRzSW5zZXJ0ZWQgPyBOdW1iZXIoaSkgOiAwKV07XG5cbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGNsb25lLCB0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290RWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU11bHRpRHJhZ0VsZW1lbnRzKCkge1xuICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQgPT09IGRyYWdFbCQxKSByZXR1cm47XG4gICAgbXVsdGlEcmFnRWxlbWVudC5wYXJlbnROb2RlICYmIG11bHRpRHJhZ0VsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChtdWx0aURyYWdFbGVtZW50KTtcbiAgfSk7XG59XG5cblNvcnRhYmxlLm1vdW50KG5ldyBBdXRvU2Nyb2xsUGx1Z2luKCkpO1xuU29ydGFibGUubW91bnQoUmVtb3ZlLCBSZXZlcnQpO1xuXG5leHBvcnQgZGVmYXVsdCBTb3J0YWJsZTtcbmV4cG9ydCB7IE11bHRpRHJhZ1BsdWdpbiBhcyBNdWx0aURyYWcsIFNvcnRhYmxlLCBTd2FwUGx1Z2luIGFzIFN3YXAgfTtcbiIsImltcG9ydCBTb3J0YWJsZSBmcm9tICdzb3J0YWJsZWpzJ1xyXG5pbXBvcnQgeyR9IGZyb20gJy4uL2NvbW1vbidcclxuaW1wb3J0IHtfcXVlc3Rpb259IGZyb20gXCIuLi9UZXN0L21vZGVsL3F1ZXN0aW9uXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzb3J0YWJsZShzZWxlY3Rvcikge1xyXG5cclxuICBsZXQgZWwgPSAkKHNlbGVjdG9yKVswXTtcclxuICBpZiAoZWwpIHtcclxuICAgIGxldCBzb3J0YWJsZSA9IFNvcnRhYmxlLmNyZWF0ZShlbCwge1xyXG4gICAgICBhbmltYXRpb246IDE1MCxcclxuICAgICAgb25FbmQ6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICBsZXQgb2xkSSA9IGV2dC5vbGRJbmRleFxyXG4gICAgICAgIGxldCBuZXdJID0gZXZ0Lm5ld0luZGV4XHJcbiAgICAgICAgaWYgKG9sZEkgPiBuZXdJKSB7XHJcbiAgICAgICAgICBsZXQgcXVlc3Rpb25zID0gX3F1ZXN0aW9uLnF1ZXN0aW9ucygpXHJcbiAgICAgICAgICBfcXVlc3Rpb24uc29ydChvbGRJKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBsZXQgcXVlc3Rpb25zID0gX3F1ZXN0aW9uLnF1ZXN0aW9ucygpXHJcbiAgICAgICAgICBfcXVlc3Rpb24uc29ydChuZXdJKVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgIH0pXHJcbiAgfVxyXG5cclxufSIsImltcG9ydCAnLi9XRFNTZWxlY3Quc2NzcydcclxuaW1wb3J0ICcuL2N1c3RvbVNlbGVjdC5zY3NzJ1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXRFNTZWxlY3Qge1xyXG5cclxuICBjb25zdHJ1Y3RvcihlbCkge1xyXG5cclxuICAgIGlmICghZWwpIHJldHVybiBmYWxzZVxyXG4gICAgaWYgKGVsLm11bHRpcGxlKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgICB0aGlzLnRpdGxlID0gZWwudGl0bGUgPz8gJydcclxuICAgIHRoaXMuZmllbGQgPSBlbC5kYXRhc2V0WydmaWVsZCddXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBnZXRGb3JtYXR0ZWRPcHRpb25zKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJvcHRpb25cIikpXHJcblxyXG4gICAgdGhpcy5zZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXHJcbiAgICBpZiAoZWwuY2xhc3NOYW1lKSB0aGlzLnNlbC5jbGFzc0xpc3QuYWRkKGVsLmNsYXNzTmFtZSlcclxuXHJcbiAgICB0aGlzLmxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIilcclxuXHJcbiAgICB0aGlzLnVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpXHJcbiAgICBzZXR1cCh0aGlzKVxyXG4gICAgZWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiXHJcbiAgICBlbC5hZnRlcih0aGlzLnNlbClcclxuICB9XHJcblxyXG4gIGdldCBzZWxlY3RlZE9wdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZmluZChvcHRpb24gPT4gb3B0aW9uLnNlbGVjdGVkKVxyXG4gIH1cclxuXHJcbiAgZ2V0IHNlbGVjdGVkT3B0aW9uSW5kZXgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmluZGV4T2YodGhpcy5zZWxlY3RlZE9wdGlvbilcclxuICB9XHJcblxyXG4gIHNlbGVjdFZhbHVlKHZhbHVlKSB7XHJcbiAgICBjb25zdCBuZXdTZWxlY3RlZE9wdGlvbiA9IHRoaXMub3B0aW9ucy5maW5kKG9wdGlvbiA9PiB7XHJcbiAgICAgIHJldHVybiBvcHRpb24udmFsdWUgPT09IHZhbHVlXHJcbiAgICB9KVxyXG4gICAgY29uc3QgcHJldlNlbGVjdGVkT3B0aW9uID0gdGhpcy5zZWxlY3RlZE9wdGlvblxyXG4gICAgcHJldlNlbGVjdGVkT3B0aW9uLnNlbGVjdGVkID0gZmFsc2VcclxuICAgIHByZXZTZWxlY3RlZE9wdGlvbi5lbGVtZW50LnNlbGVjdGVkID0gZmFsc2VcclxuXHJcbiAgICBuZXdTZWxlY3RlZE9wdGlvbi5zZWxlY3RlZCA9IHRydWVcclxuICAgIG5ld1NlbGVjdGVkT3B0aW9uLmVsZW1lbnQuc2VsZWN0ZWQgPSB0cnVlXHJcblxyXG4gICAgdGhpcy5sYWJlbC5pbm5lclRleHQgPSBuZXdTZWxlY3RlZE9wdGlvbi5sYWJlbFxyXG4gICAgdGhpcy5sYWJlbC5jbG9zZXN0KCcuY3VzdG9tLXNlbGVjdCcpLmRhdGFzZXRbJ2lkJ10gPSBuZXdTZWxlY3RlZE9wdGlvbi52YWx1ZVxyXG4gICAgdGhpcy51bFxyXG4gICAgICAucXVlcnlTZWxlY3RvcihgW2RhdGEtdmFsdWU9XCIke3ByZXZTZWxlY3RlZE9wdGlvbi52YWx1ZX1cIl1gKVxyXG4gICAgICAuY2xhc3NMaXN0LnJlbW92ZShcInNlbGVjdGVkXCIpXHJcbiAgICBjb25zdCBuZXdDdXN0b21FbGVtZW50ID0gdGhpcy51bC5xdWVyeVNlbGVjdG9yKFxyXG4gICAgICBgW2RhdGEtdmFsdWU9XCIke25ld1NlbGVjdGVkT3B0aW9uLnZhbHVlfVwiXWBcclxuICAgIClcclxuICAgIG5ld0N1c3RvbUVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpXHJcbiAgICBuZXdDdXN0b21FbGVtZW50LnNjcm9sbEludG9WaWV3KHtibG9jazogXCJuZWFyZXN0XCJ9KVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2V0dXAoc2VsZWN0KSB7XHJcblxyXG4gIGlmIChzZWxlY3QudGl0bGUpIHtcclxuICAgIHNlbGVjdC50aXRsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXHJcbiAgICBzZWxlY3QudGl0bGVFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjdXN0b20tc2VsZWN0LXRpdGxlXCIpXHJcbiAgICBzZWxlY3QudGl0bGVFbGVtZW50LmlubmVyVGV4dCA9IHNlbGVjdC50aXRsZVxyXG4gICAgc2VsZWN0LnNlbC5hcHBlbmQoc2VsZWN0LnRpdGxlRWxlbWVudClcclxuICB9XHJcblxyXG4gIHNlbGVjdC5zZWwuY2xhc3NMaXN0LmFkZChcImN1c3RvbS1zZWxlY3RcIilcclxuICBzZWxlY3Quc2VsLmRhdGFzZXRbJ2ZpZWxkJ10gPSBzZWxlY3QuZmllbGRcclxuICAvLyBkZWJ1Z2dlclxyXG4gIHNlbGVjdC5zZWwuZGF0YXNldFsnaWQnXSA9IHNlbGVjdC5zZWxlY3RlZE9wdGlvbi52YWx1ZVxyXG4gIHNlbGVjdC5zZWwudGFiSW5kZXggPSAwXHJcblxyXG4gIC8vIGRlYnVnZ2VyXHJcbiAgc2VsZWN0LmxhYmVsLmNsYXNzTGlzdC5hZGQoXCJjdXN0b20tc2VsZWN0LXZhbHVlXCIpXHJcbiAgc2VsZWN0LmxhYmVsLmlubmVyVGV4dCA9IHNlbGVjdC5zZWxlY3RlZE9wdGlvbi5sYWJlbFxyXG4gIHNlbGVjdC5zZWwuYXBwZW5kKHNlbGVjdC5sYWJlbClcclxuXHJcbiAgc2VsZWN0LnVsLmNsYXNzTGlzdC5hZGQoXCJjdXN0b20tc2VsZWN0LW9wdGlvbnNcIilcclxuICBzZWxlY3Qub3B0aW9ucy5mb3JFYWNoKG9wdGlvbiA9PiB7XHJcbiAgICBzZXRPcHRpb24ob3B0aW9uKVxyXG4gIH0pXHJcblxyXG4gIGZ1bmN0aW9uIHNldE9wdGlvbihvcHRpb24pIHtcclxuICAgIGNvbnN0IGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpXHJcbiAgICBsaS5jbGFzc0xpc3QuYWRkKFwiY3VzdG9tLXNlbGVjdC1vcHRpb25cIilcclxuICAgIGxpLmNsYXNzTGlzdC50b2dnbGUoXCJzZWxlY3RlZFwiLCBvcHRpb24uc2VsZWN0ZWQpXHJcbiAgICBsaS5pbm5lclRleHQgPSBvcHRpb24ubGFiZWxcclxuICAgIGxpLmRhdGFzZXQudmFsdWUgPSBvcHRpb24udmFsdWVcclxuICAgIGxpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XHJcbiAgICAgIHNlbGVjdC5zZWxlY3RWYWx1ZShvcHRpb24udmFsdWUpXHJcbiAgICAgIHNlbGVjdC51bC5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKVxyXG4gICAgfSlcclxuICAgIHNlbGVjdC51bC5hcHBlbmQobGkpXHJcbiAgfVxyXG5cclxuICBzZWxlY3Quc2VsLmFwcGVuZChzZWxlY3QudWwpXHJcblxyXG4gIHNlbGVjdC5sYWJlbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgc2VsZWN0LnVsLmNsYXNzTGlzdC50b2dnbGUoXCJzaG93XCIpXHJcbiAgfSlcclxuXHJcbiAgc2VsZWN0LnNlbC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCAoKSA9PiB7XHJcbiAgICBzZWxlY3QudWwuY2xhc3NMaXN0LnJlbW92ZShcInNob3dcIilcclxuICB9KVxyXG5cclxuICBsZXQgZGVib3VuY2VUaW1lb3V0XHJcbiAgbGV0IHNlYXJjaFRlcm0gPSBcIlwiXHJcbiAgc2VsZWN0LnNlbC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBlID0+IHtcclxuICAgIHN3aXRjaCAoZS5jb2RlKSB7XHJcbiAgICAgIGNhc2UgXCJTcGFjZVwiOlxyXG4gICAgICAgIHNlbGVjdC51bC5jbGFzc0xpc3QudG9nZ2xlKFwic2hvd1wiKVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgXCJBcnJvd1VwXCI6IHtcclxuICAgICAgICBjb25zdCBwcmV2T3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbc2VsZWN0LnNlbGVjdGVkT3B0aW9uSW5kZXggLSAxXVxyXG4gICAgICAgIGlmIChwcmV2T3B0aW9uKSB7XHJcbiAgICAgICAgICBzZWxlY3Quc2VsZWN0VmFsdWUocHJldk9wdGlvbi52YWx1ZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgfVxyXG4gICAgICBjYXNlIFwiQXJyb3dEb3duXCI6IHtcclxuICAgICAgICBjb25zdCBuZXh0T3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbc2VsZWN0LnNlbGVjdGVkT3B0aW9uSW5kZXggKyAxXVxyXG4gICAgICAgIGlmIChuZXh0T3B0aW9uKSB7XHJcbiAgICAgICAgICBzZWxlY3Quc2VsZWN0VmFsdWUobmV4dE9wdGlvbi52YWx1ZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgfVxyXG4gICAgICBjYXNlIFwiRW50ZXJcIjpcclxuICAgICAgY2FzZSBcIkVzY2FwZVwiOlxyXG4gICAgICAgIHNlbGVjdC51bC5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICBjbGVhclRpbWVvdXQoZGVib3VuY2VUaW1lb3V0KVxyXG4gICAgICAgIHNlYXJjaFRlcm0gKz0gZS5rZXlcclxuICAgICAgICBkZWJvdW5jZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIHNlYXJjaFRlcm0gPSBcIlwiXHJcbiAgICAgICAgfSwgNTAwKVxyXG5cclxuICAgICAgICBjb25zdCBzZWFyY2hlZE9wdGlvbiA9IHNlbGVjdC5vcHRpb25zLmZpbmQob3B0aW9uID0+IHtcclxuICAgICAgICAgIHJldHVybiBvcHRpb24ubGFiZWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKHNlYXJjaFRlcm0pXHJcbiAgICAgICAgfSlcclxuICAgICAgICBpZiAoc2VhcmNoZWRPcHRpb24pIHtcclxuICAgICAgICAgIHNlbGVjdC5zZWxlY3RWYWx1ZShzZWFyY2hlZE9wdGlvbi52YWx1ZSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRGb3JtYXR0ZWRPcHRpb25zKG9wdGlvbnMpIHtcclxuICByZXR1cm4gWy4uLm9wdGlvbnNdLm1hcChvcHRpb24gPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdmFsdWU6IG9wdGlvbi52YWx1ZSxcclxuICAgICAgbGFiZWw6IG9wdGlvbi5sYWJlbCxcclxuICAgICAgc2VsZWN0ZWQ6IG9wdGlvbi5zZWxlY3RlZCxcclxuICAgICAgZWxlbWVudDogb3B0aW9uLFxyXG4gICAgfVxyXG4gIH0pXHJcbn0iLCJpbXBvcnQgeyR9IGZyb20gXCIuLi9jb21tb25cIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFjY29yZGlvblNob3coKSB7XHJcblxyXG4gIGxldCBjdXJyZW50VGVzdElkID0gJChgW2RhdGEtdGVzdGlkXWApWzBdXHJcbiAgaWYgKGN1cnJlbnRUZXN0SWQpIHtcclxuICAgIGN1cnJlbnRUZXN0SWQgPSArY3VycmVudFRlc3RJZC5kYXRhc2V0Wyd0ZXN0aWQnXVxyXG4gICAgbGV0IG1lbnVJdGVtQ29sbGVjdGlvbiA9ICQoJy50ZXN0LWVkaXQuYWNjb3JkaW9uIGEnKVxyXG4gICAgQXJyYXkuZnJvbShtZW51SXRlbUNvbGxlY3Rpb24pLmZpbHRlcigoYSkgPT4ge1xyXG4gICAgICBpZiAoK2EuZGF0YXNldC5pZCA9PT0gY3VycmVudFRlc3RJZCkge1xyXG4gICAgICAgIGEuY2xhc3NMaXN0LmFkZCgnY3VycmVudCcpXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgfVxyXG5cclxuXHJcbiAgbGV0IGJ1dHRvbiA9ICQoJy50ZXN0LWVkaXRfX21lbnUtdG9nZ2xlJylbMF1cclxuICBpZiAoYnV0dG9uKSB7XHJcbiAgICAkKGJ1dHRvbikub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBsZXQgbWVudSA9ICQoJy50ZXN0LWVkaXRfX2FjY29yZGlvbicpWzBdXHJcbiAgICAgIG1lbnUuY2xhc3NMaXN0LnRvZ2dsZSgnb3BlbicpXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHtfdGVzdH0gZnJvbSBcIi4vbW9kZWwvdGVzdFwiO1xyXG5pbXBvcnQge19xdWVzdGlvbn0gZnJvbSBcIi4vbW9kZWwvcXVlc3Rpb25cIjtcclxuaW1wb3J0IHtfYW5zd2VyfSBmcm9tIFwiLi9tb2RlbC9hbnN3ZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRlc3RFZGl0QWN0aW9ucyh0YXJnZXQsIHR5cGUpIHtcclxuXHJcbiAgaWYgKHR5cGUgPT09ICdjbGljaycpIHtcclxuICAgIHN3aXRjaCAodHJ1ZSkge1xyXG4gICAgICBjYXNlIHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3Rlc3QtcGF0aF9fdXBkYXRlJyk6IHtcclxuICAgICAgICBfdGVzdC51cGRhdGUoKVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGNhc2UgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygndGVzdF9fdXBkYXRlJyk6IHtcclxuICAgICAgICBfdGVzdC51cGRhdGUoKVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGNhc2UgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygndGVzdF9fc2F2ZScpOiB7XHJcbiAgICAgICAgX3Rlc3QudXBkYXRlKClcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjYXNlIHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3Rlc3RfX2RlbGV0ZScpOiB7XHJcbiAgICAgICAgX3Rlc3QuZGVsZXRlKClcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjYXNlIHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3Rlc3QtcGF0aF9fY3JlYXRlJyk6IHtcclxuICAgICAgICBfdGVzdC5wYXRoX2NyZWF0ZSgpXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgY2FzZSB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCd0ZXN0X19jcmVhdGUnKToge1xyXG4gICAgICAgIF90ZXN0LmNyZWF0ZSgpXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNhc2UgISF0YXJnZXQuY2xvc2VzdCgnLnF1ZXN0aW9uX19zYXZlJyk6IHtcclxuICAgICAgICBfcXVlc3Rpb24uc2F2ZSh0YXJnZXQpXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgY2FzZSAhIXRhcmdldC5jbG9zZXN0KCcucXVlc3Rpb25fX3Nob3ctYW5zd2VycycpOiB7XHJcbiAgICAgICAgX3F1ZXN0aW9uLnNob3dBbnN3ZXJzKHRhcmdldClcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjYXNlICEhdGFyZ2V0LmNsb3Nlc3QoJy5xdWVzdGlvbl9fZGVsZXRlJyk6IHtcclxuICAgICAgICBfcXVlc3Rpb24uZGVsZXRlKHRhcmdldClcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjYXNlIHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3F1ZXN0aW9uX19jcmVhdGUtYnV0dG9uJyk6IHtcclxuICAgICAgICBfcXVlc3Rpb24uY3JlYXRlKClcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjYXNlICEhdGFyZ2V0LmNsb3Nlc3QoJy5hbnN3ZXJfX2RlbGV0ZScpOiB7XHJcbiAgICAgICAgX2Fuc3dlci5kZWwodGFyZ2V0KVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGNhc2UgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYW5zd2VyX19jcmVhdGUtYnV0dG9uJyk6IHtcclxuICAgICAgICBfYW5zd2VyLmNyZWF0ZSh0YXJnZXQpXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICh0eXBlID09PSAnY2hhbmdlJykge1xyXG4gICAgICAvLyBkZWJ1Z2dlclxyXG4gICAgc3dpdGNoICh0cnVlKSB7XHJcbiAgICAgIGNhc2UgISF0YXJnZXQuY2xvc2VzdCgnLnF1ZXN0aW9uLWVkaXRfX3BhcmVudC1zZWxlY3QnKToge1xyXG4gICAgICAgIF9xdWVzdGlvbi5jaGFuZ2VQYXJlbnQodGFyZ2V0KVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCAnLi90ZXN0LWVkaXQuc2NzcydcclxuaW1wb3J0ICcuLi9jb21wb25lbnRzL2Zvb3Rlci9mb290ZXIuc2NzcydcclxuXHJcbmltcG9ydCAnLi90ZXN0LWVkaXQtbWVudS5zY3NzJ1xyXG5pbXBvcnQgJy4uL2NvbXBvbmVudHMvcG9wdXAuc2NzcydcclxuaW1wb3J0IHRvb2x0aXBzIGZyb20gJy4uL2NvbXBvbmVudHMvdG9vbHRpcC90b29sdGlwJ1xyXG5cclxuaW1wb3J0ICcuL3Rlc3QtdXBkYXRlJ1xyXG4vLyBpbXBvcnQgJy4vcGF0aC1jcmVhdGUnXHJcbmltcG9ydCAnLi4vQWRtaW4vYWRtaW4nXHJcblxyXG5pbXBvcnQgeyR9IGZyb20gJy4uL2NvbW1vbidcclxuXHJcbmltcG9ydCB7X3F1ZXN0aW9ufSBmcm9tIFwiLi9tb2RlbC9xdWVzdGlvblwiXHJcbmltcG9ydCBzb3J0YWJsZSBmcm9tIFwiLi4vY29tcG9uZW50cy9zb3J0YWJsZVwiXHJcbmltcG9ydCBXRFNTZWxlY3QgZnJvbSBcIi4uL2NvbXBvbmVudHMvc2VsZWN0L1dEU1NlbGVjdFwiXHJcbmltcG9ydCBhY2NvcmRpb25TaG93IGZyb20gXCIuL2FjY29yZGlvbi1zaG93XCI7XHJcblxyXG5pbXBvcnQgdGVzdEVkaXRBY3Rpb25zIGZyb20gXCIuL3Rlc3RFZGl0QWN0aW9uc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGVzdEVkaXQoKSB7XHJcblxyXG4gIHRvb2x0aXBzKClcclxuICBzb3J0YWJsZSgnLnF1ZXN0aW9ucycpXHJcbiAgYWNjb3JkaW9uU2hvdygpXHJcblxyXG4vLyBkZWJ1Z2dlclxyXG4gIGxldCBjdXN0b21TZWxlY3RzID0gJCgnW2N1c3RvbS1zZWxlY3RdJyk7XHJcbiAgW10uZm9yRWFjaC5jYWxsKGN1c3RvbVNlbGVjdHMsIGZ1bmN0aW9uIChzZWxlY3QpIHtcclxuICAgIG5ldyBXRFNTZWxlY3Qoc2VsZWN0KVxyXG4gIH0pO1xyXG5cclxuLy8g0L/RgNC4INGB0L7Qt9C00LDQvdC40Lgg0L3QvtCy0L7Qs9C+INGC0LXRgdGC0LAg0L/QvtC60LDQt9Cw0YLRjCDQv9GD0YHRgtC+0Lkg0LLQvtC/0YDQvtGBXHJcbiAgaWYgKCFfcXVlc3Rpb24ucXVlc3Rpb25zKCkubGVuZ3RoXHJcbiAgICAmJiAvXFwvYWRtaW5zY1xcL3Rlc3RcXC9lZGl0Ly50ZXN0KHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSkpIHtcclxuICAgIF9xdWVzdGlvbi5zaG93Rmlyc3QoKVxyXG4gIH1cclxuXHJcbiAgLy8gZGVidWdnZXJcclxuICBsZXQgdGVzdEVkaXRXcmFwcGVyID0gJCgnLnRlc3QtZWRpdC13cmFwcGVyJylbMF1cclxuICBpZiAodGVzdEVkaXRXcmFwcGVyKSB7XHJcbiAgICB0ZXN0RWRpdFdyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLFxyXG4gICAgICAoe3RhcmdldH0pID0+IHtcclxuICAgICAgICB0ZXN0RWRpdEFjdGlvbnModGFyZ2V0LCAnY2xpY2snKVxyXG4gICAgICB9XHJcbiAgICApXHJcbiAgICB0ZXN0RWRpdFdyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJyxcclxuICAgICAgKHt0YXJnZXR9KSA9PiB7XHJcbiAgICAgICAgdGVzdEVkaXRBY3Rpb25zKHRhcmdldCwgJ2NoYW5nZScpXHJcbiAgICAgIH1cclxuICAgIClcclxuICB9XHJcbiAgLy8gYWRkVG9vbHRpcCh7XHJcbiAgLy8gICBlbHM6ICQoJy5xdWVzdGlvbl9fZGVsZXRlJyksXHJcbiAgLy8gICBtZXNzYWdlOiAn0KPQtNCw0LvQuNGC0Ywg0LLQvtC/0YDQvtGB0Ysg0Lgg0L7RgtCy0LXRgtGLJ1xyXG4gIC8vIH0pXHJcbn1cclxuXHJcblxyXG4iLCJpbXBvcnQgJy4vdGVzdC1wYWdpbmF0aW9uLnNjc3MnXHJcbmltcG9ydCB7JCwgcG9wdXAsIHBvc3R9IGZyb20gXCIuLi8uLi9jb21tb25cIjtcclxuaW1wb3J0IHtfcXVlc3Rpb259IGZyb20gXCIuLi8uLi9UZXN0L21vZGVsL3F1ZXN0aW9uXCI7XHJcbmltcG9ydCB7X2Fuc3dlcn0gZnJvbSBcIi4uLy4uL1Rlc3QvbW9kZWwvYW5zd2VyXCI7XHJcblxyXG4vLyDQn9C+0LrQsNC30LDRgtGMINC/0LXRgNCy0YPRjiDQutC90L7Qv9C60YNcclxuJCgnW2RhdGEtcGFnaW5hdGlvbl06Zmlyc3QtY2hpbGQnKS5hZGRDbGFzcygnbmF2LWFjdGl2ZScpXHJcbi8vICQoJy50ZXN0LWVkaXRfX2NvbnRlbnQnKS5hZGRDbGFzcygnZmxleDEnKVxyXG5cclxuLy8vLyBhZGQgcXVlc3Rpb25cclxuJCgnLnBhZ2luYXRpb24nKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgaWYgKGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYWRkLXF1ZXN0aW9uJykpIHtcclxuICAgICAgICBkZWJ1Z2dlclxyXG4gICAgICAgIHNob3coKVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgfVxyXG4vLy8vIHBhZ2luYXRlXHJcbiAgICBpZiAoZS50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXBhZ2luYXRpb24nKSkge1xyXG4gICAgICAgIHBhZ2luYXRlKGUudGFyZ2V0KVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgfVxyXG59KVxyXG5cclxuZnVuY3Rpb24gcGFnaW5hdGUoc2VsZikge1xyXG4vLy8gZ2V0IGNsaWNrZWQgYnV0dG9uIFJldHVybiBpZiBjbGlja2VkIGlzIGFjdGl2ZVxyXG4gICAgaWYgKHNlbGYuY2xhc3NMaXN0LmNvbnRhaW5zKCduYXYtYWN0aXZlJykpIHJldHVyblxyXG4gICAgbGV0IGFjdGl2ZV9idG4gPSAkKCcucGFnaW5hdGlvbiAubmF2LWFjdGl2ZScpWzBdXHJcbi8vLy8gY2hhbmdlIGFjdGl2ZSBidXR0b25cclxuICAgIGFjdGl2ZV9idG4uY2xhc3NMaXN0LnJlbW92ZSgnbmF2LWFjdGl2ZScpXHJcbiAgICBzZWxmLmNsYXNzTGlzdC5hZGQoJ25hdi1hY3RpdmUnKVxyXG4vLy8vIGhpZGUgdGhlIGNhcmRcclxuICAgIGxldCBpZF90b19oaWRlID0gYWN0aXZlX2J0bi5kYXRhc2V0WydwYWdpbmF0aW9uJ11cclxuICAgICQoYCNxdWVzdGlvbi0ke2lkX3RvX2hpZGV9YCkucmVtb3ZlQ2xhc3MoJ2ZsZXgxJylcclxuLy8vLyBzaG93IHRoZSBjYXJkXHJcbiAgICBsZXQgaWRfdG9fc2hvdyA9IHNlbGYuZGF0YXNldFsncGFnaW5hdGlvbiddXHJcbiAgICAkKGAjcXVlc3Rpb24tJHtpZF90b19zaG93fWApLmFkZENsYXNzKCdmbGV4MScpXHJcbn1cclxuXHJcbi8vLy8g0LTQvtCx0LDQstC70LXQvdC40LUg0LLQvtC/0YDQvtGB0LBcclxuYXN5bmMgZnVuY3Rpb24gc2hvdyhlKSB7XHJcbiAgICBsZXQgdGVzdGlkID0gKyQoJy50ZXN0LW5hbWUnKS52YWx1ZSgpXHJcbiAgICBsZXQgcXVlc3RDb3VudCA9ICQoXCJbZGF0YS1wYWdpbmF0aW9uXVwiKS5jb3VudCgpXHJcblxyXG4gICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoXHJcbiAgICAgICAgJy9xdWVzdGlvbi9zaG93JyxcclxuICAgICAgICB7dGVzdGlkLCBxdWVzdENvdW50fSlcclxuICAgIHJlcyA9IEpTT04ucGFyc2UocmVzKVxyXG4gICAgbGV0IEJsb2NrID0gcmVzLmJsb2NrXHJcbiAgICBsZXQgYmxvY2tzID0gJCgnLmJsb2NrcycpWzBdXHJcbiAgICBibG9ja3MuaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlckJlZ2luJywgQmxvY2spXHJcbiAgICBsZXQgbmV3QmxvY2sgPSAkKCcuYmxvY2tzIC5ibG9jazpmaXJzdC1jaGlsZCcpWzBdXHJcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZmxleDEnKS5jbGFzc0xpc3QucmVtb3ZlKCdmbGV4MScpXHJcbiAgICAkKG5ld0Jsb2NrKS5hZGRDbGFzcygnZmxleDEnKVxyXG4gICAgbGV0IHNhdmVfYnV0dG9uID0gJChuZXdCbG9jaykuZmluZCgnLnF1ZXN0aW9uX19zYXZlJylcclxuICAgICAgICAkKHNhdmVfYnV0dG9uKS5vbignY2xpY2snLCBfcXVlc3Rpb24oKS5zYXZlKVxyXG59XHJcblxyXG5mdW5jdGlvbiBzaG93SGlkZVBhZ2luQnRuKHBhZ0l0ZW0pIHtcclxuICAgIGxldCBhY3RpdmVQYWdpbkJ0biA9ICQoJy5wYWdpbmF0aW9uIC5uYXYtYWN0aXZlJylbMF1cclxuICAgIGlmIChhY3RpdmVQYWdpbkJ0bikge1xyXG4gICAgICAgIGFjdGl2ZVBhZ2luQnRuLmNsYXNzTGlzdC5yZW1vdmUoJ25hdi1hY3RpdmUnKVxyXG4gICAgfVxyXG4gICAgJCgnLmFkZC1xdWVzdGlvbicpWzBdLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlQmVnaW4nLCBwYWdJdGVtKVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBlbmRCbG9jaygpIHtcclxuICAgIGxldCBibG9jayA9ICQoJy5vdmVybGF5JykuZmluZCgnLmJsb2NrJylcclxuICAgICQoJy5ibG9ja3MnKS5hcHBlbmQoYmxvY2spXHJcbiAgICAkKGJsb2NrKS5hZGRDbGFzcygnZmxleDEnKVxyXG4gICAgJCgnLmEtYWRkJykub24oJ2NsaWNrJywgX2Fuc3dlci5jcmVhdGUpXHJcbiAgICAkKCcucS1kZWxldGUnKS5vbignY2xpY2snLCBfcXVlc3Rpb24oKS5kZWxldGUoKSlcclxuICAgICQoJy5hLWRlbCcpLm9uKCdjbGljaycsIF9hbnN3ZXIuZGVsZXRlKCkpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5hdkluaXQoKSB7XHJcbiAgICBsZXQgbmF2X2J1dHRvbnMgPSAkKCdbZGF0YS1wYWdpbmF0aW9uXScpXHJcbiAgICBpZiAoIW5hdl9idXR0b25zWzBdKSByZXR1cm4gZmFsc2VcclxuICAgIEFycmF5LmZyb20obmF2X2J1dHRvbnMpLm1hcCgoZWwpPT57XHJcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnbmF2LWFjdGl2ZScpXHJcbiAgICB9KVxyXG4gICAgbmF2X2J1dHRvbnNbMF0uY2xhc3NMaXN0LmFkZCgnbmF2LWFjdGl2ZScpXHJcblxyXG59XHJcblxyXG5leHBvcnQge3Nob3dIaWRlUGFnaW5CdG4sIGFwcGVuZEJsb2NrLCBuYXZJbml0fVxyXG5cclxuXHJcbiIsImltcG9ydCAnLi9kby5zY3NzJ1xyXG5cclxuaW1wb3J0IHtfdGVzdH0gZnJvbSBcIi4vbW9kZWwvdGVzdFwiXHJcbmltcG9ydCB7cG9zdCwgJH0gZnJvbSAnLi4vY29tbW9uJ1xyXG5pbXBvcnQge25hdkluaXR9IGZyb20gJy4uL2NvbXBvbmVudHMvdGVzdC1wYWdpbmF0aW9uL3Rlc3QtcGFnaW5hdGlvbidcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0ZXN0RG8oKSB7XHJcblxyXG4vL9Ch0LrRgNGL0YLRjCDQstGB0LUg0LLQvtC/0YDQvtGB0YtcclxuICAkKCcucXVlc3Rpb24nKS5yZW1vdmVDbGFzcyhcImZsZXgxXCIpXHJcblxyXG4vL9Cf0L7QutCw0LfRgtGMINC/0LXRgNCy0YvQuSDQstC+0L/RgNC+0YFcclxuICAkKCcucXVlc3Rpb246Zmlyc3QtY2hpbGQnKS5hZGRDbGFzcyhcImZsZXgxXCIpXHJcbi8vINCd0LDQttCw0YLRjCDQv9C10YDQstGD0Y7QutC90L7Qv9C60YMgbmF2aWdhdGlvblxyXG4gIG5hdkluaXQoKVxyXG4gICQoJy50ZXN0LWRvX19jb250ZW50IFt0eXBlPVwiY2hlY2tib3hcIl0nKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgbGV0IGEgPSBlLnRhcmdldC5sYWJlbHNbMF1cclxuICAgIGEuY2xhc3NMaXN0LnRvZ2dsZSgncHVzaGVkJylcclxuICB9KVxyXG5cclxuXHJcbiAgJCgnI3ByZXYnKS5vbignY2xpY2snLCBfdGVzdC5wcmV2USlcclxuICAkKCcjbmV4dCcpLm9uKCdjbGljaycsIF90ZXN0Lm5leHRRKVxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vLy8vLy8vLy8vICBSRVNVTFRTICBURVNUICDQl9Cw0LrQvtC90YfQuNGC0Ywg0YLQtdGB0YIvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLy8g0LXRgdC70Lgg0Y3RgtC+INGA0LXQt9GD0LvRjNGC0LDRgiDRgtC10YHRgtCwLCDQtNC10LDQutGC0LjQstC40YDRg9C60Lwg0LrQvdC+0L/QutGDINCX0LDQutC+0L3Rh9C40YLRjCDRgtC10YHRglxyXG4gIGxldCBidXR0b24gPSAkKCcudGVzdC1kb19fZmluaXNoLWJ0bicpWzBdXHJcbiAgaWYgKGJ1dHRvbikge1xyXG4gICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS5tYXRjaCgnXi90ZXN0L3Jlc3VsdC8uPycpKSB7XHJcbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdpbmFjdGl2ZScpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAkKCcudGVzdC1kb19fZmluaXNoLWJ0bicpLm9uKCdjbGljaycsIGFzeW5jIGZ1bmN0aW9uIChlKSB7XHJcblxyXG4gICAgbGV0IGJ1dHRvbiA9IGUudGFyZ2V0O1xyXG4gICAgaWYgKGJ1dHRvbi5jbGFzc0xpc3QuY29udGFpbnMoJ2luYWN0aXZlJykpIHJldHVybiBmYWxzZVxyXG4gICAgaWYgKGJ1dHRvbi5pZCAhPT0gJ2J0bm4nKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgICBpZiAoYnV0dG9uLnRleHQgPT0gXCLQn9Cg0J7QmdCi0Jgg0KLQldCh0KIg0JfQkNCd0J7QktCeXCIpIHtcclxuICAgICAgbG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCBjb3JyQW5zd2VycyA9IGF3YWl0IHBvc3QoJy90ZXN0L2dldENvcnJlY3RBbnN3ZXJzJywge30pXHJcbiAgICBjb3JyQW5zd2VycyA9IEpTT04ucGFyc2UoY29yckFuc3dlcnMpXHJcbiAgICBsZXQgZXJyb3JDbnQgPSBjb2xvclZpZXcoY29yckFuc3dlcnMpXHJcbiAgICBsZXQgZGF0YSA9IG9ialRvU2VydmVyKGVycm9yQ250KVxyXG4gICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9hZG1pbnNjL3Rlc3RyZXN1bHQvY2FjaGVQYWdlU2VuZEVtYWlsJywgZGF0YSlcclxuICAgIGlmIChyZXMpIHtcclxuICAgICAgJChcIiNidG5uXCIpWzBdLmhyZWYgPSBsb2NhdGlvbi5ocmVmXHJcbiAgICAgICQoXCIjYnRublwiKVswXS50ZXh0ID0gXCLQn9Cg0J7QmdCi0Jgg0KLQldCh0KIg0JfQkNCd0J7QktCeXCJcclxuICAgIH1cclxuICB9KVxyXG5cclxuICBmdW5jdGlvbiBvYmpUb1NlcnZlcihlcnJvckNudCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG9rZW46IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT1cInRva2VuXCJdJykuZ2V0QXR0cmlidXRlKCdjb250ZW50JyksXHJcbiAgICAgIHF1ZXN0aW9uQ250OiAkKCcucXVlc3Rpb24nKS5sZW5ndGgsXHJcbiAgICAgIGVycm9yQ250OiBlcnJvckNudCxcclxuICAgICAgaHRtbDogYDwhRE9DVFlQRSAke2RvY3VtZW50LmRvY3R5cGUubmFtZX0+YCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUwsXHJcbiAgICAgIHRlc3RpZDogJCgnW2RhdGEtdGVzdC1pZF0nKVswXS5kYXRhc2V0LnRlc3RJZCxcclxuICAgICAgdGVzdG5hbWU6ICQoJy50ZXN0LW5hbWUnKVswXS5pbm5lclRleHQsXHJcbiAgICAgIHVzZXI6ICQoJy51c2VyLW1lbnVfX2ZpbycpWzBdLmlubmVyVGV4dCxcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiBjb2xvclZpZXcoY29ycmVjdEFuc3dlcnMpIHtcclxuICAgIGxldCBxID0gJCgnLnF1ZXN0aW9uJylcclxuICAgIEFycmF5LmZyb20ocSkubWFwKChxdWVzdGlvbiwgaSkgPT4ge1xyXG4gICAgICBsZXQgYW5zd2VycyA9IHF1ZXN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hJyksXHJcbiAgICAgICAgZXJyb3JzID0gW11cclxuICAgICAgQXJyYXkuZnJvbShhbnN3ZXJzKS5tYXAoKGFuc3dlcikgPT4ge1xyXG4gICAgICAgIGxldCBpbnB1dCA9IGFuc3dlci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5wdXQnKVswXSxcclxuICAgICAgICAgIGFuc3dlcklkID0gaW5wdXQuaWQucmVwbGFjZShcImFuc3dlci1cIiwgXCJcIiksIC8vIGlkIHF1ZXN0aW9uXHJcbiAgICAgICAgICBsYWJlbCA9IGFuc3dlci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGFiZWwnKVswXSwgLy8g0KfRgtC+0LHRiyDQv9GA0LjQutGA0LXQv9C40YLRjCDQt9C10LvQtdC90YvQuSDQt9C90LDRh9C10Log0Log0Y3RgtC+0LzRgyDRjdC70LXQvNC10L3RgtGDXHJcbiAgICAgICAgICBjb3JyZWN0QW5zZXIgPSBjb3JyZWN0QW5zd2Vycy5pbmRleE9mKGFuc3dlcklkKSAhPT0gLTFcclxuICAgICAgICBpZiAoIWNoZWNrQ29ycmVjdEFuc3dlcnMoY29ycmVjdEFuc2VyLCBpbnB1dCwgbGFiZWwpKSB7XHJcbiAgICAgICAgICBlcnJvcnMucHVzaCh0cnVlKVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuXHJcbiAgICAgIGxldCBxdWVzdElkID0gK3F1ZXN0aW9uLmRhdGFzZXRbJ2lkJ10sIC8vIGlkIHF1ZXN0aW9uXHJcbiAgICAgICAgcGFnaW5JdGVtID0gJCgnLnBhZ2luYXRpb24gW2RhdGEtcGFnaW5hdGlvbj1cIicgKyBxdWVzdElkICsgJ1wiXScpWzBdXHJcbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgJChwYWdpbkl0ZW0pLmFkZENsYXNzKCdyZWRTaGFkb3cnKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICQocGFnaW5JdGVtKS5hZGRDbGFzcygnZ3JlZW5TaGFkb3cnKVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gICAgcmV0dXJuICQoJy5yZWRTaGFkb3cnKS5sZW5ndGhcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNoZWNrQ29ycmVjdEFuc3dlcnMoY29ycmVjdEFuc2VyLCBpbnB1dCwgbGFiZWwpIHtcclxuICAgIGlmIChpbnB1dC5jaGVja2VkICYmIGNvcnJlY3RBbnNlcikgey8vIGNoZWNrYm94INC90LDQttCw0YIuINCwINCyIGNvcnJlY3QgYW5zd2VyINC90LXRgtGDLiDQsiBjb3JyZWN0X2Fuc3dlcnMg0LXRgdGC0YwsINC10LPQviDQstGB0LXQs9C00LAg0L/QvtC00YHQstC10YfQuNCy0LDQtdC8INC30LXQu9C10L3Ri9C8XHJcbiAgICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2RvbmUnKTsgLy9ncmVlbiBjaGVjayDQt9C10LvQtdC90YvQuSDQt9C90LDRh9C10LpcclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH0gZWxzZSBpZiAoaW5wdXQuY2hlY2tlZCAmJiAhY29ycmVjdEFuc2VyKSB7Ly8gY2hlY2tib3gg0L3QsNC20LDRgizQuCDQtdGB0YLRjCDQsiBjb3JyZWN0IGFuc3dlci4g0LIgY29ycmVjdF9hbnN3ZXJzINC90LXRgiwg0LrQvdC+0L/QutCwINC90LUg0L3QsNC20LDRgtCwXHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfSBlbHNlIGlmICghaW5wdXQuY2hlY2tlZCAmJiBjb3JyZWN0QW5zZXIpIHsvLyDQutC90L7Qv9C60LAg0L3QtSDQvdCw0LbQsNGC0LAsINCyIGNvcnJlY3RfYW5zd2VycyDQtdGB0YLRjFxyXG4gICAgICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdkb25lJyk7IC8vZ3JlZW4gY2hlY2sg0LfQtdC70LXQvdGL0Lkg0LfQvdCw0YfQtdC6XHJcbiAgICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2RvbmUnKTsvLyBncmVlbiBjaGVjayDQt9C10LvQtdC90YvQuSDQt9C90LDRh9C10LpcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9IGVsc2UgaWYgKCFpbnB1dC5jaGVja2VkICYmICFjb3JyZWN0QW5zZXIpIHsvLyDQutC90L7Qv9C60LAg0L3QtSDQvdCw0LbQsNGC0LAsINCyIGNvcnJlY3RfYW5zd2VycyDQvdC10YJcclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH1cclxuICB9XHJcblxyXG59XHJcblxyXG4iLCJpbXBvcnQgJy4vdXNlcnMuc2Nzcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0KCl7XHJcblxyXG59IiwiLy8gaW1wb3J0IHJpZ2h0cyBmcm9tICcuLi9SaWdodHMvcmlnaHRzJ1xyXG5pbXBvcnQgdXNlcnMgZnJvbSAnLi91c2VycydcclxuLy8gaW1wb3J0IHJpZ2h0cyBmcm9tIFwiLi9yaWdodHNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHRpbmdzKCl7XHJcblxyXG4gIC8vIHJpZ2h0cygpXHJcbiAgdXNlcnMoKVxyXG5cclxufSIsImltcG9ydCAnLi9saXN0LnNjc3MnO1xyXG5pbXBvcnQgeyQsIHBvc3QsIHBvcHVwfSBmcm9tICcuLi8uLi9jb21tb24nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdCgpIHtcclxuICAvLyBkZWJ1Z2dlcjtcclxuICAkKCdodG1sJykucmVhZHkoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIGNvbnN0IHRhYmxlcyA9ICQoJy5jdXN0b20tbGlzdF9fd3JhcHBlcicpXHJcbiAgICBpZiAodGFibGVzKSB7XHJcbiAgICAgIFtdLmZvckVhY2guY2FsbCh0YWJsZXMsIGZ1bmN0aW9uICh0YWJsZSkge1xyXG5cclxuICAgICAgICBjb25zdCBjb250ZW50ZWRpdGFibGUgPSAkKCdbY29udGVudGVkaXRhYmxlXScpXHJcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRhYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoJy5oZWFkJylcclxuICAgICAgICBjb25zdCBzb3J0YWJsZXMgPSB0YWJsZS5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zb3J0XScpXHJcbiAgICAgICAgY29uc3QgaW5wdXRzID0gJCh0YWJsZSkuZmluZEFsbCgnLmhlYWQgaW5wdXQnKVxyXG4gICAgICAgIGNvbnN0IGlkcyA9ICQodGFibGUpWzBdLnF1ZXJ5U2VsZWN0b3JBbGwoJy5pZDpub3QoLmhlYWQnKVxyXG4gICAgICAgIGNvbnN0IG1vZGVsTmFtZSA9IHRhYmxlLmRhdGFzZXRbJ21vZGVsJ11cclxuICAgICAgICBjb25zdCByb3dzID0gW11cclxuXHJcbiAgICAgICAgJCh0YWJsZSkub24oJ2NsaWNrJywgaGFuZGxlQ2xpY2suYmluZCh0aGlzKSk7XHJcbiAgICAgICAgJCh0YWJsZSkub24oJ2tleXVwJywgaGFuZGxlS2V5VXAuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgIC8vLyBERUJPVU5DRVxyXG4gICAgICAgIGNvbnN0IGRlYm91bmNlID0gKGZuLCB0aW1lID0gNzAwKSA9PiB7XHJcbiAgICAgICAgICBsZXQgdGltZW91dDtcclxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbCA9ICgpID0+IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb25DYWxsLCB0aW1lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRlYm91bmNlZElucHV0ID0gZGVib3VuY2UoaGFuZGxlSW5wdXQpXHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVLZXlVcCh7dGFyZ2V0fSkge1xyXG5cclxuICAgICAgICAgIC8vIGNvbnRlbnRlZGl0YWJsZVxyXG4gICAgICAgICAgaWYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpKSB7XHJcbiAgICAgICAgICAgIGRlYm91bmNlZElucHV0KHRhYmxlLCBjb250ZW50ZWRpdGFibGUsIHRhcmdldClcclxuXHJcbiAgICAgICAgICAgIC8vLyBzZWFyY2hcclxuICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LmNsb3Nlc3QoJy5oZWFkJykpIHtcclxuICAgICAgICAgICAgbGV0IGhlYWRlciA9IHRhcmdldC5jbG9zZXN0KCcuaGVhZCcpXHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IFtdLmZpbmRJbmRleC5jYWxsKGhlYWRlcnMsIChlbCwgaSwgaW5wdXRzKSA9PiB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGVsID09PSBoZWFkZXJcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgc2VhcmNoKGluZGV4LCB0YXJnZXQpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVDbGljayh7dGFyZ2V0fSkge1xyXG5cclxuICAgICAgICAgIC8vLyBjcmVhdGVcclxuICAgICAgICAgIGlmICh0YXJnZXQuY2xhc3NOYW1lID09PSAnYWRkLW1vZGVsJykge1xyXG4gICAgICAgICAgICBtb2RlbENyZWF0ZShtb2RlbE5hbWUpXHJcblxyXG4gICAgICAgICAgICAvLy8gZGVsZXRlXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICB0YXJnZXQuY2xhc3NOYW1lID09PSAnLmRlbDpub3QoLmhlYWQpJyB8fFxyXG4gICAgICAgICAgICB0YXJnZXQuY2xvc2VzdCgnLmRlbDpub3QoLmhlYWQpJykpIHtcclxuICAgICAgICAgICAgbW9kZWxEZWwodGFyZ2V0LmNsb3Nlc3QoJy5kZWw6bm90KC5oZWFkKScpKVxyXG5cclxuICAgICAgICAgICAgLy8vIGVkaXRcclxuICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LmNsYXNzTmFtZSA9PT0gJy5lZGl0Om5vdCguaGVhZCknIHx8XHJcbiAgICAgICAgICAgIHRhcmdldC5jbG9zZXN0KCcuZWRpdDpub3QoLmhlYWQpJykpIHtcclxuICAgICAgICAgICAgbGV0IGlkID0gdGFyZ2V0LmNsb3Nlc3QoJy5lZGl0Om5vdCguaGVhZCknKS5kYXRhc2V0WydpZCddXHJcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IGAvYWRtaW5zYy8ke21vZGVsTmFtZX0vZWRpdC8ke2lkfWA7XHJcblxyXG4gICAgICAgICAgICAvLy8gc29ydFxyXG4gICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdoZWFkJykpIHtcclxuICAgICAgICAgICAgbGV0IGhlYWRlciA9IHRhcmdldC5jbG9zZXN0KCcuaGVhZCcpXHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IFtdLmZpbmRJbmRleC5jYWxsKGhlYWRlcnMsIChlbCwgaSwgaW5wdXRzKSA9PiB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGVsID09PSBoZWFkZXJcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgc29ydENvbHVtbihpbmRleClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERFTEVURVxyXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIG1vZGVsRGVsKGVsKSB7XHJcbiAgICAgICAgICAvLyBkZWJ1Z2dlclxyXG4gICAgICAgICAgbGV0IGlkID0gZWwuZGF0YXNldFsnaWQnXVxyXG4gICAgICAgICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoYC9hZG1pbnNjLyR7bW9kZWxOYW1lfS9kZWxldGVgLCB7aWR9KVxyXG4gICAgICAgICAgcmVzID0gSlNPTi5wYXJzZShyZXMpXHJcbiAgICAgICAgICBpZiAocmVzLm1zZyA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICBkZWxWaWV3KGlkKVxyXG4gICAgICAgICAgICBwb3B1cC5zaG93KGBpZCA6ICR7aWR9INGD0LTQsNC70LXQvdC+YClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGRlbFZpZXcoaWQpIHtcclxuICAgICAgICAgIGxldCBhcnIgPSAkKGBbZGF0YS1pZD0nJHtpZH0nXWApO1xyXG4gICAgICAgICAgW10uZm9yRWFjaC5jYWxsKGFyciwgZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZSgpXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vIENSRUFURVxyXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIG1vZGVsQ3JlYXRlKG1vZGVsTmFtZSwgZSkge1xyXG4gICAgICAgICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoYC9hZG1pbnNjLyR7bW9kZWxOYW1lfS9jcmVhdGVgLCB7fSlcclxuICAgICAgICAgIHJlcyA9IEpTT04ucGFyc2UocmVzKVxyXG4gICAgICAgICAgaWYgKHJlcy5pZCkge1xyXG4gICAgICAgICAgICBuZXdSb3cocmVzLmlkIC0gMSlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG5ld1JvdyhpZCkge1xyXG4gICAgICAgICAgbGV0IFJvdyA9IFsuLi5yb3dzWzBdXTtcclxuICAgICAgICAgIFtdLmZvckVhY2guY2FsbChSb3csIGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgICBsZXQgbmV3RWwgPSBlbC5jbG9uZU5vZGUodHJ1ZSlcclxuICAgICAgICAgICAgbGV0IHRhYmxlQ29udGVudCA9ICQodGFibGUpLmZpbmQoJy5jdXN0b20tbGlzdCcpXHJcbiAgICAgICAgICAgIHRhYmxlQ29udGVudC5hcHBlbmRDaGlsZChuZXdFbClcclxuICAgICAgICAgICAgaWYgKFsnaWQnXS5pbmNsdWRlcyhuZXdFbC5jbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgICAgbmV3RWwuaW5uZXJUZXh0ID0gaWRcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghWydkZWwnLCAnZWRpdCcsICdzYXZlJ10uaW5jbHVkZXMobmV3RWwuY2xhc3NOYW1lKSkge1xyXG4gICAgICAgICAgICAgIG5ld0VsLmlubmVyVGV4dCA9ICcnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV3RWwuZGF0YXNldFsnaWQnXSA9IGlkXHJcblxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gU0VBUkNIXHJcbiAgICAgICAgZnVuY3Rpb24gc2hvd0FsbFJvd3MoKSB7XHJcbiAgICAgICAgICBbXS5mb3JFYWNoLmNhbGwocm93cywgKHJvdykgPT4ge1xyXG4gICAgICAgICAgICBbXS5mb3JFYWNoLmNhbGwocm93LCBlbCA9PiB7XHJcbiAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdmbGV4J1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHNlYXJjaChpbmRleCwgaW5wdXQpIHtcclxuICAgICAgICAgIHNob3dBbGxSb3dzKClcclxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gaW5wdXQudmFsdWU7XHJcblxyXG4gICAgICAgICAgW10uZm9yRWFjaC5jYWxsKGlucHV0cywgKGlucCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaW5wICE9PSBpbnB1dCkgaW5wLnZhbHVlID0gJydcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIFtdLmZvckVhY2guY2FsbChyb3dzLCBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0ciA9IHJvd1tpbmRleF0uaW5uZXJUZXh0XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZ2V4cCA9IG5ldyBSZWdFeHAoYCR7dmFsdWV9YCwgJ2dpJylcclxuICAgICAgICAgICAgaWYgKCFzdHIubWF0Y2gocmVnZXhwKSkge1xyXG4gICAgICAgICAgICAgIFtdLmZvckVhY2guY2FsbChyb3csIGVsID0+IHtcclxuICAgICAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcclxuICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBTT1JUXHJcbiAgICAgICAgZnVuY3Rpb24gc29ydENvbHVtbihpbmRleCkge1xyXG4gICAgICAgICAgLy8g0J/QvtC70YPRh9C40YLRjCDRgtC10LrRg9GJ0LXQtSDQvdCw0L/RgNCw0LLQu9C10L3QuNC1XHJcbiAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBkaXJlY3Rpb25zW2luZGV4XSB8fCAnYXNjJ1xyXG5cclxuICAgICAgICAgIC8vINCk0LDQutGC0L7RgCDQv9C+INC90LDQv9GA0LDQstC70LXQvdC40Y5cclxuICAgICAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSAoZGlyZWN0aW9uID09PSAnYXNjJykgPyAxIDogLTFcclxuXHJcbiAgICAgICAgICBjb25zdCBuZXdSb3dzID0gQXJyYXkuZnJvbShyb3dzKVxyXG5cclxuICAgICAgICAgIG5ld1Jvd3Muc29ydChmdW5jdGlvbiAocm93QSwgcm93Qikge1xyXG4gICAgICAgICAgICBjb25zdCBjZWxsQSA9IHJvd0FbaW5kZXhdLmlubmVySFRNTFxyXG4gICAgICAgICAgICBjb25zdCBjZWxsQiA9IHJvd0JbaW5kZXhdLmlubmVySFRNTFxyXG5cclxuICAgICAgICAgICAgY29uc3QgYSA9IHRyYW5zZm9ybShpbmRleCwgY2VsbEEpXHJcbiAgICAgICAgICAgIGNvbnN0IGIgPSB0cmFuc2Zvcm0oaW5kZXgsIGNlbGxCKVxyXG5cclxuICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgY2FzZSBhID4gYjpcclxuICAgICAgICAgICAgICAgIHJldHVybiAxICogbXVsdGlwbGllclxyXG4gICAgICAgICAgICAgIGNhc2UgYSA8IGI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTEgKiBtdWx0aXBsaWVyXHJcbiAgICAgICAgICAgICAgY2FzZSBhID09PSBiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIC8vINCj0LTQsNC70LjRgtGMINGB0YLQsNGA0YvQtSDRgdGC0YDQvtC60LhcclxuICAgICAgICAgIFtdLmZvckVhY2guY2FsbChyb3dzLCBmdW5jdGlvbiAobm9kZUxpc3QpIHtcclxuICAgICAgICAgICAgW10uZm9yRWFjaC5jYWxsKG5vZGVMaXN0LCBlbCA9PiB7XHJcbiAgICAgICAgICAgICAgZWwucmVtb3ZlKClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIC8vINCf0L7QvNC10L3Rj9GC0Ywg0L3QsNC/0YDQsNCy0LvQtdC90LjQtVxyXG4gICAgICAgICAgZGlyZWN0aW9uc1tpbmRleF0gPSBkaXJlY3Rpb24gPT09ICdhc2MnID8gJ2Rlc2MnIDogJ2FzYydcclxuXHJcbiAgICAgICAgICAvLyDQlNC+0LHQsNCy0LjRgtGMINC90L7QstGD0Y4g0YHRgtGA0L7QutGDXHJcbiAgICAgICAgICBuZXdSb3dzLmZvckVhY2goZnVuY3Rpb24gKG5ld1Jvdykge1xyXG4gICAgICAgICAgICBuZXdSb3cgPSBBcnJheS5mcm9tKG5ld1Jvdyk7XHJcbiAgICAgICAgICAgIG5ld1Jvdy5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgIFtdLmZvckVhY2guY2FsbChuZXdSb3csIGVsID0+IHtcclxuICAgICAgICAgICAgICBoZWFkZXJzW2hlYWRlcnMubGVuZ3RoIC0gMV0uYWZ0ZXIoZWwpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLy8gZ2V0IHRhYmxlIHJvd3MgYXJyYXlcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgbGV0IGlkID0gaWRzW2ldLmRhdGFzZXQuaWRcclxuICAgICAgICAgIGxldCByb3cgPSAkKHRhYmxlKVswXS5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS1pZD0nJHtpZH0nXWApXHJcbiAgICAgICAgICByb3dzLnB1c2gocm93KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g0J3QsNC/0YDQsNCy0LvQtdC90LjQtSDRgdC+0YDRgtC40YDQvtCy0LrQuFxyXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbnMgPSBBcnJheS5mcm9tKHNvcnRhYmxlcykubWFwKGZ1bmN0aW9uIChzb3J0YWJsZSkge1xyXG4gICAgICAgICAgcmV0dXJuICcnXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vINCf0YDQtdC+0LHRgNCw0LfQvtCy0LDRgtGMINGB0L7QtNC10YDQttC40LzQvtC1INC00LDQvdC90L7QuSDRj9GH0LXQudC60Lgg0LIg0LfQsNC00LDQvdC90L7QvCDRgdGC0L7Qu9Cx0YbQtVxyXG4gICAgICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShpbmRleCwgY29udGVudCkge1xyXG4gICAgICAgICAgLy8g0J/QvtC70YPRh9C40YLRjCDRgtC40L8g0LTQsNC90L3Ri9GFINGB0YLQvtC70LHRhtCwXHJcbiAgICAgICAgICBjb25zdCB0eXBlID0gc29ydGFibGVzW2luZGV4XS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdHlwZScpXHJcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChjb250ZW50KVxyXG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIHJldHVybiBjb250ZW50XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8vIElOUFVUXHJcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlSW5wdXQodGFibGUsIGNvbnRlbnRlZGl0YWJsZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgICBpZiAoIXRhcmdldC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpKSByZXR1cm4gZmFsc2VcclxuICAgICAgICAgIGxldCBtb2RlbCA9IG1ha2VTZXJ2ZXJNb2RlbCh0YXJnZXQsIG1vZGVsTmFtZSlcclxuICAgICAgICAgIHNhdmUobW9kZWwpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhc3luYyBmdW5jdGlvbiBzYXZlKG1vZGVsKSB7XHJcbiAgICAgICAgICBsZXQgdXJsID0gYC9hZG1pbnNjLyR7bW9kZWwubW9kZWxOYW1lfS91cGRhdGVgXHJcbiAgICAgICAgICBsZXQgcmVzID0gYXdhaXQgcG9zdCh1cmwsIG1vZGVsLm1vZGVsKVxyXG4gICAgICAgICAgcmVzID0gSlNPTi5wYXJzZShyZXMpXHJcbiAgICAgICAgICBpZiAocmVzLm1zZyA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICBwb3B1cC5zaG93KCfQodC+0YXRgNCw0L3QtdC90L4hJylcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VTZXJ2ZXJNb2RlbChlbCwgbW9kZWxOYW1lKSB7XHJcbiAgICAgICAgICBsZXQgZmllbGQgPSBlbC5kYXRhc2V0WydmaWVsZCddXHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtb2RlbDoge1xyXG4gICAgICAgICAgICAgIHRva2VuOiAkKCksXHJcbiAgICAgICAgICAgICAgaWQ6IGVsLmRhdGFzZXQuaWQsXHJcbiAgICAgICAgICAgICAgW2ZpZWxkXTogZWwuaW5uZXJUZXh0XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1vZGVsTmFtZVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgfSlcclxufVxyXG4iLCJpbXBvcnQgJy4vcmlnaHRzLnNjc3MnO1xyXG5pbXBvcnQgeyQsIHBvcHVwLCBwb3N0fSBmcm9tICcuLi8uLi9jb21tb24nO1xyXG5pbXBvcnQgbGlzdCBmcm9tICdAY29tcG9uZW50cy9saXN0L2xpc3QnXHJcbi8vIGltcG9ydCBjb250ZW50ZWRpdGFibGUgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9jb250ZW50ZWRpdGFibGUnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByaWdodHMoKSB7XHJcbiAgLy8gZGVidWdnZXJcclxuICAvLyBjb250ZW50ZWRpdGFibGUoKVxyXG5cclxuXHJcblxyXG4gICQoJy5yaWdodHMtdGFibGUnKS5vbignY2xpY2snLCBoYW5kbGUpXHJcblxyXG4gIGZ1bmN0aW9uIGhhbmRsZSh7dGFyZ2V0fSkge1xyXG4gICAgaWYgKHRhcmdldC5jbG9zZXN0KCcuZGVsJykpIGRlbCh0YXJnZXQuY2xvc2VzdCgnLmRlbCcpKVxyXG4gICAgaWYgKHRhcmdldC5jbG9zZXN0KCcuc2F2ZScpKSBzYXZlKHRhcmdldC5jbG9zZXN0KCcuc2F2ZScpKVxyXG5cclxuICAgIGZ1bmN0aW9uIG1vZGVsKGVsKSB7XHJcbiAgICAgIGxldCBkYXRhSWQgPSBlbC5kYXRhc2V0LmlkID8/ICduZXcnXHJcbiAgICAgIGxldCBmaWVsZHMgPSAkKGBbZGF0YS1pZD0nJHtkYXRhSWR9J11gKVxyXG4gICAgICBsZXQgbW9kZWwgPSB7fVxyXG4gICAgICBtb2RlbC50b1NlcnYgPSB7fVxyXG4gICAgICBtb2RlbC5lbXB0eSA9IHt9XHJcblxyXG4gICAgICBmaWVsZHMubWFwKChmKSA9PiB7XHJcbiAgICAgICAgaWYgKGYuY2xhc3NMaXN0LmNvbnRhaW5zKCdpZCcpKSB7XHJcbiAgICAgICAgICBtb2RlbC5pZCA9IGZcclxuICAgICAgICAgIG1vZGVsLnRvU2Vydi5pZCA9IGYuZGF0YXNldC5pZFxyXG4gICAgICAgIH0gZWxzZSBpZiAoZi5jbGFzc0xpc3QuY29udGFpbnMoJ25hbWUnKSkge1xyXG4gICAgICAgICAgbW9kZWwubmFtZSA9IGZcclxuICAgICAgICAgIG1vZGVsLnRvU2Vydi5uYW1lID0gZi5pbm5lclRleHQudHJpbSgpXHJcbiAgICAgICAgfSBlbHNlIGlmIChmLmNsYXNzTGlzdC5jb250YWlucygnZGVzY3JpcHRpb24nKSkge1xyXG4gICAgICAgICAgbW9kZWwuZGVzY3JpcHRpb24gPSBmXHJcbiAgICAgICAgICBtb2RlbC50b1NlcnYuZGVzY3JpcHRpb24gPSBmLmlubmVyVGV4dC50cmltKClcclxuICAgICAgICB9IGVsc2UgaWYgKGYuY2xhc3NMaXN0LmNvbnRhaW5zKCdzYXZlLnN2ZycpKSB7XHJcbiAgICAgICAgICBtb2RlbC5zYXZlID0gZlxyXG4gICAgICAgIH0gZWxzZSBpZiAoZi5jbGFzc0xpc3QuY29udGFpbnMoJ2RlbCcpKSB7XHJcbiAgICAgICAgICBtb2RlbC5kZWwgPSBmXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgbW9kZWwuZW1wdHkuZGVsID0gbW9kZWwuaWQucHJldmlvdXNFbGVtZW50U2libGluZy5jbG9uZU5vZGUodHJ1ZSlcclxuICAgICAgbW9kZWwuZW1wdHkuc2F2ZSA9IG1vZGVsLmlkLnByZXZpb3VzRWxlbWVudFNpYmxpbmcucHJldmlvdXNFbGVtZW50U2libGluZy5jbG9uZU5vZGUodHJ1ZSlcclxuICAgICAgbW9kZWwuZW1wdHkuZGVzY3JpcHRpb24gPSBtb2RlbC5pZC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnByZXZpb3VzRWxlbWVudFNpYmxpbmcucHJldmlvdXNFbGVtZW50U2libGluZy5jbG9uZU5vZGUodHJ1ZSlcclxuICAgICAgbW9kZWwuZW1wdHkubmFtZSA9IG1vZGVsLmlkLnByZXZpb3VzRWxlbWVudFNpYmxpbmcucHJldmlvdXNFbGVtZW50U2libGluZy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuY2xvbmVOb2RlKHRydWUpXHJcbiAgICAgIG1vZGVsLmVtcHR5LmlkID0gbW9kZWwuaWQucHJldmlvdXNFbGVtZW50U2libGluZy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnByZXZpb3VzRWxlbWVudFNpYmxpbmcucHJldmlvdXNFbGVtZW50U2libGluZy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmNsb25lTm9kZSh0cnVlKVxyXG5cclxuICAgICAgcmV0dXJuIG1vZGVsXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGRlbChlbCkge1xyXG4gICAgICBsZXQgbW9kID0gbW9kZWwoZWwpXHJcbiAgICAgIGlmIChtb2QudG9TZXJ2LmlkID09PSAnbmV3JykgcmV0dXJuXHJcbiAgICAgIGlmIChjb25maXJtKFwi0KPQtNCw0LvQuNGC0Ywg0L/RgNCw0LLQvj9cIikpIHtcclxuICAgICAgICBkZWxEb20obW9kKVxyXG4gICAgICAgIGRlbFNlcnZlcihtb2QpXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBmdW5jdGlvbiBkZWxTZXJ2ZXIobW9kZWwpIHtcclxuICAgICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9yaWdodC9kZWxldGUnLCB7aWQ6IG1vZGVsLnRvU2Vydi5pZH0pXHJcbiAgICAgIHJlcyA9IGF3YWl0IEpTT04ucGFyc2UocmVzKVxyXG4gICAgICBpZiAocmVzLm1zZyA9PT0gJ29rJykge1xyXG4gICAgICAgIHBvcHVwLnNob3coJ9Cj0LTQsNC70LXQvdC+JylcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRlbERvbShtb2RlbCkge1xyXG4gICAgICBtb2RlbC5pZC5yZW1vdmUoKVxyXG4gICAgICBtb2RlbC5uYW1lLnJlbW92ZSgpXHJcbiAgICAgIG1vZGVsLmRlc2NyaXB0aW9uLnJlbW92ZSgpXHJcbiAgICAgIG1vZGVsLnNhdmUucmVtb3ZlKClcclxuICAgICAgbW9kZWwuZGVsLnJlbW92ZSgpXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHNhdmUoZWwpIHtcclxuICAgICAgbGV0IG1vZCA9IG1vZGVsKGVsKVxyXG4gICAgICBpZiAobW9kLnRvU2Vydi5pZCAhPT0gJ25ldycpIHtcclxuICAgICAgICB1cGRhdGUobW9kLnRvU2VydilcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoIW1vZC50b1NlcnYubmFtZSB8fCAhbW9kLnRvU2Vydi5kZXNjcmlwdGlvbikgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgY3JlYXRlKG1vZClcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZSh0b1NlcnYpIHtcclxuICAgICAgbGV0IHJlcyA9IGF3YWl0IHBvc3QoJy9yaWdodC91cGRhdGUnLCB0b1NlcnYpXHJcbiAgICAgIGlmIChhd2FpdCBKU09OLnBhcnNlKHJlcykudXBkYXRlZCkge1xyXG4gICAgICAgIHBvcHVwLnNob3coJ9Ce0LHQvdC+0LLQu9C10L3QvicpXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjbGVhck1vZGVsKG1vZGVsKXtcclxuICAgICAgbW9kZWwubmFtZS5pbm5lclRleHQgPSBcIlwiXHJcbiAgICAgIG1vZGVsLmRlc2NyaXB0aW9uLmlubmVyVGV4dCA9IFwiXCJcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVPbkRvbShtb2RlbCl7XHJcbiAgICAgIGxldCBsYXN0RWxlbWVudCA9ICQoXCIuaWRbZGF0YS1pZD0nbmV3J11cIilbMF1cclxuICAgICAgbGFzdEVsZW1lbnQuYmVmb3JlKG1vZGVsLmVtcHR5LmlkKVxyXG4gICAgICBsYXN0RWxlbWVudC5iZWZvcmUobW9kZWwuZW1wdHkubmFtZSlcclxuICAgICAgbGFzdEVsZW1lbnQuYmVmb3JlKG1vZGVsLmVtcHR5LmRlc2NyaXB0aW9uKVxyXG4gICAgICBsYXN0RWxlbWVudC5iZWZvcmUobW9kZWwuZW1wdHkuc2F2ZSlcclxuICAgICAgbGFzdEVsZW1lbnQuYmVmb3JlKG1vZGVsLmVtcHR5LmRlbClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhc3NpZ25OZXdWYWx1ZXNPbkNsb25lKG1vZGVsLCBpZCl7XHJcbiAgICAgIG1vZGVsLmVtcHR5LmlkLmRhdGFzZXQuaWQgPSBpZFxyXG4gICAgICBtb2RlbC5lbXB0eS5pZC5pbm5lclRleHQgPSBpZFxyXG4gICAgICBtb2RlbC5lbXB0eS5uYW1lLmRhdGFzZXQuaWQgPSBpZFxyXG4gICAgICBtb2RlbC5lbXB0eS5uYW1lLmlubmVyVGV4dCA9IG1vZGVsLm5hbWUuaW5uZXJUZXh0LnRyaW0oKVxyXG4gICAgICBtb2RlbC5lbXB0eS5kZXNjcmlwdGlvbi5kYXRhc2V0LmlkID0gaWRcclxuICAgICAgbW9kZWwuZW1wdHkuZGVzY3JpcHRpb24uaW5uZXJUZXh0ID0gbW9kZWwuZGVzY3JpcHRpb24uaW5uZXJUZXh0LnRyaW0oKVxyXG4gICAgICBtb2RlbC5lbXB0eS5zYXZlLmRhdGFzZXQuaWQgPSBpZFxyXG4gICAgICBtb2RlbC5lbXB0eS5kZWwuZGF0YXNldC5pZCA9IGlkXHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlKG1vZGVsKSB7XHJcbiAgICAgIGxldCByZXMgPSBhd2FpdCBwb3N0KCcvcmlnaHQvY3JlYXRlJywgbW9kZWwudG9TZXJ2KVxyXG4gICAgICByZXMgPSBhd2FpdCBKU09OLnBhcnNlKHJlcylcclxuXHJcbiAgICAgIGlmIChyZXMuaWQpIHtcclxuXHJcbiAgICAgICAgYXNzaWduTmV3VmFsdWVzT25DbG9uZShtb2RlbCwgcmVzLmlkLTEpXHJcbiAgICAgICAgY3JlYXRlT25Eb20obW9kZWwpXHJcbiAgICAgICAgY2xlYXJNb2RlbChtb2RlbClcclxuXHJcbiAgICAgICAgcG9wdXAuc2hvdygn0KHQvtGF0YDQsNC90LXQvdC+JylcclxuICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcblxyXG4gIH1cclxufSIsImltcG9ydCAnLi9jcmVhdGUvY3JlYXRlJ1xyXG5cclxuaW1wb3J0ICcuL3BsYW5uaW5nLnNjc3MnXHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGxhbm5pbmcoKXtcclxuZGVidWdnZXJcclxuXHJcbn0iLCJpbXBvcnQgeyQsIHBvcHVwLCBwb3N0fSBmcm9tICcuLi8uLi9jb21tb24nXHJcbmltcG9ydCBsaXN0IGZyb20gJ0AvY29tcG9uZW50cy9saXN0L2xpc3QnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VyKCkge1xyXG5cclxuICAvLyBsaXN0KClcclxuXHJcbiAgLy8gJCgnI3VzZXItdXBkYXRlLWJ0bicpLm9uKCdjbGljaycsIHNhdmUpXHJcbiAgLy9cclxuICAvLyBhc3luYyBmdW5jdGlvbiBzYXZlKGUpIHtcclxuICAvLyAgIGxldCByaWdodHMgPSAkKCdpbnB1dC5yaWdodDpjaGVja2VkJylcclxuICAvLyAgIHJpZ2h0cyA9IHJpZ2h0cy5tYXAoKHIpID0+IHIucHJldmlvdXNFbGVtZW50U2libGluZy5pbm5lckhUTUwpXHJcbiAgLy8gICByaWdodHMgPSByaWdodHMuam9pbignLCcpO1xyXG4gIC8vICAgbGV0IHNlbCA9ICQoJy50YWJzJykuZmluZCgnI2NvbmYnKVxyXG4gIC8vICAgbGV0IGNvbmYgPSBzZWwub3B0aW9uc1tzZWwub3B0aW9ucy5zZWxlY3RlZEluZGV4XS52YWx1ZVxyXG4gIC8vXHJcbiAgLy8gICBmdW5jdGlvbiBzZXgoKSB7XHJcbiAgLy8gICAgIGNvbnN0IGYgPSAkKCdbbmFtZT1cInNleFwiXTpjaGVja2VkJylbMF1cclxuICAvLyAgICAgY29uc3QgcyA9ICQoJ1tuYW1lPVwic2V4XCJdJylcclxuICAvLyAgICAgZm9yIChsZXQgZiBvZiBzKSB7XHJcbiAgLy8gICAgICAgaWYgKGYuY2hlY2tlZCkge1xyXG4gIC8vICAgICAgICAgcmV0dXJuIGYudmFsdWVcclxuICAvLyAgICAgICB9XHJcbiAgLy8gICAgIH1cclxuICAvLyAgICAgcmV0dXJuICdtJ1xyXG4gIC8vICAgfVxyXG4gIC8vICAgY29uc3QgbW9kZWwgPSB7XHJcbiAgLy8gICAgIGlkOiAkKCcudGFicycpLmZpbmQoJyNpZCcpLmlubmVyVGV4dC50cmltKCksXHJcbiAgLy8gICAgIGNvbmZpcm06IGNvbmYsXHJcbiAgLy8gICAgIG5hbWU6ICQoJy50YWJzJykuZmluZCgnI25hbWUnKS5pbm5lclRleHQsXHJcbiAgLy8gICAgIHN1ck5hbWU6ICQoJy50YWJzJykuZmluZCgnI3MtbmFtZScpLmlubmVyVGV4dCxcclxuICAvLyAgICAgZW1haWw6ICQoJy50YWJzJykuZmluZCgnI2VtYWlsJykuaW5uZXJUZXh0LnRyaW0oKSxcclxuICAvLyAgICAgbWlkZGxlTmFtZTogJCgnLnRhYnMnKS5maW5kKCcjbS1uYW1lJykuaW5uZXJUZXh0LFxyXG4gIC8vICAgICBwaG9uZTogJCgnLnRhYnMnKS5maW5kKCcjcGhvbmUnKS5pbm5lclRleHQsXHJcbiAgLy8gICAgIGJpcnRoRGF0ZTogJCgnLnRhYnMnKS5maW5kKCcjYmRheScpLnZhbHVlLFxyXG4gIC8vICAgICBoaXJlZDogJCgnLnRhYnMnKS5maW5kKCcjaGlyZWQnKS52YWx1ZSxcclxuICAvLyAgICAgZmlyZWQ6ICQoJy50YWJzJykuZmluZCgnI2ZpcmVkJykudmFsdWUsXHJcbiAgLy8gICAgIHJpZ2h0czogcmlnaHRzLFxyXG4gIC8vICAgICBzZXg6IHNleCgpLFxyXG4gIC8vICAgfVxyXG4gIC8vXHJcbiAgLy8gICBsZXQgcmVzID0gYXdhaXQgcG9zdCgnL3VzZXIvdXBkYXRlJywgbW9kZWwpXHJcbiAgLy9cclxuICAvLyAgIGlmKHJlcyA9PT0gJ29rJyl7XHJcbiAgLy8gICAgIHBvcHVwLnNob3coJ9Ch0L7RhdGA0LDQvdC10L3QvicpXHJcbiAgLy8gICB9XHJcbiAgLy8gfVxyXG59XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIiwiaW1wb3J0IHskfSBmcm9tICcuLi8uLi9jb21tb24nXHJcbmltcG9ydCBsaXN0IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvbGlzdC9saXN0J1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlcnMoKSB7XHJcblxyXG4gIGxpc3QoKVxyXG5cclxuICAkKCcjdXNlcnMgZGl2W2RhdGEtaWRdJykub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcclxuICAgIGNydWRVc2VyKCdVUERBVEUnLCAkKHRoaXMpKTtcclxuICB9KTtcclxuXHJcbiAgZnVuY3Rpb24gY3J1ZFVzZXIoY3J1ZCwgdGFyZ2V0KSB7XHJcblxyXG4gICAgdmFyIGRhdGEgPSB7XHJcblxyXG4gICAgICBuYW1lOiAkKHRhcmdldCkuZmluZCgnLm5hbWUnKS52YWwoKSxcclxuICAgICAgc05hbWU6ICQodGFyZ2V0KS5maW5kKCcucy1uYW1lJykudmFsKCksXHJcbiAgICAgIG1OYW1lOiAkKHRhcmdldCkuZmluZCgnLm0tbmFtZScpLnZhbCgpLFxyXG4gICAgICBiZGF5OiAkKHRhcmdldCkuZmluZCgnLmJkYXknKS52YWwoKSxcclxuICAgICAgcGhvbmU6ICQodGFyZ2V0KS5maW5kKCcucGhvbmUnKS52YWwoKSxcclxuICAgICAgY29uZjogJCh0YXJnZXQpLmZpbmQoJy5jb25maXJtJykudmFsKCksXHJcbiAgICAgIGVtYWlsOiAkKHRhcmdldCkuZmluZCgnLmVtYWlsJykudmFsKCksXHJcbiAgICAgIGhpcmVkOiAkKHRhcmdldCkuZmluZCgnLmhpcmVkJykudmFsKCksXHJcbiAgICAgIGZpcmVkOiAkKHRhcmdldCkuZmluZCgnLmZpcmVkJykudmFsKCksXHJcbiAgICAgIHVzZXJJZDogJCh0YXJnZXQpLmRhdGEoJ2lkJyksXHJcbiAgICAgIHRhYmxlOiAndXNlcnMnLFxyXG4gICAgICBjcnVkOiBjcnVkXHJcbiAgICB9O1xyXG4gICAgdmFyIHBhcmFtID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XHJcblxyXG5cclxuICB9XHJcbiAgO1xyXG5cclxuXHJcbiAgJCgnLndyYXAnKS5vbignY2xpY2snLCAnLnNhdmUuc3ZnJywgZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNlbGYgPSAkKHRoaXMpWzBdO1xyXG4gICAgaWYgKHNlbGYuY2xhc3NMaXN0LmNvbnRhaW5zKCduZXcnKSkge1xyXG4gICAgICBjcnVkVXNlcignSU5TRVJUJywgJCh0aGlzKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjcnVkVXNlcignVVBEQVRFJywgJCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG5cclxuICAkKCcud3JhcCcpLm9uKCdjbGljaycsICcuYnRuYWRkLXVzZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZGF0YSA9IHtcclxuICAgICAgYWN0aW9uOiAnYWRkVXNlcidcclxuICAgIH07XHJcbiAgICBwb3N0KCcvYWRtaW5zYy91c2VycycsIGRhdGEpLnRoZW4oZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAkKCd0Ym9keScpLmFwcGVuZChzdHIpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGFzeW5jIGZ1bmN0aW9uIHBvc3QodXJsLCBkYXRhKSB7XHJcbi8vICAgICAgZGVidWdnZXI7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgIHJlcS5vcGVuKCdQT1NUJywgdXJsKTtcclxuICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcclxuICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XHJcbiAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKFwiWC1SZXF1ZXN0ZWQtV2l0aFwiLCBcIlhNTEh0dHBSZXF1ZXN0XCIpO1xyXG4gICAgICByZXEuc2VuZCgncGFyYW09JyArIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcclxuICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmVqZWN0KEVycm9yKFwiTmV0d29yayBFcnJvclwiKSk7XHJcbiAgICAgIH07XHJcbiAgICAgIHJlcS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmVzb2x2ZShyZXEucmVzcG9uc2UpO1xyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuXHJcbiIsImltcG9ydCAnLi9tdWx0aXNlbGVjdC5zY3NzJ1xyXG5pbXBvcnQgeyR9IGZyb20gJy4uLy4uL2NvbW1vbidcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG11bHRpc2VsZWN0KCkge1xyXG5cclxuICBsZXQgUEhQbXVsdGlzZWxlY3QgPSAkKCcubXVsdGlzZWxlY3QnKVxyXG4gIGlmIChQSFBtdWx0aXNlbGVjdCkge1xyXG5cclxuICAgIFtdLmZvckVhY2guY2FsbChQSFBtdWx0aXNlbGVjdCwgZnVuY3Rpb24gKHNlbGVjdCkge1xyXG5cclxuICAgICAgc2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlQ2xpY2ssIGZhbHNlKVxyXG4gICAgICBzZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZUJsdXIsIGZhbHNlKVxyXG5cclxuICAgICAgZnVuY3Rpb24gaGFuZGxlQmx1cih7dGFyZ2V0fSkge1xyXG4gICAgICAgIGxldCBzaG93ID0gJCh0aGlzKS5maW5kKCcuc2hvdycpXHJcbiAgICAgICAgaWYgKHNob3cpIHtcclxuICAgICAgICAgIHNob3cuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBoYW5kbGVDbGljayh7dGFyZ2V0fSkge1xyXG4vLyDQvtGC0LrRgNGL0YLRjCDQstGL0LHQvtGAINGN0LvQtdC80LXQvdGC0L7QslxyXG4gICAgICAgIGlmICh0YXJnZXQuY2xvc2VzdCgnLndyYXAnKSAmJiB0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJykge1xyXG4gICAgICAgICAgbGV0IG11bHRpc2VsZWN0ID0gdGFyZ2V0LmNsb3Nlc3QoJy5tdWx0aXNlbGVjdCcpXHJcbiAgICAgICAgICBsZXQgdWwgPSBtdWx0aXNlbGVjdC5xdWVyeVNlbGVjdG9yKCd1bCcpXHJcbiAgICAgICAgICB1bC5jbGFzc0xpc3QudG9nZ2xlKCdzaG93JylcclxuXHJcbi8vINC90LDQttCw0YLQuNC1INC/0L4g0LrRgNC10YHRgtC40LrRgyDRh9C40L/QsFxyXG4gICAgICAgIH0gZWxzZSBpZiAoWydkZWwnXS5pbmNsdWRlcyh0YXJnZXQuY2xhc3NOYW1lKSkge1xyXG4gICAgICAgICAgbGV0IGlkID0gdGFyZ2V0LmNsb3Nlc3QoJy5jaGlwJykuZGF0YXNldC5pZFxyXG4gICAgICAgICAgdG9nZ2xlQmFja2dyb3VuZChpZClcclxuICAgICAgICAgIGxldCBjaGlwID0gdGFyZ2V0LmNsb3Nlc3QoJy5jaGlwJylcclxuICAgICAgICAgIGNoaXAucmVtb3ZlKClcclxuXHJcbi8vINCy0YvQsdC+0YAg0Y3Qu9C10LzQtdC90YLQsCwg0L/RgNC+0LLQtdGA0LrQsCDRgdGD0YnQtdGB0YLQstC+0LLQsNC90LjRjyDRh9C40L/QsCDQuCDQtdCz0L4g0LTQvtCx0LDQstC70LXQvdC40LVcclxuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdsYWJlbCcpIHtcclxuICAgICAgICAgIGxldCBpZCA9IHRhcmdldC5kYXRhc2V0LmlkO1xyXG4gICAgICAgICAgbGV0IG0gPSB0YXJnZXQuY2xvc2VzdCgnLm11bHRpc2VsZWN0JylcclxuICAgICAgICAgIGxldCBjaGlwcyA9IG0ucXVlcnlTZWxlY3RvckFsbCgnLmNoaXAnKTtcclxuICAgICAgICAgIGxldCBleGlzdCA9IFtdLnNvbWUuY2FsbChjaGlwcywgKGNoaXApID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNoaXAuZGF0YXNldC5pZCA9PT0gaWRcclxuICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgbGV0IHdyYXAgPSAkKG0pLmZpbmQoJy5jaGlwLXdyYXAnKVxyXG4gICAgICAgICAgaWYgKCFleGlzdCkge1xyXG4gICAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSgnc2VsZWN0ZWQnKVxyXG4gICAgICAgICAgICBsZXQgY2hpcCA9IGNyZWF0ZUNoaXAoaWQpXHJcbiAgICAgICAgICAgIHdyYXAuYXBwZW5kKGNoaXApXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSgnc2VsZWN0ZWQnKVxyXG4gICAgICAgICAgICB3cmFwLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWlkPScke2lkfSddYCkucmVtb3ZlKClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gdG9nZ2xlQmFja2dyb3VuZChpZCkge1xyXG4gICAgICAgICAgbGV0IG11bHRpID0gdGFyZ2V0LmNsb3Nlc3QoJy5tdWx0aXNlbGVjdCcpXHJcbiAgICAgICAgICAkKG11bHRpKS5maW5kKGBsYWJlbFtkYXRhLWlkPScke2lkfSddYCkuY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQ2hpcChpZCkge1xyXG4gICAgICAgICAgbGV0IGNoaXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxyXG4gICAgICAgICAgY2hpcC5jbGFzc0xpc3QuYWRkKCdjaGlwJylcclxuICAgICAgICAgIGNoaXAuaW5uZXJUZXh0ID0gdGFyZ2V0LmlubmVyVGV4dFxyXG4gICAgICAgICAgY2hpcC5kYXRhc2V0WydpZCddID0gaWRcclxuXHJcbiAgICAgICAgICBsZXQgZGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgICAgICAgIGRlbC5jbGFzc0xpc3QuYWRkKCdkZWwnKVxyXG4gICAgICAgICAgZGVsLmlubmVyVGV4dCA9ICdYJ1xyXG5cclxuICAgICAgICAgIGNoaXAuYXBwZW5kKGRlbClcclxuXHJcbiAgICAgICAgICByZXR1cm4gY2hpcFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSlcclxuICB9XHJcbn0iLCJpbXBvcnQgJy4vYWRtaW4uc2NzcydcclxuXHJcbmltcG9ydCAnLi4vY29tcG9uZW50cy9oZWFkZXIvaGVhZGVyLWFkbSdcclxuaW1wb3J0ICcuLi9jb21wb25lbnRzL2FjY29yZGlvbi9hY2NvcmRpb24nXHJcbmltcG9ydCBcIi4vbW9kZWwvY2FjaGVcIjtcclxuaW1wb3J0IHskfSBmcm9tIFwiLi4vY29tbW9uXCI7XHJcbmltcG9ydCBjYXRhbG9nSXRlbSBmcm9tIFwiLi4vY29tcG9uZW50cy9jYXRhbG9nLWl0ZW0vY2F0YWxvZy1pdGVtXCI7XHJcblxyXG5pbXBvcnQgdGVzdFJlc3VsdHMgZnJvbSAnLi4vVGVzdC90ZXN0X3Jlc3VsdHMvdGVzdF9yZXN1bHRzJ1xyXG5pbXBvcnQgdGVzdEVkaXQgZnJvbSAnLi4vVGVzdC90ZXN0LWVkaXQnXHJcbmltcG9ydCB0ZXN0RG8gZnJvbSAnLi4vVGVzdC9kbydcclxuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4vU2V0dGluZ3Mvc2V0dGluZ3MnXHJcbmltcG9ydCByaWdodHMgZnJvbSAnLi9SaWdodHMvcmlnaHRzJ1xyXG5pbXBvcnQgcGxhbm5pbmcgZnJvbSAnLi9QbGFubmluZy9wbGFubmluZydcclxuaW1wb3J0IHVzZXIgZnJvbSAnLi91c2VyL3VzZXInXHJcbmltcG9ydCB1c2VycyBmcm9tICcuL3VzZXIvdXNlcnMnXHJcblxyXG5pbXBvcnQgbGlzdCBmcm9tICdAY29tcG9uZW50cy9saXN0L2xpc3QnXHJcbmltcG9ydCBtdWx0aXNlbGVjdCBmcm9tICdAY29tcG9uZW50cy9tdWx0aXNlbGVjdC9tdWx0aXNlbGVjdCdcclxuXHJcbm5hdmlnYXRlKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSlcclxuLy8gZGVidWdnZXJcclxuY2F0YWxvZ0l0ZW0oKVxyXG5saXN0KClcclxubXVsdGlzZWxlY3QoKVxyXG5cclxuXHJcbiAgLy8gZGVidWdnZXJcclxudGVzdEVkaXQoKVxyXG5cclxuZnVuY3Rpb24gbmF2aWdhdGUoc3RyKSB7XHJcbiAgLy8gZGVidWdnZXJcclxuICBzd2l0Y2ggKHRydWUpIHtcclxuICAgIGNhc2UgL1xcL2FkbWluc2NcXC9zZXR0aW5ncy8udGVzdChzdHIpOlxyXG4gICAgY2FzZSAvXFwvYWRtaW5zY1xcL3JpZ2h0XFwvbGlzdC8udGVzdChzdHIpOlxyXG4gICAgY2FzZSAvXFwvYWRtaW5zY1xcL3Bvc3RcXC9saXN0Ly50ZXN0KHN0cik6XHJcbiAgICBjYXNlIC9cXC9hZG1pbnNjXFwvdG9kb1xcL2xpc3QvLnRlc3Qoc3RyKTpcclxuICAgICAgcmlnaHRzKClcclxuICAgICAgJChcIltocmVmPScvYWRtaW5zYy9zZXR0aW5ncyddXCIpLmFkZENsYXNzKCdjdXJyZW50JylcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgLy8gY2FzZSAvXFwvYWRtaW5zY1xcL1thLXpBLVowLTldK1xcL2VkaXQvLnRlc3Qoc3RyKTpcclxuICAgIC8vXHJcbiAgICAvLyAgIGxpc3QoKVxyXG5cclxuXHJcbiAgICBjYXNlIC9cXC9hZG1pbnNjXFwvdGVzdHJlc3VsdFxcL3Jlc3VsdHMvLnRlc3Qoc3RyKTpcclxuICAgICAgLy8gZGVidWdnZXJcclxuICAgICAgdGVzdFJlc3VsdHMoKVxyXG4gICAgICAkKFwiW2hyZWY9Jy9hZG1pbnNjL3Rlc3QvcmVzdWx0cyddXCIpLmFkZENsYXNzKCdjdXJyZW50JylcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAvXFwvYWRtaW5zY1xcL3VzZXIvLnRlc3Qoc3RyKTpcclxuICAgICAgdXNlcigpXHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgL1xcL2FkbWluc2NcXC91c2VyXFwvbGlzdC8udGVzdChzdHIpOlxyXG4gICAgICB1c2VycygpXHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgL1xcL2FkbWluc2NcXC9jcm0vLnRlc3Qoc3RyKTpcclxuICAgICAgJChcIltocmVmPScvYWRtaW5zYy9jcm0nXVwiKS5hZGRDbGFzcygnY3VycmVudCcpXHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgL1xcL2FkbWluc2NcXC9jYXRhbG9nLy50ZXN0KHN0cik6XHJcbiAgICAgICQoXCJbaHJlZj0nL2FkbWluc2MvY2F0YWxvZyddXCIpLmFkZENsYXNzKCdjdXJyZW50JylcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAvXFwvYWRtaW5zY1xcL3BsYW5uaW5nLy50ZXN0KHN0cik6XHJcbiAgICAgIHBsYW5uaW5nKClcclxuICAgICAgJChcIltocmVmPScvYWRtaW5zYy9wbGFubmluZyddXCIpLmFkZENsYXNzKCdjdXJyZW50JylcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgLy8gY2FzZSAvXFwvYWRtaW5zY1xcL3Rlc3RcXC91cGRhdGUvLnRlc3Qoc3RyKTpcclxuICAgIC8vIGNhc2UgL1xcL2FkbWluc2NcXC90ZXN0XFwvc2hvdy8udGVzdChzdHIpOlxyXG4gICAgLy8gICB0ZXN0VXBkYXRlKClcclxuICAgIC8vICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAvXFwvYWRtaW5zY1xcL3Rlc3RcXC9wYXRoc2hvdy8udGVzdChzdHIpOlxyXG4gICAgY2FzZSAvXFwvYWRtaW5zY1xcL3Rlc3RcXC9lZGl0Ly50ZXN0KHN0cik6XHJcbiAgICAgIC8vIGRlYnVnZ2VyXHJcbiAgICAgIC8vIHRlc3RFZGl0KClcclxuICAgICAgJChcIltocmVmPScvYWRtaW5zYy90ZXN0L2VkaXQnXVwiKS5hZGRDbGFzcygnY3VycmVudCcpXHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgL1xcL3Rlc3QvLnRlc3Qoc3RyKSB8fCAvXFwvdGVzdFxcL3Jlc3VsdC8udGVzdChzdHIpOlxyXG4gICAgICB0ZXN0RG8oKVxyXG4gICAgICAkKFwiW2hyZWY9Jy90ZXN0L2RvJ11cIikuYWRkQ2xhc3MoJ2N1cnJlbnQnKVxyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlIC9cXC9hZG1pbnNjXFwvU2l0ZW1hcC8udGVzdChzdHIpOlxyXG4gICAgICBzZXR0aW5ncygpXHJcbiAgICAgICQoXCJbaHJlZj0nL2FkbWluc2Mvc2V0dGluZ3MnXVwiKS5hZGRDbGFzcygnY3VycmVudCcpXHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgICQoXCJbaHJlZj0nL2FkbWluc2MnXVwiKS5hZGRDbGFzcygnY3VycmVudCcpXHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxufVxyXG5cclxuXHJcblxyXG4iXSwibmFtZXMiOlsiZHJvcERvd24iLCJlbGVtZW50SWQiLCJkcm9wZG93biIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJzaG93RHJvcGRvd24iLCJlIiwiZWxlbWVudCIsImV2ZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0TW91c2VFdmVudCIsIndpbmRvdyIsImRpc3BhdGNoRXZlbnQiLCJ2YWxpZGF0ZSIsInNvcnQiLCJlcnJvciIsIm5leHRFbGVtZW50U2libGluZyIsImFyIiwidmFsdWUiLCJtYXRjaCIsImlubmVyVGV4dCIsInN0eWxlIiwib3BhY2l0eSIsImVtYWlsIiwicmUiLCJ0ZXN0IiwiU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJwYXNzd29yZCIsInBvcHVwIiwic2hvdyIsInR4dCIsImNhbGxiYWNrIiwiY2xvc2UiLCJlbCIsInBvcHVwX19pdGVtIiwiYXBwZW5kIiwiJCIsImFkZEV2ZW50TGlzdGVuZXIiLCJib2R5IiwiaGlkZURlbGF5Iiwic2V0VGltZW91dCIsImNsYXNzTGlzdCIsInJlbW92ZSIsImFkZCIsInJlbW92ZURlbGF5IiwidGFyZ2V0IiwiY29udGFpbnMiLCJjbG9zZXN0IiwidGFnTmFtZSIsImNsYXNzTmFtZSIsImNyZWF0ZUVsZW1lbnQiLCJ1bmlxIiwiYXJyYXkiLCJBcnJheSIsImZyb20iLCJTZXQiLCJnZXQiLCJrZXkiLCJwIiwibG9jYXRpb24iLCJzZWFyY2giLCJSZWdFeHAiLCJwb3N0IiwidXJsIiwiZGF0YSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwidG9rZW4iLCJxdWVyeVNlbGVjdG9yIiwiZ2V0QXR0cmlidXRlIiwicmVxIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwic2V0UmVxdWVzdEhlYWRlciIsIkZvcm1EYXRhIiwic2VuZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJvbmVycm9yIiwiRXJyb3IiLCJvbmxvYWQiLCJyZXNwb25zZSIsIkVsZW1lbnRDb2xsZWN0aW9uIiwiYXR0ck5hbWUiLCJhdHRyVmFsIiwic2V0QXR0cmlidXRlIiwibGVuZ3RoIiwic2VsZWN0ZWRPcHRpb25zIiwib3B0aW9ucyIsImNoZWNrZWQiLCJhdHRyIiwidmFsIiwiYXJyIiwiZm9yRWFjaCIsInMiLCJwdXNoIiwiYXBwZW5kQ2hpbGQiLCJpdGVtIiwiZmlsdGVyZWQiLCJmaWx0ZXIiLCJxdWVyeVNlbGVjdG9yQWxsIiwib24iLCJjYk9yU2VsZWN0b3IiLCJjYiIsImVsZW0iLCJyZWFkeSIsImlzUmVhZHkiLCJzb21lIiwicmVhZHlTdGF0ZSIsInNlbGVjdG9yIiwiYWRkVG9vbHRpcCIsImFyZ3MiLCJjYWxsIiwib25tb3VzZWVudGVyIiwidGlwIiwibWVzc2FnZSIsImJpbmQiLCJvbm1vdXNlbGVhdmUiLCJoYW5kbGVUb2dnbGUiLCJjaGVja2JveGVzIiwiY2giLCJjaGVja2JveCIsInByZXZpb3VzRWxlbWVudFNpYmxpbmciLCJwYXJlbnQiLCJ1bCIsInBhcmVudE5vZGUiLCJmaW5kIiwic2xpZGVVcCIsImhlaWdodCIsInNsaWRlRG93biIsInVsSGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0IiwiaW5jcmVhc2VQYXJlbnQiLCJjbG9zZVNpYmxpbmdzIiwicGFyZW50SGVpZ2h0IiwicGFyc2VJbnQiLCJtYXhIZWlnaHQiLCJjaGlsZHJlbiIsIm1hcCIsImVsQXJyIiwidHlwZSIsImludGVydmFsIiwiX2NhY2hlIiwiY2xlYXJDYWNoZSIsInJlcyIsImNhY2hlIiwiY2F0YWxvZ0l0ZW0iLCJfdGVzdFJlc3VsdCIsImRlbFNlcnZlciIsImlkIiwiZGVsRG9tIiwiZGF0YXNldCIsImkiLCJkZWxldGUiLCJjb25maXJtIiwidGVzdFJlc3VsdHMiLCJ0b29sdGlwcyIsInNob3dUaXAiLCJoaWRlVGlwIiwidG9vbHRpcCIsInRvb2x0aXBIdG1sIiwidG9vbHRpcEVsZW0iLCJpbm5lckhUTUwiLCJjb29yZHMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJsZWZ0Iiwib2Zmc2V0V2lkdGgiLCJ0b3AiLCJvZmZzZXRIZWlnaHQiLCJfdGVzdCIsIm5leHRRIiwiY3VycmVudCIsImN1cnJlbnRRIiwibmF2TGVuZ3RoIiwiYWltTmF2SWQiLCJhaW1OYXZJZEZ1bmN0aW9uIiwiYWltUUVsIiwiYWltUUVsRnVuY3Rpb24iLCJwdXNoTmF2IiwicHVzaFEiLCJRRWwiLCJwcmV2USIsImN1cnJlbnRJZCIsImN1cnJOYXZFbCIsInRvZ2dsZSIsIk5hdkVsIiwiY3VycmVudEVsIiwiZGlyZWN0aW9uIiwiZGlyIiwiUU5leHRFbCIsIlFQcmV2YyIsInZpZXdNb2RlbCIsImhyZWYiLCJzcGxpdCIsInBvcCIsInRlc3RfbmFtZSIsInRleHQiLCJlbmFibGUiLCJzZWxlY3RlZEluZGV4VmFsdWUiLCJ0ZXN0aWQiLCJjaGlsZHJlbkxlbmdodCIsInBhdGhfY3JlYXRlIiwidGVzdF9wYXRoIiwic2VydmVyTW9kZWwiLCJpc1Rlc3QiLCJwYXJzZSIsIm5hbWUiLCJjcmVhdGUiLCJzZWxlY3RlZFZhbHVlQ3VzdG9tU2VsZWN0Iiwic2VsZWN0Iiwic2VsZWN0ZWQiLCJvcHQiLCJtb2RlbCIsImZpZWxkcyIsImZpZWxkIiwidXBkYXRlIiwibm90QWRtaW4iLCJXRFNTZWxlY3QiLCJ0ZXN0VXBkYXRlIiwiX2Fuc3dlciIsImFkZF9idXR0b24iLCJhbnN3ZXJzIiwicHJldl9zb3J0IiwiY2xvbmVOb2RlIiwicV9pZCIsInByZXZpb3VzX3NvcnQiLCJhbnN3ZXJDbnQiLCJkZWwiLCJnZXRNb2RlbEZvclNlcnZlciIsImFuc3dlciIsInBhcmVudF9xdWVzdGlvbiIsImNvcnJlY3RfYW5zd2VyIiwicGljYSIsImJ1dHRvbiIsImFfaWQiLCJjcmVhdGVPblNlcnZlciIsIm5ld0VsIiwiZGlzcGxheSIsImJlZm9yZSIsImRlbF9idXR0b24iLCJkZWxldGVGcm9tU2VydmVyIiwibXNnIiwiX3F1ZXN0aW9uIiwidXBUb1Flc3Rpb25OdW1iZXIiLCJxdWVzdGlvbnMiLCJxdWVzdGlvbnNFbHMiLCJ0b0NoYW5nZSIsImNoYW5nZVBhcmVudCIsInNlbGVjdGVkSW5kZXgiLCJ0ZXN0X2lkIiwicXVlc3Rpb24iLCJhY3Rpb24iLCJzaG93Rmlyc3QiLCJjbG9uZUVtcHR5TW9kZWwiLCJzYXZlIiwiYWRkQ2xhc3MiLCJyZW1vdmVDbGFzcyIsInByZXBlbmQiLCJzaG93QW5zd2VycyIsInJvdyIsImNyZWF0ZUFuc3dlckJ1dHRvbiIsImFkZEJ1dHRvbiIsInF1c3Rpb24iLCJsYXN0U29ydCIsInFzIiwicXVlc3Rpb25zQ291bnQiLCJsYXN0IiwiY3JlYXRlT25WaWV3IiwiY2xvbmUiLCJnZXRBbnN3ZXJzIiwiZGVsZXRlZCIsImRlbGV0ZUZyb21WaWV3IiwicGljcSIsImFuc3dlckJsb2NrcyIsImEiLCJTb3J0YWJsZSIsInNvcnRhYmxlIiwiYW5pbWF0aW9uIiwib25FbmQiLCJldnQiLCJvbGRJIiwib2xkSW5kZXgiLCJuZXdJIiwibmV3SW5kZXgiLCJjb25zdHJ1Y3RvciIsIm11bHRpcGxlIiwidGl0bGUiLCJnZXRGb3JtYXR0ZWRPcHRpb25zIiwic2VsIiwibGFiZWwiLCJzZXR1cCIsImFmdGVyIiwic2VsZWN0ZWRPcHRpb24iLCJvcHRpb24iLCJzZWxlY3RlZE9wdGlvbkluZGV4IiwiaW5kZXhPZiIsInNlbGVjdFZhbHVlIiwibmV3U2VsZWN0ZWRPcHRpb24iLCJwcmV2U2VsZWN0ZWRPcHRpb24iLCJuZXdDdXN0b21FbGVtZW50Iiwic2Nyb2xsSW50b1ZpZXciLCJibG9jayIsInRpdGxlRWxlbWVudCIsInRhYkluZGV4Iiwic2V0T3B0aW9uIiwibGkiLCJkZWJvdW5jZVRpbWVvdXQiLCJzZWFyY2hUZXJtIiwiY29kZSIsInByZXZPcHRpb24iLCJuZXh0T3B0aW9uIiwiY2xlYXJUaW1lb3V0Iiwic2VhcmNoZWRPcHRpb24iLCJzdGFydHNXaXRoIiwiYWNjb3JkaW9uU2hvdyIsImN1cnJlbnRUZXN0SWQiLCJtZW51SXRlbUNvbGxlY3Rpb24iLCJtZW51IiwidGVzdEVkaXRBY3Rpb25zIiwidGVzdEVkaXQiLCJjdXN0b21TZWxlY3RzIiwicGF0aG5hbWUiLCJ0ZXN0RWRpdFdyYXBwZXIiLCJwYWdpbmF0ZSIsInNlbGYiLCJhY3RpdmVfYnRuIiwiaWRfdG9faGlkZSIsImlkX3RvX3Nob3ciLCJxdWVzdENvdW50IiwiY291bnQiLCJCbG9jayIsImJsb2NrcyIsImluc2VydEFkamFjZW50SFRNTCIsIm5ld0Jsb2NrIiwic2F2ZV9idXR0b24iLCJzaG93SGlkZVBhZ2luQnRuIiwicGFnSXRlbSIsImFjdGl2ZVBhZ2luQnRuIiwiYXBwZW5kQmxvY2siLCJuYXZJbml0IiwibmF2X2J1dHRvbnMiLCJ0ZXN0RG8iLCJsYWJlbHMiLCJyZWxvYWQiLCJjb3JyQW5zd2VycyIsImVycm9yQ250IiwiY29sb3JWaWV3Iiwib2JqVG9TZXJ2ZXIiLCJxdWVzdGlvbkNudCIsImh0bWwiLCJkb2N0eXBlIiwiZG9jdW1lbnRFbGVtZW50Iiwib3V0ZXJIVE1MIiwidGVzdElkIiwidGVzdG5hbWUiLCJ1c2VyIiwiY29ycmVjdEFuc3dlcnMiLCJxIiwiZXJyb3JzIiwiaW5wdXQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImFuc3dlcklkIiwicmVwbGFjZSIsImNvcnJlY3RBbnNlciIsImNoZWNrQ29ycmVjdEFuc3dlcnMiLCJxdWVzdElkIiwicGFnaW5JdGVtIiwiaW5pdCIsInVzZXJzIiwic2V0dGluZ3MiLCJsaXN0IiwidGFibGVzIiwidGFibGUiLCJjb250ZW50ZWRpdGFibGUiLCJoZWFkZXJzIiwic29ydGFibGVzIiwiaW5wdXRzIiwiZmluZEFsbCIsImlkcyIsIm1vZGVsTmFtZSIsInJvd3MiLCJoYW5kbGVDbGljayIsImhhbmRsZUtleVVwIiwiZGVib3VuY2UiLCJmbiIsInRpbWUiLCJ0aW1lb3V0IiwiZnVuY3Rpb25DYWxsIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJkZWJvdW5jZWRJbnB1dCIsImhhbmRsZUlucHV0IiwiaGFzQXR0cmlidXRlIiwiaGVhZGVyIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJtb2RlbENyZWF0ZSIsIm1vZGVsRGVsIiwic29ydENvbHVtbiIsImRlbFZpZXciLCJuZXdSb3ciLCJSb3ciLCJ0YWJsZUNvbnRlbnQiLCJpbmNsdWRlcyIsInNob3dBbGxSb3dzIiwiaW5wIiwic3RyIiwicmVnZXhwIiwiZGlyZWN0aW9ucyIsIm11bHRpcGxpZXIiLCJuZXdSb3dzIiwicm93QSIsInJvd0IiLCJjZWxsQSIsImNlbGxCIiwidHJhbnNmb3JtIiwiYiIsIm5vZGVMaXN0IiwicmV2ZXJzZSIsImNvbnRlbnQiLCJwYXJzZUZsb2F0IiwibWFrZVNlcnZlck1vZGVsIiwicmlnaHRzIiwiaGFuZGxlIiwiZGF0YUlkIiwidG9TZXJ2IiwiZW1wdHkiLCJmIiwidHJpbSIsImRlc2NyaXB0aW9uIiwibW9kIiwidXBkYXRlZCIsImNsZWFyTW9kZWwiLCJjcmVhdGVPbkRvbSIsImxhc3RFbGVtZW50IiwiYXNzaWduTmV3VmFsdWVzT25DbG9uZSIsInBsYW5uaW5nIiwiY3J1ZFVzZXIiLCJjcnVkIiwic05hbWUiLCJtTmFtZSIsImJkYXkiLCJwaG9uZSIsImNvbmYiLCJoaXJlZCIsImZpcmVkIiwidXNlcklkIiwicGFyYW0iLCJ0aGVuIiwibXVsdGlzZWxlY3QiLCJQSFBtdWx0aXNlbGVjdCIsImhhbmRsZUJsdXIiLCJ0b2dnbGVCYWNrZ3JvdW5kIiwiY2hpcCIsIm0iLCJjaGlwcyIsImV4aXN0Iiwid3JhcCIsImNyZWF0ZUNoaXAiLCJtdWx0aSIsIm5hdmlnYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///62\n")}},__webpack_exports__={};__webpack_modules__[62]()})();